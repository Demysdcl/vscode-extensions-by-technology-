"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.LSAndTSDocResolver = void 0;
const typescript_1 = __importDefault(require("typescript"));
const utils_1 = require("../../utils");
const service_1 = require("./service");
class LSAndTSDocResolver {
    constructor(docManager, workspaceUris, configManager, transformOnTemplateError = true) {
        this.docManager = docManager;
        this.workspaceUris = workspaceUris;
        this.configManager = configManager;
        this.transformOnTemplateError = transformOnTemplateError;
        /**
         * Create a svelte document -> should only be invoked with svelte files.
         */
        this.createDocument = (fileName, content) => {
            const uri = utils_1.pathToUrl(fileName);
            const document = this.docManager.openDocument({
                text: content,
                uri
            });
            this.docManager.lockDocument(uri);
            return document;
        };
        const handleDocumentChange = (document) => {
            // This refreshes the document in the ts language service
            this.getLSAndTSDoc(document);
        };
        docManager.on('documentChange', utils_1.debounceSameArg(handleDocumentChange, (newDoc, prevDoc) => newDoc.uri === (prevDoc === null || prevDoc === void 0 ? void 0 : prevDoc.uri), 1000));
        // New files would cause typescript to rebuild its type-checker.
        // Open it immediately to reduce rebuilds in the startup
        // where multiple files and their dependencies
        // being loaded in a short period of times
        docManager.on('documentOpen', handleDocumentChange);
    }
    get lsDocumentContext() {
        return {
            createDocument: this.createDocument,
            transformOnTemplateError: this.transformOnTemplateError
        };
    }
    async getLSForPath(path) {
        return service_1.getLanguageServiceForPath(path, this.workspaceUris, this.lsDocumentContext);
    }
    async getLSAndTSDoc(document) {
        const lang = await service_1.getLanguageServiceForDocument(document, this.workspaceUris, this.lsDocumentContext);
        const tsDoc = await this.getSnapshot(document);
        const userPreferences = this.getUserPreferences(tsDoc.scriptKind);
        return { tsDoc, lang, userPreferences };
    }
    async getSnapshot(pathOrDoc) {
        const filePath = typeof pathOrDoc === 'string' ? pathOrDoc : pathOrDoc.getFilePath() || '';
        const tsService = await this.getTSService(filePath);
        return tsService.updateSnapshot(pathOrDoc);
    }
    async updateSnapshotPath(oldPath, newPath) {
        await this.deleteSnapshot(oldPath);
        return this.getSnapshot(newPath);
    }
    async deleteSnapshot(filePath) {
        (await this.getTSService(filePath)).deleteSnapshot(filePath);
        this.docManager.releaseDocument(utils_1.pathToUrl(filePath));
    }
    async getSnapshotManager(filePath) {
        return (await this.getTSService(filePath)).snapshotManager;
    }
    getTSService(filePath) {
        return service_1.getService(filePath, this.workspaceUris, this.lsDocumentContext);
    }
    getUserPreferences(scriptKind) {
        const configLang = scriptKind === typescript_1.default.ScriptKind.TS || scriptKind === typescript_1.default.ScriptKind.TSX
            ? 'typescript'
            : 'javascript';
        return this.configManager.getTsUserPreferences(configLang);
    }
}
exports.LSAndTSDocResolver = LSAndTSDocResolver;
//# sourceMappingURL=LSAndTSDocResolver.js.map