"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const collection_utils_1 = require("collection-utils");
const Annotation_1 = require("../Annotation");
const ConvenienceRenderer_1 = require("../ConvenienceRenderer");
const Naming_1 = require("../Naming");
const RendererOptions_1 = require("../RendererOptions");
const Source_1 = require("../Source");
const Strings_1 = require("../support/Strings");
const Support_1 = require("../support/Support");
const TargetLanguage_1 = require("../TargetLanguage");
const Type_1 = require("../Type");
const TypeUtils_1 = require("../TypeUtils");
var Framework;
(function (Framework) {
    Framework[Framework["None"] = 0] = "None";
    Framework[Framework["Klaxon"] = 1] = "Klaxon";
})(Framework = exports.Framework || (exports.Framework = {}));
exports.kotlinOptions = {
    framework: new RendererOptions_1.EnumOption("framework", "Serialization framework", [["just-types", Framework.None], ["klaxon", Framework.Klaxon]], "klaxon"),
    packageName: new RendererOptions_1.StringOption("package", "Package", "PACKAGE", "quicktype")
};
class KotlinTargetLanguage extends TargetLanguage_1.TargetLanguage {
    constructor() {
        super("Kotlin (beta)", ["kotlin"], "kt");
    }
    getOptions() {
        return [exports.kotlinOptions.framework, exports.kotlinOptions.packageName];
    }
    get supportsOptionalClassProperties() {
        return true;
    }
    get supportsUnionsWithBothNumberTypes() {
        return true;
    }
    makeRenderer(renderContext, untypedOptionValues) {
        return new KotlinRenderer(this, renderContext, RendererOptions_1.getOptionValues(exports.kotlinOptions, untypedOptionValues));
    }
}
exports.KotlinTargetLanguage = KotlinTargetLanguage;
const keywords = [
    "package",
    "as",
    "typealias",
    "class",
    "this",
    "super",
    "val",
    "var",
    "fun",
    "for",
    "null",
    "true",
    "false",
    "is",
    "in",
    "throw",
    "return",
    "break",
    "continue",
    "object",
    "if",
    "try",
    "else",
    "while",
    "do",
    "when",
    "interface",
    "typeof",
    "klaxon",
    "toJson",
    "Any",
    "Boolean",
    "Double",
    "Float",
    "Long",
    "Int",
    "Short",
    "System",
    "Byte",
    "String",
    "Array",
    "List",
    "Map",
    "Enum",
    "Class",
    "JsonObject",
    "JsonValue",
    "Converter",
    "Klaxon"
];
function isPartCharacter(codePoint) {
    return Strings_1.isLetterOrUnderscore(codePoint) || Strings_1.isNumeric(codePoint);
}
function isStartCharacter(codePoint) {
    return isPartCharacter(codePoint) && !Strings_1.isDigit(codePoint);
}
const legalizeName = Strings_1.legalizeCharacters(isPartCharacter);
function kotlinNameStyle(isUpper, original) {
    const words = Strings_1.splitIntoWords(original);
    return Strings_1.combineWords(words, legalizeName, isUpper ? Strings_1.firstUpperWordStyle : Strings_1.allLowerWordStyle, Strings_1.firstUpperWordStyle, isUpper ? Strings_1.allUpperWordStyle : Strings_1.allLowerWordStyle, Strings_1.allUpperWordStyle, "", isStartCharacter);
}
function unicodeEscape(codePoint) {
    return "\\u" + Strings_1.intToHex(codePoint, 4);
}
const _stringEscape = Strings_1.utf32ConcatMap(Strings_1.escapeNonPrintableMapper(Strings_1.isPrintable, unicodeEscape));
function stringEscape(s) {
    // "$this" is a template string in Kotlin so we have to escape $
    return _stringEscape(s).replace(/\$/g, "\\$");
}
const upperNamingFunction = Naming_1.funPrefixNamer("upper", s => kotlinNameStyle(true, s));
const lowerNamingFunction = Naming_1.funPrefixNamer("lower", s => kotlinNameStyle(false, s));
class KotlinRenderer extends ConvenienceRenderer_1.ConvenienceRenderer {
    constructor(targetLanguage, renderContext, _kotlinOptions) {
        super(targetLanguage, renderContext);
        this._kotlinOptions = _kotlinOptions;
    }
    get _justTypes() {
        return this._kotlinOptions.framework === Framework.None;
    }
    forbiddenNamesForGlobalNamespace() {
        return keywords;
    }
    forbiddenForObjectProperties(_o, _classNamed) {
        return { names: [], includeGlobalForbidden: true };
    }
    forbiddenForEnumCases(_e, _enumName) {
        return { names: [], includeGlobalForbidden: true };
    }
    forbiddenForUnionMembers(_u, _unionName) {
        return { names: [], includeGlobalForbidden: false };
    }
    topLevelNameStyle(rawName) {
        return kotlinNameStyle(true, rawName);
    }
    makeNamedTypeNamer() {
        return upperNamingFunction;
    }
    namerForObjectProperty() {
        return lowerNamingFunction;
    }
    makeUnionMemberNamer() {
        return Naming_1.funPrefixNamer("upper", s => kotlinNameStyle(true, s) + "Value");
    }
    makeEnumCaseNamer() {
        return upperNamingFunction;
    }
    emitDescriptionBlock(lines) {
        this.emitCommentLines(lines, " * ", "/**", " */");
    }
    emitBlock(line, f, delimiter = "curly") {
        const [open, close] = delimiter === "curly" ? ["{", "}"] : ["(", ")"];
        this.emitLine(line, " ", open);
        this.indent(f);
        this.emitLine(close);
    }
    kotlinType(t, withIssues = false, noOptional = false) {
        const optional = noOptional ? "" : "?";
        return TypeUtils_1.matchType(t, _anyType => {
            return Source_1.maybeAnnotated(withIssues, Annotation_1.anyTypeIssueAnnotation, ["Any", optional]);
        }, _nullType => {
            return Source_1.maybeAnnotated(withIssues, Annotation_1.nullTypeIssueAnnotation, ["Any", optional]);
        }, _boolType => "Boolean", _integerType => "Long", _doubleType => "Double", _stringType => "String", arrayType => ["List<", this.kotlinType(arrayType.items, withIssues), ">"], classType => this.nameForNamedType(classType), mapType => ["Map<String, ", this.kotlinType(mapType.values, withIssues), ">"], enumType => this.nameForNamedType(enumType), unionType => {
            const nullable = TypeUtils_1.nullableFromUnion(unionType);
            if (nullable !== null)
                return [this.kotlinType(nullable, withIssues), optional];
            return this.nameForNamedType(unionType);
        });
    }
    unionMemberFromJsonValue(t, e) {
        return TypeUtils_1.matchType(t, _anyType => [e, ".inside"], _nullType => "null", _boolType => [e, ".boolean"], _integerType => ["(", e, ".int?.toLong() ?: ", e, ".longValue)"], _doubleType => [e, ".double"], _stringType => [e, ".string"], arrayType => [e, ".array?.let { klaxon.parseFromJsonArray<", this.kotlinType(arrayType.items), ">(it) }"], _classType => [e, ".obj?.let { klaxon.parseFromJsonObject<", this.kotlinType(t), ">(it) }"], _mapType => [e, ".obj?.let { klaxon.parseFromJsonObject<", this.kotlinType(t), ">(it) }"], enumType => [e, ".string?.let { ", this.kotlinType(enumType), ".fromValue(it) }"], _unionType => Support_1.mustNotHappen());
    }
    unionMemberJsonValueGuard(t, _e) {
        return TypeUtils_1.matchType(t, _anyType => "is Any", _nullType => "null", _boolType => "is Boolean", _integerType => "is Int, is Long", _doubleType => "is Double", _stringType => "is String", _arrayType => "is JsonArray<*>", 
        // These could be stricter, but for now we don't allow maps
        // and objects in the same union
        _classType => "is JsonObject", _mapType => "is JsonObject", 
        // This could be stricter, but for now we don't allow strings
        // and enums in the same union
        _enumType => "is String", _unionType => Support_1.mustNotHappen());
    }
    emitHeader() {
        if (this.leadingComments !== undefined) {
            this.emitCommentLines(this.leadingComments);
        }
        else if (!this._justTypes) {
            this.emitLine("// To parse the JSON, install Klaxon and do:");
            this.emitLine("//");
            this.forEachTopLevel("none", (_, name) => {
                this.emitLine("//   val ", Source_1.modifySource(Strings_1.camelCase, name), " = ", name, ".fromJson(jsonString)");
            });
        }
        this.ensureBlankLine();
        this.emitLine("package ", this._kotlinOptions.packageName);
        this.ensureBlankLine();
        if (this._kotlinOptions.framework === Framework.Klaxon) {
            this.emitLine("import com.beust.klaxon.*");
        }
    }
    emitTopLevelArray(t, name) {
        const elementType = this.kotlinType(t.items);
        this.emitBlock(["class ", name, "(elements: Collection<", elementType, ">) : ArrayList<", elementType, ">(elements)"], () => {
            this.emitLine("public fun toJson() = klaxon.toJsonString(this)");
            this.ensureBlankLine();
            this.emitBlock("companion object", () => {
                this.emitLine("public fun fromJson(json: String) = ", name, "(klaxon.parseArray<", elementType, ">(json)!!)");
            });
        });
    }
    emitTopLevelMap(t, name) {
        const elementType = this.kotlinType(t.values);
        this.emitBlock([
            "class ",
            name,
            "(elements: Map<String, ",
            elementType,
            ">) : HashMap<String, ",
            elementType,
            ">(elements)"
        ], () => {
            this.emitLine("public fun toJson() = klaxon.toJsonString(this)");
            this.ensureBlankLine();
            this.emitBlock("companion object", () => {
                this.emitBlock(["public fun fromJson(json: String) = ", name], () => {
                    this.emitLine("klaxon.parseJsonObject(java.io.StringReader(json)) as Map<String, ", elementType, ">");
                }, "paren");
            });
        });
    }
    klaxonRenameAttribute(propName, jsonName, ignore = false) {
        const escapedName = stringEscape(jsonName);
        const namesDiffer = this.sourcelikeToString(propName) !== escapedName;
        const properties = [];
        if (namesDiffer) {
            properties.push(['name = "', escapedName, '"']);
        }
        if (ignore) {
            properties.push("ignored = true");
        }
        return properties.length === 0 ? undefined : ["@Json(", collection_utils_1.arrayIntercalate(", ", properties), ")"];
    }
    emitEmptyClassDefinition(c, className) {
        this.emitDescription(this.descriptionForType(c));
        if (this._kotlinOptions.framework === Framework.Klaxon) {
            this.emitLine("typealias ", className, " = JsonObject");
        }
        else {
            this.emitLine("class ", className, "()");
        }
    }
    emitClassDefinition(c, className) {
        if (c.getProperties().size === 0) {
            this.emitEmptyClassDefinition(c, className);
            return;
        }
        const kotlinType = (p) => {
            if (p.isOptional) {
                return [this.kotlinType(p.type, true, true), "?"];
            }
            else {
                return this.kotlinType(p.type, true);
            }
        };
        this.emitDescription(this.descriptionForType(c));
        this.emitLine("data class ", className, " (");
        this.indent(() => {
            let count = c.getProperties().size;
            let first = true;
            this.forEachClassProperty(c, "none", (name, jsonName, p) => {
                const nullable = p.type.kind === "union" && TypeUtils_1.nullableFromUnion(p.type) !== null;
                const nullableOrOptional = p.isOptional || p.type.kind === "null" || nullable;
                const last = --count === 0;
                let meta = [];
                const description = this.descriptionForClassProperty(c, jsonName);
                if (description !== undefined) {
                    meta.push(() => this.emitDescription(description));
                }
                if (this._kotlinOptions.framework === Framework.Klaxon) {
                    const rename = this.klaxonRenameAttribute(name, jsonName);
                    if (rename !== undefined) {
                        meta.push(() => this.emitLine(rename));
                    }
                }
                if (meta.length > 0 && !first) {
                    this.ensureBlankLine();
                }
                for (const emit of meta) {
                    emit();
                }
                this.emitLine("val ", name, ": ", kotlinType(p), nullableOrOptional ? " = null" : "", last ? "" : ",");
                if (meta.length > 0 && !last) {
                    this.ensureBlankLine();
                }
                first = false;
            });
        });
        const isTopLevel = collection_utils_1.iterableSome(this.topLevels, ([_, top]) => top === c);
        if (this._kotlinOptions.framework === Framework.Klaxon && isTopLevel) {
            this.emitBlock(")", () => {
                this.emitLine("public fun toJson() = klaxon.toJsonString(this)");
                this.ensureBlankLine();
                this.emitBlock("companion object", () => {
                    this.emitLine("public fun fromJson(json: String) = klaxon.parse<", className, ">(json)");
                });
            });
        }
        else {
            this.emitLine(")");
        }
    }
    emitGenericConverter() {
        this.ensureBlankLine();
        this.emitLine("private fun <T> Klaxon.convert(k: kotlin.reflect.KClass<*>, fromJson: (JsonValue) -> T, toJson: (T) -> String, isUnion: Boolean = false) =");
        this.indent(() => {
            this.emitLine("this.converter(object: Converter {");
            this.indent(() => {
                this.emitLine(`@Suppress("UNCHECKED_CAST")`);
                this.emitTable([
                    ["override fun toJson(value: Any)", " = toJson(value as T)"],
                    ["override fun fromJson(jv: JsonValue)", " = fromJson(jv) as Any"],
                    [
                        "override fun canConvert(cls: Class<*>)",
                        " = cls == k.java || (isUnion && cls.superclass == k.java)"
                    ]
                ]);
            });
            this.emitLine("})");
        });
    }
    emitEnumDefinition(e, enumName) {
        this.emitDescription(this.descriptionForType(e));
        if (this._kotlinOptions.framework === Framework.Klaxon) {
            this.emitBlock(["enum class ", enumName, "(val value: String)"], () => {
                let count = e.cases.size;
                this.forEachEnumCase(e, "none", (name, json) => {
                    this.emitLine(name, `("${stringEscape(json)}")`, --count === 0 ? ";" : ",");
                });
                this.ensureBlankLine();
                this.emitBlock("companion object", () => {
                    this.emitBlock(["public fun fromValue(value: String): ", enumName, " = when (value)"], () => {
                        let table = [];
                        this.forEachEnumCase(e, "none", (name, json) => {
                            table.push([[`"${stringEscape(json)}"`], [" -> ", name]]);
                        });
                        table.push([["else"], [" -> throw IllegalArgumentException()"]]);
                        this.emitTable(table);
                    });
                });
            });
        }
        else {
            this.emitBlock(["enum class ", enumName], () => {
                let count = e.cases.size;
                this.forEachEnumCase(e, "none", name => {
                    this.emitLine(name, --count === 0 ? "" : ",");
                });
            });
        }
    }
    emitUnionDefinition(u, unionName) {
        function sortBy(t) {
            const kind = t.kind;
            if (kind === "class")
                return kind;
            return "_" + kind;
        }
        this.emitDescription(this.descriptionForType(u));
        const [maybeNull, nonNulls] = TypeUtils_1.removeNullFromUnion(u, sortBy);
        this.emitBlock(["sealed class ", unionName], () => {
            {
                let table = [];
                this.forEachUnionMember(u, nonNulls, "none", null, (name, t) => {
                    table.push([["class ", name, "(val value: ", this.kotlinType(t), ")"], [" : ", unionName, "()"]]);
                });
                if (maybeNull !== null) {
                    table.push([["class ", this.nameForUnionMember(u, maybeNull), "()"], [" : ", unionName, "()"]]);
                }
                this.emitTable(table);
            }
            if (this._kotlinOptions.framework === Framework.Klaxon) {
                this.ensureBlankLine();
                this.emitLine("public fun toJson(): String = klaxon.toJsonString(when (this) {");
                this.indent(() => {
                    let toJsonTable = [];
                    this.forEachUnionMember(u, nonNulls, "none", null, name => {
                        toJsonTable.push([["is ", name], [" -> this.value"]]);
                    });
                    if (maybeNull !== null) {
                        const name = this.nameForUnionMember(u, maybeNull);
                        toJsonTable.push([["is ", name], [' -> "null"']]);
                    }
                    this.emitTable(toJsonTable);
                });
                this.emitLine("})");
                this.ensureBlankLine();
                this.emitBlock("companion object", () => {
                    this.emitLine("public fun fromJson(jv: JsonValue): ", unionName, " = when (jv.inside) {");
                    this.indent(() => {
                        let table = [];
                        this.forEachUnionMember(u, nonNulls, "none", null, (name, t) => {
                            table.push([
                                [this.unionMemberJsonValueGuard(t, "jv.inside")],
                                [" -> ", name, "(", this.unionMemberFromJsonValue(t, "jv"), "!!)"]
                            ]);
                        });
                        if (maybeNull !== null) {
                            const name = this.nameForUnionMember(u, maybeNull);
                            table.push([
                                [this.unionMemberJsonValueGuard(maybeNull, "jv.inside")],
                                [" -> ", name, "()"]
                            ]);
                        }
                        table.push([["else"], [" -> throw IllegalArgumentException()"]]);
                        this.emitTable(table);
                    });
                    this.emitLine("}");
                });
            }
        });
    }
    emitSourceStructure() {
        this.emitHeader();
        if (this._kotlinOptions.framework === Framework.Klaxon) {
            const hasUnions = collection_utils_1.iterableSome(this.typeGraph.allNamedTypes(), t => t instanceof Type_1.UnionType && TypeUtils_1.nullableFromUnion(t) === null);
            const hasEmptyObjects = collection_utils_1.iterableSome(this.typeGraph.allNamedTypes(), c => c instanceof Type_1.ClassType && c.getProperties().size === 0);
            if (hasUnions || this.haveEnums || hasEmptyObjects) {
                this.emitGenericConverter();
            }
            let converters = [];
            if (hasEmptyObjects) {
                converters.push([[".convert(JsonObject::class,"], [" { it.obj!! },"], [" { it.toJsonString() })"]]);
            }
            this.forEachEnum("none", (_, name) => {
                converters.push([
                    [".convert(", name, "::class,"],
                    [" { ", name, ".fromValue(it.string!!) },"],
                    [' { "\\"${it.value}\\"" })']
                ]);
            });
            this.forEachUnion("none", (_, name) => {
                converters.push([
                    [".convert(", name, "::class,"],
                    [" { ", name, ".fromJson(it) },"],
                    [" { it.toJson() }, true)"]
                ]);
            });
            this.ensureBlankLine();
            this.emitLine("private val klaxon = Klaxon()");
            if (converters.length > 0) {
                this.indent(() => this.emitTable(converters));
            }
        }
        // Top-level arrays, maps
        this.forEachTopLevel("leading", (t, name) => {
            if (t instanceof Type_1.ArrayType) {
                this.emitTopLevelArray(t, name);
            }
            else if (t instanceof Type_1.MapType) {
                this.emitTopLevelMap(t, name);
            }
        });
        this.forEachNamedType("leading-and-interposing", (c, n) => this.emitClassDefinition(c, n), (e, n) => this.emitEnumDefinition(e, n), (u, n) => this.emitUnionDefinition(u, n));
    }
}
exports.KotlinRenderer = KotlinRenderer;
