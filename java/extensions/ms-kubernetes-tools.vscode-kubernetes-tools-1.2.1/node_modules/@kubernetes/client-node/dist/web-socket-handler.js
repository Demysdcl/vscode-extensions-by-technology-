"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const ws = require("websocket");
const protocols = [
    'v4.channel.k8s.io',
    'v3.channel.k8s.io',
    'v2.channel.k8s.io',
    'channel.k8s.io',
];
class WebSocketHandler {
    constructor(config) {
        this.config = config;
    }
    static handleStandardStreams(streamNum, buff, stdout, stderr) {
        if (buff.length < 1) {
            return null;
        }
        if (streamNum === WebSocketHandler.StdoutStream) {
            stdout.write(buff);
        }
        else if (streamNum === WebSocketHandler.StderrStream) {
            stderr.write(buff);
        }
        else if (streamNum === WebSocketHandler.StatusStream) {
            // stream closing.
            if (stdout) {
                stdout.end();
            }
            if (stderr) {
                stderr.end();
            }
            return JSON.parse(buff.toString('utf8'));
        }
        else {
            throw new Error('Unknown stream: ' + streamNum);
        }
        return null;
    }
    static handleStandardInput(conn, stdin, streamNum = 0) {
        stdin.on('data', (data) => {
            const buff = Buffer.alloc(data.length + 1);
            buff.writeInt8(streamNum, 0);
            if (data instanceof Buffer) {
                data.copy(buff, 1);
            }
            else {
                buff.write(data, 1);
            }
            conn.send(buff);
        });
        stdin.on('end', () => {
            conn.close();
        });
        // Keep the stream open
        return true;
    }
    /**
     * Connect to a web socket endpoint.
     * @param path The HTTP Path to connect to on the server.
     * @param textHandler Callback for text over the web socket.
     *      Returns true if the connection should be kept alive, false to disconnect.
     * @param binaryHandler Callback for binary data over the web socket.
     *      Returns true if the connection should be kept alive, false to disconnect.
     */
    connect(path, textHandler, binaryHandler) {
        const cluster = this.config.getCurrentCluster();
        if (!cluster) {
            throw new Error('No cluster is defined.');
        }
        const server = cluster.server;
        const ssl = server.startsWith('https://');
        const target = ssl ? server.substr(8) : server.substr(7);
        const proto = ssl ? 'wss' : 'ws';
        const uri = `${proto}://${target}${path}`;
        const opts = {};
        // TODO: This doesn't set insecureSSL if skipTLSVerify is set...
        this.config.applytoHTTPSOptions(opts);
        const client = new ws.client({ tlsOptions: opts });
        return new Promise((resolve, reject) => {
            client.on('connect', (connection) => {
                connection.on('message', (message) => {
                    if (message.type === 'utf8' && message.utf8Data) {
                        if (textHandler) {
                            if (!textHandler(message.utf8Data)) {
                                connection.close();
                            }
                        }
                    }
                    else if (message.type === 'binary' && message.binaryData) {
                        if (binaryHandler) {
                            const streamNum = message.binaryData.readInt8(0);
                            if (!binaryHandler(streamNum, message.binaryData.slice(1))) {
                                connection.close();
                            }
                        }
                    }
                });
                resolve(connection);
            });
            client.on('connectFailed', (err) => {
                reject(err);
            });
            client.connect(uri, protocols);
        });
    }
}
WebSocketHandler.StdinStream = 0;
WebSocketHandler.StdoutStream = 1;
WebSocketHandler.StderrStream = 2;
WebSocketHandler.StatusStream = 3;
exports.WebSocketHandler = WebSocketHandler;
//# sourceMappingURL=web-socket-handler.js.map