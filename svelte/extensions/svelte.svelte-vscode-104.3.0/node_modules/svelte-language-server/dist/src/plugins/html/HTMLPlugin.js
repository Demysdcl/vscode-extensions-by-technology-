"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.HTMLPlugin = void 0;
const vscode_emmet_helper_1 = require("vscode-emmet-helper");
const vscode_html_languageservice_1 = require("vscode-html-languageservice");
const vscode_languageserver_1 = require("vscode-languageserver");
const documents_1 = require("../../lib/documents");
const dataProvider_1 = require("./dataProvider");
const utils_1 = require("../../lib/documents/utils");
class HTMLPlugin {
    constructor(docManager, configManager) {
        this.lang = vscode_html_languageservice_1.getLanguageService({
            customDataProviders: [dataProvider_1.svelteHtmlDataProvider],
            useDefaultDataProvider: false
        });
        this.documents = new WeakMap();
        this.styleScriptTemplate = new Set(['template', 'style', 'script']);
        this.configManager = configManager;
        docManager.on('documentChange', (document) => {
            this.documents.set(document, document.html);
        });
    }
    doHover(document, position) {
        var _a;
        if (!this.featureEnabled('hover')) {
            return null;
        }
        const html = this.documents.get(document);
        if (!html) {
            return null;
        }
        const node = html.findNodeAt(document.offsetAt(position));
        if (!node || ((_a = node.tag) === null || _a === void 0 ? void 0 : _a[0].match(/[A-Z]/))) {
            // The language service is case insensitive, and would provide
            // hover info for Svelte components like `Option` which have
            // the same name like a html tag.
            return null;
        }
        return this.lang.doHover(document, position, html);
    }
    getCompletions(document, position) {
        if (!this.featureEnabled('completions')) {
            return null;
        }
        const html = this.documents.get(document);
        if (!html) {
            return null;
        }
        if (this.isInsideMoustacheTag(html, document, position) ||
            documents_1.isInTag(position, document.scriptInfo) ||
            documents_1.isInTag(position, document.moduleScriptInfo)) {
            return null;
        }
        const emmetResults = {
            isIncomplete: true,
            items: []
        };
        if (this.configManager.getConfig().html.completions.emmet) {
            this.lang.setCompletionParticipants([
                vscode_emmet_helper_1.getEmmetCompletionParticipants(document, position, 'html', this.configManager.getEmmetConfig(), emmetResults)
            ]);
        }
        const results = this.isInComponentTag(html, document, position)
            ? // Only allow emmet inside component element tags.
                // Other attributes/events would be false positives.
                vscode_languageserver_1.CompletionList.create([])
            : this.lang.doComplete(document, position, html);
        const items = this.toCompletionItems(results.items);
        return vscode_languageserver_1.CompletionList.create([
            ...this.toCompletionItems(items),
            ...this.getLangCompletions(items),
            ...emmetResults.items
        ], 
        // Emmet completions change on every keystroke, so they are never complete
        emmetResults.items.length > 0);
    }
    /**
     * The HTML language service uses newer types which clash
     * without the stable ones. Transform to the stable types.
     */
    toCompletionItems(items) {
        return items.map((item) => {
            if (!item.textEdit || vscode_languageserver_1.TextEdit.is(item.textEdit)) {
                return item;
            }
            return {
                ...item,
                textEdit: vscode_languageserver_1.TextEdit.replace(item.textEdit.replace, item.textEdit.newText)
            };
        });
    }
    isInComponentTag(html, document, position) {
        return !!documents_1.getNodeIfIsInComponentStartTag(html, document.offsetAt(position));
    }
    getLangCompletions(completions) {
        const styleScriptTemplateCompletions = completions.filter((completion) => completion.kind === vscode_languageserver_1.CompletionItemKind.Property &&
            this.styleScriptTemplate.has(completion.label));
        const langCompletions = [];
        addLangCompletion('script', ['ts']);
        addLangCompletion('style', ['less', 'scss']);
        addLangCompletion('template', ['pug']);
        return langCompletions;
        function addLangCompletion(tag, languages) {
            const existingCompletion = styleScriptTemplateCompletions.find((completion) => completion.label === tag);
            if (!existingCompletion) {
                return;
            }
            languages.forEach((lang) => langCompletions.push({
                ...existingCompletion,
                label: `${tag} (lang="${lang}")`,
                insertText: existingCompletion.insertText &&
                    `${existingCompletion.insertText} lang="${lang}"`,
                textEdit: existingCompletion.textEdit && vscode_languageserver_1.TextEdit.is(existingCompletion.textEdit)
                    ? {
                        range: existingCompletion.textEdit.range,
                        newText: `${existingCompletion.textEdit.newText} lang="${lang}"`
                    }
                    : undefined
            }));
        }
    }
    doTagComplete(document, position) {
        if (!this.featureEnabled('tagComplete')) {
            return null;
        }
        const html = this.documents.get(document);
        if (!html) {
            return null;
        }
        if (this.isInsideMoustacheTag(html, document, position)) {
            return null;
        }
        return this.lang.doTagComplete(document, position, html);
    }
    isInsideMoustacheTag(html, document, position) {
        const offset = document.offsetAt(position);
        const node = html.findNodeAt(offset);
        return utils_1.isInsideMoustacheTag(document.getText(), node.start, offset);
    }
    getDocumentSymbols(document) {
        if (!this.featureEnabled('documentSymbols')) {
            return [];
        }
        const html = this.documents.get(document);
        if (!html) {
            return [];
        }
        return this.lang.findDocumentSymbols(document, html);
    }
    featureEnabled(feature) {
        return (this.configManager.enabled('html.enable') &&
            this.configManager.enabled(`html.${feature}.enable`));
    }
}
exports.HTMLPlugin = HTMLPlugin;
//# sourceMappingURL=HTMLPlugin.js.map