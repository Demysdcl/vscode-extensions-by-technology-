"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const fs = require("fs");
const uuidv4 = require("uuid/v4");
const vscode = require("vscode");
const vscode_extension_telemetry_1 = require("vscode-extension-telemetry");
const event_1 = require("./event");
let isDebug = false;
let reporters;
const contextProperties = {};
const SENSITIVE_EVENTS = [event_1.EventName.ERROR, event_1.EventName.OPERATION_END, event_1.EventName.OPERATION_STEP];
const SENSITIVE_PROPS = ["message", "stack"];
/**
 * Initialize TelemetryReporter by parsing attributes from a JSON file.
 * It reads these attributes: publisher, name, version, aiKey.
 * @param jsonFilepath absolute path of a JSON file.
 * @param debug If set as true, debug information be printed to console.
 */
function initializeFromJsonFile(jsonFilepath, options) {
    return __awaiter(this, void 0, void 0, function* () {
        return new Promise((resolve, reject) => {
            fs.exists(jsonFilepath, (exists) => {
                if (exists) {
                    const { publisher, name, version, aiKey } = JSON.parse(fs.readFileSync(jsonFilepath, "utf-8"));
                    initialize(`${publisher}.${name}`, version, aiKey, options);
                    return resolve();
                }
                else {
                    return reject(new Error(`The Json file '${jsonFilepath}' does not exist.`));
                }
            });
        });
    });
}
exports.initializeFromJsonFile = initializeFromJsonFile;
/**
 * Initialize TelemetryReporter from given attributes.
 * @param extensionId Identifier of the extension, used as prefix of EventName in telemetry data.
 * @param version Version of the extension.
 * @param aiKey Key of Application Insights.
 * @param debug If set as true, debug information be printed to console.
 */
function initialize(extensionId, version, aiKey, options) {
    if (reporters) {
        throw new Error("TelemetryReporter already initialized.");
    }
    if (aiKey) {
        const firstParty = options && options.firstParty;
        if (aiKey instanceof Array) {
            reporters = aiKey.map((key) => new vscode_extension_telemetry_1.default(extensionId, version, key, firstParty));
        }
        else {
            reporters = [new vscode_extension_telemetry_1.default(extensionId, version, aiKey, firstParty)];
        }
    }
    isDebug = !!(options && options.debug);
}
exports.initialize = initialize;
/**
 * Mark an Error instance as a user error.
 */
function setUserError(err) {
    err.isUserError = true;
}
exports.setUserError = setUserError;
/**
 * Set custom error code or an Error instance.
 * @param errorCode A custom error code.
 */
function setErrorCode(err, errorCode) {
    err.errorCode = errorCode;
}
exports.setErrorCode = setErrorCode;
/**
 * Instrument callback for a command to auto send OPERATION_START, OPERATION_END, ERROR telemetry.
 * A unique Id is created and accessible in the callback.
 * @param operationName For extension activation, use "activation", for VS Code commands, use command name.
 * @param cb The callback function **with a unique Id passed by its 1st parameter**.
 * @param thisArg The `this` context used when invoking the handler function.
 * @returns The instrumented callback.
 */
function instrumentOperation(operationName, cb, thisArg) {
    return (...args) => __awaiter(this, void 0, void 0, function* () {
        let error;
        const operationId = createUuid();
        const startAt = Date.now();
        try {
            sendOperationStart(operationId, operationName);
            return yield cb.apply(thisArg, [operationId, ...args]);
        }
        catch (e) {
            error = e;
            sendOperationError(operationId, operationName, e);
        }
        finally {
            const duration = Date.now() - startAt;
            sendOperationEnd(operationId, operationName, duration, error);
        }
    });
}
exports.instrumentOperation = instrumentOperation;
/**
 * Instrument callback for a command to auto send OPERATION_START, OPERATION_END, ERROR telemetry.
 * @param operationName For extension activation, use "activation", for VS Code commands, use command name.
 * @param cb The callback function.
 * @param thisArg The `this` context used when invoking the handler function.
 * @returns The instrumented callback.
 */
function instrumentSimpleOperation(operationName, cb, thisArg) {
    return instrumentOperation(operationName, (operationId, ...args) => __awaiter(this, void 0, void 0, function* () { return yield cb.apply(thisArg, args); }), thisArg /** unnecessary */);
}
exports.instrumentSimpleOperation = instrumentSimpleOperation;
/**
 * A shortcut to instrument and operation and register it as a VSCode command.
 * Note that operation Id will no longer be accessible in this approach.
 * @param command A unique identifier for the command.
 * @param cb A command handler function.
 * @param thisArg The `this` context used when invoking the handler function.
 */
function instrumentOperationAsVsCodeCommand(command, cb, thisArg) {
    return vscode.commands.registerCommand(command, instrumentSimpleOperation(command, cb, thisArg));
}
exports.instrumentOperationAsVsCodeCommand = instrumentOperationAsVsCodeCommand;
/**
 * Send OPERATION_START event.
 * @param operationId Unique id of the operation.
 * @param operationName Name of the operation.
 */
function sendOperationStart(operationId, operationName) {
    const event = {
        eventName: event_1.EventName.OPERATION_START,
        operationId,
        operationName,
    };
    sendEvent(event);
}
exports.sendOperationStart = sendOperationStart;
/**
 * Send OPERATION_END event.
 * @param operationId Unique id of the operation.
 * @param operationName Name of the operation.
 * @param duration Time elapsed for the operation, in milliseconds.
 * @param err An optional Error instance if occurs during the operation.
 */
function sendOperationEnd(operationId, operationName, duration, err) {
    const event = Object.assign({ eventName: event_1.EventName.OPERATION_END, operationId,
        operationName,
        duration }, extractErrorInfo(err));
    sendEvent(event);
}
exports.sendOperationEnd = sendOperationEnd;
/**
 * Send an ERROR event.
 * @param err An Error instance.
 */
function sendError(err) {
    const event = Object.assign({ eventName: event_1.EventName.ERROR }, extractErrorInfo(err));
    sendEvent(event);
}
exports.sendError = sendError;
/**
 * Send an ERROR event during an operation, carrying id and name of the operation.
 * @param operationId Unique id of the operation.
 * @param operationName Name of the operation.
 * @param err An Error instance containing details.
 */
function sendOperationError(operationId, operationName, err) {
    const event = Object.assign({ eventName: event_1.EventName.ERROR, operationId,
        operationName }, extractErrorInfo(err));
    sendEvent(event);
}
exports.sendOperationError = sendOperationError;
/**
 * Implementation of sendInfo.
 */
function sendInfo(operationId, dimensionsOrMeasurements, optionalMeasurements) {
    let dimensions;
    let measurements;
    if (optionalMeasurements) {
        dimensions = dimensionsOrMeasurements;
        measurements = optionalMeasurements;
    }
    else {
        dimensions = Object.assign({}, contextProperties);
        measurements = {};
        for (const key in dimensionsOrMeasurements) {
            if (typeof dimensionsOrMeasurements[key] === "string") {
                dimensions[key] = dimensionsOrMeasurements[key];
            }
            else if (typeof dimensionsOrMeasurements[key] === "number") {
                measurements[key] = dimensionsOrMeasurements[key];
            }
            else {
                // discard unsupported types.
            }
        }
    }
    sendTelemetryEvent(event_1.EventName.INFO, Object.assign(Object.assign({}, dimensions), { operationId }), measurements);
}
exports.sendInfo = sendInfo;
/**
 * Instrument callback for a procedure (regarded as a step in an operation).
 * @param operationId A unique identifier for the operation to which the step belongs.
 * @param stepName Name of the step.
 * @param cb The callback function with a unique Id passed by its 1st parameter.
 * @returns The instrumented callback.
 */
function instrumentOperationStep(operationId, stepName, cb) {
    return (...args) => __awaiter(this, void 0, void 0, function* () {
        let error;
        const startAt = Date.now();
        try {
            return yield cb(...args);
        }
        catch (e) {
            error = e;
            throw e;
        }
        finally {
            const event = Object.assign({ eventName: event_1.EventName.OPERATION_STEP, operationId,
                stepName, duration: Date.now() - startAt }, extractErrorInfo(error));
            sendEvent(event);
        }
    });
}
exports.instrumentOperationStep = instrumentOperationStep;
/**
 * Create a UUID string using uuid.v4().
 */
function createUuid() {
    return uuidv4();
}
exports.createUuid = createUuid;
/**
 * Dispose the reporter.
 */
function dispose() {
    return __awaiter(this, void 0, void 0, function* () {
        if (reporters) {
            return yield Promise.all(reporters.map((reporter) => reporter.dispose()));
        }
    });
}
exports.dispose = dispose;
/**
 * Add a context property that will be set for all "info" events.
 * It will be overwritten by the property with the same namem, if it's explicitly set in an event.
 * @param name name of context property
 * @param value value of context property
 */
function addContextProperty(name, value) {
    contextProperties[name] = value;
}
exports.addContextProperty = addContextProperty;
function extractErrorInfo(err) {
    if (!err) {
        return {
            errorCode: event_1.ErrorCodes.NO_ERROR,
        };
    }
    const richError = err;
    return {
        errorCode: richError.errorCode || event_1.ErrorCodes.GENERAL_ERROR,
        errorType: richError.isUserError ? event_1.ErrorType.USER_ERROR : event_1.ErrorType.SYSTEM_ERROR,
        message: err.message,
        stack: err.stack,
    };
}
function sendEvent(event) {
    if (!reporters) {
        return;
    }
    const dimensions = {};
    for (const key of event_1.DimensionEntries) {
        const value = event[key];
        if (value !== undefined) {
            dimensions[key] = String(value);
        }
    }
    const measurements = {};
    for (const key of event_1.MeasurementEntries) {
        const value = event[key];
        if (value !== undefined) {
            measurements[key] = value;
        }
    }
    sendTelemetryEvent(event.eventName, dimensions, measurements);
}
function sendTelemetryEvent(eventName, dimensions, measurements) {
    if (eventName in SENSITIVE_EVENTS) { // for GDPR
        reporters.forEach((reporter) => {
            reporter.sendTelemetryErrorEvent(eventName, dimensions, measurements, SENSITIVE_PROPS);
        });
    }
    else {
        reporters.forEach((reporter) => {
            reporter.sendTelemetryEvent(eventName, dimensions, measurements);
        });
    }
    if (isDebug) {
        // tslint:disable-next-line:no-console
        console.log(eventName, { eventName, dimensions, measurements });
    }
}
//# sourceMappingURL=index.js.map