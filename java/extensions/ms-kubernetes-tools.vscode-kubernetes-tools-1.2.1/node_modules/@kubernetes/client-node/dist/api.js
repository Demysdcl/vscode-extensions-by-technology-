"use strict";
/**
 * Kubernetes
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: v1.11.4
 *
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */
Object.defineProperty(exports, "__esModule", { value: true });
const request = require("request");
let defaultBasePath = 'https://localhost';
// ===============================================
// This file is autogenerated - Please do not edit
// ===============================================
/* tslint:disable:no-unused-variable */
/**
* ServiceReference holds a reference to Service.legacy.k8s.io
*/
class AdmissionregistrationV1beta1ServiceReference {
}
exports.AdmissionregistrationV1beta1ServiceReference = AdmissionregistrationV1beta1ServiceReference;
/**
* ServiceReference holds a reference to Service.legacy.k8s.io
*/
class ApiregistrationV1beta1ServiceReference {
}
exports.ApiregistrationV1beta1ServiceReference = ApiregistrationV1beta1ServiceReference;
/**
* DEPRECATED - This group version of Deployment is deprecated by apps/v1beta2/Deployment. See the release notes for more information. Deployment enables declarative updates for Pods and ReplicaSets.
*/
class AppsV1beta1Deployment {
}
exports.AppsV1beta1Deployment = AppsV1beta1Deployment;
/**
* DeploymentCondition describes the state of a deployment at a certain point.
*/
class AppsV1beta1DeploymentCondition {
}
exports.AppsV1beta1DeploymentCondition = AppsV1beta1DeploymentCondition;
/**
* DeploymentList is a list of Deployments.
*/
class AppsV1beta1DeploymentList {
}
exports.AppsV1beta1DeploymentList = AppsV1beta1DeploymentList;
/**
* DEPRECATED. DeploymentRollback stores the information required to rollback a deployment.
*/
class AppsV1beta1DeploymentRollback {
}
exports.AppsV1beta1DeploymentRollback = AppsV1beta1DeploymentRollback;
/**
* DeploymentSpec is the specification of the desired behavior of the Deployment.
*/
class AppsV1beta1DeploymentSpec {
}
exports.AppsV1beta1DeploymentSpec = AppsV1beta1DeploymentSpec;
/**
* DeploymentStatus is the most recently observed status of the Deployment.
*/
class AppsV1beta1DeploymentStatus {
}
exports.AppsV1beta1DeploymentStatus = AppsV1beta1DeploymentStatus;
/**
* DeploymentStrategy describes how to replace existing pods with new ones.
*/
class AppsV1beta1DeploymentStrategy {
}
exports.AppsV1beta1DeploymentStrategy = AppsV1beta1DeploymentStrategy;
/**
* DEPRECATED.
*/
class AppsV1beta1RollbackConfig {
}
exports.AppsV1beta1RollbackConfig = AppsV1beta1RollbackConfig;
/**
* Spec to control the desired behavior of rolling update.
*/
class AppsV1beta1RollingUpdateDeployment {
}
exports.AppsV1beta1RollingUpdateDeployment = AppsV1beta1RollingUpdateDeployment;
/**
* Scale represents a scaling request for a resource.
*/
class AppsV1beta1Scale {
}
exports.AppsV1beta1Scale = AppsV1beta1Scale;
/**
* ScaleSpec describes the attributes of a scale subresource
*/
class AppsV1beta1ScaleSpec {
}
exports.AppsV1beta1ScaleSpec = AppsV1beta1ScaleSpec;
/**
* ScaleStatus represents the current status of a scale subresource.
*/
class AppsV1beta1ScaleStatus {
}
exports.AppsV1beta1ScaleStatus = AppsV1beta1ScaleStatus;
/**
* AllowedFlexVolume represents a single Flexvolume that is allowed to be used. Deprecated: use AllowedFlexVolume from policy API Group instead.
*/
class ExtensionsV1beta1AllowedFlexVolume {
}
exports.ExtensionsV1beta1AllowedFlexVolume = ExtensionsV1beta1AllowedFlexVolume;
/**
* AllowedHostPath defines the host volume conditions that will be enabled by a policy for pods to use. It requires the path prefix to be defined. Deprecated: use AllowedHostPath from policy API Group instead.
*/
class ExtensionsV1beta1AllowedHostPath {
}
exports.ExtensionsV1beta1AllowedHostPath = ExtensionsV1beta1AllowedHostPath;
/**
* DEPRECATED - This group version of Deployment is deprecated by apps/v1beta2/Deployment. See the release notes for more information. Deployment enables declarative updates for Pods and ReplicaSets.
*/
class ExtensionsV1beta1Deployment {
}
exports.ExtensionsV1beta1Deployment = ExtensionsV1beta1Deployment;
/**
* DeploymentCondition describes the state of a deployment at a certain point.
*/
class ExtensionsV1beta1DeploymentCondition {
}
exports.ExtensionsV1beta1DeploymentCondition = ExtensionsV1beta1DeploymentCondition;
/**
* DeploymentList is a list of Deployments.
*/
class ExtensionsV1beta1DeploymentList {
}
exports.ExtensionsV1beta1DeploymentList = ExtensionsV1beta1DeploymentList;
/**
* DEPRECATED. DeploymentRollback stores the information required to rollback a deployment.
*/
class ExtensionsV1beta1DeploymentRollback {
}
exports.ExtensionsV1beta1DeploymentRollback = ExtensionsV1beta1DeploymentRollback;
/**
* DeploymentSpec is the specification of the desired behavior of the Deployment.
*/
class ExtensionsV1beta1DeploymentSpec {
}
exports.ExtensionsV1beta1DeploymentSpec = ExtensionsV1beta1DeploymentSpec;
/**
* DeploymentStatus is the most recently observed status of the Deployment.
*/
class ExtensionsV1beta1DeploymentStatus {
}
exports.ExtensionsV1beta1DeploymentStatus = ExtensionsV1beta1DeploymentStatus;
/**
* DeploymentStrategy describes how to replace existing pods with new ones.
*/
class ExtensionsV1beta1DeploymentStrategy {
}
exports.ExtensionsV1beta1DeploymentStrategy = ExtensionsV1beta1DeploymentStrategy;
/**
* FSGroupStrategyOptions defines the strategy type and options used to create the strategy. Deprecated: use FSGroupStrategyOptions from policy API Group instead.
*/
class ExtensionsV1beta1FSGroupStrategyOptions {
}
exports.ExtensionsV1beta1FSGroupStrategyOptions = ExtensionsV1beta1FSGroupStrategyOptions;
/**
* HostPortRange defines a range of host ports that will be enabled by a policy for pods to use.  It requires both the start and end to be defined. Deprecated: use HostPortRange from policy API Group instead.
*/
class ExtensionsV1beta1HostPortRange {
}
exports.ExtensionsV1beta1HostPortRange = ExtensionsV1beta1HostPortRange;
/**
* IDRange provides a min/max of an allowed range of IDs. Deprecated: use IDRange from policy API Group instead.
*/
class ExtensionsV1beta1IDRange {
}
exports.ExtensionsV1beta1IDRange = ExtensionsV1beta1IDRange;
/**
* PodSecurityPolicy governs the ability to make requests that affect the Security Context that will be applied to a pod and container. Deprecated: use PodSecurityPolicy from policy API Group instead.
*/
class ExtensionsV1beta1PodSecurityPolicy {
}
exports.ExtensionsV1beta1PodSecurityPolicy = ExtensionsV1beta1PodSecurityPolicy;
/**
* PodSecurityPolicyList is a list of PodSecurityPolicy objects. Deprecated: use PodSecurityPolicyList from policy API Group instead.
*/
class ExtensionsV1beta1PodSecurityPolicyList {
}
exports.ExtensionsV1beta1PodSecurityPolicyList = ExtensionsV1beta1PodSecurityPolicyList;
/**
* PodSecurityPolicySpec defines the policy enforced. Deprecated: use PodSecurityPolicySpec from policy API Group instead.
*/
class ExtensionsV1beta1PodSecurityPolicySpec {
}
exports.ExtensionsV1beta1PodSecurityPolicySpec = ExtensionsV1beta1PodSecurityPolicySpec;
/**
* DEPRECATED.
*/
class ExtensionsV1beta1RollbackConfig {
}
exports.ExtensionsV1beta1RollbackConfig = ExtensionsV1beta1RollbackConfig;
/**
* Spec to control the desired behavior of rolling update.
*/
class ExtensionsV1beta1RollingUpdateDeployment {
}
exports.ExtensionsV1beta1RollingUpdateDeployment = ExtensionsV1beta1RollingUpdateDeployment;
/**
* RunAsUserStrategyOptions defines the strategy type and any options used to create the strategy. Deprecated: use RunAsUserStrategyOptions from policy API Group instead.
*/
class ExtensionsV1beta1RunAsUserStrategyOptions {
}
exports.ExtensionsV1beta1RunAsUserStrategyOptions = ExtensionsV1beta1RunAsUserStrategyOptions;
/**
* SELinuxStrategyOptions defines the strategy type and any options used to create the strategy. Deprecated: use SELinuxStrategyOptions from policy API Group instead.
*/
class ExtensionsV1beta1SELinuxStrategyOptions {
}
exports.ExtensionsV1beta1SELinuxStrategyOptions = ExtensionsV1beta1SELinuxStrategyOptions;
/**
* represents a scaling request for a resource.
*/
class ExtensionsV1beta1Scale {
}
exports.ExtensionsV1beta1Scale = ExtensionsV1beta1Scale;
/**
* describes the attributes of a scale subresource
*/
class ExtensionsV1beta1ScaleSpec {
}
exports.ExtensionsV1beta1ScaleSpec = ExtensionsV1beta1ScaleSpec;
/**
* represents the current status of a scale subresource.
*/
class ExtensionsV1beta1ScaleStatus {
}
exports.ExtensionsV1beta1ScaleStatus = ExtensionsV1beta1ScaleStatus;
/**
* SupplementalGroupsStrategyOptions defines the strategy type and options used to create the strategy. Deprecated: use SupplementalGroupsStrategyOptions from policy API Group instead.
*/
class ExtensionsV1beta1SupplementalGroupsStrategyOptions {
}
exports.ExtensionsV1beta1SupplementalGroupsStrategyOptions = ExtensionsV1beta1SupplementalGroupsStrategyOptions;
/**
* AllowedFlexVolume represents a single Flexvolume that is allowed to be used.
*/
class PolicyV1beta1AllowedFlexVolume {
}
exports.PolicyV1beta1AllowedFlexVolume = PolicyV1beta1AllowedFlexVolume;
/**
* AllowedHostPath defines the host volume conditions that will be enabled by a policy for pods to use. It requires the path prefix to be defined.
*/
class PolicyV1beta1AllowedHostPath {
}
exports.PolicyV1beta1AllowedHostPath = PolicyV1beta1AllowedHostPath;
/**
* FSGroupStrategyOptions defines the strategy type and options used to create the strategy.
*/
class PolicyV1beta1FSGroupStrategyOptions {
}
exports.PolicyV1beta1FSGroupStrategyOptions = PolicyV1beta1FSGroupStrategyOptions;
/**
* HostPortRange defines a range of host ports that will be enabled by a policy for pods to use.  It requires both the start and end to be defined.
*/
class PolicyV1beta1HostPortRange {
}
exports.PolicyV1beta1HostPortRange = PolicyV1beta1HostPortRange;
/**
* IDRange provides a min/max of an allowed range of IDs.
*/
class PolicyV1beta1IDRange {
}
exports.PolicyV1beta1IDRange = PolicyV1beta1IDRange;
/**
* PodSecurityPolicy governs the ability to make requests that affect the Security Context that will be applied to a pod and container.
*/
class PolicyV1beta1PodSecurityPolicy {
}
exports.PolicyV1beta1PodSecurityPolicy = PolicyV1beta1PodSecurityPolicy;
/**
* PodSecurityPolicyList is a list of PodSecurityPolicy objects.
*/
class PolicyV1beta1PodSecurityPolicyList {
}
exports.PolicyV1beta1PodSecurityPolicyList = PolicyV1beta1PodSecurityPolicyList;
/**
* PodSecurityPolicySpec defines the policy enforced.
*/
class PolicyV1beta1PodSecurityPolicySpec {
}
exports.PolicyV1beta1PodSecurityPolicySpec = PolicyV1beta1PodSecurityPolicySpec;
/**
* RunAsUserStrategyOptions defines the strategy type and any options used to create the strategy.
*/
class PolicyV1beta1RunAsUserStrategyOptions {
}
exports.PolicyV1beta1RunAsUserStrategyOptions = PolicyV1beta1RunAsUserStrategyOptions;
/**
* SELinuxStrategyOptions defines the strategy type and any options used to create the strategy.
*/
class PolicyV1beta1SELinuxStrategyOptions {
}
exports.PolicyV1beta1SELinuxStrategyOptions = PolicyV1beta1SELinuxStrategyOptions;
/**
* SupplementalGroupsStrategyOptions defines the strategy type and options used to create the strategy.
*/
class PolicyV1beta1SupplementalGroupsStrategyOptions {
}
exports.PolicyV1beta1SupplementalGroupsStrategyOptions = PolicyV1beta1SupplementalGroupsStrategyOptions;
/**
* RawExtension is used to hold extensions in external versions.  To use this, make a field which has RawExtension as its type in your external, versioned struct, and Object in your internal struct. You also need to register your various plugin types.  // Internal package: type MyAPIObject struct {  runtime.TypeMeta `json:\",inline\"`  MyPlugin runtime.Object `json:\"myPlugin\"` } type PluginA struct {  AOption string `json:\"aOption\"` }  // External package: type MyAPIObject struct {  runtime.TypeMeta `json:\",inline\"`  MyPlugin runtime.RawExtension `json:\"myPlugin\"` } type PluginA struct {  AOption string `json:\"aOption\"` }  // On the wire, the JSON will look something like this: {  \"kind\":\"MyAPIObject\",  \"apiVersion\":\"v1\",  \"myPlugin\": {   \"kind\":\"PluginA\",   \"aOption\":\"foo\",  }, }  So what happens? Decode first uses json or yaml to unmarshal the serialized data into your external MyAPIObject. That causes the raw JSON to be stored, but not unpacked. The next step is to copy (using pkg/conversion) into the internal struct. The runtime package's DefaultScheme has conversion functions installed which will unpack the JSON stored in RawExtension, turning it into the correct object type, and storing it in the Object. (TODO: In the case where the object is of an unknown type, a runtime.Unknown object will be created and stored.)
*/
class RuntimeRawExtension {
}
exports.RuntimeRawExtension = RuntimeRawExtension;
/**
* APIGroup contains the name, the supported versions, and the preferred version of a group.
*/
class V1APIGroup {
}
exports.V1APIGroup = V1APIGroup;
/**
* APIGroupList is a list of APIGroup, to allow clients to discover the API at /apis.
*/
class V1APIGroupList {
}
exports.V1APIGroupList = V1APIGroupList;
/**
* APIResource specifies the name of a resource and whether it is namespaced.
*/
class V1APIResource {
}
exports.V1APIResource = V1APIResource;
/**
* APIResourceList is a list of APIResource, it is used to expose the name of the resources supported in a specific group and version, and if the resource is namespaced.
*/
class V1APIResourceList {
}
exports.V1APIResourceList = V1APIResourceList;
/**
* APIService represents a server for a particular GroupVersion. Name must be \"version.group\".
*/
class V1APIService {
}
exports.V1APIService = V1APIService;
class V1APIServiceCondition {
}
exports.V1APIServiceCondition = V1APIServiceCondition;
/**
* APIServiceList is a list of APIService objects.
*/
class V1APIServiceList {
}
exports.V1APIServiceList = V1APIServiceList;
/**
* APIServiceSpec contains information for locating and communicating with a server. Only https is supported, though you are able to disable certificate verification.
*/
class V1APIServiceSpec {
}
exports.V1APIServiceSpec = V1APIServiceSpec;
/**
* APIServiceStatus contains derived information about an API server
*/
class V1APIServiceStatus {
}
exports.V1APIServiceStatus = V1APIServiceStatus;
/**
* APIVersions lists the versions that are available, to allow clients to discover the API at /api, which is the root path of the legacy v1 API.
*/
class V1APIVersions {
}
exports.V1APIVersions = V1APIVersions;
/**
* Represents a Persistent Disk resource in AWS.  An AWS EBS disk must exist before mounting to a container. The disk must also be in the same AWS zone as the kubelet. An AWS EBS disk can only be mounted as read/write once. AWS EBS volumes support ownership management and SELinux relabeling.
*/
class V1AWSElasticBlockStoreVolumeSource {
}
exports.V1AWSElasticBlockStoreVolumeSource = V1AWSElasticBlockStoreVolumeSource;
/**
* Affinity is a group of affinity scheduling rules.
*/
class V1Affinity {
}
exports.V1Affinity = V1Affinity;
/**
* AggregationRule describes how to locate ClusterRoles to aggregate into the ClusterRole
*/
class V1AggregationRule {
}
exports.V1AggregationRule = V1AggregationRule;
/**
* AttachedVolume describes a volume attached to a node
*/
class V1AttachedVolume {
}
exports.V1AttachedVolume = V1AttachedVolume;
/**
* AzureDisk represents an Azure Data Disk mount on the host and bind mount to the pod.
*/
class V1AzureDiskVolumeSource {
}
exports.V1AzureDiskVolumeSource = V1AzureDiskVolumeSource;
/**
* AzureFile represents an Azure File Service mount on the host and bind mount to the pod.
*/
class V1AzureFilePersistentVolumeSource {
}
exports.V1AzureFilePersistentVolumeSource = V1AzureFilePersistentVolumeSource;
/**
* AzureFile represents an Azure File Service mount on the host and bind mount to the pod.
*/
class V1AzureFileVolumeSource {
}
exports.V1AzureFileVolumeSource = V1AzureFileVolumeSource;
/**
* Binding ties one object to another; for example, a pod is bound to a node by a scheduler. Deprecated in 1.7, please use the bindings subresource of pods instead.
*/
class V1Binding {
}
exports.V1Binding = V1Binding;
/**
* Represents storage that is managed by an external CSI volume driver (Beta feature)
*/
class V1CSIPersistentVolumeSource {
}
exports.V1CSIPersistentVolumeSource = V1CSIPersistentVolumeSource;
/**
* Adds and removes POSIX capabilities from running containers.
*/
class V1Capabilities {
}
exports.V1Capabilities = V1Capabilities;
/**
* Represents a Ceph Filesystem mount that lasts the lifetime of a pod Cephfs volumes do not support ownership management or SELinux relabeling.
*/
class V1CephFSPersistentVolumeSource {
}
exports.V1CephFSPersistentVolumeSource = V1CephFSPersistentVolumeSource;
/**
* Represents a Ceph Filesystem mount that lasts the lifetime of a pod Cephfs volumes do not support ownership management or SELinux relabeling.
*/
class V1CephFSVolumeSource {
}
exports.V1CephFSVolumeSource = V1CephFSVolumeSource;
/**
* Represents a cinder volume resource in Openstack. A Cinder volume must exist before mounting to a container. The volume must also be in the same region as the kubelet. Cinder volumes support ownership management and SELinux relabeling.
*/
class V1CinderPersistentVolumeSource {
}
exports.V1CinderPersistentVolumeSource = V1CinderPersistentVolumeSource;
/**
* Represents a cinder volume resource in Openstack. A Cinder volume must exist before mounting to a container. The volume must also be in the same region as the kubelet. Cinder volumes support ownership management and SELinux relabeling.
*/
class V1CinderVolumeSource {
}
exports.V1CinderVolumeSource = V1CinderVolumeSource;
/**
* ClientIPConfig represents the configurations of Client IP based session affinity.
*/
class V1ClientIPConfig {
}
exports.V1ClientIPConfig = V1ClientIPConfig;
/**
* ClusterRole is a cluster level, logical grouping of PolicyRules that can be referenced as a unit by a RoleBinding or ClusterRoleBinding.
*/
class V1ClusterRole {
}
exports.V1ClusterRole = V1ClusterRole;
/**
* ClusterRoleBinding references a ClusterRole, but not contain it.  It can reference a ClusterRole in the global namespace, and adds who information via Subject.
*/
class V1ClusterRoleBinding {
}
exports.V1ClusterRoleBinding = V1ClusterRoleBinding;
/**
* ClusterRoleBindingList is a collection of ClusterRoleBindings
*/
class V1ClusterRoleBindingList {
}
exports.V1ClusterRoleBindingList = V1ClusterRoleBindingList;
/**
* ClusterRoleList is a collection of ClusterRoles
*/
class V1ClusterRoleList {
}
exports.V1ClusterRoleList = V1ClusterRoleList;
/**
* Information about the condition of a component.
*/
class V1ComponentCondition {
}
exports.V1ComponentCondition = V1ComponentCondition;
/**
* ComponentStatus (and ComponentStatusList) holds the cluster validation info.
*/
class V1ComponentStatus {
}
exports.V1ComponentStatus = V1ComponentStatus;
/**
* Status of all the conditions for the component as a list of ComponentStatus objects.
*/
class V1ComponentStatusList {
}
exports.V1ComponentStatusList = V1ComponentStatusList;
/**
* ConfigMap holds configuration data for pods to consume.
*/
class V1ConfigMap {
}
exports.V1ConfigMap = V1ConfigMap;
/**
* ConfigMapEnvSource selects a ConfigMap to populate the environment variables with.  The contents of the target ConfigMap's Data field will represent the key-value pairs as environment variables.
*/
class V1ConfigMapEnvSource {
}
exports.V1ConfigMapEnvSource = V1ConfigMapEnvSource;
/**
* Selects a key from a ConfigMap.
*/
class V1ConfigMapKeySelector {
}
exports.V1ConfigMapKeySelector = V1ConfigMapKeySelector;
/**
* ConfigMapList is a resource containing a list of ConfigMap objects.
*/
class V1ConfigMapList {
}
exports.V1ConfigMapList = V1ConfigMapList;
/**
* ConfigMapNodeConfigSource contains the information to reference a ConfigMap as a config source for the Node.
*/
class V1ConfigMapNodeConfigSource {
}
exports.V1ConfigMapNodeConfigSource = V1ConfigMapNodeConfigSource;
/**
* Adapts a ConfigMap into a projected volume.  The contents of the target ConfigMap's Data field will be presented in a projected volume as files using the keys in the Data field as the file names, unless the items element is populated with specific mappings of keys to paths. Note that this is identical to a configmap volume source without the default mode.
*/
class V1ConfigMapProjection {
}
exports.V1ConfigMapProjection = V1ConfigMapProjection;
/**
* Adapts a ConfigMap into a volume.  The contents of the target ConfigMap's Data field will be presented in a volume as files using the keys in the Data field as the file names, unless the items element is populated with specific mappings of keys to paths. ConfigMap volumes support ownership management and SELinux relabeling.
*/
class V1ConfigMapVolumeSource {
}
exports.V1ConfigMapVolumeSource = V1ConfigMapVolumeSource;
/**
* A single application container that you want to run within a pod.
*/
class V1Container {
}
exports.V1Container = V1Container;
/**
* Describe a container image
*/
class V1ContainerImage {
}
exports.V1ContainerImage = V1ContainerImage;
/**
* ContainerPort represents a network port in a single container.
*/
class V1ContainerPort {
}
exports.V1ContainerPort = V1ContainerPort;
/**
* ContainerState holds a possible state of container. Only one of its members may be specified. If none of them is specified, the default one is ContainerStateWaiting.
*/
class V1ContainerState {
}
exports.V1ContainerState = V1ContainerState;
/**
* ContainerStateRunning is a running state of a container.
*/
class V1ContainerStateRunning {
}
exports.V1ContainerStateRunning = V1ContainerStateRunning;
/**
* ContainerStateTerminated is a terminated state of a container.
*/
class V1ContainerStateTerminated {
}
exports.V1ContainerStateTerminated = V1ContainerStateTerminated;
/**
* ContainerStateWaiting is a waiting state of a container.
*/
class V1ContainerStateWaiting {
}
exports.V1ContainerStateWaiting = V1ContainerStateWaiting;
/**
* ContainerStatus contains details for the current status of this container.
*/
class V1ContainerStatus {
}
exports.V1ContainerStatus = V1ContainerStatus;
/**
* ControllerRevision implements an immutable snapshot of state data. Clients are responsible for serializing and deserializing the objects that contain their internal state. Once a ControllerRevision has been successfully created, it can not be updated. The API Server will fail validation of all requests that attempt to mutate the Data field. ControllerRevisions may, however, be deleted. Note that, due to its use by both the DaemonSet and StatefulSet controllers for update and rollback, this object is beta. However, it may be subject to name and representation changes in future releases, and clients should not depend on its stability. It is primarily for internal use by controllers.
*/
class V1ControllerRevision {
}
exports.V1ControllerRevision = V1ControllerRevision;
/**
* ControllerRevisionList is a resource containing a list of ControllerRevision objects.
*/
class V1ControllerRevisionList {
}
exports.V1ControllerRevisionList = V1ControllerRevisionList;
/**
* CrossVersionObjectReference contains enough information to let you identify the referred resource.
*/
class V1CrossVersionObjectReference {
}
exports.V1CrossVersionObjectReference = V1CrossVersionObjectReference;
/**
* DaemonEndpoint contains information about a single Daemon endpoint.
*/
class V1DaemonEndpoint {
}
exports.V1DaemonEndpoint = V1DaemonEndpoint;
/**
* DaemonSet represents the configuration of a daemon set.
*/
class V1DaemonSet {
}
exports.V1DaemonSet = V1DaemonSet;
/**
* DaemonSetCondition describes the state of a DaemonSet at a certain point.
*/
class V1DaemonSetCondition {
}
exports.V1DaemonSetCondition = V1DaemonSetCondition;
/**
* DaemonSetList is a collection of daemon sets.
*/
class V1DaemonSetList {
}
exports.V1DaemonSetList = V1DaemonSetList;
/**
* DaemonSetSpec is the specification of a daemon set.
*/
class V1DaemonSetSpec {
}
exports.V1DaemonSetSpec = V1DaemonSetSpec;
/**
* DaemonSetStatus represents the current status of a daemon set.
*/
class V1DaemonSetStatus {
}
exports.V1DaemonSetStatus = V1DaemonSetStatus;
/**
* DaemonSetUpdateStrategy is a struct used to control the update strategy for a DaemonSet.
*/
class V1DaemonSetUpdateStrategy {
}
exports.V1DaemonSetUpdateStrategy = V1DaemonSetUpdateStrategy;
/**
* DeleteOptions may be provided when deleting an API object.
*/
class V1DeleteOptions {
}
exports.V1DeleteOptions = V1DeleteOptions;
/**
* Deployment enables declarative updates for Pods and ReplicaSets.
*/
class V1Deployment {
}
exports.V1Deployment = V1Deployment;
/**
* DeploymentCondition describes the state of a deployment at a certain point.
*/
class V1DeploymentCondition {
}
exports.V1DeploymentCondition = V1DeploymentCondition;
/**
* DeploymentList is a list of Deployments.
*/
class V1DeploymentList {
}
exports.V1DeploymentList = V1DeploymentList;
/**
* DeploymentSpec is the specification of the desired behavior of the Deployment.
*/
class V1DeploymentSpec {
}
exports.V1DeploymentSpec = V1DeploymentSpec;
/**
* DeploymentStatus is the most recently observed status of the Deployment.
*/
class V1DeploymentStatus {
}
exports.V1DeploymentStatus = V1DeploymentStatus;
/**
* DeploymentStrategy describes how to replace existing pods with new ones.
*/
class V1DeploymentStrategy {
}
exports.V1DeploymentStrategy = V1DeploymentStrategy;
/**
* Represents downward API info for projecting into a projected volume. Note that this is identical to a downwardAPI volume source without the default mode.
*/
class V1DownwardAPIProjection {
}
exports.V1DownwardAPIProjection = V1DownwardAPIProjection;
/**
* DownwardAPIVolumeFile represents information to create the file containing the pod field
*/
class V1DownwardAPIVolumeFile {
}
exports.V1DownwardAPIVolumeFile = V1DownwardAPIVolumeFile;
/**
* DownwardAPIVolumeSource represents a volume containing downward API info. Downward API volumes support ownership management and SELinux relabeling.
*/
class V1DownwardAPIVolumeSource {
}
exports.V1DownwardAPIVolumeSource = V1DownwardAPIVolumeSource;
/**
* Represents an empty directory for a pod. Empty directory volumes support ownership management and SELinux relabeling.
*/
class V1EmptyDirVolumeSource {
}
exports.V1EmptyDirVolumeSource = V1EmptyDirVolumeSource;
/**
* EndpointAddress is a tuple that describes single IP address.
*/
class V1EndpointAddress {
}
exports.V1EndpointAddress = V1EndpointAddress;
/**
* EndpointPort is a tuple that describes a single port.
*/
class V1EndpointPort {
}
exports.V1EndpointPort = V1EndpointPort;
/**
* EndpointSubset is a group of addresses with a common set of ports. The expanded set of endpoints is the Cartesian product of Addresses x Ports. For example, given:   {     Addresses: [{\"ip\": \"10.10.1.1\"}, {\"ip\": \"10.10.2.2\"}],     Ports:     [{\"name\": \"a\", \"port\": 8675}, {\"name\": \"b\", \"port\": 309}]   } The resulting set of endpoints can be viewed as:     a: [ 10.10.1.1:8675, 10.10.2.2:8675 ],     b: [ 10.10.1.1:309, 10.10.2.2:309 ]
*/
class V1EndpointSubset {
}
exports.V1EndpointSubset = V1EndpointSubset;
/**
* Endpoints is a collection of endpoints that implement the actual service. Example:   Name: \"mysvc\",   Subsets: [     {       Addresses: [{\"ip\": \"10.10.1.1\"}, {\"ip\": \"10.10.2.2\"}],       Ports: [{\"name\": \"a\", \"port\": 8675}, {\"name\": \"b\", \"port\": 309}]     },     {       Addresses: [{\"ip\": \"10.10.3.3\"}],       Ports: [{\"name\": \"a\", \"port\": 93}, {\"name\": \"b\", \"port\": 76}]     },  ]
*/
class V1Endpoints {
}
exports.V1Endpoints = V1Endpoints;
/**
* EndpointsList is a list of endpoints.
*/
class V1EndpointsList {
}
exports.V1EndpointsList = V1EndpointsList;
/**
* EnvFromSource represents the source of a set of ConfigMaps
*/
class V1EnvFromSource {
}
exports.V1EnvFromSource = V1EnvFromSource;
/**
* EnvVar represents an environment variable present in a Container.
*/
class V1EnvVar {
}
exports.V1EnvVar = V1EnvVar;
/**
* EnvVarSource represents a source for the value of an EnvVar.
*/
class V1EnvVarSource {
}
exports.V1EnvVarSource = V1EnvVarSource;
/**
* Event is a report of an event somewhere in the cluster.
*/
class V1Event {
}
exports.V1Event = V1Event;
/**
* EventList is a list of events.
*/
class V1EventList {
}
exports.V1EventList = V1EventList;
/**
* EventSeries contain information on series of events, i.e. thing that was/is happening continuously for some time.
*/
class V1EventSeries {
}
exports.V1EventSeries = V1EventSeries;
/**
* EventSource contains information for an event.
*/
class V1EventSource {
}
exports.V1EventSource = V1EventSource;
/**
* ExecAction describes a \"run in container\" action.
*/
class V1ExecAction {
}
exports.V1ExecAction = V1ExecAction;
/**
* Represents a Fibre Channel volume. Fibre Channel volumes can only be mounted as read/write once. Fibre Channel volumes support ownership management and SELinux relabeling.
*/
class V1FCVolumeSource {
}
exports.V1FCVolumeSource = V1FCVolumeSource;
/**
* FlexPersistentVolumeSource represents a generic persistent volume resource that is provisioned/attached using an exec based plugin.
*/
class V1FlexPersistentVolumeSource {
}
exports.V1FlexPersistentVolumeSource = V1FlexPersistentVolumeSource;
/**
* FlexVolume represents a generic volume resource that is provisioned/attached using an exec based plugin.
*/
class V1FlexVolumeSource {
}
exports.V1FlexVolumeSource = V1FlexVolumeSource;
/**
* Represents a Flocker volume mounted by the Flocker agent. One and only one of datasetName and datasetUUID should be set. Flocker volumes do not support ownership management or SELinux relabeling.
*/
class V1FlockerVolumeSource {
}
exports.V1FlockerVolumeSource = V1FlockerVolumeSource;
/**
* Represents a Persistent Disk resource in Google Compute Engine.  A GCE PD must exist before mounting to a container. The disk must also be in the same GCE project and zone as the kubelet. A GCE PD can only be mounted as read/write once or read-only many times. GCE PDs support ownership management and SELinux relabeling.
*/
class V1GCEPersistentDiskVolumeSource {
}
exports.V1GCEPersistentDiskVolumeSource = V1GCEPersistentDiskVolumeSource;
/**
* Represents a volume that is populated with the contents of a git repository. Git repo volumes do not support ownership management. Git repo volumes support SELinux relabeling.  DEPRECATED: GitRepo is deprecated. To provision a container with a git repo, mount an EmptyDir into an InitContainer that clones the repo using git, then mount the EmptyDir into the Pod's container.
*/
class V1GitRepoVolumeSource {
}
exports.V1GitRepoVolumeSource = V1GitRepoVolumeSource;
/**
* Represents a Glusterfs mount that lasts the lifetime of a pod. Glusterfs volumes do not support ownership management or SELinux relabeling.
*/
class V1GlusterfsVolumeSource {
}
exports.V1GlusterfsVolumeSource = V1GlusterfsVolumeSource;
/**
* GroupVersion contains the \"group/version\" and \"version\" string of a version. It is made a struct to keep extensibility.
*/
class V1GroupVersionForDiscovery {
}
exports.V1GroupVersionForDiscovery = V1GroupVersionForDiscovery;
/**
* HTTPGetAction describes an action based on HTTP Get requests.
*/
class V1HTTPGetAction {
}
exports.V1HTTPGetAction = V1HTTPGetAction;
/**
* HTTPHeader describes a custom header to be used in HTTP probes
*/
class V1HTTPHeader {
}
exports.V1HTTPHeader = V1HTTPHeader;
/**
* Handler defines a specific action that should be taken
*/
class V1Handler {
}
exports.V1Handler = V1Handler;
/**
* configuration of a horizontal pod autoscaler.
*/
class V1HorizontalPodAutoscaler {
}
exports.V1HorizontalPodAutoscaler = V1HorizontalPodAutoscaler;
/**
* list of horizontal pod autoscaler objects.
*/
class V1HorizontalPodAutoscalerList {
}
exports.V1HorizontalPodAutoscalerList = V1HorizontalPodAutoscalerList;
/**
* specification of a horizontal pod autoscaler.
*/
class V1HorizontalPodAutoscalerSpec {
}
exports.V1HorizontalPodAutoscalerSpec = V1HorizontalPodAutoscalerSpec;
/**
* current status of a horizontal pod autoscaler
*/
class V1HorizontalPodAutoscalerStatus {
}
exports.V1HorizontalPodAutoscalerStatus = V1HorizontalPodAutoscalerStatus;
/**
* HostAlias holds the mapping between IP and hostnames that will be injected as an entry in the pod's hosts file.
*/
class V1HostAlias {
}
exports.V1HostAlias = V1HostAlias;
/**
* Represents a host path mapped into a pod. Host path volumes do not support ownership management or SELinux relabeling.
*/
class V1HostPathVolumeSource {
}
exports.V1HostPathVolumeSource = V1HostPathVolumeSource;
/**
* IPBlock describes a particular CIDR (Ex. \"192.168.1.1/24\") that is allowed to the pods matched by a NetworkPolicySpec's podSelector. The except entry describes CIDRs that should not be included within this rule.
*/
class V1IPBlock {
}
exports.V1IPBlock = V1IPBlock;
/**
* ISCSIPersistentVolumeSource represents an ISCSI disk. ISCSI volumes can only be mounted as read/write once. ISCSI volumes support ownership management and SELinux relabeling.
*/
class V1ISCSIPersistentVolumeSource {
}
exports.V1ISCSIPersistentVolumeSource = V1ISCSIPersistentVolumeSource;
/**
* Represents an ISCSI disk. ISCSI volumes can only be mounted as read/write once. ISCSI volumes support ownership management and SELinux relabeling.
*/
class V1ISCSIVolumeSource {
}
exports.V1ISCSIVolumeSource = V1ISCSIVolumeSource;
/**
* Initializer is information about an initializer that has not yet completed.
*/
class V1Initializer {
}
exports.V1Initializer = V1Initializer;
/**
* Initializers tracks the progress of initialization.
*/
class V1Initializers {
}
exports.V1Initializers = V1Initializers;
/**
* Job represents the configuration of a single job.
*/
class V1Job {
}
exports.V1Job = V1Job;
/**
* JobCondition describes current state of a job.
*/
class V1JobCondition {
}
exports.V1JobCondition = V1JobCondition;
/**
* JobList is a collection of jobs.
*/
class V1JobList {
}
exports.V1JobList = V1JobList;
/**
* JobSpec describes how the job execution will look like.
*/
class V1JobSpec {
}
exports.V1JobSpec = V1JobSpec;
/**
* JobStatus represents the current state of a Job.
*/
class V1JobStatus {
}
exports.V1JobStatus = V1JobStatus;
/**
* Maps a string key to a path within a volume.
*/
class V1KeyToPath {
}
exports.V1KeyToPath = V1KeyToPath;
/**
* A label selector is a label query over a set of resources. The result of matchLabels and matchExpressions are ANDed. An empty label selector matches all objects. A null label selector matches no objects.
*/
class V1LabelSelector {
}
exports.V1LabelSelector = V1LabelSelector;
/**
* A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
*/
class V1LabelSelectorRequirement {
}
exports.V1LabelSelectorRequirement = V1LabelSelectorRequirement;
/**
* Lifecycle describes actions that the management system should take in response to container lifecycle events. For the PostStart and PreStop lifecycle handlers, management of the container blocks until the action is complete, unless the container process fails, in which case the handler is aborted.
*/
class V1Lifecycle {
}
exports.V1Lifecycle = V1Lifecycle;
/**
* LimitRange sets resource usage limits for each kind of resource in a Namespace.
*/
class V1LimitRange {
}
exports.V1LimitRange = V1LimitRange;
/**
* LimitRangeItem defines a min/max usage limit for any resource that matches on kind.
*/
class V1LimitRangeItem {
}
exports.V1LimitRangeItem = V1LimitRangeItem;
/**
* LimitRangeList is a list of LimitRange items.
*/
class V1LimitRangeList {
}
exports.V1LimitRangeList = V1LimitRangeList;
/**
* LimitRangeSpec defines a min/max usage limit for resources that match on kind.
*/
class V1LimitRangeSpec {
}
exports.V1LimitRangeSpec = V1LimitRangeSpec;
/**
* ListMeta describes metadata that synthetic resources must have, including lists and various status objects. A resource may have only one of {ObjectMeta, ListMeta}.
*/
class V1ListMeta {
}
exports.V1ListMeta = V1ListMeta;
/**
* LoadBalancerIngress represents the status of a load-balancer ingress point: traffic intended for the service should be sent to an ingress point.
*/
class V1LoadBalancerIngress {
}
exports.V1LoadBalancerIngress = V1LoadBalancerIngress;
/**
* LoadBalancerStatus represents the status of a load-balancer.
*/
class V1LoadBalancerStatus {
}
exports.V1LoadBalancerStatus = V1LoadBalancerStatus;
/**
* LocalObjectReference contains enough information to let you locate the referenced object inside the same namespace.
*/
class V1LocalObjectReference {
}
exports.V1LocalObjectReference = V1LocalObjectReference;
/**
* LocalSubjectAccessReview checks whether or not a user or group can perform an action in a given namespace. Having a namespace scoped resource makes it much easier to grant namespace scoped policy that includes permissions checking.
*/
class V1LocalSubjectAccessReview {
}
exports.V1LocalSubjectAccessReview = V1LocalSubjectAccessReview;
/**
* Local represents directly-attached storage with node affinity (Beta feature)
*/
class V1LocalVolumeSource {
}
exports.V1LocalVolumeSource = V1LocalVolumeSource;
/**
* Represents an NFS mount that lasts the lifetime of a pod. NFS volumes do not support ownership management or SELinux relabeling.
*/
class V1NFSVolumeSource {
}
exports.V1NFSVolumeSource = V1NFSVolumeSource;
/**
* Namespace provides a scope for Names. Use of multiple namespaces is optional.
*/
class V1Namespace {
}
exports.V1Namespace = V1Namespace;
/**
* NamespaceList is a list of Namespaces.
*/
class V1NamespaceList {
}
exports.V1NamespaceList = V1NamespaceList;
/**
* NamespaceSpec describes the attributes on a Namespace.
*/
class V1NamespaceSpec {
}
exports.V1NamespaceSpec = V1NamespaceSpec;
/**
* NamespaceStatus is information about the current status of a Namespace.
*/
class V1NamespaceStatus {
}
exports.V1NamespaceStatus = V1NamespaceStatus;
/**
* NetworkPolicy describes what network traffic is allowed for a set of Pods
*/
class V1NetworkPolicy {
}
exports.V1NetworkPolicy = V1NetworkPolicy;
/**
* NetworkPolicyEgressRule describes a particular set of traffic that is allowed out of pods matched by a NetworkPolicySpec's podSelector. The traffic must match both ports and to. This type is beta-level in 1.8
*/
class V1NetworkPolicyEgressRule {
}
exports.V1NetworkPolicyEgressRule = V1NetworkPolicyEgressRule;
/**
* NetworkPolicyIngressRule describes a particular set of traffic that is allowed to the pods matched by a NetworkPolicySpec's podSelector. The traffic must match both ports and from.
*/
class V1NetworkPolicyIngressRule {
}
exports.V1NetworkPolicyIngressRule = V1NetworkPolicyIngressRule;
/**
* NetworkPolicyList is a list of NetworkPolicy objects.
*/
class V1NetworkPolicyList {
}
exports.V1NetworkPolicyList = V1NetworkPolicyList;
/**
* NetworkPolicyPeer describes a peer to allow traffic from. Only certain combinations of fields are allowed
*/
class V1NetworkPolicyPeer {
}
exports.V1NetworkPolicyPeer = V1NetworkPolicyPeer;
/**
* NetworkPolicyPort describes a port to allow traffic on
*/
class V1NetworkPolicyPort {
}
exports.V1NetworkPolicyPort = V1NetworkPolicyPort;
/**
* NetworkPolicySpec provides the specification of a NetworkPolicy
*/
class V1NetworkPolicySpec {
}
exports.V1NetworkPolicySpec = V1NetworkPolicySpec;
/**
* Node is a worker node in Kubernetes. Each node will have a unique identifier in the cache (i.e. in etcd).
*/
class V1Node {
}
exports.V1Node = V1Node;
/**
* NodeAddress contains information for the node's address.
*/
class V1NodeAddress {
}
exports.V1NodeAddress = V1NodeAddress;
/**
* Node affinity is a group of node affinity scheduling rules.
*/
class V1NodeAffinity {
}
exports.V1NodeAffinity = V1NodeAffinity;
/**
* NodeCondition contains condition information for a node.
*/
class V1NodeCondition {
}
exports.V1NodeCondition = V1NodeCondition;
/**
* NodeConfigSource specifies a source of node configuration. Exactly one subfield (excluding metadata) must be non-nil.
*/
class V1NodeConfigSource {
}
exports.V1NodeConfigSource = V1NodeConfigSource;
/**
* NodeConfigStatus describes the status of the config assigned by Node.Spec.ConfigSource.
*/
class V1NodeConfigStatus {
}
exports.V1NodeConfigStatus = V1NodeConfigStatus;
/**
* NodeDaemonEndpoints lists ports opened by daemons running on the Node.
*/
class V1NodeDaemonEndpoints {
}
exports.V1NodeDaemonEndpoints = V1NodeDaemonEndpoints;
/**
* NodeList is the whole list of all Nodes which have been registered with master.
*/
class V1NodeList {
}
exports.V1NodeList = V1NodeList;
/**
* A node selector represents the union of the results of one or more label queries over a set of nodes; that is, it represents the OR of the selectors represented by the node selector terms.
*/
class V1NodeSelector {
}
exports.V1NodeSelector = V1NodeSelector;
/**
* A node selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
*/
class V1NodeSelectorRequirement {
}
exports.V1NodeSelectorRequirement = V1NodeSelectorRequirement;
/**
* A null or empty node selector term matches no objects. The requirements of them are ANDed. The TopologySelectorTerm type implements a subset of the NodeSelectorTerm.
*/
class V1NodeSelectorTerm {
}
exports.V1NodeSelectorTerm = V1NodeSelectorTerm;
/**
* NodeSpec describes the attributes that a node is created with.
*/
class V1NodeSpec {
}
exports.V1NodeSpec = V1NodeSpec;
/**
* NodeStatus is information about the current status of a node.
*/
class V1NodeStatus {
}
exports.V1NodeStatus = V1NodeStatus;
/**
* NodeSystemInfo is a set of ids/uuids to uniquely identify the node.
*/
class V1NodeSystemInfo {
}
exports.V1NodeSystemInfo = V1NodeSystemInfo;
/**
* NonResourceAttributes includes the authorization attributes available for non-resource requests to the Authorizer interface
*/
class V1NonResourceAttributes {
}
exports.V1NonResourceAttributes = V1NonResourceAttributes;
/**
* NonResourceRule holds information that describes a rule for the non-resource
*/
class V1NonResourceRule {
}
exports.V1NonResourceRule = V1NonResourceRule;
/**
* ObjectFieldSelector selects an APIVersioned field of an object.
*/
class V1ObjectFieldSelector {
}
exports.V1ObjectFieldSelector = V1ObjectFieldSelector;
/**
* ObjectMeta is metadata that all persisted resources must have, which includes all objects users must create.
*/
class V1ObjectMeta {
}
exports.V1ObjectMeta = V1ObjectMeta;
/**
* ObjectReference contains enough information to let you inspect or modify the referred object.
*/
class V1ObjectReference {
}
exports.V1ObjectReference = V1ObjectReference;
/**
* OwnerReference contains enough information to let you identify an owning object. Currently, an owning object must be in the same namespace, so there is no namespace field.
*/
class V1OwnerReference {
}
exports.V1OwnerReference = V1OwnerReference;
/**
* PersistentVolume (PV) is a storage resource provisioned by an administrator. It is analogous to a node. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes
*/
class V1PersistentVolume {
}
exports.V1PersistentVolume = V1PersistentVolume;
/**
* PersistentVolumeClaim is a user's request for and claim to a persistent volume
*/
class V1PersistentVolumeClaim {
}
exports.V1PersistentVolumeClaim = V1PersistentVolumeClaim;
/**
* PersistentVolumeClaimCondition contails details about state of pvc
*/
class V1PersistentVolumeClaimCondition {
}
exports.V1PersistentVolumeClaimCondition = V1PersistentVolumeClaimCondition;
/**
* PersistentVolumeClaimList is a list of PersistentVolumeClaim items.
*/
class V1PersistentVolumeClaimList {
}
exports.V1PersistentVolumeClaimList = V1PersistentVolumeClaimList;
/**
* PersistentVolumeClaimSpec describes the common attributes of storage devices and allows a Source for provider-specific attributes
*/
class V1PersistentVolumeClaimSpec {
}
exports.V1PersistentVolumeClaimSpec = V1PersistentVolumeClaimSpec;
/**
* PersistentVolumeClaimStatus is the current status of a persistent volume claim.
*/
class V1PersistentVolumeClaimStatus {
}
exports.V1PersistentVolumeClaimStatus = V1PersistentVolumeClaimStatus;
/**
* PersistentVolumeClaimVolumeSource references the user's PVC in the same namespace. This volume finds the bound PV and mounts that volume for the pod. A PersistentVolumeClaimVolumeSource is, essentially, a wrapper around another type of volume that is owned by someone else (the system).
*/
class V1PersistentVolumeClaimVolumeSource {
}
exports.V1PersistentVolumeClaimVolumeSource = V1PersistentVolumeClaimVolumeSource;
/**
* PersistentVolumeList is a list of PersistentVolume items.
*/
class V1PersistentVolumeList {
}
exports.V1PersistentVolumeList = V1PersistentVolumeList;
/**
* PersistentVolumeSpec is the specification of a persistent volume.
*/
class V1PersistentVolumeSpec {
}
exports.V1PersistentVolumeSpec = V1PersistentVolumeSpec;
/**
* PersistentVolumeStatus is the current status of a persistent volume.
*/
class V1PersistentVolumeStatus {
}
exports.V1PersistentVolumeStatus = V1PersistentVolumeStatus;
/**
* Represents a Photon Controller persistent disk resource.
*/
class V1PhotonPersistentDiskVolumeSource {
}
exports.V1PhotonPersistentDiskVolumeSource = V1PhotonPersistentDiskVolumeSource;
/**
* Pod is a collection of containers that can run on a host. This resource is created by clients and scheduled onto hosts.
*/
class V1Pod {
}
exports.V1Pod = V1Pod;
/**
* Pod affinity is a group of inter pod affinity scheduling rules.
*/
class V1PodAffinity {
}
exports.V1PodAffinity = V1PodAffinity;
/**
* Defines a set of pods (namely those matching the labelSelector relative to the given namespace(s)) that this pod should be co-located (affinity) or not co-located (anti-affinity) with, where co-located is defined as running on a node whose value of the label with key <topologyKey> matches that of any node on which a pod of the set of pods is running
*/
class V1PodAffinityTerm {
}
exports.V1PodAffinityTerm = V1PodAffinityTerm;
/**
* Pod anti affinity is a group of inter pod anti affinity scheduling rules.
*/
class V1PodAntiAffinity {
}
exports.V1PodAntiAffinity = V1PodAntiAffinity;
/**
* PodCondition contains details for the current condition of this pod.
*/
class V1PodCondition {
}
exports.V1PodCondition = V1PodCondition;
/**
* PodDNSConfig defines the DNS parameters of a pod in addition to those generated from DNSPolicy.
*/
class V1PodDNSConfig {
}
exports.V1PodDNSConfig = V1PodDNSConfig;
/**
* PodDNSConfigOption defines DNS resolver options of a pod.
*/
class V1PodDNSConfigOption {
}
exports.V1PodDNSConfigOption = V1PodDNSConfigOption;
/**
* PodList is a list of Pods.
*/
class V1PodList {
}
exports.V1PodList = V1PodList;
/**
* PodReadinessGate contains the reference to a pod condition
*/
class V1PodReadinessGate {
}
exports.V1PodReadinessGate = V1PodReadinessGate;
/**
* PodSecurityContext holds pod-level security attributes and common container settings. Some fields are also present in container.securityContext.  Field values of container.securityContext take precedence over field values of PodSecurityContext.
*/
class V1PodSecurityContext {
}
exports.V1PodSecurityContext = V1PodSecurityContext;
/**
* PodSpec is a description of a pod.
*/
class V1PodSpec {
}
exports.V1PodSpec = V1PodSpec;
/**
* PodStatus represents information about the status of a pod. Status may trail the actual state of a system, especially if the node that hosts the pod cannot contact the control plane.
*/
class V1PodStatus {
}
exports.V1PodStatus = V1PodStatus;
/**
* PodTemplate describes a template for creating copies of a predefined pod.
*/
class V1PodTemplate {
}
exports.V1PodTemplate = V1PodTemplate;
/**
* PodTemplateList is a list of PodTemplates.
*/
class V1PodTemplateList {
}
exports.V1PodTemplateList = V1PodTemplateList;
/**
* PodTemplateSpec describes the data a pod should have when created from a template
*/
class V1PodTemplateSpec {
}
exports.V1PodTemplateSpec = V1PodTemplateSpec;
/**
* PolicyRule holds information that describes a policy rule, but does not contain information about who the rule applies to or which namespace the rule applies to.
*/
class V1PolicyRule {
}
exports.V1PolicyRule = V1PolicyRule;
/**
* PortworxVolumeSource represents a Portworx volume resource.
*/
class V1PortworxVolumeSource {
}
exports.V1PortworxVolumeSource = V1PortworxVolumeSource;
/**
* Preconditions must be fulfilled before an operation (update, delete, etc.) is carried out.
*/
class V1Preconditions {
}
exports.V1Preconditions = V1Preconditions;
/**
* An empty preferred scheduling term matches all objects with implicit weight 0 (i.e. it's a no-op). A null preferred scheduling term matches no objects (i.e. is also a no-op).
*/
class V1PreferredSchedulingTerm {
}
exports.V1PreferredSchedulingTerm = V1PreferredSchedulingTerm;
/**
* Probe describes a health check to be performed against a container to determine whether it is alive or ready to receive traffic.
*/
class V1Probe {
}
exports.V1Probe = V1Probe;
/**
* Represents a projected volume source
*/
class V1ProjectedVolumeSource {
}
exports.V1ProjectedVolumeSource = V1ProjectedVolumeSource;
/**
* Represents a Quobyte mount that lasts the lifetime of a pod. Quobyte volumes do not support ownership management or SELinux relabeling.
*/
class V1QuobyteVolumeSource {
}
exports.V1QuobyteVolumeSource = V1QuobyteVolumeSource;
/**
* Represents a Rados Block Device mount that lasts the lifetime of a pod. RBD volumes support ownership management and SELinux relabeling.
*/
class V1RBDPersistentVolumeSource {
}
exports.V1RBDPersistentVolumeSource = V1RBDPersistentVolumeSource;
/**
* Represents a Rados Block Device mount that lasts the lifetime of a pod. RBD volumes support ownership management and SELinux relabeling.
*/
class V1RBDVolumeSource {
}
exports.V1RBDVolumeSource = V1RBDVolumeSource;
/**
* ReplicaSet ensures that a specified number of pod replicas are running at any given time.
*/
class V1ReplicaSet {
}
exports.V1ReplicaSet = V1ReplicaSet;
/**
* ReplicaSetCondition describes the state of a replica set at a certain point.
*/
class V1ReplicaSetCondition {
}
exports.V1ReplicaSetCondition = V1ReplicaSetCondition;
/**
* ReplicaSetList is a collection of ReplicaSets.
*/
class V1ReplicaSetList {
}
exports.V1ReplicaSetList = V1ReplicaSetList;
/**
* ReplicaSetSpec is the specification of a ReplicaSet.
*/
class V1ReplicaSetSpec {
}
exports.V1ReplicaSetSpec = V1ReplicaSetSpec;
/**
* ReplicaSetStatus represents the current status of a ReplicaSet.
*/
class V1ReplicaSetStatus {
}
exports.V1ReplicaSetStatus = V1ReplicaSetStatus;
/**
* ReplicationController represents the configuration of a replication controller.
*/
class V1ReplicationController {
}
exports.V1ReplicationController = V1ReplicationController;
/**
* ReplicationControllerCondition describes the state of a replication controller at a certain point.
*/
class V1ReplicationControllerCondition {
}
exports.V1ReplicationControllerCondition = V1ReplicationControllerCondition;
/**
* ReplicationControllerList is a collection of replication controllers.
*/
class V1ReplicationControllerList {
}
exports.V1ReplicationControllerList = V1ReplicationControllerList;
/**
* ReplicationControllerSpec is the specification of a replication controller.
*/
class V1ReplicationControllerSpec {
}
exports.V1ReplicationControllerSpec = V1ReplicationControllerSpec;
/**
* ReplicationControllerStatus represents the current status of a replication controller.
*/
class V1ReplicationControllerStatus {
}
exports.V1ReplicationControllerStatus = V1ReplicationControllerStatus;
/**
* ResourceAttributes includes the authorization attributes available for resource requests to the Authorizer interface
*/
class V1ResourceAttributes {
}
exports.V1ResourceAttributes = V1ResourceAttributes;
/**
* ResourceFieldSelector represents container resources (cpu, memory) and their output format
*/
class V1ResourceFieldSelector {
}
exports.V1ResourceFieldSelector = V1ResourceFieldSelector;
/**
* ResourceQuota sets aggregate quota restrictions enforced per namespace
*/
class V1ResourceQuota {
}
exports.V1ResourceQuota = V1ResourceQuota;
/**
* ResourceQuotaList is a list of ResourceQuota items.
*/
class V1ResourceQuotaList {
}
exports.V1ResourceQuotaList = V1ResourceQuotaList;
/**
* ResourceQuotaSpec defines the desired hard limits to enforce for Quota.
*/
class V1ResourceQuotaSpec {
}
exports.V1ResourceQuotaSpec = V1ResourceQuotaSpec;
/**
* ResourceQuotaStatus defines the enforced hard limits and observed use.
*/
class V1ResourceQuotaStatus {
}
exports.V1ResourceQuotaStatus = V1ResourceQuotaStatus;
/**
* ResourceRequirements describes the compute resource requirements.
*/
class V1ResourceRequirements {
}
exports.V1ResourceRequirements = V1ResourceRequirements;
/**
* ResourceRule is the list of actions the subject is allowed to perform on resources. The list ordering isn't significant, may contain duplicates, and possibly be incomplete.
*/
class V1ResourceRule {
}
exports.V1ResourceRule = V1ResourceRule;
/**
* Role is a namespaced, logical grouping of PolicyRules that can be referenced as a unit by a RoleBinding.
*/
class V1Role {
}
exports.V1Role = V1Role;
/**
* RoleBinding references a role, but does not contain it.  It can reference a Role in the same namespace or a ClusterRole in the global namespace. It adds who information via Subjects and namespace information by which namespace it exists in.  RoleBindings in a given namespace only have effect in that namespace.
*/
class V1RoleBinding {
}
exports.V1RoleBinding = V1RoleBinding;
/**
* RoleBindingList is a collection of RoleBindings
*/
class V1RoleBindingList {
}
exports.V1RoleBindingList = V1RoleBindingList;
/**
* RoleList is a collection of Roles
*/
class V1RoleList {
}
exports.V1RoleList = V1RoleList;
/**
* RoleRef contains information that points to the role being used
*/
class V1RoleRef {
}
exports.V1RoleRef = V1RoleRef;
/**
* Spec to control the desired behavior of daemon set rolling update.
*/
class V1RollingUpdateDaemonSet {
}
exports.V1RollingUpdateDaemonSet = V1RollingUpdateDaemonSet;
/**
* Spec to control the desired behavior of rolling update.
*/
class V1RollingUpdateDeployment {
}
exports.V1RollingUpdateDeployment = V1RollingUpdateDeployment;
/**
* RollingUpdateStatefulSetStrategy is used to communicate parameter for RollingUpdateStatefulSetStrategyType.
*/
class V1RollingUpdateStatefulSetStrategy {
}
exports.V1RollingUpdateStatefulSetStrategy = V1RollingUpdateStatefulSetStrategy;
/**
* SELinuxOptions are the labels to be applied to the container
*/
class V1SELinuxOptions {
}
exports.V1SELinuxOptions = V1SELinuxOptions;
/**
* Scale represents a scaling request for a resource.
*/
class V1Scale {
}
exports.V1Scale = V1Scale;
/**
* ScaleIOPersistentVolumeSource represents a persistent ScaleIO volume
*/
class V1ScaleIOPersistentVolumeSource {
}
exports.V1ScaleIOPersistentVolumeSource = V1ScaleIOPersistentVolumeSource;
/**
* ScaleIOVolumeSource represents a persistent ScaleIO volume
*/
class V1ScaleIOVolumeSource {
}
exports.V1ScaleIOVolumeSource = V1ScaleIOVolumeSource;
/**
* ScaleSpec describes the attributes of a scale subresource.
*/
class V1ScaleSpec {
}
exports.V1ScaleSpec = V1ScaleSpec;
/**
* ScaleStatus represents the current status of a scale subresource.
*/
class V1ScaleStatus {
}
exports.V1ScaleStatus = V1ScaleStatus;
/**
* A scope selector represents the AND of the selectors represented by the scoped-resource selector requirements.
*/
class V1ScopeSelector {
}
exports.V1ScopeSelector = V1ScopeSelector;
/**
* A scoped-resource selector requirement is a selector that contains values, a scope name, and an operator that relates the scope name and values.
*/
class V1ScopedResourceSelectorRequirement {
}
exports.V1ScopedResourceSelectorRequirement = V1ScopedResourceSelectorRequirement;
/**
* Secret holds secret data of a certain type. The total bytes of the values in the Data field must be less than MaxSecretSize bytes.
*/
class V1Secret {
}
exports.V1Secret = V1Secret;
/**
* SecretEnvSource selects a Secret to populate the environment variables with.  The contents of the target Secret's Data field will represent the key-value pairs as environment variables.
*/
class V1SecretEnvSource {
}
exports.V1SecretEnvSource = V1SecretEnvSource;
/**
* SecretKeySelector selects a key of a Secret.
*/
class V1SecretKeySelector {
}
exports.V1SecretKeySelector = V1SecretKeySelector;
/**
* SecretList is a list of Secret.
*/
class V1SecretList {
}
exports.V1SecretList = V1SecretList;
/**
* Adapts a secret into a projected volume.  The contents of the target Secret's Data field will be presented in a projected volume as files using the keys in the Data field as the file names. Note that this is identical to a secret volume source without the default mode.
*/
class V1SecretProjection {
}
exports.V1SecretProjection = V1SecretProjection;
/**
* SecretReference represents a Secret Reference. It has enough information to retrieve secret in any namespace
*/
class V1SecretReference {
}
exports.V1SecretReference = V1SecretReference;
/**
* Adapts a Secret into a volume.  The contents of the target Secret's Data field will be presented in a volume as files using the keys in the Data field as the file names. Secret volumes support ownership management and SELinux relabeling.
*/
class V1SecretVolumeSource {
}
exports.V1SecretVolumeSource = V1SecretVolumeSource;
/**
* SecurityContext holds security configuration that will be applied to a container. Some fields are present in both SecurityContext and PodSecurityContext.  When both are set, the values in SecurityContext take precedence.
*/
class V1SecurityContext {
}
exports.V1SecurityContext = V1SecurityContext;
/**
* SelfSubjectAccessReview checks whether or the current user can perform an action.  Not filling in a spec.namespace means \"in all namespaces\".  Self is a special case, because users should always be able to check whether they can perform an action
*/
class V1SelfSubjectAccessReview {
}
exports.V1SelfSubjectAccessReview = V1SelfSubjectAccessReview;
/**
* SelfSubjectAccessReviewSpec is a description of the access request.  Exactly one of ResourceAuthorizationAttributes and NonResourceAuthorizationAttributes must be set
*/
class V1SelfSubjectAccessReviewSpec {
}
exports.V1SelfSubjectAccessReviewSpec = V1SelfSubjectAccessReviewSpec;
/**
* SelfSubjectRulesReview enumerates the set of actions the current user can perform within a namespace. The returned list of actions may be incomplete depending on the server's authorization mode, and any errors experienced during the evaluation. SelfSubjectRulesReview should be used by UIs to show/hide actions, or to quickly let an end user reason about their permissions. It should NOT Be used by external systems to drive authorization decisions as this raises confused deputy, cache lifetime/revocation, and correctness concerns. SubjectAccessReview, and LocalAccessReview are the correct way to defer authorization decisions to the API server.
*/
class V1SelfSubjectRulesReview {
}
exports.V1SelfSubjectRulesReview = V1SelfSubjectRulesReview;
class V1SelfSubjectRulesReviewSpec {
}
exports.V1SelfSubjectRulesReviewSpec = V1SelfSubjectRulesReviewSpec;
/**
* ServerAddressByClientCIDR helps the client to determine the server address that they should use, depending on the clientCIDR that they match.
*/
class V1ServerAddressByClientCIDR {
}
exports.V1ServerAddressByClientCIDR = V1ServerAddressByClientCIDR;
/**
* Service is a named abstraction of software service (for example, mysql) consisting of local port (for example 3306) that the proxy listens on, and the selector that determines which pods will answer requests sent through the proxy.
*/
class V1Service {
}
exports.V1Service = V1Service;
/**
* ServiceAccount binds together: * a name, understood by users, and perhaps by peripheral systems, for an identity * a principal that can be authenticated and authorized * a set of secrets
*/
class V1ServiceAccount {
}
exports.V1ServiceAccount = V1ServiceAccount;
/**
* ServiceAccountList is a list of ServiceAccount objects
*/
class V1ServiceAccountList {
}
exports.V1ServiceAccountList = V1ServiceAccountList;
/**
* ServiceAccountTokenProjection represents a projected service account token volume. This projection can be used to insert a service account token into the pods runtime filesystem for use against APIs (Kubernetes API Server or otherwise).
*/
class V1ServiceAccountTokenProjection {
}
exports.V1ServiceAccountTokenProjection = V1ServiceAccountTokenProjection;
/**
* ServiceList holds a list of services.
*/
class V1ServiceList {
}
exports.V1ServiceList = V1ServiceList;
/**
* ServicePort contains information on service's port.
*/
class V1ServicePort {
}
exports.V1ServicePort = V1ServicePort;
/**
* ServiceReference holds a reference to Service.legacy.k8s.io
*/
class V1ServiceReference {
}
exports.V1ServiceReference = V1ServiceReference;
/**
* ServiceSpec describes the attributes that a user creates on a service.
*/
class V1ServiceSpec {
}
exports.V1ServiceSpec = V1ServiceSpec;
/**
* ServiceStatus represents the current status of a service.
*/
class V1ServiceStatus {
}
exports.V1ServiceStatus = V1ServiceStatus;
/**
* SessionAffinityConfig represents the configurations of session affinity.
*/
class V1SessionAffinityConfig {
}
exports.V1SessionAffinityConfig = V1SessionAffinityConfig;
/**
* StatefulSet represents a set of pods with consistent identities. Identities are defined as:  - Network: A single stable DNS and hostname.  - Storage: As many VolumeClaims as requested. The StatefulSet guarantees that a given network identity will always map to the same storage identity.
*/
class V1StatefulSet {
}
exports.V1StatefulSet = V1StatefulSet;
/**
* StatefulSetCondition describes the state of a statefulset at a certain point.
*/
class V1StatefulSetCondition {
}
exports.V1StatefulSetCondition = V1StatefulSetCondition;
/**
* StatefulSetList is a collection of StatefulSets.
*/
class V1StatefulSetList {
}
exports.V1StatefulSetList = V1StatefulSetList;
/**
* A StatefulSetSpec is the specification of a StatefulSet.
*/
class V1StatefulSetSpec {
}
exports.V1StatefulSetSpec = V1StatefulSetSpec;
/**
* StatefulSetStatus represents the current state of a StatefulSet.
*/
class V1StatefulSetStatus {
}
exports.V1StatefulSetStatus = V1StatefulSetStatus;
/**
* StatefulSetUpdateStrategy indicates the strategy that the StatefulSet controller will use to perform updates. It includes any additional parameters necessary to perform the update for the indicated strategy.
*/
class V1StatefulSetUpdateStrategy {
}
exports.V1StatefulSetUpdateStrategy = V1StatefulSetUpdateStrategy;
/**
* Status is a return value for calls that don't return other objects.
*/
class V1Status {
}
exports.V1Status = V1Status;
/**
* StatusCause provides more information about an api.Status failure, including cases when multiple errors are encountered.
*/
class V1StatusCause {
}
exports.V1StatusCause = V1StatusCause;
/**
* StatusDetails is a set of additional properties that MAY be set by the server to provide additional information about a response. The Reason field of a Status object defines what attributes will be set. Clients must ignore fields that do not match the defined type of each attribute, and should assume that any attribute may be empty, invalid, or under defined.
*/
class V1StatusDetails {
}
exports.V1StatusDetails = V1StatusDetails;
/**
* StorageClass describes the parameters for a class of storage for which PersistentVolumes can be dynamically provisioned.  StorageClasses are non-namespaced; the name of the storage class according to etcd is in ObjectMeta.Name.
*/
class V1StorageClass {
}
exports.V1StorageClass = V1StorageClass;
/**
* StorageClassList is a collection of storage classes.
*/
class V1StorageClassList {
}
exports.V1StorageClassList = V1StorageClassList;
/**
* Represents a StorageOS persistent volume resource.
*/
class V1StorageOSPersistentVolumeSource {
}
exports.V1StorageOSPersistentVolumeSource = V1StorageOSPersistentVolumeSource;
/**
* Represents a StorageOS persistent volume resource.
*/
class V1StorageOSVolumeSource {
}
exports.V1StorageOSVolumeSource = V1StorageOSVolumeSource;
/**
* Subject contains a reference to the object or user identities a role binding applies to.  This can either hold a direct API object reference, or a value for non-objects such as user and group names.
*/
class V1Subject {
}
exports.V1Subject = V1Subject;
/**
* SubjectAccessReview checks whether or not a user or group can perform an action.
*/
class V1SubjectAccessReview {
}
exports.V1SubjectAccessReview = V1SubjectAccessReview;
/**
* SubjectAccessReviewSpec is a description of the access request.  Exactly one of ResourceAuthorizationAttributes and NonResourceAuthorizationAttributes must be set
*/
class V1SubjectAccessReviewSpec {
}
exports.V1SubjectAccessReviewSpec = V1SubjectAccessReviewSpec;
/**
* SubjectAccessReviewStatus
*/
class V1SubjectAccessReviewStatus {
}
exports.V1SubjectAccessReviewStatus = V1SubjectAccessReviewStatus;
/**
* SubjectRulesReviewStatus contains the result of a rules check. This check can be incomplete depending on the set of authorizers the server is configured with and any errors experienced during evaluation. Because authorization rules are additive, if a rule appears in a list it's safe to assume the subject has that permission, even if that list is incomplete.
*/
class V1SubjectRulesReviewStatus {
}
exports.V1SubjectRulesReviewStatus = V1SubjectRulesReviewStatus;
/**
* Sysctl defines a kernel parameter to be set
*/
class V1Sysctl {
}
exports.V1Sysctl = V1Sysctl;
/**
* TCPSocketAction describes an action based on opening a socket
*/
class V1TCPSocketAction {
}
exports.V1TCPSocketAction = V1TCPSocketAction;
/**
* The node this Taint is attached to has the \"effect\" on any pod that does not tolerate the Taint.
*/
class V1Taint {
}
exports.V1Taint = V1Taint;
/**
* TokenReview attempts to authenticate a token to a known user. Note: TokenReview requests may be cached by the webhook token authenticator plugin in the kube-apiserver.
*/
class V1TokenReview {
}
exports.V1TokenReview = V1TokenReview;
/**
* TokenReviewSpec is a description of the token authentication request.
*/
class V1TokenReviewSpec {
}
exports.V1TokenReviewSpec = V1TokenReviewSpec;
/**
* TokenReviewStatus is the result of the token authentication request.
*/
class V1TokenReviewStatus {
}
exports.V1TokenReviewStatus = V1TokenReviewStatus;
/**
* The pod this Toleration is attached to tolerates any taint that matches the triple <key,value,effect> using the matching operator <operator>.
*/
class V1Toleration {
}
exports.V1Toleration = V1Toleration;
/**
* A topology selector requirement is a selector that matches given label. This is an alpha feature and may change in the future.
*/
class V1TopologySelectorLabelRequirement {
}
exports.V1TopologySelectorLabelRequirement = V1TopologySelectorLabelRequirement;
/**
* A topology selector term represents the result of label queries. A null or empty topology selector term matches no objects. The requirements of them are ANDed. It provides a subset of functionality as NodeSelectorTerm. This is an alpha feature and may change in the future.
*/
class V1TopologySelectorTerm {
}
exports.V1TopologySelectorTerm = V1TopologySelectorTerm;
/**
* UserInfo holds the information about the user needed to implement the user.Info interface.
*/
class V1UserInfo {
}
exports.V1UserInfo = V1UserInfo;
/**
* Volume represents a named volume in a pod that may be accessed by any container in the pod.
*/
class V1Volume {
}
exports.V1Volume = V1Volume;
/**
* volumeDevice describes a mapping of a raw block device within a container.
*/
class V1VolumeDevice {
}
exports.V1VolumeDevice = V1VolumeDevice;
/**
* VolumeMount describes a mounting of a Volume within a container.
*/
class V1VolumeMount {
}
exports.V1VolumeMount = V1VolumeMount;
/**
* VolumeNodeAffinity defines constraints that limit what nodes this volume can be accessed from.
*/
class V1VolumeNodeAffinity {
}
exports.V1VolumeNodeAffinity = V1VolumeNodeAffinity;
/**
* Projection that may be projected along with other supported volume types
*/
class V1VolumeProjection {
}
exports.V1VolumeProjection = V1VolumeProjection;
/**
* Represents a vSphere volume resource.
*/
class V1VsphereVirtualDiskVolumeSource {
}
exports.V1VsphereVirtualDiskVolumeSource = V1VsphereVirtualDiskVolumeSource;
/**
* Event represents a single event to a watched resource.
*/
class V1WatchEvent {
}
exports.V1WatchEvent = V1WatchEvent;
/**
* The weights of all of the matched WeightedPodAffinityTerm fields are added per-node to find the most preferred node(s)
*/
class V1WeightedPodAffinityTerm {
}
exports.V1WeightedPodAffinityTerm = V1WeightedPodAffinityTerm;
/**
* AggregationRule describes how to locate ClusterRoles to aggregate into the ClusterRole
*/
class V1alpha1AggregationRule {
}
exports.V1alpha1AggregationRule = V1alpha1AggregationRule;
/**
* ClusterRole is a cluster level, logical grouping of PolicyRules that can be referenced as a unit by a RoleBinding or ClusterRoleBinding.
*/
class V1alpha1ClusterRole {
}
exports.V1alpha1ClusterRole = V1alpha1ClusterRole;
/**
* ClusterRoleBinding references a ClusterRole, but not contain it.  It can reference a ClusterRole in the global namespace, and adds who information via Subject.
*/
class V1alpha1ClusterRoleBinding {
}
exports.V1alpha1ClusterRoleBinding = V1alpha1ClusterRoleBinding;
/**
* ClusterRoleBindingList is a collection of ClusterRoleBindings
*/
class V1alpha1ClusterRoleBindingList {
}
exports.V1alpha1ClusterRoleBindingList = V1alpha1ClusterRoleBindingList;
/**
* ClusterRoleList is a collection of ClusterRoles
*/
class V1alpha1ClusterRoleList {
}
exports.V1alpha1ClusterRoleList = V1alpha1ClusterRoleList;
/**
* Initializer describes the name and the failure policy of an initializer, and what resources it applies to.
*/
class V1alpha1Initializer {
}
exports.V1alpha1Initializer = V1alpha1Initializer;
/**
* InitializerConfiguration describes the configuration of initializers.
*/
class V1alpha1InitializerConfiguration {
}
exports.V1alpha1InitializerConfiguration = V1alpha1InitializerConfiguration;
/**
* InitializerConfigurationList is a list of InitializerConfiguration.
*/
class V1alpha1InitializerConfigurationList {
}
exports.V1alpha1InitializerConfigurationList = V1alpha1InitializerConfigurationList;
/**
* PodPreset is a policy resource that defines additional runtime requirements for a Pod.
*/
class V1alpha1PodPreset {
}
exports.V1alpha1PodPreset = V1alpha1PodPreset;
/**
* PodPresetList is a list of PodPreset objects.
*/
class V1alpha1PodPresetList {
}
exports.V1alpha1PodPresetList = V1alpha1PodPresetList;
/**
* PodPresetSpec is a description of a pod preset.
*/
class V1alpha1PodPresetSpec {
}
exports.V1alpha1PodPresetSpec = V1alpha1PodPresetSpec;
/**
* PolicyRule holds information that describes a policy rule, but does not contain information about who the rule applies to or which namespace the rule applies to.
*/
class V1alpha1PolicyRule {
}
exports.V1alpha1PolicyRule = V1alpha1PolicyRule;
/**
* PriorityClass defines mapping from a priority class name to the priority integer value. The value can be any valid integer.
*/
class V1alpha1PriorityClass {
}
exports.V1alpha1PriorityClass = V1alpha1PriorityClass;
/**
* PriorityClassList is a collection of priority classes.
*/
class V1alpha1PriorityClassList {
}
exports.V1alpha1PriorityClassList = V1alpha1PriorityClassList;
/**
* Role is a namespaced, logical grouping of PolicyRules that can be referenced as a unit by a RoleBinding.
*/
class V1alpha1Role {
}
exports.V1alpha1Role = V1alpha1Role;
/**
* RoleBinding references a role, but does not contain it.  It can reference a Role in the same namespace or a ClusterRole in the global namespace. It adds who information via Subjects and namespace information by which namespace it exists in.  RoleBindings in a given namespace only have effect in that namespace.
*/
class V1alpha1RoleBinding {
}
exports.V1alpha1RoleBinding = V1alpha1RoleBinding;
/**
* RoleBindingList is a collection of RoleBindings
*/
class V1alpha1RoleBindingList {
}
exports.V1alpha1RoleBindingList = V1alpha1RoleBindingList;
/**
* RoleList is a collection of Roles
*/
class V1alpha1RoleList {
}
exports.V1alpha1RoleList = V1alpha1RoleList;
/**
* RoleRef contains information that points to the role being used
*/
class V1alpha1RoleRef {
}
exports.V1alpha1RoleRef = V1alpha1RoleRef;
/**
* Rule is a tuple of APIGroups, APIVersion, and Resources.It is recommended to make sure that all the tuple expansions are valid.
*/
class V1alpha1Rule {
}
exports.V1alpha1Rule = V1alpha1Rule;
/**
* Subject contains a reference to the object or user identities a role binding applies to.  This can either hold a direct API object reference, or a value for non-objects such as user and group names.
*/
class V1alpha1Subject {
}
exports.V1alpha1Subject = V1alpha1Subject;
/**
* VolumeAttachment captures the intent to attach or detach the specified volume to/from the specified node.  VolumeAttachment objects are non-namespaced.
*/
class V1alpha1VolumeAttachment {
}
exports.V1alpha1VolumeAttachment = V1alpha1VolumeAttachment;
/**
* VolumeAttachmentList is a collection of VolumeAttachment objects.
*/
class V1alpha1VolumeAttachmentList {
}
exports.V1alpha1VolumeAttachmentList = V1alpha1VolumeAttachmentList;
/**
* VolumeAttachmentSource represents a volume that should be attached. Right now only PersistenVolumes can be attached via external attacher, in future we may allow also inline volumes in pods. Exactly one member can be set.
*/
class V1alpha1VolumeAttachmentSource {
}
exports.V1alpha1VolumeAttachmentSource = V1alpha1VolumeAttachmentSource;
/**
* VolumeAttachmentSpec is the specification of a VolumeAttachment request.
*/
class V1alpha1VolumeAttachmentSpec {
}
exports.V1alpha1VolumeAttachmentSpec = V1alpha1VolumeAttachmentSpec;
/**
* VolumeAttachmentStatus is the status of a VolumeAttachment request.
*/
class V1alpha1VolumeAttachmentStatus {
}
exports.V1alpha1VolumeAttachmentStatus = V1alpha1VolumeAttachmentStatus;
/**
* VolumeError captures an error encountered during a volume operation.
*/
class V1alpha1VolumeError {
}
exports.V1alpha1VolumeError = V1alpha1VolumeError;
/**
* APIService represents a server for a particular GroupVersion. Name must be \"version.group\".
*/
class V1beta1APIService {
}
exports.V1beta1APIService = V1beta1APIService;
class V1beta1APIServiceCondition {
}
exports.V1beta1APIServiceCondition = V1beta1APIServiceCondition;
/**
* APIServiceList is a list of APIService objects.
*/
class V1beta1APIServiceList {
}
exports.V1beta1APIServiceList = V1beta1APIServiceList;
/**
* APIServiceSpec contains information for locating and communicating with a server. Only https is supported, though you are able to disable certificate verification.
*/
class V1beta1APIServiceSpec {
}
exports.V1beta1APIServiceSpec = V1beta1APIServiceSpec;
/**
* APIServiceStatus contains derived information about an API server
*/
class V1beta1APIServiceStatus {
}
exports.V1beta1APIServiceStatus = V1beta1APIServiceStatus;
/**
* AggregationRule describes how to locate ClusterRoles to aggregate into the ClusterRole
*/
class V1beta1AggregationRule {
}
exports.V1beta1AggregationRule = V1beta1AggregationRule;
/**
* Describes a certificate signing request
*/
class V1beta1CertificateSigningRequest {
}
exports.V1beta1CertificateSigningRequest = V1beta1CertificateSigningRequest;
class V1beta1CertificateSigningRequestCondition {
}
exports.V1beta1CertificateSigningRequestCondition = V1beta1CertificateSigningRequestCondition;
class V1beta1CertificateSigningRequestList {
}
exports.V1beta1CertificateSigningRequestList = V1beta1CertificateSigningRequestList;
/**
* This information is immutable after the request is created. Only the Request and Usages fields can be set on creation, other fields are derived by Kubernetes and cannot be modified by users.
*/
class V1beta1CertificateSigningRequestSpec {
}
exports.V1beta1CertificateSigningRequestSpec = V1beta1CertificateSigningRequestSpec;
class V1beta1CertificateSigningRequestStatus {
}
exports.V1beta1CertificateSigningRequestStatus = V1beta1CertificateSigningRequestStatus;
/**
* ClusterRole is a cluster level, logical grouping of PolicyRules that can be referenced as a unit by a RoleBinding or ClusterRoleBinding.
*/
class V1beta1ClusterRole {
}
exports.V1beta1ClusterRole = V1beta1ClusterRole;
/**
* ClusterRoleBinding references a ClusterRole, but not contain it.  It can reference a ClusterRole in the global namespace, and adds who information via Subject.
*/
class V1beta1ClusterRoleBinding {
}
exports.V1beta1ClusterRoleBinding = V1beta1ClusterRoleBinding;
/**
* ClusterRoleBindingList is a collection of ClusterRoleBindings
*/
class V1beta1ClusterRoleBindingList {
}
exports.V1beta1ClusterRoleBindingList = V1beta1ClusterRoleBindingList;
/**
* ClusterRoleList is a collection of ClusterRoles
*/
class V1beta1ClusterRoleList {
}
exports.V1beta1ClusterRoleList = V1beta1ClusterRoleList;
/**
* DEPRECATED - This group version of ControllerRevision is deprecated by apps/v1beta2/ControllerRevision. See the release notes for more information. ControllerRevision implements an immutable snapshot of state data. Clients are responsible for serializing and deserializing the objects that contain their internal state. Once a ControllerRevision has been successfully created, it can not be updated. The API Server will fail validation of all requests that attempt to mutate the Data field. ControllerRevisions may, however, be deleted. Note that, due to its use by both the DaemonSet and StatefulSet controllers for update and rollback, this object is beta. However, it may be subject to name and representation changes in future releases, and clients should not depend on its stability. It is primarily for internal use by controllers.
*/
class V1beta1ControllerRevision {
}
exports.V1beta1ControllerRevision = V1beta1ControllerRevision;
/**
* ControllerRevisionList is a resource containing a list of ControllerRevision objects.
*/
class V1beta1ControllerRevisionList {
}
exports.V1beta1ControllerRevisionList = V1beta1ControllerRevisionList;
/**
* CronJob represents the configuration of a single cron job.
*/
class V1beta1CronJob {
}
exports.V1beta1CronJob = V1beta1CronJob;
/**
* CronJobList is a collection of cron jobs.
*/
class V1beta1CronJobList {
}
exports.V1beta1CronJobList = V1beta1CronJobList;
/**
* CronJobSpec describes how the job execution will look like and when it will actually run.
*/
class V1beta1CronJobSpec {
}
exports.V1beta1CronJobSpec = V1beta1CronJobSpec;
/**
* CronJobStatus represents the current state of a cron job.
*/
class V1beta1CronJobStatus {
}
exports.V1beta1CronJobStatus = V1beta1CronJobStatus;
/**
* CustomResourceColumnDefinition specifies a column for server side printing.
*/
class V1beta1CustomResourceColumnDefinition {
}
exports.V1beta1CustomResourceColumnDefinition = V1beta1CustomResourceColumnDefinition;
/**
* CustomResourceDefinition represents a resource that should be exposed on the API server.  Its name MUST be in the format <.spec.name>.<.spec.group>.
*/
class V1beta1CustomResourceDefinition {
}
exports.V1beta1CustomResourceDefinition = V1beta1CustomResourceDefinition;
/**
* CustomResourceDefinitionCondition contains details for the current condition of this pod.
*/
class V1beta1CustomResourceDefinitionCondition {
}
exports.V1beta1CustomResourceDefinitionCondition = V1beta1CustomResourceDefinitionCondition;
/**
* CustomResourceDefinitionList is a list of CustomResourceDefinition objects.
*/
class V1beta1CustomResourceDefinitionList {
}
exports.V1beta1CustomResourceDefinitionList = V1beta1CustomResourceDefinitionList;
/**
* CustomResourceDefinitionNames indicates the names to serve this CustomResourceDefinition
*/
class V1beta1CustomResourceDefinitionNames {
}
exports.V1beta1CustomResourceDefinitionNames = V1beta1CustomResourceDefinitionNames;
/**
* CustomResourceDefinitionSpec describes how a user wants their resource to appear
*/
class V1beta1CustomResourceDefinitionSpec {
}
exports.V1beta1CustomResourceDefinitionSpec = V1beta1CustomResourceDefinitionSpec;
/**
* CustomResourceDefinitionStatus indicates the state of the CustomResourceDefinition
*/
class V1beta1CustomResourceDefinitionStatus {
}
exports.V1beta1CustomResourceDefinitionStatus = V1beta1CustomResourceDefinitionStatus;
class V1beta1CustomResourceDefinitionVersion {
}
exports.V1beta1CustomResourceDefinitionVersion = V1beta1CustomResourceDefinitionVersion;
/**
* CustomResourceSubresourceScale defines how to serve the scale subresource for CustomResources.
*/
class V1beta1CustomResourceSubresourceScale {
}
exports.V1beta1CustomResourceSubresourceScale = V1beta1CustomResourceSubresourceScale;
/**
* CustomResourceSubresources defines the status and scale subresources for CustomResources.
*/
class V1beta1CustomResourceSubresources {
}
exports.V1beta1CustomResourceSubresources = V1beta1CustomResourceSubresources;
/**
* CustomResourceValidation is a list of validation methods for CustomResources.
*/
class V1beta1CustomResourceValidation {
}
exports.V1beta1CustomResourceValidation = V1beta1CustomResourceValidation;
/**
* DEPRECATED - This group version of DaemonSet is deprecated by apps/v1beta2/DaemonSet. See the release notes for more information. DaemonSet represents the configuration of a daemon set.
*/
class V1beta1DaemonSet {
}
exports.V1beta1DaemonSet = V1beta1DaemonSet;
/**
* DaemonSetCondition describes the state of a DaemonSet at a certain point.
*/
class V1beta1DaemonSetCondition {
}
exports.V1beta1DaemonSetCondition = V1beta1DaemonSetCondition;
/**
* DaemonSetList is a collection of daemon sets.
*/
class V1beta1DaemonSetList {
}
exports.V1beta1DaemonSetList = V1beta1DaemonSetList;
/**
* DaemonSetSpec is the specification of a daemon set.
*/
class V1beta1DaemonSetSpec {
}
exports.V1beta1DaemonSetSpec = V1beta1DaemonSetSpec;
/**
* DaemonSetStatus represents the current status of a daemon set.
*/
class V1beta1DaemonSetStatus {
}
exports.V1beta1DaemonSetStatus = V1beta1DaemonSetStatus;
class V1beta1DaemonSetUpdateStrategy {
}
exports.V1beta1DaemonSetUpdateStrategy = V1beta1DaemonSetUpdateStrategy;
/**
* Event is a report of an event somewhere in the cluster. It generally denotes some state change in the system.
*/
class V1beta1Event {
}
exports.V1beta1Event = V1beta1Event;
/**
* EventList is a list of Event objects.
*/
class V1beta1EventList {
}
exports.V1beta1EventList = V1beta1EventList;
/**
* EventSeries contain information on series of events, i.e. thing that was/is happening continuously for some time.
*/
class V1beta1EventSeries {
}
exports.V1beta1EventSeries = V1beta1EventSeries;
/**
* Eviction evicts a pod from its node subject to certain policies and safety constraints. This is a subresource of Pod.  A request to cause such an eviction is created by POSTing to .../pods/<pod name>/evictions.
*/
class V1beta1Eviction {
}
exports.V1beta1Eviction = V1beta1Eviction;
/**
* ExternalDocumentation allows referencing an external resource for extended documentation.
*/
class V1beta1ExternalDocumentation {
}
exports.V1beta1ExternalDocumentation = V1beta1ExternalDocumentation;
/**
* HTTPIngressPath associates a path regex with a backend. Incoming urls matching the path are forwarded to the backend.
*/
class V1beta1HTTPIngressPath {
}
exports.V1beta1HTTPIngressPath = V1beta1HTTPIngressPath;
/**
* HTTPIngressRuleValue is a list of http selectors pointing to backends. In the example: http://<host>/<path>?<searchpart> -> backend where where parts of the url correspond to RFC 3986, this resource will be used to match against everything after the last '/' and before the first '?' or '#'.
*/
class V1beta1HTTPIngressRuleValue {
}
exports.V1beta1HTTPIngressRuleValue = V1beta1HTTPIngressRuleValue;
/**
* DEPRECATED 1.9 - This group version of IPBlock is deprecated by networking/v1/IPBlock. IPBlock describes a particular CIDR (Ex. \"192.168.1.1/24\") that is allowed to the pods matched by a NetworkPolicySpec's podSelector. The except entry describes CIDRs that should not be included within this rule.
*/
class V1beta1IPBlock {
}
exports.V1beta1IPBlock = V1beta1IPBlock;
/**
* Ingress is a collection of rules that allow inbound connections to reach the endpoints defined by a backend. An Ingress can be configured to give services externally-reachable urls, load balance traffic, terminate SSL, offer name based virtual hosting etc.
*/
class V1beta1Ingress {
}
exports.V1beta1Ingress = V1beta1Ingress;
/**
* IngressBackend describes all endpoints for a given service and port.
*/
class V1beta1IngressBackend {
}
exports.V1beta1IngressBackend = V1beta1IngressBackend;
/**
* IngressList is a collection of Ingress.
*/
class V1beta1IngressList {
}
exports.V1beta1IngressList = V1beta1IngressList;
/**
* IngressRule represents the rules mapping the paths under a specified host to the related backend services. Incoming requests are first evaluated for a host match, then routed to the backend associated with the matching IngressRuleValue.
*/
class V1beta1IngressRule {
}
exports.V1beta1IngressRule = V1beta1IngressRule;
/**
* IngressSpec describes the Ingress the user wishes to exist.
*/
class V1beta1IngressSpec {
}
exports.V1beta1IngressSpec = V1beta1IngressSpec;
/**
* IngressStatus describe the current state of the Ingress.
*/
class V1beta1IngressStatus {
}
exports.V1beta1IngressStatus = V1beta1IngressStatus;
/**
* IngressTLS describes the transport layer security associated with an Ingress.
*/
class V1beta1IngressTLS {
}
exports.V1beta1IngressTLS = V1beta1IngressTLS;
/**
* JSONSchemaProps is a JSON-Schema following Specification Draft 4 (http://json-schema.org/).
*/
class V1beta1JSONSchemaProps {
}
exports.V1beta1JSONSchemaProps = V1beta1JSONSchemaProps;
/**
* JobTemplateSpec describes the data a Job should have when created from a template
*/
class V1beta1JobTemplateSpec {
}
exports.V1beta1JobTemplateSpec = V1beta1JobTemplateSpec;
/**
* LocalSubjectAccessReview checks whether or not a user or group can perform an action in a given namespace. Having a namespace scoped resource makes it much easier to grant namespace scoped policy that includes permissions checking.
*/
class V1beta1LocalSubjectAccessReview {
}
exports.V1beta1LocalSubjectAccessReview = V1beta1LocalSubjectAccessReview;
/**
* MutatingWebhookConfiguration describes the configuration of and admission webhook that accept or reject and may change the object.
*/
class V1beta1MutatingWebhookConfiguration {
}
exports.V1beta1MutatingWebhookConfiguration = V1beta1MutatingWebhookConfiguration;
/**
* MutatingWebhookConfigurationList is a list of MutatingWebhookConfiguration.
*/
class V1beta1MutatingWebhookConfigurationList {
}
exports.V1beta1MutatingWebhookConfigurationList = V1beta1MutatingWebhookConfigurationList;
/**
* DEPRECATED 1.9 - This group version of NetworkPolicy is deprecated by networking/v1/NetworkPolicy. NetworkPolicy describes what network traffic is allowed for a set of Pods
*/
class V1beta1NetworkPolicy {
}
exports.V1beta1NetworkPolicy = V1beta1NetworkPolicy;
/**
* DEPRECATED 1.9 - This group version of NetworkPolicyEgressRule is deprecated by networking/v1/NetworkPolicyEgressRule. NetworkPolicyEgressRule describes a particular set of traffic that is allowed out of pods matched by a NetworkPolicySpec's podSelector. The traffic must match both ports and to. This type is beta-level in 1.8
*/
class V1beta1NetworkPolicyEgressRule {
}
exports.V1beta1NetworkPolicyEgressRule = V1beta1NetworkPolicyEgressRule;
/**
* DEPRECATED 1.9 - This group version of NetworkPolicyIngressRule is deprecated by networking/v1/NetworkPolicyIngressRule. This NetworkPolicyIngressRule matches traffic if and only if the traffic matches both ports AND from.
*/
class V1beta1NetworkPolicyIngressRule {
}
exports.V1beta1NetworkPolicyIngressRule = V1beta1NetworkPolicyIngressRule;
/**
* DEPRECATED 1.9 - This group version of NetworkPolicyList is deprecated by networking/v1/NetworkPolicyList. Network Policy List is a list of NetworkPolicy objects.
*/
class V1beta1NetworkPolicyList {
}
exports.V1beta1NetworkPolicyList = V1beta1NetworkPolicyList;
/**
* DEPRECATED 1.9 - This group version of NetworkPolicyPeer is deprecated by networking/v1/NetworkPolicyPeer.
*/
class V1beta1NetworkPolicyPeer {
}
exports.V1beta1NetworkPolicyPeer = V1beta1NetworkPolicyPeer;
/**
* DEPRECATED 1.9 - This group version of NetworkPolicyPort is deprecated by networking/v1/NetworkPolicyPort.
*/
class V1beta1NetworkPolicyPort {
}
exports.V1beta1NetworkPolicyPort = V1beta1NetworkPolicyPort;
/**
* DEPRECATED 1.9 - This group version of NetworkPolicySpec is deprecated by networking/v1/NetworkPolicySpec.
*/
class V1beta1NetworkPolicySpec {
}
exports.V1beta1NetworkPolicySpec = V1beta1NetworkPolicySpec;
/**
* NonResourceAttributes includes the authorization attributes available for non-resource requests to the Authorizer interface
*/
class V1beta1NonResourceAttributes {
}
exports.V1beta1NonResourceAttributes = V1beta1NonResourceAttributes;
/**
* NonResourceRule holds information that describes a rule for the non-resource
*/
class V1beta1NonResourceRule {
}
exports.V1beta1NonResourceRule = V1beta1NonResourceRule;
/**
* PodDisruptionBudget is an object to define the max disruption that can be caused to a collection of pods
*/
class V1beta1PodDisruptionBudget {
}
exports.V1beta1PodDisruptionBudget = V1beta1PodDisruptionBudget;
/**
* PodDisruptionBudgetList is a collection of PodDisruptionBudgets.
*/
class V1beta1PodDisruptionBudgetList {
}
exports.V1beta1PodDisruptionBudgetList = V1beta1PodDisruptionBudgetList;
/**
* PodDisruptionBudgetSpec is a description of a PodDisruptionBudget.
*/
class V1beta1PodDisruptionBudgetSpec {
}
exports.V1beta1PodDisruptionBudgetSpec = V1beta1PodDisruptionBudgetSpec;
/**
* PodDisruptionBudgetStatus represents information about the status of a PodDisruptionBudget. Status may trail the actual state of a system.
*/
class V1beta1PodDisruptionBudgetStatus {
}
exports.V1beta1PodDisruptionBudgetStatus = V1beta1PodDisruptionBudgetStatus;
/**
* PolicyRule holds information that describes a policy rule, but does not contain information about who the rule applies to or which namespace the rule applies to.
*/
class V1beta1PolicyRule {
}
exports.V1beta1PolicyRule = V1beta1PolicyRule;
/**
* PriorityClass defines mapping from a priority class name to the priority integer value. The value can be any valid integer.
*/
class V1beta1PriorityClass {
}
exports.V1beta1PriorityClass = V1beta1PriorityClass;
/**
* PriorityClassList is a collection of priority classes.
*/
class V1beta1PriorityClassList {
}
exports.V1beta1PriorityClassList = V1beta1PriorityClassList;
/**
* DEPRECATED - This group version of ReplicaSet is deprecated by apps/v1beta2/ReplicaSet. See the release notes for more information. ReplicaSet ensures that a specified number of pod replicas are running at any given time.
*/
class V1beta1ReplicaSet {
}
exports.V1beta1ReplicaSet = V1beta1ReplicaSet;
/**
* ReplicaSetCondition describes the state of a replica set at a certain point.
*/
class V1beta1ReplicaSetCondition {
}
exports.V1beta1ReplicaSetCondition = V1beta1ReplicaSetCondition;
/**
* ReplicaSetList is a collection of ReplicaSets.
*/
class V1beta1ReplicaSetList {
}
exports.V1beta1ReplicaSetList = V1beta1ReplicaSetList;
/**
* ReplicaSetSpec is the specification of a ReplicaSet.
*/
class V1beta1ReplicaSetSpec {
}
exports.V1beta1ReplicaSetSpec = V1beta1ReplicaSetSpec;
/**
* ReplicaSetStatus represents the current status of a ReplicaSet.
*/
class V1beta1ReplicaSetStatus {
}
exports.V1beta1ReplicaSetStatus = V1beta1ReplicaSetStatus;
/**
* ResourceAttributes includes the authorization attributes available for resource requests to the Authorizer interface
*/
class V1beta1ResourceAttributes {
}
exports.V1beta1ResourceAttributes = V1beta1ResourceAttributes;
/**
* ResourceRule is the list of actions the subject is allowed to perform on resources. The list ordering isn't significant, may contain duplicates, and possibly be incomplete.
*/
class V1beta1ResourceRule {
}
exports.V1beta1ResourceRule = V1beta1ResourceRule;
/**
* Role is a namespaced, logical grouping of PolicyRules that can be referenced as a unit by a RoleBinding.
*/
class V1beta1Role {
}
exports.V1beta1Role = V1beta1Role;
/**
* RoleBinding references a role, but does not contain it.  It can reference a Role in the same namespace or a ClusterRole in the global namespace. It adds who information via Subjects and namespace information by which namespace it exists in.  RoleBindings in a given namespace only have effect in that namespace.
*/
class V1beta1RoleBinding {
}
exports.V1beta1RoleBinding = V1beta1RoleBinding;
/**
* RoleBindingList is a collection of RoleBindings
*/
class V1beta1RoleBindingList {
}
exports.V1beta1RoleBindingList = V1beta1RoleBindingList;
/**
* RoleList is a collection of Roles
*/
class V1beta1RoleList {
}
exports.V1beta1RoleList = V1beta1RoleList;
/**
* RoleRef contains information that points to the role being used
*/
class V1beta1RoleRef {
}
exports.V1beta1RoleRef = V1beta1RoleRef;
/**
* Spec to control the desired behavior of daemon set rolling update.
*/
class V1beta1RollingUpdateDaemonSet {
}
exports.V1beta1RollingUpdateDaemonSet = V1beta1RollingUpdateDaemonSet;
/**
* RollingUpdateStatefulSetStrategy is used to communicate parameter for RollingUpdateStatefulSetStrategyType.
*/
class V1beta1RollingUpdateStatefulSetStrategy {
}
exports.V1beta1RollingUpdateStatefulSetStrategy = V1beta1RollingUpdateStatefulSetStrategy;
/**
* RuleWithOperations is a tuple of Operations and Resources. It is recommended to make sure that all the tuple expansions are valid.
*/
class V1beta1RuleWithOperations {
}
exports.V1beta1RuleWithOperations = V1beta1RuleWithOperations;
/**
* SelfSubjectAccessReview checks whether or the current user can perform an action.  Not filling in a spec.namespace means \"in all namespaces\".  Self is a special case, because users should always be able to check whether they can perform an action
*/
class V1beta1SelfSubjectAccessReview {
}
exports.V1beta1SelfSubjectAccessReview = V1beta1SelfSubjectAccessReview;
/**
* SelfSubjectAccessReviewSpec is a description of the access request.  Exactly one of ResourceAuthorizationAttributes and NonResourceAuthorizationAttributes must be set
*/
class V1beta1SelfSubjectAccessReviewSpec {
}
exports.V1beta1SelfSubjectAccessReviewSpec = V1beta1SelfSubjectAccessReviewSpec;
/**
* SelfSubjectRulesReview enumerates the set of actions the current user can perform within a namespace. The returned list of actions may be incomplete depending on the server's authorization mode, and any errors experienced during the evaluation. SelfSubjectRulesReview should be used by UIs to show/hide actions, or to quickly let an end user reason about their permissions. It should NOT Be used by external systems to drive authorization decisions as this raises confused deputy, cache lifetime/revocation, and correctness concerns. SubjectAccessReview, and LocalAccessReview are the correct way to defer authorization decisions to the API server.
*/
class V1beta1SelfSubjectRulesReview {
}
exports.V1beta1SelfSubjectRulesReview = V1beta1SelfSubjectRulesReview;
class V1beta1SelfSubjectRulesReviewSpec {
}
exports.V1beta1SelfSubjectRulesReviewSpec = V1beta1SelfSubjectRulesReviewSpec;
/**
* DEPRECATED - This group version of StatefulSet is deprecated by apps/v1beta2/StatefulSet. See the release notes for more information. StatefulSet represents a set of pods with consistent identities. Identities are defined as:  - Network: A single stable DNS and hostname.  - Storage: As many VolumeClaims as requested. The StatefulSet guarantees that a given network identity will always map to the same storage identity.
*/
class V1beta1StatefulSet {
}
exports.V1beta1StatefulSet = V1beta1StatefulSet;
/**
* StatefulSetCondition describes the state of a statefulset at a certain point.
*/
class V1beta1StatefulSetCondition {
}
exports.V1beta1StatefulSetCondition = V1beta1StatefulSetCondition;
/**
* StatefulSetList is a collection of StatefulSets.
*/
class V1beta1StatefulSetList {
}
exports.V1beta1StatefulSetList = V1beta1StatefulSetList;
/**
* A StatefulSetSpec is the specification of a StatefulSet.
*/
class V1beta1StatefulSetSpec {
}
exports.V1beta1StatefulSetSpec = V1beta1StatefulSetSpec;
/**
* StatefulSetStatus represents the current state of a StatefulSet.
*/
class V1beta1StatefulSetStatus {
}
exports.V1beta1StatefulSetStatus = V1beta1StatefulSetStatus;
/**
* StatefulSetUpdateStrategy indicates the strategy that the StatefulSet controller will use to perform updates. It includes any additional parameters necessary to perform the update for the indicated strategy.
*/
class V1beta1StatefulSetUpdateStrategy {
}
exports.V1beta1StatefulSetUpdateStrategy = V1beta1StatefulSetUpdateStrategy;
/**
* StorageClass describes the parameters for a class of storage for which PersistentVolumes can be dynamically provisioned.  StorageClasses are non-namespaced; the name of the storage class according to etcd is in ObjectMeta.Name.
*/
class V1beta1StorageClass {
}
exports.V1beta1StorageClass = V1beta1StorageClass;
/**
* StorageClassList is a collection of storage classes.
*/
class V1beta1StorageClassList {
}
exports.V1beta1StorageClassList = V1beta1StorageClassList;
/**
* Subject contains a reference to the object or user identities a role binding applies to.  This can either hold a direct API object reference, or a value for non-objects such as user and group names.
*/
class V1beta1Subject {
}
exports.V1beta1Subject = V1beta1Subject;
/**
* SubjectAccessReview checks whether or not a user or group can perform an action.
*/
class V1beta1SubjectAccessReview {
}
exports.V1beta1SubjectAccessReview = V1beta1SubjectAccessReview;
/**
* SubjectAccessReviewSpec is a description of the access request.  Exactly one of ResourceAuthorizationAttributes and NonResourceAuthorizationAttributes must be set
*/
class V1beta1SubjectAccessReviewSpec {
}
exports.V1beta1SubjectAccessReviewSpec = V1beta1SubjectAccessReviewSpec;
/**
* SubjectAccessReviewStatus
*/
class V1beta1SubjectAccessReviewStatus {
}
exports.V1beta1SubjectAccessReviewStatus = V1beta1SubjectAccessReviewStatus;
/**
* SubjectRulesReviewStatus contains the result of a rules check. This check can be incomplete depending on the set of authorizers the server is configured with and any errors experienced during evaluation. Because authorization rules are additive, if a rule appears in a list it's safe to assume the subject has that permission, even if that list is incomplete.
*/
class V1beta1SubjectRulesReviewStatus {
}
exports.V1beta1SubjectRulesReviewStatus = V1beta1SubjectRulesReviewStatus;
/**
* TokenReview attempts to authenticate a token to a known user. Note: TokenReview requests may be cached by the webhook token authenticator plugin in the kube-apiserver.
*/
class V1beta1TokenReview {
}
exports.V1beta1TokenReview = V1beta1TokenReview;
/**
* TokenReviewSpec is a description of the token authentication request.
*/
class V1beta1TokenReviewSpec {
}
exports.V1beta1TokenReviewSpec = V1beta1TokenReviewSpec;
/**
* TokenReviewStatus is the result of the token authentication request.
*/
class V1beta1TokenReviewStatus {
}
exports.V1beta1TokenReviewStatus = V1beta1TokenReviewStatus;
/**
* UserInfo holds the information about the user needed to implement the user.Info interface.
*/
class V1beta1UserInfo {
}
exports.V1beta1UserInfo = V1beta1UserInfo;
/**
* ValidatingWebhookConfiguration describes the configuration of and admission webhook that accept or reject and object without changing it.
*/
class V1beta1ValidatingWebhookConfiguration {
}
exports.V1beta1ValidatingWebhookConfiguration = V1beta1ValidatingWebhookConfiguration;
/**
* ValidatingWebhookConfigurationList is a list of ValidatingWebhookConfiguration.
*/
class V1beta1ValidatingWebhookConfigurationList {
}
exports.V1beta1ValidatingWebhookConfigurationList = V1beta1ValidatingWebhookConfigurationList;
/**
* VolumeAttachment captures the intent to attach or detach the specified volume to/from the specified node.  VolumeAttachment objects are non-namespaced.
*/
class V1beta1VolumeAttachment {
}
exports.V1beta1VolumeAttachment = V1beta1VolumeAttachment;
/**
* VolumeAttachmentList is a collection of VolumeAttachment objects.
*/
class V1beta1VolumeAttachmentList {
}
exports.V1beta1VolumeAttachmentList = V1beta1VolumeAttachmentList;
/**
* VolumeAttachmentSource represents a volume that should be attached. Right now only PersistenVolumes can be attached via external attacher, in future we may allow also inline volumes in pods. Exactly one member can be set.
*/
class V1beta1VolumeAttachmentSource {
}
exports.V1beta1VolumeAttachmentSource = V1beta1VolumeAttachmentSource;
/**
* VolumeAttachmentSpec is the specification of a VolumeAttachment request.
*/
class V1beta1VolumeAttachmentSpec {
}
exports.V1beta1VolumeAttachmentSpec = V1beta1VolumeAttachmentSpec;
/**
* VolumeAttachmentStatus is the status of a VolumeAttachment request.
*/
class V1beta1VolumeAttachmentStatus {
}
exports.V1beta1VolumeAttachmentStatus = V1beta1VolumeAttachmentStatus;
/**
* VolumeError captures an error encountered during a volume operation.
*/
class V1beta1VolumeError {
}
exports.V1beta1VolumeError = V1beta1VolumeError;
/**
* Webhook describes an admission webhook and the resources and operations it applies to.
*/
class V1beta1Webhook {
}
exports.V1beta1Webhook = V1beta1Webhook;
/**
* WebhookClientConfig contains the information to make a TLS connection with the webhook
*/
class V1beta1WebhookClientConfig {
}
exports.V1beta1WebhookClientConfig = V1beta1WebhookClientConfig;
/**
* DEPRECATED - This group version of ControllerRevision is deprecated by apps/v1/ControllerRevision. See the release notes for more information. ControllerRevision implements an immutable snapshot of state data. Clients are responsible for serializing and deserializing the objects that contain their internal state. Once a ControllerRevision has been successfully created, it can not be updated. The API Server will fail validation of all requests that attempt to mutate the Data field. ControllerRevisions may, however, be deleted. Note that, due to its use by both the DaemonSet and StatefulSet controllers for update and rollback, this object is beta. However, it may be subject to name and representation changes in future releases, and clients should not depend on its stability. It is primarily for internal use by controllers.
*/
class V1beta2ControllerRevision {
}
exports.V1beta2ControllerRevision = V1beta2ControllerRevision;
/**
* ControllerRevisionList is a resource containing a list of ControllerRevision objects.
*/
class V1beta2ControllerRevisionList {
}
exports.V1beta2ControllerRevisionList = V1beta2ControllerRevisionList;
/**
* DEPRECATED - This group version of DaemonSet is deprecated by apps/v1/DaemonSet. See the release notes for more information. DaemonSet represents the configuration of a daemon set.
*/
class V1beta2DaemonSet {
}
exports.V1beta2DaemonSet = V1beta2DaemonSet;
/**
* DaemonSetCondition describes the state of a DaemonSet at a certain point.
*/
class V1beta2DaemonSetCondition {
}
exports.V1beta2DaemonSetCondition = V1beta2DaemonSetCondition;
/**
* DaemonSetList is a collection of daemon sets.
*/
class V1beta2DaemonSetList {
}
exports.V1beta2DaemonSetList = V1beta2DaemonSetList;
/**
* DaemonSetSpec is the specification of a daemon set.
*/
class V1beta2DaemonSetSpec {
}
exports.V1beta2DaemonSetSpec = V1beta2DaemonSetSpec;
/**
* DaemonSetStatus represents the current status of a daemon set.
*/
class V1beta2DaemonSetStatus {
}
exports.V1beta2DaemonSetStatus = V1beta2DaemonSetStatus;
/**
* DaemonSetUpdateStrategy is a struct used to control the update strategy for a DaemonSet.
*/
class V1beta2DaemonSetUpdateStrategy {
}
exports.V1beta2DaemonSetUpdateStrategy = V1beta2DaemonSetUpdateStrategy;
/**
* DEPRECATED - This group version of Deployment is deprecated by apps/v1/Deployment. See the release notes for more information. Deployment enables declarative updates for Pods and ReplicaSets.
*/
class V1beta2Deployment {
}
exports.V1beta2Deployment = V1beta2Deployment;
/**
* DeploymentCondition describes the state of a deployment at a certain point.
*/
class V1beta2DeploymentCondition {
}
exports.V1beta2DeploymentCondition = V1beta2DeploymentCondition;
/**
* DeploymentList is a list of Deployments.
*/
class V1beta2DeploymentList {
}
exports.V1beta2DeploymentList = V1beta2DeploymentList;
/**
* DeploymentSpec is the specification of the desired behavior of the Deployment.
*/
class V1beta2DeploymentSpec {
}
exports.V1beta2DeploymentSpec = V1beta2DeploymentSpec;
/**
* DeploymentStatus is the most recently observed status of the Deployment.
*/
class V1beta2DeploymentStatus {
}
exports.V1beta2DeploymentStatus = V1beta2DeploymentStatus;
/**
* DeploymentStrategy describes how to replace existing pods with new ones.
*/
class V1beta2DeploymentStrategy {
}
exports.V1beta2DeploymentStrategy = V1beta2DeploymentStrategy;
/**
* DEPRECATED - This group version of ReplicaSet is deprecated by apps/v1/ReplicaSet. See the release notes for more information. ReplicaSet ensures that a specified number of pod replicas are running at any given time.
*/
class V1beta2ReplicaSet {
}
exports.V1beta2ReplicaSet = V1beta2ReplicaSet;
/**
* ReplicaSetCondition describes the state of a replica set at a certain point.
*/
class V1beta2ReplicaSetCondition {
}
exports.V1beta2ReplicaSetCondition = V1beta2ReplicaSetCondition;
/**
* ReplicaSetList is a collection of ReplicaSets.
*/
class V1beta2ReplicaSetList {
}
exports.V1beta2ReplicaSetList = V1beta2ReplicaSetList;
/**
* ReplicaSetSpec is the specification of a ReplicaSet.
*/
class V1beta2ReplicaSetSpec {
}
exports.V1beta2ReplicaSetSpec = V1beta2ReplicaSetSpec;
/**
* ReplicaSetStatus represents the current status of a ReplicaSet.
*/
class V1beta2ReplicaSetStatus {
}
exports.V1beta2ReplicaSetStatus = V1beta2ReplicaSetStatus;
/**
* Spec to control the desired behavior of daemon set rolling update.
*/
class V1beta2RollingUpdateDaemonSet {
}
exports.V1beta2RollingUpdateDaemonSet = V1beta2RollingUpdateDaemonSet;
/**
* Spec to control the desired behavior of rolling update.
*/
class V1beta2RollingUpdateDeployment {
}
exports.V1beta2RollingUpdateDeployment = V1beta2RollingUpdateDeployment;
/**
* RollingUpdateStatefulSetStrategy is used to communicate parameter for RollingUpdateStatefulSetStrategyType.
*/
class V1beta2RollingUpdateStatefulSetStrategy {
}
exports.V1beta2RollingUpdateStatefulSetStrategy = V1beta2RollingUpdateStatefulSetStrategy;
/**
* Scale represents a scaling request for a resource.
*/
class V1beta2Scale {
}
exports.V1beta2Scale = V1beta2Scale;
/**
* ScaleSpec describes the attributes of a scale subresource
*/
class V1beta2ScaleSpec {
}
exports.V1beta2ScaleSpec = V1beta2ScaleSpec;
/**
* ScaleStatus represents the current status of a scale subresource.
*/
class V1beta2ScaleStatus {
}
exports.V1beta2ScaleStatus = V1beta2ScaleStatus;
/**
* DEPRECATED - This group version of StatefulSet is deprecated by apps/v1/StatefulSet. See the release notes for more information. StatefulSet represents a set of pods with consistent identities. Identities are defined as:  - Network: A single stable DNS and hostname.  - Storage: As many VolumeClaims as requested. The StatefulSet guarantees that a given network identity will always map to the same storage identity.
*/
class V1beta2StatefulSet {
}
exports.V1beta2StatefulSet = V1beta2StatefulSet;
/**
* StatefulSetCondition describes the state of a statefulset at a certain point.
*/
class V1beta2StatefulSetCondition {
}
exports.V1beta2StatefulSetCondition = V1beta2StatefulSetCondition;
/**
* StatefulSetList is a collection of StatefulSets.
*/
class V1beta2StatefulSetList {
}
exports.V1beta2StatefulSetList = V1beta2StatefulSetList;
/**
* A StatefulSetSpec is the specification of a StatefulSet.
*/
class V1beta2StatefulSetSpec {
}
exports.V1beta2StatefulSetSpec = V1beta2StatefulSetSpec;
/**
* StatefulSetStatus represents the current state of a StatefulSet.
*/
class V1beta2StatefulSetStatus {
}
exports.V1beta2StatefulSetStatus = V1beta2StatefulSetStatus;
/**
* StatefulSetUpdateStrategy indicates the strategy that the StatefulSet controller will use to perform updates. It includes any additional parameters necessary to perform the update for the indicated strategy.
*/
class V1beta2StatefulSetUpdateStrategy {
}
exports.V1beta2StatefulSetUpdateStrategy = V1beta2StatefulSetUpdateStrategy;
/**
* CronJob represents the configuration of a single cron job.
*/
class V2alpha1CronJob {
}
exports.V2alpha1CronJob = V2alpha1CronJob;
/**
* CronJobList is a collection of cron jobs.
*/
class V2alpha1CronJobList {
}
exports.V2alpha1CronJobList = V2alpha1CronJobList;
/**
* CronJobSpec describes how the job execution will look like and when it will actually run.
*/
class V2alpha1CronJobSpec {
}
exports.V2alpha1CronJobSpec = V2alpha1CronJobSpec;
/**
* CronJobStatus represents the current state of a cron job.
*/
class V2alpha1CronJobStatus {
}
exports.V2alpha1CronJobStatus = V2alpha1CronJobStatus;
/**
* JobTemplateSpec describes the data a Job should have when created from a template
*/
class V2alpha1JobTemplateSpec {
}
exports.V2alpha1JobTemplateSpec = V2alpha1JobTemplateSpec;
/**
* CrossVersionObjectReference contains enough information to let you identify the referred resource.
*/
class V2beta1CrossVersionObjectReference {
}
exports.V2beta1CrossVersionObjectReference = V2beta1CrossVersionObjectReference;
/**
* ExternalMetricSource indicates how to scale on a metric not associated with any Kubernetes object (for example length of queue in cloud messaging service, or QPS from loadbalancer running outside of cluster). Exactly one \"target\" type should be set.
*/
class V2beta1ExternalMetricSource {
}
exports.V2beta1ExternalMetricSource = V2beta1ExternalMetricSource;
/**
* ExternalMetricStatus indicates the current value of a global metric not associated with any Kubernetes object.
*/
class V2beta1ExternalMetricStatus {
}
exports.V2beta1ExternalMetricStatus = V2beta1ExternalMetricStatus;
/**
* HorizontalPodAutoscaler is the configuration for a horizontal pod autoscaler, which automatically manages the replica count of any resource implementing the scale subresource based on the metrics specified.
*/
class V2beta1HorizontalPodAutoscaler {
}
exports.V2beta1HorizontalPodAutoscaler = V2beta1HorizontalPodAutoscaler;
/**
* HorizontalPodAutoscalerCondition describes the state of a HorizontalPodAutoscaler at a certain point.
*/
class V2beta1HorizontalPodAutoscalerCondition {
}
exports.V2beta1HorizontalPodAutoscalerCondition = V2beta1HorizontalPodAutoscalerCondition;
/**
* HorizontalPodAutoscaler is a list of horizontal pod autoscaler objects.
*/
class V2beta1HorizontalPodAutoscalerList {
}
exports.V2beta1HorizontalPodAutoscalerList = V2beta1HorizontalPodAutoscalerList;
/**
* HorizontalPodAutoscalerSpec describes the desired functionality of the HorizontalPodAutoscaler.
*/
class V2beta1HorizontalPodAutoscalerSpec {
}
exports.V2beta1HorizontalPodAutoscalerSpec = V2beta1HorizontalPodAutoscalerSpec;
/**
* HorizontalPodAutoscalerStatus describes the current status of a horizontal pod autoscaler.
*/
class V2beta1HorizontalPodAutoscalerStatus {
}
exports.V2beta1HorizontalPodAutoscalerStatus = V2beta1HorizontalPodAutoscalerStatus;
/**
* MetricSpec specifies how to scale based on a single metric (only `type` and one other matching field should be set at once).
*/
class V2beta1MetricSpec {
}
exports.V2beta1MetricSpec = V2beta1MetricSpec;
/**
* MetricStatus describes the last-read state of a single metric.
*/
class V2beta1MetricStatus {
}
exports.V2beta1MetricStatus = V2beta1MetricStatus;
/**
* ObjectMetricSource indicates how to scale on a metric describing a kubernetes object (for example, hits-per-second on an Ingress object).
*/
class V2beta1ObjectMetricSource {
}
exports.V2beta1ObjectMetricSource = V2beta1ObjectMetricSource;
/**
* ObjectMetricStatus indicates the current value of a metric describing a kubernetes object (for example, hits-per-second on an Ingress object).
*/
class V2beta1ObjectMetricStatus {
}
exports.V2beta1ObjectMetricStatus = V2beta1ObjectMetricStatus;
/**
* PodsMetricSource indicates how to scale on a metric describing each pod in the current scale target (for example, transactions-processed-per-second). The values will be averaged together before being compared to the target value.
*/
class V2beta1PodsMetricSource {
}
exports.V2beta1PodsMetricSource = V2beta1PodsMetricSource;
/**
* PodsMetricStatus indicates the current value of a metric describing each pod in the current scale target (for example, transactions-processed-per-second).
*/
class V2beta1PodsMetricStatus {
}
exports.V2beta1PodsMetricStatus = V2beta1PodsMetricStatus;
/**
* ResourceMetricSource indicates how to scale on a resource metric known to Kubernetes, as specified in requests and limits, describing each pod in the current scale target (e.g. CPU or memory).  The values will be averaged together before being compared to the target.  Such metrics are built in to Kubernetes, and have special scaling options on top of those available to normal per-pod metrics using the \"pods\" source.  Only one \"target\" type should be set.
*/
class V2beta1ResourceMetricSource {
}
exports.V2beta1ResourceMetricSource = V2beta1ResourceMetricSource;
/**
* ResourceMetricStatus indicates the current value of a resource metric known to Kubernetes, as specified in requests and limits, describing each pod in the current scale target (e.g. CPU or memory).  Such metrics are built in to Kubernetes, and have special scaling options on top of those available to normal per-pod metrics using the \"pods\" source.
*/
class V2beta1ResourceMetricStatus {
}
exports.V2beta1ResourceMetricStatus = V2beta1ResourceMetricStatus;
/**
* Info contains versioning information. how we'll want to distribute that information.
*/
class VersionInfo {
}
exports.VersionInfo = VersionInfo;
class HttpBasicAuth {
    constructor() {
        this.username = '';
        this.password = '';
    }
    applyToRequest(requestOptions) {
        requestOptions.auth = {
            username: this.username, password: this.password
        };
    }
}
exports.HttpBasicAuth = HttpBasicAuth;
class ApiKeyAuth {
    constructor(location, paramName) {
        this.location = location;
        this.paramName = paramName;
        this.apiKey = '';
    }
    applyToRequest(requestOptions) {
        if (this.location == "query") {
            requestOptions.qs[this.paramName] = this.apiKey;
        }
        else if (this.location == "header" && requestOptions && requestOptions.headers) {
            requestOptions.headers[this.paramName] = this.apiKey;
        }
    }
}
exports.ApiKeyAuth = ApiKeyAuth;
class OAuth {
    constructor() {
        this.accessToken = '';
    }
    applyToRequest(requestOptions) {
        if (requestOptions && requestOptions.headers) {
            requestOptions.headers["Authorization"] = "Bearer " + this.accessToken;
        }
    }
}
exports.OAuth = OAuth;
class VoidAuth {
    constructor() {
        this.username = '';
        this.password = '';
    }
    applyToRequest(_) {
        // Do nothing
    }
}
exports.VoidAuth = VoidAuth;
var AdmissionregistrationApiApiKeys;
(function (AdmissionregistrationApiApiKeys) {
    AdmissionregistrationApiApiKeys[AdmissionregistrationApiApiKeys["BearerToken"] = 0] = "BearerToken";
})(AdmissionregistrationApiApiKeys = exports.AdmissionregistrationApiApiKeys || (exports.AdmissionregistrationApiApiKeys = {}));
class AdmissionregistrationApi {
    constructor(basePathOrUsername, password, basePath) {
        this._basePath = defaultBasePath;
        this.defaultHeaders = {};
        this._useQuerystring = false;
        this.authentications = {
            'default': new VoidAuth(),
            'BearerToken': new ApiKeyAuth('header', 'authorization'),
        };
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        }
        else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername;
            }
        }
    }
    set useQuerystring(value) {
        this._useQuerystring = value;
    }
    set basePath(basePath) {
        this._basePath = basePath;
    }
    get basePath() {
        return this._basePath;
    }
    setDefaultAuthentication(auth) {
        this.authentications.default = auth;
    }
    setApiKey(key, value) {
        this.authentications[AdmissionregistrationApiApiKeys[key]].apiKey = value;
    }
    /**
     * get information of a group
     */
    getAPIGroup() {
        const localVarPath = this.basePath + '/apis/admissionregistration.k8s.io/';
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        let useFormData = false;
        let requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
exports.AdmissionregistrationApi = AdmissionregistrationApi;
var Admissionregistration_v1alpha1ApiApiKeys;
(function (Admissionregistration_v1alpha1ApiApiKeys) {
    Admissionregistration_v1alpha1ApiApiKeys[Admissionregistration_v1alpha1ApiApiKeys["BearerToken"] = 0] = "BearerToken";
})(Admissionregistration_v1alpha1ApiApiKeys = exports.Admissionregistration_v1alpha1ApiApiKeys || (exports.Admissionregistration_v1alpha1ApiApiKeys = {}));
class Admissionregistration_v1alpha1Api {
    constructor(basePathOrUsername, password, basePath) {
        this._basePath = defaultBasePath;
        this.defaultHeaders = {};
        this._useQuerystring = false;
        this.authentications = {
            'default': new VoidAuth(),
            'BearerToken': new ApiKeyAuth('header', 'authorization'),
        };
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        }
        else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername;
            }
        }
    }
    set useQuerystring(value) {
        this._useQuerystring = value;
    }
    set basePath(basePath) {
        this._basePath = basePath;
    }
    get basePath() {
        return this._basePath;
    }
    setDefaultAuthentication(auth) {
        this.authentications.default = auth;
    }
    setApiKey(key, value) {
        this.authentications[Admissionregistration_v1alpha1ApiApiKeys[key]].apiKey = value;
    }
    /**
     * create an InitializerConfiguration
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    createInitializerConfiguration(body, pretty) {
        const localVarPath = this.basePath + '/apis/admissionregistration.k8s.io/v1alpha1/initializerconfigurations';
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling createInitializerConfiguration.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * delete collection of InitializerConfiguration
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param includeUninitialized If true, partially initialized resources are included in the response.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param timeoutSeconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    deleteCollectionInitializerConfiguration(pretty, _continue, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch) {
        const localVarPath = this.basePath + '/apis/admissionregistration.k8s.io/v1alpha1/initializerconfigurations';
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (_continue !== undefined) {
            queryParameters['continue'] = _continue;
        }
        if (fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = fieldSelector;
        }
        if (includeUninitialized !== undefined) {
            queryParameters['includeUninitialized'] = includeUninitialized;
        }
        if (labelSelector !== undefined) {
            queryParameters['labelSelector'] = labelSelector;
        }
        if (limit !== undefined) {
            queryParameters['limit'] = limit;
        }
        if (resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = resourceVersion;
        }
        if (timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = timeoutSeconds;
        }
        if (watch !== undefined) {
            queryParameters['watch'] = watch;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * delete an InitializerConfiguration
     * @param name name of the InitializerConfiguration
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param gracePeriodSeconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @param orphanDependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @param propagationPolicy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
     */
    deleteInitializerConfiguration(name, body, pretty, gracePeriodSeconds, orphanDependents, propagationPolicy) {
        const localVarPath = this.basePath + '/apis/admissionregistration.k8s.io/v1alpha1/initializerconfigurations/{name}'
            .replace('{' + 'name' + '}', String(name));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling deleteInitializerConfiguration.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling deleteInitializerConfiguration.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (gracePeriodSeconds !== undefined) {
            queryParameters['gracePeriodSeconds'] = gracePeriodSeconds;
        }
        if (orphanDependents !== undefined) {
            queryParameters['orphanDependents'] = orphanDependents;
        }
        if (propagationPolicy !== undefined) {
            queryParameters['propagationPolicy'] = propagationPolicy;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * get available resources
     */
    getAPIResources() {
        const localVarPath = this.basePath + '/apis/admissionregistration.k8s.io/v1alpha1/';
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        let useFormData = false;
        let requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * list or watch objects of kind InitializerConfiguration
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param includeUninitialized If true, partially initialized resources are included in the response.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param timeoutSeconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    listInitializerConfiguration(pretty, _continue, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch) {
        const localVarPath = this.basePath + '/apis/admissionregistration.k8s.io/v1alpha1/initializerconfigurations';
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (_continue !== undefined) {
            queryParameters['continue'] = _continue;
        }
        if (fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = fieldSelector;
        }
        if (includeUninitialized !== undefined) {
            queryParameters['includeUninitialized'] = includeUninitialized;
        }
        if (labelSelector !== undefined) {
            queryParameters['labelSelector'] = labelSelector;
        }
        if (limit !== undefined) {
            queryParameters['limit'] = limit;
        }
        if (resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = resourceVersion;
        }
        if (timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = timeoutSeconds;
        }
        if (watch !== undefined) {
            queryParameters['watch'] = watch;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * partially update the specified InitializerConfiguration
     * @param name name of the InitializerConfiguration
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    patchInitializerConfiguration(name, body, pretty) {
        const localVarPath = this.basePath + '/apis/admissionregistration.k8s.io/v1alpha1/initializerconfigurations/{name}'
            .replace('{' + 'name' + '}', String(name));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling patchInitializerConfiguration.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling patchInitializerConfiguration.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'PATCH',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * read the specified InitializerConfiguration
     * @param name name of the InitializerConfiguration
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param exact Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;.
     * @param _export Should this value be exported.  Export strips fields that a user can not specify.
     */
    readInitializerConfiguration(name, pretty, exact, _export) {
        const localVarPath = this.basePath + '/apis/admissionregistration.k8s.io/v1alpha1/initializerconfigurations/{name}'
            .replace('{' + 'name' + '}', String(name));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling readInitializerConfiguration.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (exact !== undefined) {
            queryParameters['exact'] = exact;
        }
        if (_export !== undefined) {
            queryParameters['export'] = _export;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * replace the specified InitializerConfiguration
     * @param name name of the InitializerConfiguration
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    replaceInitializerConfiguration(name, body, pretty) {
        const localVarPath = this.basePath + '/apis/admissionregistration.k8s.io/v1alpha1/initializerconfigurations/{name}'
            .replace('{' + 'name' + '}', String(name));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling replaceInitializerConfiguration.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling replaceInitializerConfiguration.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
exports.Admissionregistration_v1alpha1Api = Admissionregistration_v1alpha1Api;
var Admissionregistration_v1beta1ApiApiKeys;
(function (Admissionregistration_v1beta1ApiApiKeys) {
    Admissionregistration_v1beta1ApiApiKeys[Admissionregistration_v1beta1ApiApiKeys["BearerToken"] = 0] = "BearerToken";
})(Admissionregistration_v1beta1ApiApiKeys = exports.Admissionregistration_v1beta1ApiApiKeys || (exports.Admissionregistration_v1beta1ApiApiKeys = {}));
class Admissionregistration_v1beta1Api {
    constructor(basePathOrUsername, password, basePath) {
        this._basePath = defaultBasePath;
        this.defaultHeaders = {};
        this._useQuerystring = false;
        this.authentications = {
            'default': new VoidAuth(),
            'BearerToken': new ApiKeyAuth('header', 'authorization'),
        };
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        }
        else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername;
            }
        }
    }
    set useQuerystring(value) {
        this._useQuerystring = value;
    }
    set basePath(basePath) {
        this._basePath = basePath;
    }
    get basePath() {
        return this._basePath;
    }
    setDefaultAuthentication(auth) {
        this.authentications.default = auth;
    }
    setApiKey(key, value) {
        this.authentications[Admissionregistration_v1beta1ApiApiKeys[key]].apiKey = value;
    }
    /**
     * create a MutatingWebhookConfiguration
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    createMutatingWebhookConfiguration(body, pretty) {
        const localVarPath = this.basePath + '/apis/admissionregistration.k8s.io/v1beta1/mutatingwebhookconfigurations';
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling createMutatingWebhookConfiguration.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * create a ValidatingWebhookConfiguration
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    createValidatingWebhookConfiguration(body, pretty) {
        const localVarPath = this.basePath + '/apis/admissionregistration.k8s.io/v1beta1/validatingwebhookconfigurations';
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling createValidatingWebhookConfiguration.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * delete collection of MutatingWebhookConfiguration
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param includeUninitialized If true, partially initialized resources are included in the response.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param timeoutSeconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    deleteCollectionMutatingWebhookConfiguration(pretty, _continue, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch) {
        const localVarPath = this.basePath + '/apis/admissionregistration.k8s.io/v1beta1/mutatingwebhookconfigurations';
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (_continue !== undefined) {
            queryParameters['continue'] = _continue;
        }
        if (fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = fieldSelector;
        }
        if (includeUninitialized !== undefined) {
            queryParameters['includeUninitialized'] = includeUninitialized;
        }
        if (labelSelector !== undefined) {
            queryParameters['labelSelector'] = labelSelector;
        }
        if (limit !== undefined) {
            queryParameters['limit'] = limit;
        }
        if (resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = resourceVersion;
        }
        if (timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = timeoutSeconds;
        }
        if (watch !== undefined) {
            queryParameters['watch'] = watch;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * delete collection of ValidatingWebhookConfiguration
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param includeUninitialized If true, partially initialized resources are included in the response.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param timeoutSeconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    deleteCollectionValidatingWebhookConfiguration(pretty, _continue, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch) {
        const localVarPath = this.basePath + '/apis/admissionregistration.k8s.io/v1beta1/validatingwebhookconfigurations';
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (_continue !== undefined) {
            queryParameters['continue'] = _continue;
        }
        if (fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = fieldSelector;
        }
        if (includeUninitialized !== undefined) {
            queryParameters['includeUninitialized'] = includeUninitialized;
        }
        if (labelSelector !== undefined) {
            queryParameters['labelSelector'] = labelSelector;
        }
        if (limit !== undefined) {
            queryParameters['limit'] = limit;
        }
        if (resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = resourceVersion;
        }
        if (timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = timeoutSeconds;
        }
        if (watch !== undefined) {
            queryParameters['watch'] = watch;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * delete a MutatingWebhookConfiguration
     * @param name name of the MutatingWebhookConfiguration
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param gracePeriodSeconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @param orphanDependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @param propagationPolicy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
     */
    deleteMutatingWebhookConfiguration(name, body, pretty, gracePeriodSeconds, orphanDependents, propagationPolicy) {
        const localVarPath = this.basePath + '/apis/admissionregistration.k8s.io/v1beta1/mutatingwebhookconfigurations/{name}'
            .replace('{' + 'name' + '}', String(name));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling deleteMutatingWebhookConfiguration.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling deleteMutatingWebhookConfiguration.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (gracePeriodSeconds !== undefined) {
            queryParameters['gracePeriodSeconds'] = gracePeriodSeconds;
        }
        if (orphanDependents !== undefined) {
            queryParameters['orphanDependents'] = orphanDependents;
        }
        if (propagationPolicy !== undefined) {
            queryParameters['propagationPolicy'] = propagationPolicy;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * delete a ValidatingWebhookConfiguration
     * @param name name of the ValidatingWebhookConfiguration
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param gracePeriodSeconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @param orphanDependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @param propagationPolicy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
     */
    deleteValidatingWebhookConfiguration(name, body, pretty, gracePeriodSeconds, orphanDependents, propagationPolicy) {
        const localVarPath = this.basePath + '/apis/admissionregistration.k8s.io/v1beta1/validatingwebhookconfigurations/{name}'
            .replace('{' + 'name' + '}', String(name));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling deleteValidatingWebhookConfiguration.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling deleteValidatingWebhookConfiguration.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (gracePeriodSeconds !== undefined) {
            queryParameters['gracePeriodSeconds'] = gracePeriodSeconds;
        }
        if (orphanDependents !== undefined) {
            queryParameters['orphanDependents'] = orphanDependents;
        }
        if (propagationPolicy !== undefined) {
            queryParameters['propagationPolicy'] = propagationPolicy;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * get available resources
     */
    getAPIResources() {
        const localVarPath = this.basePath + '/apis/admissionregistration.k8s.io/v1beta1/';
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        let useFormData = false;
        let requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * list or watch objects of kind MutatingWebhookConfiguration
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param includeUninitialized If true, partially initialized resources are included in the response.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param timeoutSeconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    listMutatingWebhookConfiguration(pretty, _continue, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch) {
        const localVarPath = this.basePath + '/apis/admissionregistration.k8s.io/v1beta1/mutatingwebhookconfigurations';
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (_continue !== undefined) {
            queryParameters['continue'] = _continue;
        }
        if (fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = fieldSelector;
        }
        if (includeUninitialized !== undefined) {
            queryParameters['includeUninitialized'] = includeUninitialized;
        }
        if (labelSelector !== undefined) {
            queryParameters['labelSelector'] = labelSelector;
        }
        if (limit !== undefined) {
            queryParameters['limit'] = limit;
        }
        if (resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = resourceVersion;
        }
        if (timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = timeoutSeconds;
        }
        if (watch !== undefined) {
            queryParameters['watch'] = watch;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * list or watch objects of kind ValidatingWebhookConfiguration
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param includeUninitialized If true, partially initialized resources are included in the response.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param timeoutSeconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    listValidatingWebhookConfiguration(pretty, _continue, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch) {
        const localVarPath = this.basePath + '/apis/admissionregistration.k8s.io/v1beta1/validatingwebhookconfigurations';
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (_continue !== undefined) {
            queryParameters['continue'] = _continue;
        }
        if (fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = fieldSelector;
        }
        if (includeUninitialized !== undefined) {
            queryParameters['includeUninitialized'] = includeUninitialized;
        }
        if (labelSelector !== undefined) {
            queryParameters['labelSelector'] = labelSelector;
        }
        if (limit !== undefined) {
            queryParameters['limit'] = limit;
        }
        if (resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = resourceVersion;
        }
        if (timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = timeoutSeconds;
        }
        if (watch !== undefined) {
            queryParameters['watch'] = watch;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * partially update the specified MutatingWebhookConfiguration
     * @param name name of the MutatingWebhookConfiguration
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    patchMutatingWebhookConfiguration(name, body, pretty) {
        const localVarPath = this.basePath + '/apis/admissionregistration.k8s.io/v1beta1/mutatingwebhookconfigurations/{name}'
            .replace('{' + 'name' + '}', String(name));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling patchMutatingWebhookConfiguration.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling patchMutatingWebhookConfiguration.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'PATCH',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * partially update the specified ValidatingWebhookConfiguration
     * @param name name of the ValidatingWebhookConfiguration
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    patchValidatingWebhookConfiguration(name, body, pretty) {
        const localVarPath = this.basePath + '/apis/admissionregistration.k8s.io/v1beta1/validatingwebhookconfigurations/{name}'
            .replace('{' + 'name' + '}', String(name));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling patchValidatingWebhookConfiguration.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling patchValidatingWebhookConfiguration.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'PATCH',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * read the specified MutatingWebhookConfiguration
     * @param name name of the MutatingWebhookConfiguration
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param exact Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;.
     * @param _export Should this value be exported.  Export strips fields that a user can not specify.
     */
    readMutatingWebhookConfiguration(name, pretty, exact, _export) {
        const localVarPath = this.basePath + '/apis/admissionregistration.k8s.io/v1beta1/mutatingwebhookconfigurations/{name}'
            .replace('{' + 'name' + '}', String(name));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling readMutatingWebhookConfiguration.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (exact !== undefined) {
            queryParameters['exact'] = exact;
        }
        if (_export !== undefined) {
            queryParameters['export'] = _export;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * read the specified ValidatingWebhookConfiguration
     * @param name name of the ValidatingWebhookConfiguration
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param exact Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;.
     * @param _export Should this value be exported.  Export strips fields that a user can not specify.
     */
    readValidatingWebhookConfiguration(name, pretty, exact, _export) {
        const localVarPath = this.basePath + '/apis/admissionregistration.k8s.io/v1beta1/validatingwebhookconfigurations/{name}'
            .replace('{' + 'name' + '}', String(name));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling readValidatingWebhookConfiguration.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (exact !== undefined) {
            queryParameters['exact'] = exact;
        }
        if (_export !== undefined) {
            queryParameters['export'] = _export;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * replace the specified MutatingWebhookConfiguration
     * @param name name of the MutatingWebhookConfiguration
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    replaceMutatingWebhookConfiguration(name, body, pretty) {
        const localVarPath = this.basePath + '/apis/admissionregistration.k8s.io/v1beta1/mutatingwebhookconfigurations/{name}'
            .replace('{' + 'name' + '}', String(name));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling replaceMutatingWebhookConfiguration.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling replaceMutatingWebhookConfiguration.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * replace the specified ValidatingWebhookConfiguration
     * @param name name of the ValidatingWebhookConfiguration
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    replaceValidatingWebhookConfiguration(name, body, pretty) {
        const localVarPath = this.basePath + '/apis/admissionregistration.k8s.io/v1beta1/validatingwebhookconfigurations/{name}'
            .replace('{' + 'name' + '}', String(name));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling replaceValidatingWebhookConfiguration.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling replaceValidatingWebhookConfiguration.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
exports.Admissionregistration_v1beta1Api = Admissionregistration_v1beta1Api;
var ApiextensionsApiApiKeys;
(function (ApiextensionsApiApiKeys) {
    ApiextensionsApiApiKeys[ApiextensionsApiApiKeys["BearerToken"] = 0] = "BearerToken";
})(ApiextensionsApiApiKeys = exports.ApiextensionsApiApiKeys || (exports.ApiextensionsApiApiKeys = {}));
class ApiextensionsApi {
    constructor(basePathOrUsername, password, basePath) {
        this._basePath = defaultBasePath;
        this.defaultHeaders = {};
        this._useQuerystring = false;
        this.authentications = {
            'default': new VoidAuth(),
            'BearerToken': new ApiKeyAuth('header', 'authorization'),
        };
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        }
        else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername;
            }
        }
    }
    set useQuerystring(value) {
        this._useQuerystring = value;
    }
    set basePath(basePath) {
        this._basePath = basePath;
    }
    get basePath() {
        return this._basePath;
    }
    setDefaultAuthentication(auth) {
        this.authentications.default = auth;
    }
    setApiKey(key, value) {
        this.authentications[ApiextensionsApiApiKeys[key]].apiKey = value;
    }
    /**
     * get information of a group
     */
    getAPIGroup() {
        const localVarPath = this.basePath + '/apis/apiextensions.k8s.io/';
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        let useFormData = false;
        let requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
exports.ApiextensionsApi = ApiextensionsApi;
var Apiextensions_v1beta1ApiApiKeys;
(function (Apiextensions_v1beta1ApiApiKeys) {
    Apiextensions_v1beta1ApiApiKeys[Apiextensions_v1beta1ApiApiKeys["BearerToken"] = 0] = "BearerToken";
})(Apiextensions_v1beta1ApiApiKeys = exports.Apiextensions_v1beta1ApiApiKeys || (exports.Apiextensions_v1beta1ApiApiKeys = {}));
class Apiextensions_v1beta1Api {
    constructor(basePathOrUsername, password, basePath) {
        this._basePath = defaultBasePath;
        this.defaultHeaders = {};
        this._useQuerystring = false;
        this.authentications = {
            'default': new VoidAuth(),
            'BearerToken': new ApiKeyAuth('header', 'authorization'),
        };
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        }
        else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername;
            }
        }
    }
    set useQuerystring(value) {
        this._useQuerystring = value;
    }
    set basePath(basePath) {
        this._basePath = basePath;
    }
    get basePath() {
        return this._basePath;
    }
    setDefaultAuthentication(auth) {
        this.authentications.default = auth;
    }
    setApiKey(key, value) {
        this.authentications[Apiextensions_v1beta1ApiApiKeys[key]].apiKey = value;
    }
    /**
     * create a CustomResourceDefinition
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    createCustomResourceDefinition(body, pretty) {
        const localVarPath = this.basePath + '/apis/apiextensions.k8s.io/v1beta1/customresourcedefinitions';
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling createCustomResourceDefinition.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * delete collection of CustomResourceDefinition
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param includeUninitialized If true, partially initialized resources are included in the response.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param timeoutSeconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    deleteCollectionCustomResourceDefinition(pretty, _continue, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch) {
        const localVarPath = this.basePath + '/apis/apiextensions.k8s.io/v1beta1/customresourcedefinitions';
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (_continue !== undefined) {
            queryParameters['continue'] = _continue;
        }
        if (fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = fieldSelector;
        }
        if (includeUninitialized !== undefined) {
            queryParameters['includeUninitialized'] = includeUninitialized;
        }
        if (labelSelector !== undefined) {
            queryParameters['labelSelector'] = labelSelector;
        }
        if (limit !== undefined) {
            queryParameters['limit'] = limit;
        }
        if (resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = resourceVersion;
        }
        if (timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = timeoutSeconds;
        }
        if (watch !== undefined) {
            queryParameters['watch'] = watch;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * delete a CustomResourceDefinition
     * @param name name of the CustomResourceDefinition
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param gracePeriodSeconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @param orphanDependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @param propagationPolicy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
     */
    deleteCustomResourceDefinition(name, body, pretty, gracePeriodSeconds, orphanDependents, propagationPolicy) {
        const localVarPath = this.basePath + '/apis/apiextensions.k8s.io/v1beta1/customresourcedefinitions/{name}'
            .replace('{' + 'name' + '}', String(name));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling deleteCustomResourceDefinition.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling deleteCustomResourceDefinition.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (gracePeriodSeconds !== undefined) {
            queryParameters['gracePeriodSeconds'] = gracePeriodSeconds;
        }
        if (orphanDependents !== undefined) {
            queryParameters['orphanDependents'] = orphanDependents;
        }
        if (propagationPolicy !== undefined) {
            queryParameters['propagationPolicy'] = propagationPolicy;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * get available resources
     */
    getAPIResources() {
        const localVarPath = this.basePath + '/apis/apiextensions.k8s.io/v1beta1/';
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        let useFormData = false;
        let requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * list or watch objects of kind CustomResourceDefinition
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param includeUninitialized If true, partially initialized resources are included in the response.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param timeoutSeconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    listCustomResourceDefinition(pretty, _continue, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch) {
        const localVarPath = this.basePath + '/apis/apiextensions.k8s.io/v1beta1/customresourcedefinitions';
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (_continue !== undefined) {
            queryParameters['continue'] = _continue;
        }
        if (fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = fieldSelector;
        }
        if (includeUninitialized !== undefined) {
            queryParameters['includeUninitialized'] = includeUninitialized;
        }
        if (labelSelector !== undefined) {
            queryParameters['labelSelector'] = labelSelector;
        }
        if (limit !== undefined) {
            queryParameters['limit'] = limit;
        }
        if (resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = resourceVersion;
        }
        if (timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = timeoutSeconds;
        }
        if (watch !== undefined) {
            queryParameters['watch'] = watch;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * partially update the specified CustomResourceDefinition
     * @param name name of the CustomResourceDefinition
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    patchCustomResourceDefinition(name, body, pretty) {
        const localVarPath = this.basePath + '/apis/apiextensions.k8s.io/v1beta1/customresourcedefinitions/{name}'
            .replace('{' + 'name' + '}', String(name));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling patchCustomResourceDefinition.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling patchCustomResourceDefinition.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'PATCH',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * partially update status of the specified CustomResourceDefinition
     * @param name name of the CustomResourceDefinition
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    patchCustomResourceDefinitionStatus(name, body, pretty) {
        const localVarPath = this.basePath + '/apis/apiextensions.k8s.io/v1beta1/customresourcedefinitions/{name}/status'
            .replace('{' + 'name' + '}', String(name));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling patchCustomResourceDefinitionStatus.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling patchCustomResourceDefinitionStatus.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'PATCH',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * read the specified CustomResourceDefinition
     * @param name name of the CustomResourceDefinition
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param exact Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;.
     * @param _export Should this value be exported.  Export strips fields that a user can not specify.
     */
    readCustomResourceDefinition(name, pretty, exact, _export) {
        const localVarPath = this.basePath + '/apis/apiextensions.k8s.io/v1beta1/customresourcedefinitions/{name}'
            .replace('{' + 'name' + '}', String(name));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling readCustomResourceDefinition.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (exact !== undefined) {
            queryParameters['exact'] = exact;
        }
        if (_export !== undefined) {
            queryParameters['export'] = _export;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * read status of the specified CustomResourceDefinition
     * @param name name of the CustomResourceDefinition
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    readCustomResourceDefinitionStatus(name, pretty) {
        const localVarPath = this.basePath + '/apis/apiextensions.k8s.io/v1beta1/customresourcedefinitions/{name}/status'
            .replace('{' + 'name' + '}', String(name));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling readCustomResourceDefinitionStatus.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * replace the specified CustomResourceDefinition
     * @param name name of the CustomResourceDefinition
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    replaceCustomResourceDefinition(name, body, pretty) {
        const localVarPath = this.basePath + '/apis/apiextensions.k8s.io/v1beta1/customresourcedefinitions/{name}'
            .replace('{' + 'name' + '}', String(name));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling replaceCustomResourceDefinition.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling replaceCustomResourceDefinition.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * replace status of the specified CustomResourceDefinition
     * @param name name of the CustomResourceDefinition
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    replaceCustomResourceDefinitionStatus(name, body, pretty) {
        const localVarPath = this.basePath + '/apis/apiextensions.k8s.io/v1beta1/customresourcedefinitions/{name}/status'
            .replace('{' + 'name' + '}', String(name));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling replaceCustomResourceDefinitionStatus.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling replaceCustomResourceDefinitionStatus.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
exports.Apiextensions_v1beta1Api = Apiextensions_v1beta1Api;
var ApiregistrationApiApiKeys;
(function (ApiregistrationApiApiKeys) {
    ApiregistrationApiApiKeys[ApiregistrationApiApiKeys["BearerToken"] = 0] = "BearerToken";
})(ApiregistrationApiApiKeys = exports.ApiregistrationApiApiKeys || (exports.ApiregistrationApiApiKeys = {}));
class ApiregistrationApi {
    constructor(basePathOrUsername, password, basePath) {
        this._basePath = defaultBasePath;
        this.defaultHeaders = {};
        this._useQuerystring = false;
        this.authentications = {
            'default': new VoidAuth(),
            'BearerToken': new ApiKeyAuth('header', 'authorization'),
        };
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        }
        else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername;
            }
        }
    }
    set useQuerystring(value) {
        this._useQuerystring = value;
    }
    set basePath(basePath) {
        this._basePath = basePath;
    }
    get basePath() {
        return this._basePath;
    }
    setDefaultAuthentication(auth) {
        this.authentications.default = auth;
    }
    setApiKey(key, value) {
        this.authentications[ApiregistrationApiApiKeys[key]].apiKey = value;
    }
    /**
     * get information of a group
     */
    getAPIGroup() {
        const localVarPath = this.basePath + '/apis/apiregistration.k8s.io/';
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        let useFormData = false;
        let requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
exports.ApiregistrationApi = ApiregistrationApi;
var Apiregistration_v1ApiApiKeys;
(function (Apiregistration_v1ApiApiKeys) {
    Apiregistration_v1ApiApiKeys[Apiregistration_v1ApiApiKeys["BearerToken"] = 0] = "BearerToken";
})(Apiregistration_v1ApiApiKeys = exports.Apiregistration_v1ApiApiKeys || (exports.Apiregistration_v1ApiApiKeys = {}));
class Apiregistration_v1Api {
    constructor(basePathOrUsername, password, basePath) {
        this._basePath = defaultBasePath;
        this.defaultHeaders = {};
        this._useQuerystring = false;
        this.authentications = {
            'default': new VoidAuth(),
            'BearerToken': new ApiKeyAuth('header', 'authorization'),
        };
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        }
        else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername;
            }
        }
    }
    set useQuerystring(value) {
        this._useQuerystring = value;
    }
    set basePath(basePath) {
        this._basePath = basePath;
    }
    get basePath() {
        return this._basePath;
    }
    setDefaultAuthentication(auth) {
        this.authentications.default = auth;
    }
    setApiKey(key, value) {
        this.authentications[Apiregistration_v1ApiApiKeys[key]].apiKey = value;
    }
    /**
     * create an APIService
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    createAPIService(body, pretty) {
        const localVarPath = this.basePath + '/apis/apiregistration.k8s.io/v1/apiservices';
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling createAPIService.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * delete an APIService
     * @param name name of the APIService
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param gracePeriodSeconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @param orphanDependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @param propagationPolicy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
     */
    deleteAPIService(name, body, pretty, gracePeriodSeconds, orphanDependents, propagationPolicy) {
        const localVarPath = this.basePath + '/apis/apiregistration.k8s.io/v1/apiservices/{name}'
            .replace('{' + 'name' + '}', String(name));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling deleteAPIService.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling deleteAPIService.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (gracePeriodSeconds !== undefined) {
            queryParameters['gracePeriodSeconds'] = gracePeriodSeconds;
        }
        if (orphanDependents !== undefined) {
            queryParameters['orphanDependents'] = orphanDependents;
        }
        if (propagationPolicy !== undefined) {
            queryParameters['propagationPolicy'] = propagationPolicy;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * delete collection of APIService
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param includeUninitialized If true, partially initialized resources are included in the response.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param timeoutSeconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    deleteCollectionAPIService(pretty, _continue, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch) {
        const localVarPath = this.basePath + '/apis/apiregistration.k8s.io/v1/apiservices';
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (_continue !== undefined) {
            queryParameters['continue'] = _continue;
        }
        if (fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = fieldSelector;
        }
        if (includeUninitialized !== undefined) {
            queryParameters['includeUninitialized'] = includeUninitialized;
        }
        if (labelSelector !== undefined) {
            queryParameters['labelSelector'] = labelSelector;
        }
        if (limit !== undefined) {
            queryParameters['limit'] = limit;
        }
        if (resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = resourceVersion;
        }
        if (timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = timeoutSeconds;
        }
        if (watch !== undefined) {
            queryParameters['watch'] = watch;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * get available resources
     */
    getAPIResources() {
        const localVarPath = this.basePath + '/apis/apiregistration.k8s.io/v1/';
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        let useFormData = false;
        let requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * list or watch objects of kind APIService
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param includeUninitialized If true, partially initialized resources are included in the response.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param timeoutSeconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    listAPIService(pretty, _continue, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch) {
        const localVarPath = this.basePath + '/apis/apiregistration.k8s.io/v1/apiservices';
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (_continue !== undefined) {
            queryParameters['continue'] = _continue;
        }
        if (fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = fieldSelector;
        }
        if (includeUninitialized !== undefined) {
            queryParameters['includeUninitialized'] = includeUninitialized;
        }
        if (labelSelector !== undefined) {
            queryParameters['labelSelector'] = labelSelector;
        }
        if (limit !== undefined) {
            queryParameters['limit'] = limit;
        }
        if (resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = resourceVersion;
        }
        if (timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = timeoutSeconds;
        }
        if (watch !== undefined) {
            queryParameters['watch'] = watch;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * partially update the specified APIService
     * @param name name of the APIService
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    patchAPIService(name, body, pretty) {
        const localVarPath = this.basePath + '/apis/apiregistration.k8s.io/v1/apiservices/{name}'
            .replace('{' + 'name' + '}', String(name));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling patchAPIService.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling patchAPIService.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'PATCH',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * partially update status of the specified APIService
     * @param name name of the APIService
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    patchAPIServiceStatus(name, body, pretty) {
        const localVarPath = this.basePath + '/apis/apiregistration.k8s.io/v1/apiservices/{name}/status'
            .replace('{' + 'name' + '}', String(name));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling patchAPIServiceStatus.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling patchAPIServiceStatus.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'PATCH',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * read the specified APIService
     * @param name name of the APIService
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param exact Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;.
     * @param _export Should this value be exported.  Export strips fields that a user can not specify.
     */
    readAPIService(name, pretty, exact, _export) {
        const localVarPath = this.basePath + '/apis/apiregistration.k8s.io/v1/apiservices/{name}'
            .replace('{' + 'name' + '}', String(name));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling readAPIService.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (exact !== undefined) {
            queryParameters['exact'] = exact;
        }
        if (_export !== undefined) {
            queryParameters['export'] = _export;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * read status of the specified APIService
     * @param name name of the APIService
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    readAPIServiceStatus(name, pretty) {
        const localVarPath = this.basePath + '/apis/apiregistration.k8s.io/v1/apiservices/{name}/status'
            .replace('{' + 'name' + '}', String(name));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling readAPIServiceStatus.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * replace the specified APIService
     * @param name name of the APIService
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    replaceAPIService(name, body, pretty) {
        const localVarPath = this.basePath + '/apis/apiregistration.k8s.io/v1/apiservices/{name}'
            .replace('{' + 'name' + '}', String(name));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling replaceAPIService.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling replaceAPIService.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * replace status of the specified APIService
     * @param name name of the APIService
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    replaceAPIServiceStatus(name, body, pretty) {
        const localVarPath = this.basePath + '/apis/apiregistration.k8s.io/v1/apiservices/{name}/status'
            .replace('{' + 'name' + '}', String(name));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling replaceAPIServiceStatus.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling replaceAPIServiceStatus.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
exports.Apiregistration_v1Api = Apiregistration_v1Api;
var Apiregistration_v1beta1ApiApiKeys;
(function (Apiregistration_v1beta1ApiApiKeys) {
    Apiregistration_v1beta1ApiApiKeys[Apiregistration_v1beta1ApiApiKeys["BearerToken"] = 0] = "BearerToken";
})(Apiregistration_v1beta1ApiApiKeys = exports.Apiregistration_v1beta1ApiApiKeys || (exports.Apiregistration_v1beta1ApiApiKeys = {}));
class Apiregistration_v1beta1Api {
    constructor(basePathOrUsername, password, basePath) {
        this._basePath = defaultBasePath;
        this.defaultHeaders = {};
        this._useQuerystring = false;
        this.authentications = {
            'default': new VoidAuth(),
            'BearerToken': new ApiKeyAuth('header', 'authorization'),
        };
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        }
        else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername;
            }
        }
    }
    set useQuerystring(value) {
        this._useQuerystring = value;
    }
    set basePath(basePath) {
        this._basePath = basePath;
    }
    get basePath() {
        return this._basePath;
    }
    setDefaultAuthentication(auth) {
        this.authentications.default = auth;
    }
    setApiKey(key, value) {
        this.authentications[Apiregistration_v1beta1ApiApiKeys[key]].apiKey = value;
    }
    /**
     * create an APIService
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    createAPIService(body, pretty) {
        const localVarPath = this.basePath + '/apis/apiregistration.k8s.io/v1beta1/apiservices';
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling createAPIService.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * delete an APIService
     * @param name name of the APIService
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param gracePeriodSeconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @param orphanDependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @param propagationPolicy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
     */
    deleteAPIService(name, body, pretty, gracePeriodSeconds, orphanDependents, propagationPolicy) {
        const localVarPath = this.basePath + '/apis/apiregistration.k8s.io/v1beta1/apiservices/{name}'
            .replace('{' + 'name' + '}', String(name));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling deleteAPIService.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling deleteAPIService.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (gracePeriodSeconds !== undefined) {
            queryParameters['gracePeriodSeconds'] = gracePeriodSeconds;
        }
        if (orphanDependents !== undefined) {
            queryParameters['orphanDependents'] = orphanDependents;
        }
        if (propagationPolicy !== undefined) {
            queryParameters['propagationPolicy'] = propagationPolicy;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * delete collection of APIService
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param includeUninitialized If true, partially initialized resources are included in the response.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param timeoutSeconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    deleteCollectionAPIService(pretty, _continue, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch) {
        const localVarPath = this.basePath + '/apis/apiregistration.k8s.io/v1beta1/apiservices';
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (_continue !== undefined) {
            queryParameters['continue'] = _continue;
        }
        if (fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = fieldSelector;
        }
        if (includeUninitialized !== undefined) {
            queryParameters['includeUninitialized'] = includeUninitialized;
        }
        if (labelSelector !== undefined) {
            queryParameters['labelSelector'] = labelSelector;
        }
        if (limit !== undefined) {
            queryParameters['limit'] = limit;
        }
        if (resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = resourceVersion;
        }
        if (timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = timeoutSeconds;
        }
        if (watch !== undefined) {
            queryParameters['watch'] = watch;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * get available resources
     */
    getAPIResources() {
        const localVarPath = this.basePath + '/apis/apiregistration.k8s.io/v1beta1/';
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        let useFormData = false;
        let requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * list or watch objects of kind APIService
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param includeUninitialized If true, partially initialized resources are included in the response.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param timeoutSeconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    listAPIService(pretty, _continue, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch) {
        const localVarPath = this.basePath + '/apis/apiregistration.k8s.io/v1beta1/apiservices';
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (_continue !== undefined) {
            queryParameters['continue'] = _continue;
        }
        if (fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = fieldSelector;
        }
        if (includeUninitialized !== undefined) {
            queryParameters['includeUninitialized'] = includeUninitialized;
        }
        if (labelSelector !== undefined) {
            queryParameters['labelSelector'] = labelSelector;
        }
        if (limit !== undefined) {
            queryParameters['limit'] = limit;
        }
        if (resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = resourceVersion;
        }
        if (timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = timeoutSeconds;
        }
        if (watch !== undefined) {
            queryParameters['watch'] = watch;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * partially update the specified APIService
     * @param name name of the APIService
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    patchAPIService(name, body, pretty) {
        const localVarPath = this.basePath + '/apis/apiregistration.k8s.io/v1beta1/apiservices/{name}'
            .replace('{' + 'name' + '}', String(name));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling patchAPIService.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling patchAPIService.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'PATCH',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * partially update status of the specified APIService
     * @param name name of the APIService
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    patchAPIServiceStatus(name, body, pretty) {
        const localVarPath = this.basePath + '/apis/apiregistration.k8s.io/v1beta1/apiservices/{name}/status'
            .replace('{' + 'name' + '}', String(name));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling patchAPIServiceStatus.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling patchAPIServiceStatus.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'PATCH',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * read the specified APIService
     * @param name name of the APIService
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param exact Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;.
     * @param _export Should this value be exported.  Export strips fields that a user can not specify.
     */
    readAPIService(name, pretty, exact, _export) {
        const localVarPath = this.basePath + '/apis/apiregistration.k8s.io/v1beta1/apiservices/{name}'
            .replace('{' + 'name' + '}', String(name));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling readAPIService.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (exact !== undefined) {
            queryParameters['exact'] = exact;
        }
        if (_export !== undefined) {
            queryParameters['export'] = _export;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * read status of the specified APIService
     * @param name name of the APIService
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    readAPIServiceStatus(name, pretty) {
        const localVarPath = this.basePath + '/apis/apiregistration.k8s.io/v1beta1/apiservices/{name}/status'
            .replace('{' + 'name' + '}', String(name));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling readAPIServiceStatus.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * replace the specified APIService
     * @param name name of the APIService
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    replaceAPIService(name, body, pretty) {
        const localVarPath = this.basePath + '/apis/apiregistration.k8s.io/v1beta1/apiservices/{name}'
            .replace('{' + 'name' + '}', String(name));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling replaceAPIService.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling replaceAPIService.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * replace status of the specified APIService
     * @param name name of the APIService
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    replaceAPIServiceStatus(name, body, pretty) {
        const localVarPath = this.basePath + '/apis/apiregistration.k8s.io/v1beta1/apiservices/{name}/status'
            .replace('{' + 'name' + '}', String(name));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling replaceAPIServiceStatus.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling replaceAPIServiceStatus.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
exports.Apiregistration_v1beta1Api = Apiregistration_v1beta1Api;
var ApisApiApiKeys;
(function (ApisApiApiKeys) {
    ApisApiApiKeys[ApisApiApiKeys["BearerToken"] = 0] = "BearerToken";
})(ApisApiApiKeys = exports.ApisApiApiKeys || (exports.ApisApiApiKeys = {}));
class ApisApi {
    constructor(basePathOrUsername, password, basePath) {
        this._basePath = defaultBasePath;
        this.defaultHeaders = {};
        this._useQuerystring = false;
        this.authentications = {
            'default': new VoidAuth(),
            'BearerToken': new ApiKeyAuth('header', 'authorization'),
        };
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        }
        else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername;
            }
        }
    }
    set useQuerystring(value) {
        this._useQuerystring = value;
    }
    set basePath(basePath) {
        this._basePath = basePath;
    }
    get basePath() {
        return this._basePath;
    }
    setDefaultAuthentication(auth) {
        this.authentications.default = auth;
    }
    setApiKey(key, value) {
        this.authentications[ApisApiApiKeys[key]].apiKey = value;
    }
    /**
     * get available API versions
     */
    getAPIVersions() {
        const localVarPath = this.basePath + '/apis/';
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        let useFormData = false;
        let requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
exports.ApisApi = ApisApi;
var AppsApiApiKeys;
(function (AppsApiApiKeys) {
    AppsApiApiKeys[AppsApiApiKeys["BearerToken"] = 0] = "BearerToken";
})(AppsApiApiKeys = exports.AppsApiApiKeys || (exports.AppsApiApiKeys = {}));
class AppsApi {
    constructor(basePathOrUsername, password, basePath) {
        this._basePath = defaultBasePath;
        this.defaultHeaders = {};
        this._useQuerystring = false;
        this.authentications = {
            'default': new VoidAuth(),
            'BearerToken': new ApiKeyAuth('header', 'authorization'),
        };
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        }
        else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername;
            }
        }
    }
    set useQuerystring(value) {
        this._useQuerystring = value;
    }
    set basePath(basePath) {
        this._basePath = basePath;
    }
    get basePath() {
        return this._basePath;
    }
    setDefaultAuthentication(auth) {
        this.authentications.default = auth;
    }
    setApiKey(key, value) {
        this.authentications[AppsApiApiKeys[key]].apiKey = value;
    }
    /**
     * get information of a group
     */
    getAPIGroup() {
        const localVarPath = this.basePath + '/apis/apps/';
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        let useFormData = false;
        let requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
exports.AppsApi = AppsApi;
var Apps_v1ApiApiKeys;
(function (Apps_v1ApiApiKeys) {
    Apps_v1ApiApiKeys[Apps_v1ApiApiKeys["BearerToken"] = 0] = "BearerToken";
})(Apps_v1ApiApiKeys = exports.Apps_v1ApiApiKeys || (exports.Apps_v1ApiApiKeys = {}));
class Apps_v1Api {
    constructor(basePathOrUsername, password, basePath) {
        this._basePath = defaultBasePath;
        this.defaultHeaders = {};
        this._useQuerystring = false;
        this.authentications = {
            'default': new VoidAuth(),
            'BearerToken': new ApiKeyAuth('header', 'authorization'),
        };
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        }
        else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername;
            }
        }
    }
    set useQuerystring(value) {
        this._useQuerystring = value;
    }
    set basePath(basePath) {
        this._basePath = basePath;
    }
    get basePath() {
        return this._basePath;
    }
    setDefaultAuthentication(auth) {
        this.authentications.default = auth;
    }
    setApiKey(key, value) {
        this.authentications[Apps_v1ApiApiKeys[key]].apiKey = value;
    }
    /**
     * create a ControllerRevision
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    createNamespacedControllerRevision(namespace, body, pretty) {
        const localVarPath = this.basePath + '/apis/apps/v1/namespaces/{namespace}/controllerrevisions'
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling createNamespacedControllerRevision.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling createNamespacedControllerRevision.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * create a DaemonSet
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    createNamespacedDaemonSet(namespace, body, pretty) {
        const localVarPath = this.basePath + '/apis/apps/v1/namespaces/{namespace}/daemonsets'
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling createNamespacedDaemonSet.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling createNamespacedDaemonSet.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * create a Deployment
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    createNamespacedDeployment(namespace, body, pretty) {
        const localVarPath = this.basePath + '/apis/apps/v1/namespaces/{namespace}/deployments'
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling createNamespacedDeployment.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling createNamespacedDeployment.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * create a ReplicaSet
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    createNamespacedReplicaSet(namespace, body, pretty) {
        const localVarPath = this.basePath + '/apis/apps/v1/namespaces/{namespace}/replicasets'
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling createNamespacedReplicaSet.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling createNamespacedReplicaSet.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * create a StatefulSet
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    createNamespacedStatefulSet(namespace, body, pretty) {
        const localVarPath = this.basePath + '/apis/apps/v1/namespaces/{namespace}/statefulsets'
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling createNamespacedStatefulSet.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling createNamespacedStatefulSet.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * delete collection of ControllerRevision
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param includeUninitialized If true, partially initialized resources are included in the response.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param timeoutSeconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    deleteCollectionNamespacedControllerRevision(namespace, pretty, _continue, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch) {
        const localVarPath = this.basePath + '/apis/apps/v1/namespaces/{namespace}/controllerrevisions'
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling deleteCollectionNamespacedControllerRevision.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (_continue !== undefined) {
            queryParameters['continue'] = _continue;
        }
        if (fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = fieldSelector;
        }
        if (includeUninitialized !== undefined) {
            queryParameters['includeUninitialized'] = includeUninitialized;
        }
        if (labelSelector !== undefined) {
            queryParameters['labelSelector'] = labelSelector;
        }
        if (limit !== undefined) {
            queryParameters['limit'] = limit;
        }
        if (resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = resourceVersion;
        }
        if (timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = timeoutSeconds;
        }
        if (watch !== undefined) {
            queryParameters['watch'] = watch;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * delete collection of DaemonSet
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param includeUninitialized If true, partially initialized resources are included in the response.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param timeoutSeconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    deleteCollectionNamespacedDaemonSet(namespace, pretty, _continue, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch) {
        const localVarPath = this.basePath + '/apis/apps/v1/namespaces/{namespace}/daemonsets'
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling deleteCollectionNamespacedDaemonSet.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (_continue !== undefined) {
            queryParameters['continue'] = _continue;
        }
        if (fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = fieldSelector;
        }
        if (includeUninitialized !== undefined) {
            queryParameters['includeUninitialized'] = includeUninitialized;
        }
        if (labelSelector !== undefined) {
            queryParameters['labelSelector'] = labelSelector;
        }
        if (limit !== undefined) {
            queryParameters['limit'] = limit;
        }
        if (resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = resourceVersion;
        }
        if (timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = timeoutSeconds;
        }
        if (watch !== undefined) {
            queryParameters['watch'] = watch;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * delete collection of Deployment
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param includeUninitialized If true, partially initialized resources are included in the response.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param timeoutSeconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    deleteCollectionNamespacedDeployment(namespace, pretty, _continue, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch) {
        const localVarPath = this.basePath + '/apis/apps/v1/namespaces/{namespace}/deployments'
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling deleteCollectionNamespacedDeployment.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (_continue !== undefined) {
            queryParameters['continue'] = _continue;
        }
        if (fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = fieldSelector;
        }
        if (includeUninitialized !== undefined) {
            queryParameters['includeUninitialized'] = includeUninitialized;
        }
        if (labelSelector !== undefined) {
            queryParameters['labelSelector'] = labelSelector;
        }
        if (limit !== undefined) {
            queryParameters['limit'] = limit;
        }
        if (resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = resourceVersion;
        }
        if (timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = timeoutSeconds;
        }
        if (watch !== undefined) {
            queryParameters['watch'] = watch;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * delete collection of ReplicaSet
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param includeUninitialized If true, partially initialized resources are included in the response.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param timeoutSeconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    deleteCollectionNamespacedReplicaSet(namespace, pretty, _continue, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch) {
        const localVarPath = this.basePath + '/apis/apps/v1/namespaces/{namespace}/replicasets'
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling deleteCollectionNamespacedReplicaSet.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (_continue !== undefined) {
            queryParameters['continue'] = _continue;
        }
        if (fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = fieldSelector;
        }
        if (includeUninitialized !== undefined) {
            queryParameters['includeUninitialized'] = includeUninitialized;
        }
        if (labelSelector !== undefined) {
            queryParameters['labelSelector'] = labelSelector;
        }
        if (limit !== undefined) {
            queryParameters['limit'] = limit;
        }
        if (resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = resourceVersion;
        }
        if (timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = timeoutSeconds;
        }
        if (watch !== undefined) {
            queryParameters['watch'] = watch;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * delete collection of StatefulSet
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param includeUninitialized If true, partially initialized resources are included in the response.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param timeoutSeconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    deleteCollectionNamespacedStatefulSet(namespace, pretty, _continue, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch) {
        const localVarPath = this.basePath + '/apis/apps/v1/namespaces/{namespace}/statefulsets'
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling deleteCollectionNamespacedStatefulSet.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (_continue !== undefined) {
            queryParameters['continue'] = _continue;
        }
        if (fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = fieldSelector;
        }
        if (includeUninitialized !== undefined) {
            queryParameters['includeUninitialized'] = includeUninitialized;
        }
        if (labelSelector !== undefined) {
            queryParameters['labelSelector'] = labelSelector;
        }
        if (limit !== undefined) {
            queryParameters['limit'] = limit;
        }
        if (resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = resourceVersion;
        }
        if (timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = timeoutSeconds;
        }
        if (watch !== undefined) {
            queryParameters['watch'] = watch;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * delete a ControllerRevision
     * @param name name of the ControllerRevision
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param gracePeriodSeconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @param orphanDependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @param propagationPolicy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
     */
    deleteNamespacedControllerRevision(name, namespace, body, pretty, gracePeriodSeconds, orphanDependents, propagationPolicy) {
        const localVarPath = this.basePath + '/apis/apps/v1/namespaces/{namespace}/controllerrevisions/{name}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling deleteNamespacedControllerRevision.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling deleteNamespacedControllerRevision.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling deleteNamespacedControllerRevision.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (gracePeriodSeconds !== undefined) {
            queryParameters['gracePeriodSeconds'] = gracePeriodSeconds;
        }
        if (orphanDependents !== undefined) {
            queryParameters['orphanDependents'] = orphanDependents;
        }
        if (propagationPolicy !== undefined) {
            queryParameters['propagationPolicy'] = propagationPolicy;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * delete a DaemonSet
     * @param name name of the DaemonSet
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param gracePeriodSeconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @param orphanDependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @param propagationPolicy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
     */
    deleteNamespacedDaemonSet(name, namespace, body, pretty, gracePeriodSeconds, orphanDependents, propagationPolicy) {
        const localVarPath = this.basePath + '/apis/apps/v1/namespaces/{namespace}/daemonsets/{name}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling deleteNamespacedDaemonSet.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling deleteNamespacedDaemonSet.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling deleteNamespacedDaemonSet.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (gracePeriodSeconds !== undefined) {
            queryParameters['gracePeriodSeconds'] = gracePeriodSeconds;
        }
        if (orphanDependents !== undefined) {
            queryParameters['orphanDependents'] = orphanDependents;
        }
        if (propagationPolicy !== undefined) {
            queryParameters['propagationPolicy'] = propagationPolicy;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * delete a Deployment
     * @param name name of the Deployment
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param gracePeriodSeconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @param orphanDependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @param propagationPolicy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
     */
    deleteNamespacedDeployment(name, namespace, body, pretty, gracePeriodSeconds, orphanDependents, propagationPolicy) {
        const localVarPath = this.basePath + '/apis/apps/v1/namespaces/{namespace}/deployments/{name}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling deleteNamespacedDeployment.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling deleteNamespacedDeployment.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling deleteNamespacedDeployment.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (gracePeriodSeconds !== undefined) {
            queryParameters['gracePeriodSeconds'] = gracePeriodSeconds;
        }
        if (orphanDependents !== undefined) {
            queryParameters['orphanDependents'] = orphanDependents;
        }
        if (propagationPolicy !== undefined) {
            queryParameters['propagationPolicy'] = propagationPolicy;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * delete a ReplicaSet
     * @param name name of the ReplicaSet
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param gracePeriodSeconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @param orphanDependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @param propagationPolicy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
     */
    deleteNamespacedReplicaSet(name, namespace, body, pretty, gracePeriodSeconds, orphanDependents, propagationPolicy) {
        const localVarPath = this.basePath + '/apis/apps/v1/namespaces/{namespace}/replicasets/{name}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling deleteNamespacedReplicaSet.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling deleteNamespacedReplicaSet.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling deleteNamespacedReplicaSet.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (gracePeriodSeconds !== undefined) {
            queryParameters['gracePeriodSeconds'] = gracePeriodSeconds;
        }
        if (orphanDependents !== undefined) {
            queryParameters['orphanDependents'] = orphanDependents;
        }
        if (propagationPolicy !== undefined) {
            queryParameters['propagationPolicy'] = propagationPolicy;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * delete a StatefulSet
     * @param name name of the StatefulSet
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param gracePeriodSeconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @param orphanDependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @param propagationPolicy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
     */
    deleteNamespacedStatefulSet(name, namespace, body, pretty, gracePeriodSeconds, orphanDependents, propagationPolicy) {
        const localVarPath = this.basePath + '/apis/apps/v1/namespaces/{namespace}/statefulsets/{name}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling deleteNamespacedStatefulSet.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling deleteNamespacedStatefulSet.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling deleteNamespacedStatefulSet.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (gracePeriodSeconds !== undefined) {
            queryParameters['gracePeriodSeconds'] = gracePeriodSeconds;
        }
        if (orphanDependents !== undefined) {
            queryParameters['orphanDependents'] = orphanDependents;
        }
        if (propagationPolicy !== undefined) {
            queryParameters['propagationPolicy'] = propagationPolicy;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * get available resources
     */
    getAPIResources() {
        const localVarPath = this.basePath + '/apis/apps/v1/';
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        let useFormData = false;
        let requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * list or watch objects of kind ControllerRevision
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param includeUninitialized If true, partially initialized resources are included in the response.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param timeoutSeconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    listControllerRevisionForAllNamespaces(_continue, fieldSelector, includeUninitialized, labelSelector, limit, pretty, resourceVersion, timeoutSeconds, watch) {
        const localVarPath = this.basePath + '/apis/apps/v1/controllerrevisions';
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        if (_continue !== undefined) {
            queryParameters['continue'] = _continue;
        }
        if (fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = fieldSelector;
        }
        if (includeUninitialized !== undefined) {
            queryParameters['includeUninitialized'] = includeUninitialized;
        }
        if (labelSelector !== undefined) {
            queryParameters['labelSelector'] = labelSelector;
        }
        if (limit !== undefined) {
            queryParameters['limit'] = limit;
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = resourceVersion;
        }
        if (timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = timeoutSeconds;
        }
        if (watch !== undefined) {
            queryParameters['watch'] = watch;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * list or watch objects of kind DaemonSet
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param includeUninitialized If true, partially initialized resources are included in the response.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param timeoutSeconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    listDaemonSetForAllNamespaces(_continue, fieldSelector, includeUninitialized, labelSelector, limit, pretty, resourceVersion, timeoutSeconds, watch) {
        const localVarPath = this.basePath + '/apis/apps/v1/daemonsets';
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        if (_continue !== undefined) {
            queryParameters['continue'] = _continue;
        }
        if (fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = fieldSelector;
        }
        if (includeUninitialized !== undefined) {
            queryParameters['includeUninitialized'] = includeUninitialized;
        }
        if (labelSelector !== undefined) {
            queryParameters['labelSelector'] = labelSelector;
        }
        if (limit !== undefined) {
            queryParameters['limit'] = limit;
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = resourceVersion;
        }
        if (timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = timeoutSeconds;
        }
        if (watch !== undefined) {
            queryParameters['watch'] = watch;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * list or watch objects of kind Deployment
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param includeUninitialized If true, partially initialized resources are included in the response.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param timeoutSeconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    listDeploymentForAllNamespaces(_continue, fieldSelector, includeUninitialized, labelSelector, limit, pretty, resourceVersion, timeoutSeconds, watch) {
        const localVarPath = this.basePath + '/apis/apps/v1/deployments';
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        if (_continue !== undefined) {
            queryParameters['continue'] = _continue;
        }
        if (fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = fieldSelector;
        }
        if (includeUninitialized !== undefined) {
            queryParameters['includeUninitialized'] = includeUninitialized;
        }
        if (labelSelector !== undefined) {
            queryParameters['labelSelector'] = labelSelector;
        }
        if (limit !== undefined) {
            queryParameters['limit'] = limit;
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = resourceVersion;
        }
        if (timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = timeoutSeconds;
        }
        if (watch !== undefined) {
            queryParameters['watch'] = watch;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * list or watch objects of kind ControllerRevision
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param includeUninitialized If true, partially initialized resources are included in the response.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param timeoutSeconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    listNamespacedControllerRevision(namespace, pretty, _continue, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch) {
        const localVarPath = this.basePath + '/apis/apps/v1/namespaces/{namespace}/controllerrevisions'
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling listNamespacedControllerRevision.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (_continue !== undefined) {
            queryParameters['continue'] = _continue;
        }
        if (fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = fieldSelector;
        }
        if (includeUninitialized !== undefined) {
            queryParameters['includeUninitialized'] = includeUninitialized;
        }
        if (labelSelector !== undefined) {
            queryParameters['labelSelector'] = labelSelector;
        }
        if (limit !== undefined) {
            queryParameters['limit'] = limit;
        }
        if (resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = resourceVersion;
        }
        if (timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = timeoutSeconds;
        }
        if (watch !== undefined) {
            queryParameters['watch'] = watch;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * list or watch objects of kind DaemonSet
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param includeUninitialized If true, partially initialized resources are included in the response.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param timeoutSeconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    listNamespacedDaemonSet(namespace, pretty, _continue, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch) {
        const localVarPath = this.basePath + '/apis/apps/v1/namespaces/{namespace}/daemonsets'
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling listNamespacedDaemonSet.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (_continue !== undefined) {
            queryParameters['continue'] = _continue;
        }
        if (fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = fieldSelector;
        }
        if (includeUninitialized !== undefined) {
            queryParameters['includeUninitialized'] = includeUninitialized;
        }
        if (labelSelector !== undefined) {
            queryParameters['labelSelector'] = labelSelector;
        }
        if (limit !== undefined) {
            queryParameters['limit'] = limit;
        }
        if (resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = resourceVersion;
        }
        if (timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = timeoutSeconds;
        }
        if (watch !== undefined) {
            queryParameters['watch'] = watch;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * list or watch objects of kind Deployment
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param includeUninitialized If true, partially initialized resources are included in the response.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param timeoutSeconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    listNamespacedDeployment(namespace, pretty, _continue, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch) {
        const localVarPath = this.basePath + '/apis/apps/v1/namespaces/{namespace}/deployments'
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling listNamespacedDeployment.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (_continue !== undefined) {
            queryParameters['continue'] = _continue;
        }
        if (fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = fieldSelector;
        }
        if (includeUninitialized !== undefined) {
            queryParameters['includeUninitialized'] = includeUninitialized;
        }
        if (labelSelector !== undefined) {
            queryParameters['labelSelector'] = labelSelector;
        }
        if (limit !== undefined) {
            queryParameters['limit'] = limit;
        }
        if (resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = resourceVersion;
        }
        if (timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = timeoutSeconds;
        }
        if (watch !== undefined) {
            queryParameters['watch'] = watch;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * list or watch objects of kind ReplicaSet
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param includeUninitialized If true, partially initialized resources are included in the response.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param timeoutSeconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    listNamespacedReplicaSet(namespace, pretty, _continue, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch) {
        const localVarPath = this.basePath + '/apis/apps/v1/namespaces/{namespace}/replicasets'
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling listNamespacedReplicaSet.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (_continue !== undefined) {
            queryParameters['continue'] = _continue;
        }
        if (fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = fieldSelector;
        }
        if (includeUninitialized !== undefined) {
            queryParameters['includeUninitialized'] = includeUninitialized;
        }
        if (labelSelector !== undefined) {
            queryParameters['labelSelector'] = labelSelector;
        }
        if (limit !== undefined) {
            queryParameters['limit'] = limit;
        }
        if (resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = resourceVersion;
        }
        if (timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = timeoutSeconds;
        }
        if (watch !== undefined) {
            queryParameters['watch'] = watch;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * list or watch objects of kind StatefulSet
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param includeUninitialized If true, partially initialized resources are included in the response.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param timeoutSeconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    listNamespacedStatefulSet(namespace, pretty, _continue, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch) {
        const localVarPath = this.basePath + '/apis/apps/v1/namespaces/{namespace}/statefulsets'
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling listNamespacedStatefulSet.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (_continue !== undefined) {
            queryParameters['continue'] = _continue;
        }
        if (fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = fieldSelector;
        }
        if (includeUninitialized !== undefined) {
            queryParameters['includeUninitialized'] = includeUninitialized;
        }
        if (labelSelector !== undefined) {
            queryParameters['labelSelector'] = labelSelector;
        }
        if (limit !== undefined) {
            queryParameters['limit'] = limit;
        }
        if (resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = resourceVersion;
        }
        if (timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = timeoutSeconds;
        }
        if (watch !== undefined) {
            queryParameters['watch'] = watch;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * list or watch objects of kind ReplicaSet
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param includeUninitialized If true, partially initialized resources are included in the response.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param timeoutSeconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    listReplicaSetForAllNamespaces(_continue, fieldSelector, includeUninitialized, labelSelector, limit, pretty, resourceVersion, timeoutSeconds, watch) {
        const localVarPath = this.basePath + '/apis/apps/v1/replicasets';
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        if (_continue !== undefined) {
            queryParameters['continue'] = _continue;
        }
        if (fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = fieldSelector;
        }
        if (includeUninitialized !== undefined) {
            queryParameters['includeUninitialized'] = includeUninitialized;
        }
        if (labelSelector !== undefined) {
            queryParameters['labelSelector'] = labelSelector;
        }
        if (limit !== undefined) {
            queryParameters['limit'] = limit;
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = resourceVersion;
        }
        if (timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = timeoutSeconds;
        }
        if (watch !== undefined) {
            queryParameters['watch'] = watch;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * list or watch objects of kind StatefulSet
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param includeUninitialized If true, partially initialized resources are included in the response.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param timeoutSeconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    listStatefulSetForAllNamespaces(_continue, fieldSelector, includeUninitialized, labelSelector, limit, pretty, resourceVersion, timeoutSeconds, watch) {
        const localVarPath = this.basePath + '/apis/apps/v1/statefulsets';
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        if (_continue !== undefined) {
            queryParameters['continue'] = _continue;
        }
        if (fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = fieldSelector;
        }
        if (includeUninitialized !== undefined) {
            queryParameters['includeUninitialized'] = includeUninitialized;
        }
        if (labelSelector !== undefined) {
            queryParameters['labelSelector'] = labelSelector;
        }
        if (limit !== undefined) {
            queryParameters['limit'] = limit;
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = resourceVersion;
        }
        if (timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = timeoutSeconds;
        }
        if (watch !== undefined) {
            queryParameters['watch'] = watch;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * partially update the specified ControllerRevision
     * @param name name of the ControllerRevision
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    patchNamespacedControllerRevision(name, namespace, body, pretty) {
        const localVarPath = this.basePath + '/apis/apps/v1/namespaces/{namespace}/controllerrevisions/{name}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling patchNamespacedControllerRevision.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling patchNamespacedControllerRevision.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling patchNamespacedControllerRevision.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'PATCH',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * partially update the specified DaemonSet
     * @param name name of the DaemonSet
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    patchNamespacedDaemonSet(name, namespace, body, pretty) {
        const localVarPath = this.basePath + '/apis/apps/v1/namespaces/{namespace}/daemonsets/{name}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling patchNamespacedDaemonSet.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling patchNamespacedDaemonSet.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling patchNamespacedDaemonSet.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'PATCH',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * partially update status of the specified DaemonSet
     * @param name name of the DaemonSet
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    patchNamespacedDaemonSetStatus(name, namespace, body, pretty) {
        const localVarPath = this.basePath + '/apis/apps/v1/namespaces/{namespace}/daemonsets/{name}/status'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling patchNamespacedDaemonSetStatus.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling patchNamespacedDaemonSetStatus.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling patchNamespacedDaemonSetStatus.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'PATCH',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * partially update the specified Deployment
     * @param name name of the Deployment
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    patchNamespacedDeployment(name, namespace, body, pretty) {
        const localVarPath = this.basePath + '/apis/apps/v1/namespaces/{namespace}/deployments/{name}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling patchNamespacedDeployment.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling patchNamespacedDeployment.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling patchNamespacedDeployment.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'PATCH',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * partially update scale of the specified Deployment
     * @param name name of the Scale
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    patchNamespacedDeploymentScale(name, namespace, body, pretty) {
        const localVarPath = this.basePath + '/apis/apps/v1/namespaces/{namespace}/deployments/{name}/scale'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling patchNamespacedDeploymentScale.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling patchNamespacedDeploymentScale.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling patchNamespacedDeploymentScale.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'PATCH',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * partially update status of the specified Deployment
     * @param name name of the Deployment
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    patchNamespacedDeploymentStatus(name, namespace, body, pretty) {
        const localVarPath = this.basePath + '/apis/apps/v1/namespaces/{namespace}/deployments/{name}/status'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling patchNamespacedDeploymentStatus.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling patchNamespacedDeploymentStatus.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling patchNamespacedDeploymentStatus.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'PATCH',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * partially update the specified ReplicaSet
     * @param name name of the ReplicaSet
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    patchNamespacedReplicaSet(name, namespace, body, pretty) {
        const localVarPath = this.basePath + '/apis/apps/v1/namespaces/{namespace}/replicasets/{name}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling patchNamespacedReplicaSet.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling patchNamespacedReplicaSet.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling patchNamespacedReplicaSet.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'PATCH',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * partially update scale of the specified ReplicaSet
     * @param name name of the Scale
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    patchNamespacedReplicaSetScale(name, namespace, body, pretty) {
        const localVarPath = this.basePath + '/apis/apps/v1/namespaces/{namespace}/replicasets/{name}/scale'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling patchNamespacedReplicaSetScale.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling patchNamespacedReplicaSetScale.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling patchNamespacedReplicaSetScale.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'PATCH',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * partially update status of the specified ReplicaSet
     * @param name name of the ReplicaSet
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    patchNamespacedReplicaSetStatus(name, namespace, body, pretty) {
        const localVarPath = this.basePath + '/apis/apps/v1/namespaces/{namespace}/replicasets/{name}/status'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling patchNamespacedReplicaSetStatus.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling patchNamespacedReplicaSetStatus.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling patchNamespacedReplicaSetStatus.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'PATCH',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * partially update the specified StatefulSet
     * @param name name of the StatefulSet
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    patchNamespacedStatefulSet(name, namespace, body, pretty) {
        const localVarPath = this.basePath + '/apis/apps/v1/namespaces/{namespace}/statefulsets/{name}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling patchNamespacedStatefulSet.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling patchNamespacedStatefulSet.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling patchNamespacedStatefulSet.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'PATCH',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * partially update scale of the specified StatefulSet
     * @param name name of the Scale
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    patchNamespacedStatefulSetScale(name, namespace, body, pretty) {
        const localVarPath = this.basePath + '/apis/apps/v1/namespaces/{namespace}/statefulsets/{name}/scale'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling patchNamespacedStatefulSetScale.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling patchNamespacedStatefulSetScale.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling patchNamespacedStatefulSetScale.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'PATCH',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * partially update status of the specified StatefulSet
     * @param name name of the StatefulSet
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    patchNamespacedStatefulSetStatus(name, namespace, body, pretty) {
        const localVarPath = this.basePath + '/apis/apps/v1/namespaces/{namespace}/statefulsets/{name}/status'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling patchNamespacedStatefulSetStatus.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling patchNamespacedStatefulSetStatus.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling patchNamespacedStatefulSetStatus.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'PATCH',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * read the specified ControllerRevision
     * @param name name of the ControllerRevision
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param exact Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;.
     * @param _export Should this value be exported.  Export strips fields that a user can not specify.
     */
    readNamespacedControllerRevision(name, namespace, pretty, exact, _export) {
        const localVarPath = this.basePath + '/apis/apps/v1/namespaces/{namespace}/controllerrevisions/{name}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling readNamespacedControllerRevision.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling readNamespacedControllerRevision.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (exact !== undefined) {
            queryParameters['exact'] = exact;
        }
        if (_export !== undefined) {
            queryParameters['export'] = _export;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * read the specified DaemonSet
     * @param name name of the DaemonSet
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param exact Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;.
     * @param _export Should this value be exported.  Export strips fields that a user can not specify.
     */
    readNamespacedDaemonSet(name, namespace, pretty, exact, _export) {
        const localVarPath = this.basePath + '/apis/apps/v1/namespaces/{namespace}/daemonsets/{name}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling readNamespacedDaemonSet.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling readNamespacedDaemonSet.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (exact !== undefined) {
            queryParameters['exact'] = exact;
        }
        if (_export !== undefined) {
            queryParameters['export'] = _export;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * read status of the specified DaemonSet
     * @param name name of the DaemonSet
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    readNamespacedDaemonSetStatus(name, namespace, pretty) {
        const localVarPath = this.basePath + '/apis/apps/v1/namespaces/{namespace}/daemonsets/{name}/status'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling readNamespacedDaemonSetStatus.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling readNamespacedDaemonSetStatus.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * read the specified Deployment
     * @param name name of the Deployment
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param exact Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;.
     * @param _export Should this value be exported.  Export strips fields that a user can not specify.
     */
    readNamespacedDeployment(name, namespace, pretty, exact, _export) {
        const localVarPath = this.basePath + '/apis/apps/v1/namespaces/{namespace}/deployments/{name}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling readNamespacedDeployment.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling readNamespacedDeployment.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (exact !== undefined) {
            queryParameters['exact'] = exact;
        }
        if (_export !== undefined) {
            queryParameters['export'] = _export;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * read scale of the specified Deployment
     * @param name name of the Scale
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    readNamespacedDeploymentScale(name, namespace, pretty) {
        const localVarPath = this.basePath + '/apis/apps/v1/namespaces/{namespace}/deployments/{name}/scale'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling readNamespacedDeploymentScale.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling readNamespacedDeploymentScale.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * read status of the specified Deployment
     * @param name name of the Deployment
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    readNamespacedDeploymentStatus(name, namespace, pretty) {
        const localVarPath = this.basePath + '/apis/apps/v1/namespaces/{namespace}/deployments/{name}/status'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling readNamespacedDeploymentStatus.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling readNamespacedDeploymentStatus.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * read the specified ReplicaSet
     * @param name name of the ReplicaSet
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param exact Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;.
     * @param _export Should this value be exported.  Export strips fields that a user can not specify.
     */
    readNamespacedReplicaSet(name, namespace, pretty, exact, _export) {
        const localVarPath = this.basePath + '/apis/apps/v1/namespaces/{namespace}/replicasets/{name}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling readNamespacedReplicaSet.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling readNamespacedReplicaSet.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (exact !== undefined) {
            queryParameters['exact'] = exact;
        }
        if (_export !== undefined) {
            queryParameters['export'] = _export;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * read scale of the specified ReplicaSet
     * @param name name of the Scale
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    readNamespacedReplicaSetScale(name, namespace, pretty) {
        const localVarPath = this.basePath + '/apis/apps/v1/namespaces/{namespace}/replicasets/{name}/scale'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling readNamespacedReplicaSetScale.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling readNamespacedReplicaSetScale.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * read status of the specified ReplicaSet
     * @param name name of the ReplicaSet
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    readNamespacedReplicaSetStatus(name, namespace, pretty) {
        const localVarPath = this.basePath + '/apis/apps/v1/namespaces/{namespace}/replicasets/{name}/status'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling readNamespacedReplicaSetStatus.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling readNamespacedReplicaSetStatus.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * read the specified StatefulSet
     * @param name name of the StatefulSet
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param exact Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;.
     * @param _export Should this value be exported.  Export strips fields that a user can not specify.
     */
    readNamespacedStatefulSet(name, namespace, pretty, exact, _export) {
        const localVarPath = this.basePath + '/apis/apps/v1/namespaces/{namespace}/statefulsets/{name}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling readNamespacedStatefulSet.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling readNamespacedStatefulSet.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (exact !== undefined) {
            queryParameters['exact'] = exact;
        }
        if (_export !== undefined) {
            queryParameters['export'] = _export;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * read scale of the specified StatefulSet
     * @param name name of the Scale
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    readNamespacedStatefulSetScale(name, namespace, pretty) {
        const localVarPath = this.basePath + '/apis/apps/v1/namespaces/{namespace}/statefulsets/{name}/scale'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling readNamespacedStatefulSetScale.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling readNamespacedStatefulSetScale.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * read status of the specified StatefulSet
     * @param name name of the StatefulSet
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    readNamespacedStatefulSetStatus(name, namespace, pretty) {
        const localVarPath = this.basePath + '/apis/apps/v1/namespaces/{namespace}/statefulsets/{name}/status'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling readNamespacedStatefulSetStatus.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling readNamespacedStatefulSetStatus.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * replace the specified ControllerRevision
     * @param name name of the ControllerRevision
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    replaceNamespacedControllerRevision(name, namespace, body, pretty) {
        const localVarPath = this.basePath + '/apis/apps/v1/namespaces/{namespace}/controllerrevisions/{name}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling replaceNamespacedControllerRevision.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling replaceNamespacedControllerRevision.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling replaceNamespacedControllerRevision.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * replace the specified DaemonSet
     * @param name name of the DaemonSet
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    replaceNamespacedDaemonSet(name, namespace, body, pretty) {
        const localVarPath = this.basePath + '/apis/apps/v1/namespaces/{namespace}/daemonsets/{name}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling replaceNamespacedDaemonSet.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling replaceNamespacedDaemonSet.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling replaceNamespacedDaemonSet.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * replace status of the specified DaemonSet
     * @param name name of the DaemonSet
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    replaceNamespacedDaemonSetStatus(name, namespace, body, pretty) {
        const localVarPath = this.basePath + '/apis/apps/v1/namespaces/{namespace}/daemonsets/{name}/status'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling replaceNamespacedDaemonSetStatus.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling replaceNamespacedDaemonSetStatus.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling replaceNamespacedDaemonSetStatus.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * replace the specified Deployment
     * @param name name of the Deployment
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    replaceNamespacedDeployment(name, namespace, body, pretty) {
        const localVarPath = this.basePath + '/apis/apps/v1/namespaces/{namespace}/deployments/{name}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling replaceNamespacedDeployment.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling replaceNamespacedDeployment.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling replaceNamespacedDeployment.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * replace scale of the specified Deployment
     * @param name name of the Scale
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    replaceNamespacedDeploymentScale(name, namespace, body, pretty) {
        const localVarPath = this.basePath + '/apis/apps/v1/namespaces/{namespace}/deployments/{name}/scale'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling replaceNamespacedDeploymentScale.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling replaceNamespacedDeploymentScale.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling replaceNamespacedDeploymentScale.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * replace status of the specified Deployment
     * @param name name of the Deployment
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    replaceNamespacedDeploymentStatus(name, namespace, body, pretty) {
        const localVarPath = this.basePath + '/apis/apps/v1/namespaces/{namespace}/deployments/{name}/status'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling replaceNamespacedDeploymentStatus.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling replaceNamespacedDeploymentStatus.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling replaceNamespacedDeploymentStatus.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * replace the specified ReplicaSet
     * @param name name of the ReplicaSet
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    replaceNamespacedReplicaSet(name, namespace, body, pretty) {
        const localVarPath = this.basePath + '/apis/apps/v1/namespaces/{namespace}/replicasets/{name}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling replaceNamespacedReplicaSet.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling replaceNamespacedReplicaSet.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling replaceNamespacedReplicaSet.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * replace scale of the specified ReplicaSet
     * @param name name of the Scale
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    replaceNamespacedReplicaSetScale(name, namespace, body, pretty) {
        const localVarPath = this.basePath + '/apis/apps/v1/namespaces/{namespace}/replicasets/{name}/scale'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling replaceNamespacedReplicaSetScale.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling replaceNamespacedReplicaSetScale.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling replaceNamespacedReplicaSetScale.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * replace status of the specified ReplicaSet
     * @param name name of the ReplicaSet
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    replaceNamespacedReplicaSetStatus(name, namespace, body, pretty) {
        const localVarPath = this.basePath + '/apis/apps/v1/namespaces/{namespace}/replicasets/{name}/status'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling replaceNamespacedReplicaSetStatus.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling replaceNamespacedReplicaSetStatus.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling replaceNamespacedReplicaSetStatus.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * replace the specified StatefulSet
     * @param name name of the StatefulSet
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    replaceNamespacedStatefulSet(name, namespace, body, pretty) {
        const localVarPath = this.basePath + '/apis/apps/v1/namespaces/{namespace}/statefulsets/{name}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling replaceNamespacedStatefulSet.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling replaceNamespacedStatefulSet.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling replaceNamespacedStatefulSet.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * replace scale of the specified StatefulSet
     * @param name name of the Scale
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    replaceNamespacedStatefulSetScale(name, namespace, body, pretty) {
        const localVarPath = this.basePath + '/apis/apps/v1/namespaces/{namespace}/statefulsets/{name}/scale'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling replaceNamespacedStatefulSetScale.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling replaceNamespacedStatefulSetScale.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling replaceNamespacedStatefulSetScale.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * replace status of the specified StatefulSet
     * @param name name of the StatefulSet
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    replaceNamespacedStatefulSetStatus(name, namespace, body, pretty) {
        const localVarPath = this.basePath + '/apis/apps/v1/namespaces/{namespace}/statefulsets/{name}/status'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling replaceNamespacedStatefulSetStatus.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling replaceNamespacedStatefulSetStatus.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling replaceNamespacedStatefulSetStatus.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
exports.Apps_v1Api = Apps_v1Api;
var Apps_v1beta1ApiApiKeys;
(function (Apps_v1beta1ApiApiKeys) {
    Apps_v1beta1ApiApiKeys[Apps_v1beta1ApiApiKeys["BearerToken"] = 0] = "BearerToken";
})(Apps_v1beta1ApiApiKeys = exports.Apps_v1beta1ApiApiKeys || (exports.Apps_v1beta1ApiApiKeys = {}));
class Apps_v1beta1Api {
    constructor(basePathOrUsername, password, basePath) {
        this._basePath = defaultBasePath;
        this.defaultHeaders = {};
        this._useQuerystring = false;
        this.authentications = {
            'default': new VoidAuth(),
            'BearerToken': new ApiKeyAuth('header', 'authorization'),
        };
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        }
        else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername;
            }
        }
    }
    set useQuerystring(value) {
        this._useQuerystring = value;
    }
    set basePath(basePath) {
        this._basePath = basePath;
    }
    get basePath() {
        return this._basePath;
    }
    setDefaultAuthentication(auth) {
        this.authentications.default = auth;
    }
    setApiKey(key, value) {
        this.authentications[Apps_v1beta1ApiApiKeys[key]].apiKey = value;
    }
    /**
     * create a ControllerRevision
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    createNamespacedControllerRevision(namespace, body, pretty) {
        const localVarPath = this.basePath + '/apis/apps/v1beta1/namespaces/{namespace}/controllerrevisions'
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling createNamespacedControllerRevision.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling createNamespacedControllerRevision.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * create a Deployment
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    createNamespacedDeployment(namespace, body, pretty) {
        const localVarPath = this.basePath + '/apis/apps/v1beta1/namespaces/{namespace}/deployments'
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling createNamespacedDeployment.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling createNamespacedDeployment.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * create rollback of a Deployment
     * @param name name of the DeploymentRollback
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    createNamespacedDeploymentRollback(name, namespace, body, pretty) {
        const localVarPath = this.basePath + '/apis/apps/v1beta1/namespaces/{namespace}/deployments/{name}/rollback'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling createNamespacedDeploymentRollback.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling createNamespacedDeploymentRollback.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling createNamespacedDeploymentRollback.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * create a StatefulSet
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    createNamespacedStatefulSet(namespace, body, pretty) {
        const localVarPath = this.basePath + '/apis/apps/v1beta1/namespaces/{namespace}/statefulsets'
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling createNamespacedStatefulSet.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling createNamespacedStatefulSet.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * delete collection of ControllerRevision
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param includeUninitialized If true, partially initialized resources are included in the response.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param timeoutSeconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    deleteCollectionNamespacedControllerRevision(namespace, pretty, _continue, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch) {
        const localVarPath = this.basePath + '/apis/apps/v1beta1/namespaces/{namespace}/controllerrevisions'
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling deleteCollectionNamespacedControllerRevision.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (_continue !== undefined) {
            queryParameters['continue'] = _continue;
        }
        if (fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = fieldSelector;
        }
        if (includeUninitialized !== undefined) {
            queryParameters['includeUninitialized'] = includeUninitialized;
        }
        if (labelSelector !== undefined) {
            queryParameters['labelSelector'] = labelSelector;
        }
        if (limit !== undefined) {
            queryParameters['limit'] = limit;
        }
        if (resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = resourceVersion;
        }
        if (timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = timeoutSeconds;
        }
        if (watch !== undefined) {
            queryParameters['watch'] = watch;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * delete collection of Deployment
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param includeUninitialized If true, partially initialized resources are included in the response.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param timeoutSeconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    deleteCollectionNamespacedDeployment(namespace, pretty, _continue, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch) {
        const localVarPath = this.basePath + '/apis/apps/v1beta1/namespaces/{namespace}/deployments'
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling deleteCollectionNamespacedDeployment.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (_continue !== undefined) {
            queryParameters['continue'] = _continue;
        }
        if (fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = fieldSelector;
        }
        if (includeUninitialized !== undefined) {
            queryParameters['includeUninitialized'] = includeUninitialized;
        }
        if (labelSelector !== undefined) {
            queryParameters['labelSelector'] = labelSelector;
        }
        if (limit !== undefined) {
            queryParameters['limit'] = limit;
        }
        if (resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = resourceVersion;
        }
        if (timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = timeoutSeconds;
        }
        if (watch !== undefined) {
            queryParameters['watch'] = watch;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * delete collection of StatefulSet
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param includeUninitialized If true, partially initialized resources are included in the response.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param timeoutSeconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    deleteCollectionNamespacedStatefulSet(namespace, pretty, _continue, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch) {
        const localVarPath = this.basePath + '/apis/apps/v1beta1/namespaces/{namespace}/statefulsets'
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling deleteCollectionNamespacedStatefulSet.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (_continue !== undefined) {
            queryParameters['continue'] = _continue;
        }
        if (fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = fieldSelector;
        }
        if (includeUninitialized !== undefined) {
            queryParameters['includeUninitialized'] = includeUninitialized;
        }
        if (labelSelector !== undefined) {
            queryParameters['labelSelector'] = labelSelector;
        }
        if (limit !== undefined) {
            queryParameters['limit'] = limit;
        }
        if (resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = resourceVersion;
        }
        if (timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = timeoutSeconds;
        }
        if (watch !== undefined) {
            queryParameters['watch'] = watch;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * delete a ControllerRevision
     * @param name name of the ControllerRevision
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param gracePeriodSeconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @param orphanDependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @param propagationPolicy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
     */
    deleteNamespacedControllerRevision(name, namespace, body, pretty, gracePeriodSeconds, orphanDependents, propagationPolicy) {
        const localVarPath = this.basePath + '/apis/apps/v1beta1/namespaces/{namespace}/controllerrevisions/{name}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling deleteNamespacedControllerRevision.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling deleteNamespacedControllerRevision.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling deleteNamespacedControllerRevision.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (gracePeriodSeconds !== undefined) {
            queryParameters['gracePeriodSeconds'] = gracePeriodSeconds;
        }
        if (orphanDependents !== undefined) {
            queryParameters['orphanDependents'] = orphanDependents;
        }
        if (propagationPolicy !== undefined) {
            queryParameters['propagationPolicy'] = propagationPolicy;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * delete a Deployment
     * @param name name of the Deployment
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param gracePeriodSeconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @param orphanDependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @param propagationPolicy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
     */
    deleteNamespacedDeployment(name, namespace, body, pretty, gracePeriodSeconds, orphanDependents, propagationPolicy) {
        const localVarPath = this.basePath + '/apis/apps/v1beta1/namespaces/{namespace}/deployments/{name}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling deleteNamespacedDeployment.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling deleteNamespacedDeployment.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling deleteNamespacedDeployment.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (gracePeriodSeconds !== undefined) {
            queryParameters['gracePeriodSeconds'] = gracePeriodSeconds;
        }
        if (orphanDependents !== undefined) {
            queryParameters['orphanDependents'] = orphanDependents;
        }
        if (propagationPolicy !== undefined) {
            queryParameters['propagationPolicy'] = propagationPolicy;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * delete a StatefulSet
     * @param name name of the StatefulSet
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param gracePeriodSeconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @param orphanDependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @param propagationPolicy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
     */
    deleteNamespacedStatefulSet(name, namespace, body, pretty, gracePeriodSeconds, orphanDependents, propagationPolicy) {
        const localVarPath = this.basePath + '/apis/apps/v1beta1/namespaces/{namespace}/statefulsets/{name}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling deleteNamespacedStatefulSet.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling deleteNamespacedStatefulSet.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling deleteNamespacedStatefulSet.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (gracePeriodSeconds !== undefined) {
            queryParameters['gracePeriodSeconds'] = gracePeriodSeconds;
        }
        if (orphanDependents !== undefined) {
            queryParameters['orphanDependents'] = orphanDependents;
        }
        if (propagationPolicy !== undefined) {
            queryParameters['propagationPolicy'] = propagationPolicy;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * get available resources
     */
    getAPIResources() {
        const localVarPath = this.basePath + '/apis/apps/v1beta1/';
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        let useFormData = false;
        let requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * list or watch objects of kind ControllerRevision
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param includeUninitialized If true, partially initialized resources are included in the response.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param timeoutSeconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    listControllerRevisionForAllNamespaces(_continue, fieldSelector, includeUninitialized, labelSelector, limit, pretty, resourceVersion, timeoutSeconds, watch) {
        const localVarPath = this.basePath + '/apis/apps/v1beta1/controllerrevisions';
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        if (_continue !== undefined) {
            queryParameters['continue'] = _continue;
        }
        if (fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = fieldSelector;
        }
        if (includeUninitialized !== undefined) {
            queryParameters['includeUninitialized'] = includeUninitialized;
        }
        if (labelSelector !== undefined) {
            queryParameters['labelSelector'] = labelSelector;
        }
        if (limit !== undefined) {
            queryParameters['limit'] = limit;
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = resourceVersion;
        }
        if (timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = timeoutSeconds;
        }
        if (watch !== undefined) {
            queryParameters['watch'] = watch;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * list or watch objects of kind Deployment
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param includeUninitialized If true, partially initialized resources are included in the response.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param timeoutSeconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    listDeploymentForAllNamespaces(_continue, fieldSelector, includeUninitialized, labelSelector, limit, pretty, resourceVersion, timeoutSeconds, watch) {
        const localVarPath = this.basePath + '/apis/apps/v1beta1/deployments';
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        if (_continue !== undefined) {
            queryParameters['continue'] = _continue;
        }
        if (fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = fieldSelector;
        }
        if (includeUninitialized !== undefined) {
            queryParameters['includeUninitialized'] = includeUninitialized;
        }
        if (labelSelector !== undefined) {
            queryParameters['labelSelector'] = labelSelector;
        }
        if (limit !== undefined) {
            queryParameters['limit'] = limit;
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = resourceVersion;
        }
        if (timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = timeoutSeconds;
        }
        if (watch !== undefined) {
            queryParameters['watch'] = watch;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * list or watch objects of kind ControllerRevision
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param includeUninitialized If true, partially initialized resources are included in the response.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param timeoutSeconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    listNamespacedControllerRevision(namespace, pretty, _continue, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch) {
        const localVarPath = this.basePath + '/apis/apps/v1beta1/namespaces/{namespace}/controllerrevisions'
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling listNamespacedControllerRevision.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (_continue !== undefined) {
            queryParameters['continue'] = _continue;
        }
        if (fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = fieldSelector;
        }
        if (includeUninitialized !== undefined) {
            queryParameters['includeUninitialized'] = includeUninitialized;
        }
        if (labelSelector !== undefined) {
            queryParameters['labelSelector'] = labelSelector;
        }
        if (limit !== undefined) {
            queryParameters['limit'] = limit;
        }
        if (resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = resourceVersion;
        }
        if (timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = timeoutSeconds;
        }
        if (watch !== undefined) {
            queryParameters['watch'] = watch;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * list or watch objects of kind Deployment
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param includeUninitialized If true, partially initialized resources are included in the response.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param timeoutSeconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    listNamespacedDeployment(namespace, pretty, _continue, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch) {
        const localVarPath = this.basePath + '/apis/apps/v1beta1/namespaces/{namespace}/deployments'
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling listNamespacedDeployment.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (_continue !== undefined) {
            queryParameters['continue'] = _continue;
        }
        if (fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = fieldSelector;
        }
        if (includeUninitialized !== undefined) {
            queryParameters['includeUninitialized'] = includeUninitialized;
        }
        if (labelSelector !== undefined) {
            queryParameters['labelSelector'] = labelSelector;
        }
        if (limit !== undefined) {
            queryParameters['limit'] = limit;
        }
        if (resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = resourceVersion;
        }
        if (timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = timeoutSeconds;
        }
        if (watch !== undefined) {
            queryParameters['watch'] = watch;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * list or watch objects of kind StatefulSet
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param includeUninitialized If true, partially initialized resources are included in the response.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param timeoutSeconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    listNamespacedStatefulSet(namespace, pretty, _continue, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch) {
        const localVarPath = this.basePath + '/apis/apps/v1beta1/namespaces/{namespace}/statefulsets'
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling listNamespacedStatefulSet.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (_continue !== undefined) {
            queryParameters['continue'] = _continue;
        }
        if (fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = fieldSelector;
        }
        if (includeUninitialized !== undefined) {
            queryParameters['includeUninitialized'] = includeUninitialized;
        }
        if (labelSelector !== undefined) {
            queryParameters['labelSelector'] = labelSelector;
        }
        if (limit !== undefined) {
            queryParameters['limit'] = limit;
        }
        if (resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = resourceVersion;
        }
        if (timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = timeoutSeconds;
        }
        if (watch !== undefined) {
            queryParameters['watch'] = watch;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * list or watch objects of kind StatefulSet
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param includeUninitialized If true, partially initialized resources are included in the response.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param timeoutSeconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    listStatefulSetForAllNamespaces(_continue, fieldSelector, includeUninitialized, labelSelector, limit, pretty, resourceVersion, timeoutSeconds, watch) {
        const localVarPath = this.basePath + '/apis/apps/v1beta1/statefulsets';
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        if (_continue !== undefined) {
            queryParameters['continue'] = _continue;
        }
        if (fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = fieldSelector;
        }
        if (includeUninitialized !== undefined) {
            queryParameters['includeUninitialized'] = includeUninitialized;
        }
        if (labelSelector !== undefined) {
            queryParameters['labelSelector'] = labelSelector;
        }
        if (limit !== undefined) {
            queryParameters['limit'] = limit;
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = resourceVersion;
        }
        if (timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = timeoutSeconds;
        }
        if (watch !== undefined) {
            queryParameters['watch'] = watch;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * partially update the specified ControllerRevision
     * @param name name of the ControllerRevision
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    patchNamespacedControllerRevision(name, namespace, body, pretty) {
        const localVarPath = this.basePath + '/apis/apps/v1beta1/namespaces/{namespace}/controllerrevisions/{name}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling patchNamespacedControllerRevision.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling patchNamespacedControllerRevision.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling patchNamespacedControllerRevision.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'PATCH',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * partially update the specified Deployment
     * @param name name of the Deployment
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    patchNamespacedDeployment(name, namespace, body, pretty) {
        const localVarPath = this.basePath + '/apis/apps/v1beta1/namespaces/{namespace}/deployments/{name}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling patchNamespacedDeployment.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling patchNamespacedDeployment.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling patchNamespacedDeployment.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'PATCH',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * partially update scale of the specified Deployment
     * @param name name of the Scale
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    patchNamespacedDeploymentScale(name, namespace, body, pretty) {
        const localVarPath = this.basePath + '/apis/apps/v1beta1/namespaces/{namespace}/deployments/{name}/scale'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling patchNamespacedDeploymentScale.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling patchNamespacedDeploymentScale.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling patchNamespacedDeploymentScale.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'PATCH',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * partially update status of the specified Deployment
     * @param name name of the Deployment
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    patchNamespacedDeploymentStatus(name, namespace, body, pretty) {
        const localVarPath = this.basePath + '/apis/apps/v1beta1/namespaces/{namespace}/deployments/{name}/status'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling patchNamespacedDeploymentStatus.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling patchNamespacedDeploymentStatus.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling patchNamespacedDeploymentStatus.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'PATCH',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * partially update the specified StatefulSet
     * @param name name of the StatefulSet
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    patchNamespacedStatefulSet(name, namespace, body, pretty) {
        const localVarPath = this.basePath + '/apis/apps/v1beta1/namespaces/{namespace}/statefulsets/{name}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling patchNamespacedStatefulSet.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling patchNamespacedStatefulSet.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling patchNamespacedStatefulSet.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'PATCH',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * partially update scale of the specified StatefulSet
     * @param name name of the Scale
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    patchNamespacedStatefulSetScale(name, namespace, body, pretty) {
        const localVarPath = this.basePath + '/apis/apps/v1beta1/namespaces/{namespace}/statefulsets/{name}/scale'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling patchNamespacedStatefulSetScale.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling patchNamespacedStatefulSetScale.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling patchNamespacedStatefulSetScale.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'PATCH',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * partially update status of the specified StatefulSet
     * @param name name of the StatefulSet
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    patchNamespacedStatefulSetStatus(name, namespace, body, pretty) {
        const localVarPath = this.basePath + '/apis/apps/v1beta1/namespaces/{namespace}/statefulsets/{name}/status'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling patchNamespacedStatefulSetStatus.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling patchNamespacedStatefulSetStatus.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling patchNamespacedStatefulSetStatus.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'PATCH',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * read the specified ControllerRevision
     * @param name name of the ControllerRevision
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param exact Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;.
     * @param _export Should this value be exported.  Export strips fields that a user can not specify.
     */
    readNamespacedControllerRevision(name, namespace, pretty, exact, _export) {
        const localVarPath = this.basePath + '/apis/apps/v1beta1/namespaces/{namespace}/controllerrevisions/{name}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling readNamespacedControllerRevision.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling readNamespacedControllerRevision.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (exact !== undefined) {
            queryParameters['exact'] = exact;
        }
        if (_export !== undefined) {
            queryParameters['export'] = _export;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * read the specified Deployment
     * @param name name of the Deployment
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param exact Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;.
     * @param _export Should this value be exported.  Export strips fields that a user can not specify.
     */
    readNamespacedDeployment(name, namespace, pretty, exact, _export) {
        const localVarPath = this.basePath + '/apis/apps/v1beta1/namespaces/{namespace}/deployments/{name}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling readNamespacedDeployment.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling readNamespacedDeployment.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (exact !== undefined) {
            queryParameters['exact'] = exact;
        }
        if (_export !== undefined) {
            queryParameters['export'] = _export;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * read scale of the specified Deployment
     * @param name name of the Scale
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    readNamespacedDeploymentScale(name, namespace, pretty) {
        const localVarPath = this.basePath + '/apis/apps/v1beta1/namespaces/{namespace}/deployments/{name}/scale'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling readNamespacedDeploymentScale.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling readNamespacedDeploymentScale.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * read status of the specified Deployment
     * @param name name of the Deployment
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    readNamespacedDeploymentStatus(name, namespace, pretty) {
        const localVarPath = this.basePath + '/apis/apps/v1beta1/namespaces/{namespace}/deployments/{name}/status'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling readNamespacedDeploymentStatus.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling readNamespacedDeploymentStatus.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * read the specified StatefulSet
     * @param name name of the StatefulSet
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param exact Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;.
     * @param _export Should this value be exported.  Export strips fields that a user can not specify.
     */
    readNamespacedStatefulSet(name, namespace, pretty, exact, _export) {
        const localVarPath = this.basePath + '/apis/apps/v1beta1/namespaces/{namespace}/statefulsets/{name}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling readNamespacedStatefulSet.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling readNamespacedStatefulSet.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (exact !== undefined) {
            queryParameters['exact'] = exact;
        }
        if (_export !== undefined) {
            queryParameters['export'] = _export;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * read scale of the specified StatefulSet
     * @param name name of the Scale
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    readNamespacedStatefulSetScale(name, namespace, pretty) {
        const localVarPath = this.basePath + '/apis/apps/v1beta1/namespaces/{namespace}/statefulsets/{name}/scale'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling readNamespacedStatefulSetScale.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling readNamespacedStatefulSetScale.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * read status of the specified StatefulSet
     * @param name name of the StatefulSet
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    readNamespacedStatefulSetStatus(name, namespace, pretty) {
        const localVarPath = this.basePath + '/apis/apps/v1beta1/namespaces/{namespace}/statefulsets/{name}/status'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling readNamespacedStatefulSetStatus.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling readNamespacedStatefulSetStatus.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * replace the specified ControllerRevision
     * @param name name of the ControllerRevision
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    replaceNamespacedControllerRevision(name, namespace, body, pretty) {
        const localVarPath = this.basePath + '/apis/apps/v1beta1/namespaces/{namespace}/controllerrevisions/{name}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling replaceNamespacedControllerRevision.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling replaceNamespacedControllerRevision.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling replaceNamespacedControllerRevision.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * replace the specified Deployment
     * @param name name of the Deployment
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    replaceNamespacedDeployment(name, namespace, body, pretty) {
        const localVarPath = this.basePath + '/apis/apps/v1beta1/namespaces/{namespace}/deployments/{name}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling replaceNamespacedDeployment.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling replaceNamespacedDeployment.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling replaceNamespacedDeployment.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * replace scale of the specified Deployment
     * @param name name of the Scale
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    replaceNamespacedDeploymentScale(name, namespace, body, pretty) {
        const localVarPath = this.basePath + '/apis/apps/v1beta1/namespaces/{namespace}/deployments/{name}/scale'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling replaceNamespacedDeploymentScale.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling replaceNamespacedDeploymentScale.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling replaceNamespacedDeploymentScale.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * replace status of the specified Deployment
     * @param name name of the Deployment
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    replaceNamespacedDeploymentStatus(name, namespace, body, pretty) {
        const localVarPath = this.basePath + '/apis/apps/v1beta1/namespaces/{namespace}/deployments/{name}/status'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling replaceNamespacedDeploymentStatus.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling replaceNamespacedDeploymentStatus.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling replaceNamespacedDeploymentStatus.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * replace the specified StatefulSet
     * @param name name of the StatefulSet
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    replaceNamespacedStatefulSet(name, namespace, body, pretty) {
        const localVarPath = this.basePath + '/apis/apps/v1beta1/namespaces/{namespace}/statefulsets/{name}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling replaceNamespacedStatefulSet.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling replaceNamespacedStatefulSet.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling replaceNamespacedStatefulSet.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * replace scale of the specified StatefulSet
     * @param name name of the Scale
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    replaceNamespacedStatefulSetScale(name, namespace, body, pretty) {
        const localVarPath = this.basePath + '/apis/apps/v1beta1/namespaces/{namespace}/statefulsets/{name}/scale'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling replaceNamespacedStatefulSetScale.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling replaceNamespacedStatefulSetScale.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling replaceNamespacedStatefulSetScale.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * replace status of the specified StatefulSet
     * @param name name of the StatefulSet
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    replaceNamespacedStatefulSetStatus(name, namespace, body, pretty) {
        const localVarPath = this.basePath + '/apis/apps/v1beta1/namespaces/{namespace}/statefulsets/{name}/status'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling replaceNamespacedStatefulSetStatus.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling replaceNamespacedStatefulSetStatus.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling replaceNamespacedStatefulSetStatus.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
exports.Apps_v1beta1Api = Apps_v1beta1Api;
var Apps_v1beta2ApiApiKeys;
(function (Apps_v1beta2ApiApiKeys) {
    Apps_v1beta2ApiApiKeys[Apps_v1beta2ApiApiKeys["BearerToken"] = 0] = "BearerToken";
})(Apps_v1beta2ApiApiKeys = exports.Apps_v1beta2ApiApiKeys || (exports.Apps_v1beta2ApiApiKeys = {}));
class Apps_v1beta2Api {
    constructor(basePathOrUsername, password, basePath) {
        this._basePath = defaultBasePath;
        this.defaultHeaders = {};
        this._useQuerystring = false;
        this.authentications = {
            'default': new VoidAuth(),
            'BearerToken': new ApiKeyAuth('header', 'authorization'),
        };
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        }
        else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername;
            }
        }
    }
    set useQuerystring(value) {
        this._useQuerystring = value;
    }
    set basePath(basePath) {
        this._basePath = basePath;
    }
    get basePath() {
        return this._basePath;
    }
    setDefaultAuthentication(auth) {
        this.authentications.default = auth;
    }
    setApiKey(key, value) {
        this.authentications[Apps_v1beta2ApiApiKeys[key]].apiKey = value;
    }
    /**
     * create a ControllerRevision
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    createNamespacedControllerRevision(namespace, body, pretty) {
        const localVarPath = this.basePath + '/apis/apps/v1beta2/namespaces/{namespace}/controllerrevisions'
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling createNamespacedControllerRevision.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling createNamespacedControllerRevision.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * create a DaemonSet
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    createNamespacedDaemonSet(namespace, body, pretty) {
        const localVarPath = this.basePath + '/apis/apps/v1beta2/namespaces/{namespace}/daemonsets'
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling createNamespacedDaemonSet.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling createNamespacedDaemonSet.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * create a Deployment
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    createNamespacedDeployment(namespace, body, pretty) {
        const localVarPath = this.basePath + '/apis/apps/v1beta2/namespaces/{namespace}/deployments'
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling createNamespacedDeployment.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling createNamespacedDeployment.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * create a ReplicaSet
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    createNamespacedReplicaSet(namespace, body, pretty) {
        const localVarPath = this.basePath + '/apis/apps/v1beta2/namespaces/{namespace}/replicasets'
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling createNamespacedReplicaSet.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling createNamespacedReplicaSet.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * create a StatefulSet
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    createNamespacedStatefulSet(namespace, body, pretty) {
        const localVarPath = this.basePath + '/apis/apps/v1beta2/namespaces/{namespace}/statefulsets'
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling createNamespacedStatefulSet.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling createNamespacedStatefulSet.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * delete collection of ControllerRevision
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param includeUninitialized If true, partially initialized resources are included in the response.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param timeoutSeconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    deleteCollectionNamespacedControllerRevision(namespace, pretty, _continue, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch) {
        const localVarPath = this.basePath + '/apis/apps/v1beta2/namespaces/{namespace}/controllerrevisions'
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling deleteCollectionNamespacedControllerRevision.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (_continue !== undefined) {
            queryParameters['continue'] = _continue;
        }
        if (fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = fieldSelector;
        }
        if (includeUninitialized !== undefined) {
            queryParameters['includeUninitialized'] = includeUninitialized;
        }
        if (labelSelector !== undefined) {
            queryParameters['labelSelector'] = labelSelector;
        }
        if (limit !== undefined) {
            queryParameters['limit'] = limit;
        }
        if (resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = resourceVersion;
        }
        if (timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = timeoutSeconds;
        }
        if (watch !== undefined) {
            queryParameters['watch'] = watch;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * delete collection of DaemonSet
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param includeUninitialized If true, partially initialized resources are included in the response.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param timeoutSeconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    deleteCollectionNamespacedDaemonSet(namespace, pretty, _continue, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch) {
        const localVarPath = this.basePath + '/apis/apps/v1beta2/namespaces/{namespace}/daemonsets'
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling deleteCollectionNamespacedDaemonSet.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (_continue !== undefined) {
            queryParameters['continue'] = _continue;
        }
        if (fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = fieldSelector;
        }
        if (includeUninitialized !== undefined) {
            queryParameters['includeUninitialized'] = includeUninitialized;
        }
        if (labelSelector !== undefined) {
            queryParameters['labelSelector'] = labelSelector;
        }
        if (limit !== undefined) {
            queryParameters['limit'] = limit;
        }
        if (resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = resourceVersion;
        }
        if (timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = timeoutSeconds;
        }
        if (watch !== undefined) {
            queryParameters['watch'] = watch;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * delete collection of Deployment
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param includeUninitialized If true, partially initialized resources are included in the response.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param timeoutSeconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    deleteCollectionNamespacedDeployment(namespace, pretty, _continue, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch) {
        const localVarPath = this.basePath + '/apis/apps/v1beta2/namespaces/{namespace}/deployments'
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling deleteCollectionNamespacedDeployment.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (_continue !== undefined) {
            queryParameters['continue'] = _continue;
        }
        if (fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = fieldSelector;
        }
        if (includeUninitialized !== undefined) {
            queryParameters['includeUninitialized'] = includeUninitialized;
        }
        if (labelSelector !== undefined) {
            queryParameters['labelSelector'] = labelSelector;
        }
        if (limit !== undefined) {
            queryParameters['limit'] = limit;
        }
        if (resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = resourceVersion;
        }
        if (timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = timeoutSeconds;
        }
        if (watch !== undefined) {
            queryParameters['watch'] = watch;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * delete collection of ReplicaSet
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param includeUninitialized If true, partially initialized resources are included in the response.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param timeoutSeconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    deleteCollectionNamespacedReplicaSet(namespace, pretty, _continue, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch) {
        const localVarPath = this.basePath + '/apis/apps/v1beta2/namespaces/{namespace}/replicasets'
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling deleteCollectionNamespacedReplicaSet.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (_continue !== undefined) {
            queryParameters['continue'] = _continue;
        }
        if (fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = fieldSelector;
        }
        if (includeUninitialized !== undefined) {
            queryParameters['includeUninitialized'] = includeUninitialized;
        }
        if (labelSelector !== undefined) {
            queryParameters['labelSelector'] = labelSelector;
        }
        if (limit !== undefined) {
            queryParameters['limit'] = limit;
        }
        if (resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = resourceVersion;
        }
        if (timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = timeoutSeconds;
        }
        if (watch !== undefined) {
            queryParameters['watch'] = watch;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * delete collection of StatefulSet
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param includeUninitialized If true, partially initialized resources are included in the response.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param timeoutSeconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    deleteCollectionNamespacedStatefulSet(namespace, pretty, _continue, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch) {
        const localVarPath = this.basePath + '/apis/apps/v1beta2/namespaces/{namespace}/statefulsets'
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling deleteCollectionNamespacedStatefulSet.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (_continue !== undefined) {
            queryParameters['continue'] = _continue;
        }
        if (fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = fieldSelector;
        }
        if (includeUninitialized !== undefined) {
            queryParameters['includeUninitialized'] = includeUninitialized;
        }
        if (labelSelector !== undefined) {
            queryParameters['labelSelector'] = labelSelector;
        }
        if (limit !== undefined) {
            queryParameters['limit'] = limit;
        }
        if (resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = resourceVersion;
        }
        if (timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = timeoutSeconds;
        }
        if (watch !== undefined) {
            queryParameters['watch'] = watch;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * delete a ControllerRevision
     * @param name name of the ControllerRevision
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param gracePeriodSeconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @param orphanDependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @param propagationPolicy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
     */
    deleteNamespacedControllerRevision(name, namespace, body, pretty, gracePeriodSeconds, orphanDependents, propagationPolicy) {
        const localVarPath = this.basePath + '/apis/apps/v1beta2/namespaces/{namespace}/controllerrevisions/{name}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling deleteNamespacedControllerRevision.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling deleteNamespacedControllerRevision.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling deleteNamespacedControllerRevision.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (gracePeriodSeconds !== undefined) {
            queryParameters['gracePeriodSeconds'] = gracePeriodSeconds;
        }
        if (orphanDependents !== undefined) {
            queryParameters['orphanDependents'] = orphanDependents;
        }
        if (propagationPolicy !== undefined) {
            queryParameters['propagationPolicy'] = propagationPolicy;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * delete a DaemonSet
     * @param name name of the DaemonSet
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param gracePeriodSeconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @param orphanDependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @param propagationPolicy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
     */
    deleteNamespacedDaemonSet(name, namespace, body, pretty, gracePeriodSeconds, orphanDependents, propagationPolicy) {
        const localVarPath = this.basePath + '/apis/apps/v1beta2/namespaces/{namespace}/daemonsets/{name}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling deleteNamespacedDaemonSet.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling deleteNamespacedDaemonSet.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling deleteNamespacedDaemonSet.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (gracePeriodSeconds !== undefined) {
            queryParameters['gracePeriodSeconds'] = gracePeriodSeconds;
        }
        if (orphanDependents !== undefined) {
            queryParameters['orphanDependents'] = orphanDependents;
        }
        if (propagationPolicy !== undefined) {
            queryParameters['propagationPolicy'] = propagationPolicy;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * delete a Deployment
     * @param name name of the Deployment
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param gracePeriodSeconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @param orphanDependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @param propagationPolicy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
     */
    deleteNamespacedDeployment(name, namespace, body, pretty, gracePeriodSeconds, orphanDependents, propagationPolicy) {
        const localVarPath = this.basePath + '/apis/apps/v1beta2/namespaces/{namespace}/deployments/{name}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling deleteNamespacedDeployment.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling deleteNamespacedDeployment.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling deleteNamespacedDeployment.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (gracePeriodSeconds !== undefined) {
            queryParameters['gracePeriodSeconds'] = gracePeriodSeconds;
        }
        if (orphanDependents !== undefined) {
            queryParameters['orphanDependents'] = orphanDependents;
        }
        if (propagationPolicy !== undefined) {
            queryParameters['propagationPolicy'] = propagationPolicy;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * delete a ReplicaSet
     * @param name name of the ReplicaSet
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param gracePeriodSeconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @param orphanDependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @param propagationPolicy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
     */
    deleteNamespacedReplicaSet(name, namespace, body, pretty, gracePeriodSeconds, orphanDependents, propagationPolicy) {
        const localVarPath = this.basePath + '/apis/apps/v1beta2/namespaces/{namespace}/replicasets/{name}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling deleteNamespacedReplicaSet.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling deleteNamespacedReplicaSet.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling deleteNamespacedReplicaSet.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (gracePeriodSeconds !== undefined) {
            queryParameters['gracePeriodSeconds'] = gracePeriodSeconds;
        }
        if (orphanDependents !== undefined) {
            queryParameters['orphanDependents'] = orphanDependents;
        }
        if (propagationPolicy !== undefined) {
            queryParameters['propagationPolicy'] = propagationPolicy;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * delete a StatefulSet
     * @param name name of the StatefulSet
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param gracePeriodSeconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @param orphanDependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @param propagationPolicy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
     */
    deleteNamespacedStatefulSet(name, namespace, body, pretty, gracePeriodSeconds, orphanDependents, propagationPolicy) {
        const localVarPath = this.basePath + '/apis/apps/v1beta2/namespaces/{namespace}/statefulsets/{name}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling deleteNamespacedStatefulSet.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling deleteNamespacedStatefulSet.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling deleteNamespacedStatefulSet.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (gracePeriodSeconds !== undefined) {
            queryParameters['gracePeriodSeconds'] = gracePeriodSeconds;
        }
        if (orphanDependents !== undefined) {
            queryParameters['orphanDependents'] = orphanDependents;
        }
        if (propagationPolicy !== undefined) {
            queryParameters['propagationPolicy'] = propagationPolicy;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * get available resources
     */
    getAPIResources() {
        const localVarPath = this.basePath + '/apis/apps/v1beta2/';
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        let useFormData = false;
        let requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * list or watch objects of kind ControllerRevision
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param includeUninitialized If true, partially initialized resources are included in the response.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param timeoutSeconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    listControllerRevisionForAllNamespaces(_continue, fieldSelector, includeUninitialized, labelSelector, limit, pretty, resourceVersion, timeoutSeconds, watch) {
        const localVarPath = this.basePath + '/apis/apps/v1beta2/controllerrevisions';
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        if (_continue !== undefined) {
            queryParameters['continue'] = _continue;
        }
        if (fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = fieldSelector;
        }
        if (includeUninitialized !== undefined) {
            queryParameters['includeUninitialized'] = includeUninitialized;
        }
        if (labelSelector !== undefined) {
            queryParameters['labelSelector'] = labelSelector;
        }
        if (limit !== undefined) {
            queryParameters['limit'] = limit;
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = resourceVersion;
        }
        if (timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = timeoutSeconds;
        }
        if (watch !== undefined) {
            queryParameters['watch'] = watch;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * list or watch objects of kind DaemonSet
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param includeUninitialized If true, partially initialized resources are included in the response.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param timeoutSeconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    listDaemonSetForAllNamespaces(_continue, fieldSelector, includeUninitialized, labelSelector, limit, pretty, resourceVersion, timeoutSeconds, watch) {
        const localVarPath = this.basePath + '/apis/apps/v1beta2/daemonsets';
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        if (_continue !== undefined) {
            queryParameters['continue'] = _continue;
        }
        if (fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = fieldSelector;
        }
        if (includeUninitialized !== undefined) {
            queryParameters['includeUninitialized'] = includeUninitialized;
        }
        if (labelSelector !== undefined) {
            queryParameters['labelSelector'] = labelSelector;
        }
        if (limit !== undefined) {
            queryParameters['limit'] = limit;
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = resourceVersion;
        }
        if (timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = timeoutSeconds;
        }
        if (watch !== undefined) {
            queryParameters['watch'] = watch;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * list or watch objects of kind Deployment
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param includeUninitialized If true, partially initialized resources are included in the response.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param timeoutSeconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    listDeploymentForAllNamespaces(_continue, fieldSelector, includeUninitialized, labelSelector, limit, pretty, resourceVersion, timeoutSeconds, watch) {
        const localVarPath = this.basePath + '/apis/apps/v1beta2/deployments';
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        if (_continue !== undefined) {
            queryParameters['continue'] = _continue;
        }
        if (fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = fieldSelector;
        }
        if (includeUninitialized !== undefined) {
            queryParameters['includeUninitialized'] = includeUninitialized;
        }
        if (labelSelector !== undefined) {
            queryParameters['labelSelector'] = labelSelector;
        }
        if (limit !== undefined) {
            queryParameters['limit'] = limit;
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = resourceVersion;
        }
        if (timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = timeoutSeconds;
        }
        if (watch !== undefined) {
            queryParameters['watch'] = watch;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * list or watch objects of kind ControllerRevision
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param includeUninitialized If true, partially initialized resources are included in the response.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param timeoutSeconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    listNamespacedControllerRevision(namespace, pretty, _continue, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch) {
        const localVarPath = this.basePath + '/apis/apps/v1beta2/namespaces/{namespace}/controllerrevisions'
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling listNamespacedControllerRevision.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (_continue !== undefined) {
            queryParameters['continue'] = _continue;
        }
        if (fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = fieldSelector;
        }
        if (includeUninitialized !== undefined) {
            queryParameters['includeUninitialized'] = includeUninitialized;
        }
        if (labelSelector !== undefined) {
            queryParameters['labelSelector'] = labelSelector;
        }
        if (limit !== undefined) {
            queryParameters['limit'] = limit;
        }
        if (resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = resourceVersion;
        }
        if (timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = timeoutSeconds;
        }
        if (watch !== undefined) {
            queryParameters['watch'] = watch;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * list or watch objects of kind DaemonSet
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param includeUninitialized If true, partially initialized resources are included in the response.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param timeoutSeconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    listNamespacedDaemonSet(namespace, pretty, _continue, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch) {
        const localVarPath = this.basePath + '/apis/apps/v1beta2/namespaces/{namespace}/daemonsets'
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling listNamespacedDaemonSet.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (_continue !== undefined) {
            queryParameters['continue'] = _continue;
        }
        if (fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = fieldSelector;
        }
        if (includeUninitialized !== undefined) {
            queryParameters['includeUninitialized'] = includeUninitialized;
        }
        if (labelSelector !== undefined) {
            queryParameters['labelSelector'] = labelSelector;
        }
        if (limit !== undefined) {
            queryParameters['limit'] = limit;
        }
        if (resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = resourceVersion;
        }
        if (timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = timeoutSeconds;
        }
        if (watch !== undefined) {
            queryParameters['watch'] = watch;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * list or watch objects of kind Deployment
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param includeUninitialized If true, partially initialized resources are included in the response.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param timeoutSeconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    listNamespacedDeployment(namespace, pretty, _continue, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch) {
        const localVarPath = this.basePath + '/apis/apps/v1beta2/namespaces/{namespace}/deployments'
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling listNamespacedDeployment.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (_continue !== undefined) {
            queryParameters['continue'] = _continue;
        }
        if (fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = fieldSelector;
        }
        if (includeUninitialized !== undefined) {
            queryParameters['includeUninitialized'] = includeUninitialized;
        }
        if (labelSelector !== undefined) {
            queryParameters['labelSelector'] = labelSelector;
        }
        if (limit !== undefined) {
            queryParameters['limit'] = limit;
        }
        if (resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = resourceVersion;
        }
        if (timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = timeoutSeconds;
        }
        if (watch !== undefined) {
            queryParameters['watch'] = watch;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * list or watch objects of kind ReplicaSet
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param includeUninitialized If true, partially initialized resources are included in the response.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param timeoutSeconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    listNamespacedReplicaSet(namespace, pretty, _continue, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch) {
        const localVarPath = this.basePath + '/apis/apps/v1beta2/namespaces/{namespace}/replicasets'
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling listNamespacedReplicaSet.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (_continue !== undefined) {
            queryParameters['continue'] = _continue;
        }
        if (fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = fieldSelector;
        }
        if (includeUninitialized !== undefined) {
            queryParameters['includeUninitialized'] = includeUninitialized;
        }
        if (labelSelector !== undefined) {
            queryParameters['labelSelector'] = labelSelector;
        }
        if (limit !== undefined) {
            queryParameters['limit'] = limit;
        }
        if (resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = resourceVersion;
        }
        if (timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = timeoutSeconds;
        }
        if (watch !== undefined) {
            queryParameters['watch'] = watch;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * list or watch objects of kind StatefulSet
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param includeUninitialized If true, partially initialized resources are included in the response.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param timeoutSeconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    listNamespacedStatefulSet(namespace, pretty, _continue, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch) {
        const localVarPath = this.basePath + '/apis/apps/v1beta2/namespaces/{namespace}/statefulsets'
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling listNamespacedStatefulSet.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (_continue !== undefined) {
            queryParameters['continue'] = _continue;
        }
        if (fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = fieldSelector;
        }
        if (includeUninitialized !== undefined) {
            queryParameters['includeUninitialized'] = includeUninitialized;
        }
        if (labelSelector !== undefined) {
            queryParameters['labelSelector'] = labelSelector;
        }
        if (limit !== undefined) {
            queryParameters['limit'] = limit;
        }
        if (resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = resourceVersion;
        }
        if (timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = timeoutSeconds;
        }
        if (watch !== undefined) {
            queryParameters['watch'] = watch;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * list or watch objects of kind ReplicaSet
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param includeUninitialized If true, partially initialized resources are included in the response.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param timeoutSeconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    listReplicaSetForAllNamespaces(_continue, fieldSelector, includeUninitialized, labelSelector, limit, pretty, resourceVersion, timeoutSeconds, watch) {
        const localVarPath = this.basePath + '/apis/apps/v1beta2/replicasets';
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        if (_continue !== undefined) {
            queryParameters['continue'] = _continue;
        }
        if (fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = fieldSelector;
        }
        if (includeUninitialized !== undefined) {
            queryParameters['includeUninitialized'] = includeUninitialized;
        }
        if (labelSelector !== undefined) {
            queryParameters['labelSelector'] = labelSelector;
        }
        if (limit !== undefined) {
            queryParameters['limit'] = limit;
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = resourceVersion;
        }
        if (timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = timeoutSeconds;
        }
        if (watch !== undefined) {
            queryParameters['watch'] = watch;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * list or watch objects of kind StatefulSet
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param includeUninitialized If true, partially initialized resources are included in the response.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param timeoutSeconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    listStatefulSetForAllNamespaces(_continue, fieldSelector, includeUninitialized, labelSelector, limit, pretty, resourceVersion, timeoutSeconds, watch) {
        const localVarPath = this.basePath + '/apis/apps/v1beta2/statefulsets';
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        if (_continue !== undefined) {
            queryParameters['continue'] = _continue;
        }
        if (fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = fieldSelector;
        }
        if (includeUninitialized !== undefined) {
            queryParameters['includeUninitialized'] = includeUninitialized;
        }
        if (labelSelector !== undefined) {
            queryParameters['labelSelector'] = labelSelector;
        }
        if (limit !== undefined) {
            queryParameters['limit'] = limit;
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = resourceVersion;
        }
        if (timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = timeoutSeconds;
        }
        if (watch !== undefined) {
            queryParameters['watch'] = watch;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * partially update the specified ControllerRevision
     * @param name name of the ControllerRevision
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    patchNamespacedControllerRevision(name, namespace, body, pretty) {
        const localVarPath = this.basePath + '/apis/apps/v1beta2/namespaces/{namespace}/controllerrevisions/{name}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling patchNamespacedControllerRevision.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling patchNamespacedControllerRevision.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling patchNamespacedControllerRevision.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'PATCH',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * partially update the specified DaemonSet
     * @param name name of the DaemonSet
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    patchNamespacedDaemonSet(name, namespace, body, pretty) {
        const localVarPath = this.basePath + '/apis/apps/v1beta2/namespaces/{namespace}/daemonsets/{name}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling patchNamespacedDaemonSet.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling patchNamespacedDaemonSet.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling patchNamespacedDaemonSet.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'PATCH',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * partially update status of the specified DaemonSet
     * @param name name of the DaemonSet
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    patchNamespacedDaemonSetStatus(name, namespace, body, pretty) {
        const localVarPath = this.basePath + '/apis/apps/v1beta2/namespaces/{namespace}/daemonsets/{name}/status'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling patchNamespacedDaemonSetStatus.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling patchNamespacedDaemonSetStatus.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling patchNamespacedDaemonSetStatus.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'PATCH',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * partially update the specified Deployment
     * @param name name of the Deployment
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    patchNamespacedDeployment(name, namespace, body, pretty) {
        const localVarPath = this.basePath + '/apis/apps/v1beta2/namespaces/{namespace}/deployments/{name}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling patchNamespacedDeployment.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling patchNamespacedDeployment.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling patchNamespacedDeployment.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'PATCH',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * partially update scale of the specified Deployment
     * @param name name of the Scale
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    patchNamespacedDeploymentScale(name, namespace, body, pretty) {
        const localVarPath = this.basePath + '/apis/apps/v1beta2/namespaces/{namespace}/deployments/{name}/scale'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling patchNamespacedDeploymentScale.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling patchNamespacedDeploymentScale.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling patchNamespacedDeploymentScale.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'PATCH',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * partially update status of the specified Deployment
     * @param name name of the Deployment
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    patchNamespacedDeploymentStatus(name, namespace, body, pretty) {
        const localVarPath = this.basePath + '/apis/apps/v1beta2/namespaces/{namespace}/deployments/{name}/status'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling patchNamespacedDeploymentStatus.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling patchNamespacedDeploymentStatus.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling patchNamespacedDeploymentStatus.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'PATCH',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * partially update the specified ReplicaSet
     * @param name name of the ReplicaSet
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    patchNamespacedReplicaSet(name, namespace, body, pretty) {
        const localVarPath = this.basePath + '/apis/apps/v1beta2/namespaces/{namespace}/replicasets/{name}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling patchNamespacedReplicaSet.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling patchNamespacedReplicaSet.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling patchNamespacedReplicaSet.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'PATCH',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * partially update scale of the specified ReplicaSet
     * @param name name of the Scale
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    patchNamespacedReplicaSetScale(name, namespace, body, pretty) {
        const localVarPath = this.basePath + '/apis/apps/v1beta2/namespaces/{namespace}/replicasets/{name}/scale'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling patchNamespacedReplicaSetScale.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling patchNamespacedReplicaSetScale.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling patchNamespacedReplicaSetScale.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'PATCH',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * partially update status of the specified ReplicaSet
     * @param name name of the ReplicaSet
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    patchNamespacedReplicaSetStatus(name, namespace, body, pretty) {
        const localVarPath = this.basePath + '/apis/apps/v1beta2/namespaces/{namespace}/replicasets/{name}/status'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling patchNamespacedReplicaSetStatus.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling patchNamespacedReplicaSetStatus.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling patchNamespacedReplicaSetStatus.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'PATCH',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * partially update the specified StatefulSet
     * @param name name of the StatefulSet
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    patchNamespacedStatefulSet(name, namespace, body, pretty) {
        const localVarPath = this.basePath + '/apis/apps/v1beta2/namespaces/{namespace}/statefulsets/{name}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling patchNamespacedStatefulSet.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling patchNamespacedStatefulSet.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling patchNamespacedStatefulSet.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'PATCH',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * partially update scale of the specified StatefulSet
     * @param name name of the Scale
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    patchNamespacedStatefulSetScale(name, namespace, body, pretty) {
        const localVarPath = this.basePath + '/apis/apps/v1beta2/namespaces/{namespace}/statefulsets/{name}/scale'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling patchNamespacedStatefulSetScale.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling patchNamespacedStatefulSetScale.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling patchNamespacedStatefulSetScale.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'PATCH',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * partially update status of the specified StatefulSet
     * @param name name of the StatefulSet
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    patchNamespacedStatefulSetStatus(name, namespace, body, pretty) {
        const localVarPath = this.basePath + '/apis/apps/v1beta2/namespaces/{namespace}/statefulsets/{name}/status'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling patchNamespacedStatefulSetStatus.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling patchNamespacedStatefulSetStatus.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling patchNamespacedStatefulSetStatus.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'PATCH',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * read the specified ControllerRevision
     * @param name name of the ControllerRevision
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param exact Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;.
     * @param _export Should this value be exported.  Export strips fields that a user can not specify.
     */
    readNamespacedControllerRevision(name, namespace, pretty, exact, _export) {
        const localVarPath = this.basePath + '/apis/apps/v1beta2/namespaces/{namespace}/controllerrevisions/{name}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling readNamespacedControllerRevision.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling readNamespacedControllerRevision.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (exact !== undefined) {
            queryParameters['exact'] = exact;
        }
        if (_export !== undefined) {
            queryParameters['export'] = _export;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * read the specified DaemonSet
     * @param name name of the DaemonSet
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param exact Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;.
     * @param _export Should this value be exported.  Export strips fields that a user can not specify.
     */
    readNamespacedDaemonSet(name, namespace, pretty, exact, _export) {
        const localVarPath = this.basePath + '/apis/apps/v1beta2/namespaces/{namespace}/daemonsets/{name}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling readNamespacedDaemonSet.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling readNamespacedDaemonSet.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (exact !== undefined) {
            queryParameters['exact'] = exact;
        }
        if (_export !== undefined) {
            queryParameters['export'] = _export;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * read status of the specified DaemonSet
     * @param name name of the DaemonSet
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    readNamespacedDaemonSetStatus(name, namespace, pretty) {
        const localVarPath = this.basePath + '/apis/apps/v1beta2/namespaces/{namespace}/daemonsets/{name}/status'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling readNamespacedDaemonSetStatus.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling readNamespacedDaemonSetStatus.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * read the specified Deployment
     * @param name name of the Deployment
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param exact Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;.
     * @param _export Should this value be exported.  Export strips fields that a user can not specify.
     */
    readNamespacedDeployment(name, namespace, pretty, exact, _export) {
        const localVarPath = this.basePath + '/apis/apps/v1beta2/namespaces/{namespace}/deployments/{name}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling readNamespacedDeployment.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling readNamespacedDeployment.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (exact !== undefined) {
            queryParameters['exact'] = exact;
        }
        if (_export !== undefined) {
            queryParameters['export'] = _export;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * read scale of the specified Deployment
     * @param name name of the Scale
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    readNamespacedDeploymentScale(name, namespace, pretty) {
        const localVarPath = this.basePath + '/apis/apps/v1beta2/namespaces/{namespace}/deployments/{name}/scale'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling readNamespacedDeploymentScale.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling readNamespacedDeploymentScale.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * read status of the specified Deployment
     * @param name name of the Deployment
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    readNamespacedDeploymentStatus(name, namespace, pretty) {
        const localVarPath = this.basePath + '/apis/apps/v1beta2/namespaces/{namespace}/deployments/{name}/status'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling readNamespacedDeploymentStatus.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling readNamespacedDeploymentStatus.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * read the specified ReplicaSet
     * @param name name of the ReplicaSet
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param exact Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;.
     * @param _export Should this value be exported.  Export strips fields that a user can not specify.
     */
    readNamespacedReplicaSet(name, namespace, pretty, exact, _export) {
        const localVarPath = this.basePath + '/apis/apps/v1beta2/namespaces/{namespace}/replicasets/{name}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling readNamespacedReplicaSet.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling readNamespacedReplicaSet.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (exact !== undefined) {
            queryParameters['exact'] = exact;
        }
        if (_export !== undefined) {
            queryParameters['export'] = _export;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * read scale of the specified ReplicaSet
     * @param name name of the Scale
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    readNamespacedReplicaSetScale(name, namespace, pretty) {
        const localVarPath = this.basePath + '/apis/apps/v1beta2/namespaces/{namespace}/replicasets/{name}/scale'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling readNamespacedReplicaSetScale.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling readNamespacedReplicaSetScale.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * read status of the specified ReplicaSet
     * @param name name of the ReplicaSet
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    readNamespacedReplicaSetStatus(name, namespace, pretty) {
        const localVarPath = this.basePath + '/apis/apps/v1beta2/namespaces/{namespace}/replicasets/{name}/status'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling readNamespacedReplicaSetStatus.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling readNamespacedReplicaSetStatus.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * read the specified StatefulSet
     * @param name name of the StatefulSet
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param exact Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;.
     * @param _export Should this value be exported.  Export strips fields that a user can not specify.
     */
    readNamespacedStatefulSet(name, namespace, pretty, exact, _export) {
        const localVarPath = this.basePath + '/apis/apps/v1beta2/namespaces/{namespace}/statefulsets/{name}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling readNamespacedStatefulSet.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling readNamespacedStatefulSet.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (exact !== undefined) {
            queryParameters['exact'] = exact;
        }
        if (_export !== undefined) {
            queryParameters['export'] = _export;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * read scale of the specified StatefulSet
     * @param name name of the Scale
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    readNamespacedStatefulSetScale(name, namespace, pretty) {
        const localVarPath = this.basePath + '/apis/apps/v1beta2/namespaces/{namespace}/statefulsets/{name}/scale'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling readNamespacedStatefulSetScale.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling readNamespacedStatefulSetScale.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * read status of the specified StatefulSet
     * @param name name of the StatefulSet
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    readNamespacedStatefulSetStatus(name, namespace, pretty) {
        const localVarPath = this.basePath + '/apis/apps/v1beta2/namespaces/{namespace}/statefulsets/{name}/status'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling readNamespacedStatefulSetStatus.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling readNamespacedStatefulSetStatus.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * replace the specified ControllerRevision
     * @param name name of the ControllerRevision
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    replaceNamespacedControllerRevision(name, namespace, body, pretty) {
        const localVarPath = this.basePath + '/apis/apps/v1beta2/namespaces/{namespace}/controllerrevisions/{name}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling replaceNamespacedControllerRevision.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling replaceNamespacedControllerRevision.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling replaceNamespacedControllerRevision.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * replace the specified DaemonSet
     * @param name name of the DaemonSet
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    replaceNamespacedDaemonSet(name, namespace, body, pretty) {
        const localVarPath = this.basePath + '/apis/apps/v1beta2/namespaces/{namespace}/daemonsets/{name}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling replaceNamespacedDaemonSet.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling replaceNamespacedDaemonSet.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling replaceNamespacedDaemonSet.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * replace status of the specified DaemonSet
     * @param name name of the DaemonSet
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    replaceNamespacedDaemonSetStatus(name, namespace, body, pretty) {
        const localVarPath = this.basePath + '/apis/apps/v1beta2/namespaces/{namespace}/daemonsets/{name}/status'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling replaceNamespacedDaemonSetStatus.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling replaceNamespacedDaemonSetStatus.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling replaceNamespacedDaemonSetStatus.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * replace the specified Deployment
     * @param name name of the Deployment
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    replaceNamespacedDeployment(name, namespace, body, pretty) {
        const localVarPath = this.basePath + '/apis/apps/v1beta2/namespaces/{namespace}/deployments/{name}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling replaceNamespacedDeployment.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling replaceNamespacedDeployment.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling replaceNamespacedDeployment.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * replace scale of the specified Deployment
     * @param name name of the Scale
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    replaceNamespacedDeploymentScale(name, namespace, body, pretty) {
        const localVarPath = this.basePath + '/apis/apps/v1beta2/namespaces/{namespace}/deployments/{name}/scale'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling replaceNamespacedDeploymentScale.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling replaceNamespacedDeploymentScale.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling replaceNamespacedDeploymentScale.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * replace status of the specified Deployment
     * @param name name of the Deployment
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    replaceNamespacedDeploymentStatus(name, namespace, body, pretty) {
        const localVarPath = this.basePath + '/apis/apps/v1beta2/namespaces/{namespace}/deployments/{name}/status'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling replaceNamespacedDeploymentStatus.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling replaceNamespacedDeploymentStatus.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling replaceNamespacedDeploymentStatus.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * replace the specified ReplicaSet
     * @param name name of the ReplicaSet
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    replaceNamespacedReplicaSet(name, namespace, body, pretty) {
        const localVarPath = this.basePath + '/apis/apps/v1beta2/namespaces/{namespace}/replicasets/{name}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling replaceNamespacedReplicaSet.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling replaceNamespacedReplicaSet.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling replaceNamespacedReplicaSet.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * replace scale of the specified ReplicaSet
     * @param name name of the Scale
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    replaceNamespacedReplicaSetScale(name, namespace, body, pretty) {
        const localVarPath = this.basePath + '/apis/apps/v1beta2/namespaces/{namespace}/replicasets/{name}/scale'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling replaceNamespacedReplicaSetScale.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling replaceNamespacedReplicaSetScale.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling replaceNamespacedReplicaSetScale.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * replace status of the specified ReplicaSet
     * @param name name of the ReplicaSet
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    replaceNamespacedReplicaSetStatus(name, namespace, body, pretty) {
        const localVarPath = this.basePath + '/apis/apps/v1beta2/namespaces/{namespace}/replicasets/{name}/status'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling replaceNamespacedReplicaSetStatus.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling replaceNamespacedReplicaSetStatus.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling replaceNamespacedReplicaSetStatus.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * replace the specified StatefulSet
     * @param name name of the StatefulSet
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    replaceNamespacedStatefulSet(name, namespace, body, pretty) {
        const localVarPath = this.basePath + '/apis/apps/v1beta2/namespaces/{namespace}/statefulsets/{name}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling replaceNamespacedStatefulSet.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling replaceNamespacedStatefulSet.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling replaceNamespacedStatefulSet.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * replace scale of the specified StatefulSet
     * @param name name of the Scale
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    replaceNamespacedStatefulSetScale(name, namespace, body, pretty) {
        const localVarPath = this.basePath + '/apis/apps/v1beta2/namespaces/{namespace}/statefulsets/{name}/scale'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling replaceNamespacedStatefulSetScale.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling replaceNamespacedStatefulSetScale.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling replaceNamespacedStatefulSetScale.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * replace status of the specified StatefulSet
     * @param name name of the StatefulSet
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    replaceNamespacedStatefulSetStatus(name, namespace, body, pretty) {
        const localVarPath = this.basePath + '/apis/apps/v1beta2/namespaces/{namespace}/statefulsets/{name}/status'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling replaceNamespacedStatefulSetStatus.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling replaceNamespacedStatefulSetStatus.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling replaceNamespacedStatefulSetStatus.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
exports.Apps_v1beta2Api = Apps_v1beta2Api;
var AuthenticationApiApiKeys;
(function (AuthenticationApiApiKeys) {
    AuthenticationApiApiKeys[AuthenticationApiApiKeys["BearerToken"] = 0] = "BearerToken";
})(AuthenticationApiApiKeys = exports.AuthenticationApiApiKeys || (exports.AuthenticationApiApiKeys = {}));
class AuthenticationApi {
    constructor(basePathOrUsername, password, basePath) {
        this._basePath = defaultBasePath;
        this.defaultHeaders = {};
        this._useQuerystring = false;
        this.authentications = {
            'default': new VoidAuth(),
            'BearerToken': new ApiKeyAuth('header', 'authorization'),
        };
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        }
        else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername;
            }
        }
    }
    set useQuerystring(value) {
        this._useQuerystring = value;
    }
    set basePath(basePath) {
        this._basePath = basePath;
    }
    get basePath() {
        return this._basePath;
    }
    setDefaultAuthentication(auth) {
        this.authentications.default = auth;
    }
    setApiKey(key, value) {
        this.authentications[AuthenticationApiApiKeys[key]].apiKey = value;
    }
    /**
     * get information of a group
     */
    getAPIGroup() {
        const localVarPath = this.basePath + '/apis/authentication.k8s.io/';
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        let useFormData = false;
        let requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
exports.AuthenticationApi = AuthenticationApi;
var Authentication_v1ApiApiKeys;
(function (Authentication_v1ApiApiKeys) {
    Authentication_v1ApiApiKeys[Authentication_v1ApiApiKeys["BearerToken"] = 0] = "BearerToken";
})(Authentication_v1ApiApiKeys = exports.Authentication_v1ApiApiKeys || (exports.Authentication_v1ApiApiKeys = {}));
class Authentication_v1Api {
    constructor(basePathOrUsername, password, basePath) {
        this._basePath = defaultBasePath;
        this.defaultHeaders = {};
        this._useQuerystring = false;
        this.authentications = {
            'default': new VoidAuth(),
            'BearerToken': new ApiKeyAuth('header', 'authorization'),
        };
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        }
        else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername;
            }
        }
    }
    set useQuerystring(value) {
        this._useQuerystring = value;
    }
    set basePath(basePath) {
        this._basePath = basePath;
    }
    get basePath() {
        return this._basePath;
    }
    setDefaultAuthentication(auth) {
        this.authentications.default = auth;
    }
    setApiKey(key, value) {
        this.authentications[Authentication_v1ApiApiKeys[key]].apiKey = value;
    }
    /**
     * create a TokenReview
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    createTokenReview(body, pretty) {
        const localVarPath = this.basePath + '/apis/authentication.k8s.io/v1/tokenreviews';
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling createTokenReview.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * get available resources
     */
    getAPIResources() {
        const localVarPath = this.basePath + '/apis/authentication.k8s.io/v1/';
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        let useFormData = false;
        let requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
exports.Authentication_v1Api = Authentication_v1Api;
var Authentication_v1beta1ApiApiKeys;
(function (Authentication_v1beta1ApiApiKeys) {
    Authentication_v1beta1ApiApiKeys[Authentication_v1beta1ApiApiKeys["BearerToken"] = 0] = "BearerToken";
})(Authentication_v1beta1ApiApiKeys = exports.Authentication_v1beta1ApiApiKeys || (exports.Authentication_v1beta1ApiApiKeys = {}));
class Authentication_v1beta1Api {
    constructor(basePathOrUsername, password, basePath) {
        this._basePath = defaultBasePath;
        this.defaultHeaders = {};
        this._useQuerystring = false;
        this.authentications = {
            'default': new VoidAuth(),
            'BearerToken': new ApiKeyAuth('header', 'authorization'),
        };
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        }
        else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername;
            }
        }
    }
    set useQuerystring(value) {
        this._useQuerystring = value;
    }
    set basePath(basePath) {
        this._basePath = basePath;
    }
    get basePath() {
        return this._basePath;
    }
    setDefaultAuthentication(auth) {
        this.authentications.default = auth;
    }
    setApiKey(key, value) {
        this.authentications[Authentication_v1beta1ApiApiKeys[key]].apiKey = value;
    }
    /**
     * create a TokenReview
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    createTokenReview(body, pretty) {
        const localVarPath = this.basePath + '/apis/authentication.k8s.io/v1beta1/tokenreviews';
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling createTokenReview.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * get available resources
     */
    getAPIResources() {
        const localVarPath = this.basePath + '/apis/authentication.k8s.io/v1beta1/';
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        let useFormData = false;
        let requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
exports.Authentication_v1beta1Api = Authentication_v1beta1Api;
var AuthorizationApiApiKeys;
(function (AuthorizationApiApiKeys) {
    AuthorizationApiApiKeys[AuthorizationApiApiKeys["BearerToken"] = 0] = "BearerToken";
})(AuthorizationApiApiKeys = exports.AuthorizationApiApiKeys || (exports.AuthorizationApiApiKeys = {}));
class AuthorizationApi {
    constructor(basePathOrUsername, password, basePath) {
        this._basePath = defaultBasePath;
        this.defaultHeaders = {};
        this._useQuerystring = false;
        this.authentications = {
            'default': new VoidAuth(),
            'BearerToken': new ApiKeyAuth('header', 'authorization'),
        };
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        }
        else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername;
            }
        }
    }
    set useQuerystring(value) {
        this._useQuerystring = value;
    }
    set basePath(basePath) {
        this._basePath = basePath;
    }
    get basePath() {
        return this._basePath;
    }
    setDefaultAuthentication(auth) {
        this.authentications.default = auth;
    }
    setApiKey(key, value) {
        this.authentications[AuthorizationApiApiKeys[key]].apiKey = value;
    }
    /**
     * get information of a group
     */
    getAPIGroup() {
        const localVarPath = this.basePath + '/apis/authorization.k8s.io/';
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        let useFormData = false;
        let requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
exports.AuthorizationApi = AuthorizationApi;
var Authorization_v1ApiApiKeys;
(function (Authorization_v1ApiApiKeys) {
    Authorization_v1ApiApiKeys[Authorization_v1ApiApiKeys["BearerToken"] = 0] = "BearerToken";
})(Authorization_v1ApiApiKeys = exports.Authorization_v1ApiApiKeys || (exports.Authorization_v1ApiApiKeys = {}));
class Authorization_v1Api {
    constructor(basePathOrUsername, password, basePath) {
        this._basePath = defaultBasePath;
        this.defaultHeaders = {};
        this._useQuerystring = false;
        this.authentications = {
            'default': new VoidAuth(),
            'BearerToken': new ApiKeyAuth('header', 'authorization'),
        };
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        }
        else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername;
            }
        }
    }
    set useQuerystring(value) {
        this._useQuerystring = value;
    }
    set basePath(basePath) {
        this._basePath = basePath;
    }
    get basePath() {
        return this._basePath;
    }
    setDefaultAuthentication(auth) {
        this.authentications.default = auth;
    }
    setApiKey(key, value) {
        this.authentications[Authorization_v1ApiApiKeys[key]].apiKey = value;
    }
    /**
     * create a LocalSubjectAccessReview
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    createNamespacedLocalSubjectAccessReview(namespace, body, pretty) {
        const localVarPath = this.basePath + '/apis/authorization.k8s.io/v1/namespaces/{namespace}/localsubjectaccessreviews'
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling createNamespacedLocalSubjectAccessReview.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling createNamespacedLocalSubjectAccessReview.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * create a SelfSubjectAccessReview
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    createSelfSubjectAccessReview(body, pretty) {
        const localVarPath = this.basePath + '/apis/authorization.k8s.io/v1/selfsubjectaccessreviews';
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling createSelfSubjectAccessReview.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * create a SelfSubjectRulesReview
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    createSelfSubjectRulesReview(body, pretty) {
        const localVarPath = this.basePath + '/apis/authorization.k8s.io/v1/selfsubjectrulesreviews';
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling createSelfSubjectRulesReview.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * create a SubjectAccessReview
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    createSubjectAccessReview(body, pretty) {
        const localVarPath = this.basePath + '/apis/authorization.k8s.io/v1/subjectaccessreviews';
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling createSubjectAccessReview.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * get available resources
     */
    getAPIResources() {
        const localVarPath = this.basePath + '/apis/authorization.k8s.io/v1/';
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        let useFormData = false;
        let requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
exports.Authorization_v1Api = Authorization_v1Api;
var Authorization_v1beta1ApiApiKeys;
(function (Authorization_v1beta1ApiApiKeys) {
    Authorization_v1beta1ApiApiKeys[Authorization_v1beta1ApiApiKeys["BearerToken"] = 0] = "BearerToken";
})(Authorization_v1beta1ApiApiKeys = exports.Authorization_v1beta1ApiApiKeys || (exports.Authorization_v1beta1ApiApiKeys = {}));
class Authorization_v1beta1Api {
    constructor(basePathOrUsername, password, basePath) {
        this._basePath = defaultBasePath;
        this.defaultHeaders = {};
        this._useQuerystring = false;
        this.authentications = {
            'default': new VoidAuth(),
            'BearerToken': new ApiKeyAuth('header', 'authorization'),
        };
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        }
        else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername;
            }
        }
    }
    set useQuerystring(value) {
        this._useQuerystring = value;
    }
    set basePath(basePath) {
        this._basePath = basePath;
    }
    get basePath() {
        return this._basePath;
    }
    setDefaultAuthentication(auth) {
        this.authentications.default = auth;
    }
    setApiKey(key, value) {
        this.authentications[Authorization_v1beta1ApiApiKeys[key]].apiKey = value;
    }
    /**
     * create a LocalSubjectAccessReview
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    createNamespacedLocalSubjectAccessReview(namespace, body, pretty) {
        const localVarPath = this.basePath + '/apis/authorization.k8s.io/v1beta1/namespaces/{namespace}/localsubjectaccessreviews'
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling createNamespacedLocalSubjectAccessReview.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling createNamespacedLocalSubjectAccessReview.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * create a SelfSubjectAccessReview
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    createSelfSubjectAccessReview(body, pretty) {
        const localVarPath = this.basePath + '/apis/authorization.k8s.io/v1beta1/selfsubjectaccessreviews';
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling createSelfSubjectAccessReview.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * create a SelfSubjectRulesReview
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    createSelfSubjectRulesReview(body, pretty) {
        const localVarPath = this.basePath + '/apis/authorization.k8s.io/v1beta1/selfsubjectrulesreviews';
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling createSelfSubjectRulesReview.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * create a SubjectAccessReview
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    createSubjectAccessReview(body, pretty) {
        const localVarPath = this.basePath + '/apis/authorization.k8s.io/v1beta1/subjectaccessreviews';
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling createSubjectAccessReview.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * get available resources
     */
    getAPIResources() {
        const localVarPath = this.basePath + '/apis/authorization.k8s.io/v1beta1/';
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        let useFormData = false;
        let requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
exports.Authorization_v1beta1Api = Authorization_v1beta1Api;
var AutoscalingApiApiKeys;
(function (AutoscalingApiApiKeys) {
    AutoscalingApiApiKeys[AutoscalingApiApiKeys["BearerToken"] = 0] = "BearerToken";
})(AutoscalingApiApiKeys = exports.AutoscalingApiApiKeys || (exports.AutoscalingApiApiKeys = {}));
class AutoscalingApi {
    constructor(basePathOrUsername, password, basePath) {
        this._basePath = defaultBasePath;
        this.defaultHeaders = {};
        this._useQuerystring = false;
        this.authentications = {
            'default': new VoidAuth(),
            'BearerToken': new ApiKeyAuth('header', 'authorization'),
        };
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        }
        else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername;
            }
        }
    }
    set useQuerystring(value) {
        this._useQuerystring = value;
    }
    set basePath(basePath) {
        this._basePath = basePath;
    }
    get basePath() {
        return this._basePath;
    }
    setDefaultAuthentication(auth) {
        this.authentications.default = auth;
    }
    setApiKey(key, value) {
        this.authentications[AutoscalingApiApiKeys[key]].apiKey = value;
    }
    /**
     * get information of a group
     */
    getAPIGroup() {
        const localVarPath = this.basePath + '/apis/autoscaling/';
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        let useFormData = false;
        let requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
exports.AutoscalingApi = AutoscalingApi;
var Autoscaling_v1ApiApiKeys;
(function (Autoscaling_v1ApiApiKeys) {
    Autoscaling_v1ApiApiKeys[Autoscaling_v1ApiApiKeys["BearerToken"] = 0] = "BearerToken";
})(Autoscaling_v1ApiApiKeys = exports.Autoscaling_v1ApiApiKeys || (exports.Autoscaling_v1ApiApiKeys = {}));
class Autoscaling_v1Api {
    constructor(basePathOrUsername, password, basePath) {
        this._basePath = defaultBasePath;
        this.defaultHeaders = {};
        this._useQuerystring = false;
        this.authentications = {
            'default': new VoidAuth(),
            'BearerToken': new ApiKeyAuth('header', 'authorization'),
        };
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        }
        else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername;
            }
        }
    }
    set useQuerystring(value) {
        this._useQuerystring = value;
    }
    set basePath(basePath) {
        this._basePath = basePath;
    }
    get basePath() {
        return this._basePath;
    }
    setDefaultAuthentication(auth) {
        this.authentications.default = auth;
    }
    setApiKey(key, value) {
        this.authentications[Autoscaling_v1ApiApiKeys[key]].apiKey = value;
    }
    /**
     * create a HorizontalPodAutoscaler
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    createNamespacedHorizontalPodAutoscaler(namespace, body, pretty) {
        const localVarPath = this.basePath + '/apis/autoscaling/v1/namespaces/{namespace}/horizontalpodautoscalers'
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling createNamespacedHorizontalPodAutoscaler.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling createNamespacedHorizontalPodAutoscaler.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * delete collection of HorizontalPodAutoscaler
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param includeUninitialized If true, partially initialized resources are included in the response.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param timeoutSeconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    deleteCollectionNamespacedHorizontalPodAutoscaler(namespace, pretty, _continue, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch) {
        const localVarPath = this.basePath + '/apis/autoscaling/v1/namespaces/{namespace}/horizontalpodautoscalers'
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling deleteCollectionNamespacedHorizontalPodAutoscaler.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (_continue !== undefined) {
            queryParameters['continue'] = _continue;
        }
        if (fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = fieldSelector;
        }
        if (includeUninitialized !== undefined) {
            queryParameters['includeUninitialized'] = includeUninitialized;
        }
        if (labelSelector !== undefined) {
            queryParameters['labelSelector'] = labelSelector;
        }
        if (limit !== undefined) {
            queryParameters['limit'] = limit;
        }
        if (resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = resourceVersion;
        }
        if (timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = timeoutSeconds;
        }
        if (watch !== undefined) {
            queryParameters['watch'] = watch;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * delete a HorizontalPodAutoscaler
     * @param name name of the HorizontalPodAutoscaler
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param gracePeriodSeconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @param orphanDependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @param propagationPolicy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
     */
    deleteNamespacedHorizontalPodAutoscaler(name, namespace, body, pretty, gracePeriodSeconds, orphanDependents, propagationPolicy) {
        const localVarPath = this.basePath + '/apis/autoscaling/v1/namespaces/{namespace}/horizontalpodautoscalers/{name}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling deleteNamespacedHorizontalPodAutoscaler.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling deleteNamespacedHorizontalPodAutoscaler.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling deleteNamespacedHorizontalPodAutoscaler.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (gracePeriodSeconds !== undefined) {
            queryParameters['gracePeriodSeconds'] = gracePeriodSeconds;
        }
        if (orphanDependents !== undefined) {
            queryParameters['orphanDependents'] = orphanDependents;
        }
        if (propagationPolicy !== undefined) {
            queryParameters['propagationPolicy'] = propagationPolicy;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * get available resources
     */
    getAPIResources() {
        const localVarPath = this.basePath + '/apis/autoscaling/v1/';
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        let useFormData = false;
        let requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * list or watch objects of kind HorizontalPodAutoscaler
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param includeUninitialized If true, partially initialized resources are included in the response.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param timeoutSeconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    listHorizontalPodAutoscalerForAllNamespaces(_continue, fieldSelector, includeUninitialized, labelSelector, limit, pretty, resourceVersion, timeoutSeconds, watch) {
        const localVarPath = this.basePath + '/apis/autoscaling/v1/horizontalpodautoscalers';
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        if (_continue !== undefined) {
            queryParameters['continue'] = _continue;
        }
        if (fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = fieldSelector;
        }
        if (includeUninitialized !== undefined) {
            queryParameters['includeUninitialized'] = includeUninitialized;
        }
        if (labelSelector !== undefined) {
            queryParameters['labelSelector'] = labelSelector;
        }
        if (limit !== undefined) {
            queryParameters['limit'] = limit;
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = resourceVersion;
        }
        if (timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = timeoutSeconds;
        }
        if (watch !== undefined) {
            queryParameters['watch'] = watch;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * list or watch objects of kind HorizontalPodAutoscaler
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param includeUninitialized If true, partially initialized resources are included in the response.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param timeoutSeconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    listNamespacedHorizontalPodAutoscaler(namespace, pretty, _continue, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch) {
        const localVarPath = this.basePath + '/apis/autoscaling/v1/namespaces/{namespace}/horizontalpodautoscalers'
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling listNamespacedHorizontalPodAutoscaler.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (_continue !== undefined) {
            queryParameters['continue'] = _continue;
        }
        if (fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = fieldSelector;
        }
        if (includeUninitialized !== undefined) {
            queryParameters['includeUninitialized'] = includeUninitialized;
        }
        if (labelSelector !== undefined) {
            queryParameters['labelSelector'] = labelSelector;
        }
        if (limit !== undefined) {
            queryParameters['limit'] = limit;
        }
        if (resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = resourceVersion;
        }
        if (timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = timeoutSeconds;
        }
        if (watch !== undefined) {
            queryParameters['watch'] = watch;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * partially update the specified HorizontalPodAutoscaler
     * @param name name of the HorizontalPodAutoscaler
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    patchNamespacedHorizontalPodAutoscaler(name, namespace, body, pretty) {
        const localVarPath = this.basePath + '/apis/autoscaling/v1/namespaces/{namespace}/horizontalpodautoscalers/{name}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling patchNamespacedHorizontalPodAutoscaler.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling patchNamespacedHorizontalPodAutoscaler.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling patchNamespacedHorizontalPodAutoscaler.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'PATCH',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * partially update status of the specified HorizontalPodAutoscaler
     * @param name name of the HorizontalPodAutoscaler
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    patchNamespacedHorizontalPodAutoscalerStatus(name, namespace, body, pretty) {
        const localVarPath = this.basePath + '/apis/autoscaling/v1/namespaces/{namespace}/horizontalpodautoscalers/{name}/status'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling patchNamespacedHorizontalPodAutoscalerStatus.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling patchNamespacedHorizontalPodAutoscalerStatus.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling patchNamespacedHorizontalPodAutoscalerStatus.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'PATCH',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * read the specified HorizontalPodAutoscaler
     * @param name name of the HorizontalPodAutoscaler
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param exact Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;.
     * @param _export Should this value be exported.  Export strips fields that a user can not specify.
     */
    readNamespacedHorizontalPodAutoscaler(name, namespace, pretty, exact, _export) {
        const localVarPath = this.basePath + '/apis/autoscaling/v1/namespaces/{namespace}/horizontalpodautoscalers/{name}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling readNamespacedHorizontalPodAutoscaler.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling readNamespacedHorizontalPodAutoscaler.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (exact !== undefined) {
            queryParameters['exact'] = exact;
        }
        if (_export !== undefined) {
            queryParameters['export'] = _export;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * read status of the specified HorizontalPodAutoscaler
     * @param name name of the HorizontalPodAutoscaler
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    readNamespacedHorizontalPodAutoscalerStatus(name, namespace, pretty) {
        const localVarPath = this.basePath + '/apis/autoscaling/v1/namespaces/{namespace}/horizontalpodautoscalers/{name}/status'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling readNamespacedHorizontalPodAutoscalerStatus.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling readNamespacedHorizontalPodAutoscalerStatus.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * replace the specified HorizontalPodAutoscaler
     * @param name name of the HorizontalPodAutoscaler
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    replaceNamespacedHorizontalPodAutoscaler(name, namespace, body, pretty) {
        const localVarPath = this.basePath + '/apis/autoscaling/v1/namespaces/{namespace}/horizontalpodautoscalers/{name}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling replaceNamespacedHorizontalPodAutoscaler.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling replaceNamespacedHorizontalPodAutoscaler.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling replaceNamespacedHorizontalPodAutoscaler.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * replace status of the specified HorizontalPodAutoscaler
     * @param name name of the HorizontalPodAutoscaler
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    replaceNamespacedHorizontalPodAutoscalerStatus(name, namespace, body, pretty) {
        const localVarPath = this.basePath + '/apis/autoscaling/v1/namespaces/{namespace}/horizontalpodautoscalers/{name}/status'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling replaceNamespacedHorizontalPodAutoscalerStatus.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling replaceNamespacedHorizontalPodAutoscalerStatus.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling replaceNamespacedHorizontalPodAutoscalerStatus.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
exports.Autoscaling_v1Api = Autoscaling_v1Api;
var Autoscaling_v2beta1ApiApiKeys;
(function (Autoscaling_v2beta1ApiApiKeys) {
    Autoscaling_v2beta1ApiApiKeys[Autoscaling_v2beta1ApiApiKeys["BearerToken"] = 0] = "BearerToken";
})(Autoscaling_v2beta1ApiApiKeys = exports.Autoscaling_v2beta1ApiApiKeys || (exports.Autoscaling_v2beta1ApiApiKeys = {}));
class Autoscaling_v2beta1Api {
    constructor(basePathOrUsername, password, basePath) {
        this._basePath = defaultBasePath;
        this.defaultHeaders = {};
        this._useQuerystring = false;
        this.authentications = {
            'default': new VoidAuth(),
            'BearerToken': new ApiKeyAuth('header', 'authorization'),
        };
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        }
        else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername;
            }
        }
    }
    set useQuerystring(value) {
        this._useQuerystring = value;
    }
    set basePath(basePath) {
        this._basePath = basePath;
    }
    get basePath() {
        return this._basePath;
    }
    setDefaultAuthentication(auth) {
        this.authentications.default = auth;
    }
    setApiKey(key, value) {
        this.authentications[Autoscaling_v2beta1ApiApiKeys[key]].apiKey = value;
    }
    /**
     * create a HorizontalPodAutoscaler
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    createNamespacedHorizontalPodAutoscaler(namespace, body, pretty) {
        const localVarPath = this.basePath + '/apis/autoscaling/v2beta1/namespaces/{namespace}/horizontalpodautoscalers'
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling createNamespacedHorizontalPodAutoscaler.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling createNamespacedHorizontalPodAutoscaler.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * delete collection of HorizontalPodAutoscaler
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param includeUninitialized If true, partially initialized resources are included in the response.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param timeoutSeconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    deleteCollectionNamespacedHorizontalPodAutoscaler(namespace, pretty, _continue, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch) {
        const localVarPath = this.basePath + '/apis/autoscaling/v2beta1/namespaces/{namespace}/horizontalpodautoscalers'
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling deleteCollectionNamespacedHorizontalPodAutoscaler.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (_continue !== undefined) {
            queryParameters['continue'] = _continue;
        }
        if (fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = fieldSelector;
        }
        if (includeUninitialized !== undefined) {
            queryParameters['includeUninitialized'] = includeUninitialized;
        }
        if (labelSelector !== undefined) {
            queryParameters['labelSelector'] = labelSelector;
        }
        if (limit !== undefined) {
            queryParameters['limit'] = limit;
        }
        if (resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = resourceVersion;
        }
        if (timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = timeoutSeconds;
        }
        if (watch !== undefined) {
            queryParameters['watch'] = watch;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * delete a HorizontalPodAutoscaler
     * @param name name of the HorizontalPodAutoscaler
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param gracePeriodSeconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @param orphanDependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @param propagationPolicy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
     */
    deleteNamespacedHorizontalPodAutoscaler(name, namespace, body, pretty, gracePeriodSeconds, orphanDependents, propagationPolicy) {
        const localVarPath = this.basePath + '/apis/autoscaling/v2beta1/namespaces/{namespace}/horizontalpodautoscalers/{name}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling deleteNamespacedHorizontalPodAutoscaler.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling deleteNamespacedHorizontalPodAutoscaler.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling deleteNamespacedHorizontalPodAutoscaler.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (gracePeriodSeconds !== undefined) {
            queryParameters['gracePeriodSeconds'] = gracePeriodSeconds;
        }
        if (orphanDependents !== undefined) {
            queryParameters['orphanDependents'] = orphanDependents;
        }
        if (propagationPolicy !== undefined) {
            queryParameters['propagationPolicy'] = propagationPolicy;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * get available resources
     */
    getAPIResources() {
        const localVarPath = this.basePath + '/apis/autoscaling/v2beta1/';
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        let useFormData = false;
        let requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * list or watch objects of kind HorizontalPodAutoscaler
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param includeUninitialized If true, partially initialized resources are included in the response.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param timeoutSeconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    listHorizontalPodAutoscalerForAllNamespaces(_continue, fieldSelector, includeUninitialized, labelSelector, limit, pretty, resourceVersion, timeoutSeconds, watch) {
        const localVarPath = this.basePath + '/apis/autoscaling/v2beta1/horizontalpodautoscalers';
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        if (_continue !== undefined) {
            queryParameters['continue'] = _continue;
        }
        if (fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = fieldSelector;
        }
        if (includeUninitialized !== undefined) {
            queryParameters['includeUninitialized'] = includeUninitialized;
        }
        if (labelSelector !== undefined) {
            queryParameters['labelSelector'] = labelSelector;
        }
        if (limit !== undefined) {
            queryParameters['limit'] = limit;
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = resourceVersion;
        }
        if (timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = timeoutSeconds;
        }
        if (watch !== undefined) {
            queryParameters['watch'] = watch;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * list or watch objects of kind HorizontalPodAutoscaler
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param includeUninitialized If true, partially initialized resources are included in the response.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param timeoutSeconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    listNamespacedHorizontalPodAutoscaler(namespace, pretty, _continue, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch) {
        const localVarPath = this.basePath + '/apis/autoscaling/v2beta1/namespaces/{namespace}/horizontalpodautoscalers'
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling listNamespacedHorizontalPodAutoscaler.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (_continue !== undefined) {
            queryParameters['continue'] = _continue;
        }
        if (fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = fieldSelector;
        }
        if (includeUninitialized !== undefined) {
            queryParameters['includeUninitialized'] = includeUninitialized;
        }
        if (labelSelector !== undefined) {
            queryParameters['labelSelector'] = labelSelector;
        }
        if (limit !== undefined) {
            queryParameters['limit'] = limit;
        }
        if (resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = resourceVersion;
        }
        if (timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = timeoutSeconds;
        }
        if (watch !== undefined) {
            queryParameters['watch'] = watch;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * partially update the specified HorizontalPodAutoscaler
     * @param name name of the HorizontalPodAutoscaler
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    patchNamespacedHorizontalPodAutoscaler(name, namespace, body, pretty) {
        const localVarPath = this.basePath + '/apis/autoscaling/v2beta1/namespaces/{namespace}/horizontalpodautoscalers/{name}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling patchNamespacedHorizontalPodAutoscaler.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling patchNamespacedHorizontalPodAutoscaler.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling patchNamespacedHorizontalPodAutoscaler.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'PATCH',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * partially update status of the specified HorizontalPodAutoscaler
     * @param name name of the HorizontalPodAutoscaler
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    patchNamespacedHorizontalPodAutoscalerStatus(name, namespace, body, pretty) {
        const localVarPath = this.basePath + '/apis/autoscaling/v2beta1/namespaces/{namespace}/horizontalpodautoscalers/{name}/status'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling patchNamespacedHorizontalPodAutoscalerStatus.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling patchNamespacedHorizontalPodAutoscalerStatus.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling patchNamespacedHorizontalPodAutoscalerStatus.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'PATCH',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * read the specified HorizontalPodAutoscaler
     * @param name name of the HorizontalPodAutoscaler
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param exact Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;.
     * @param _export Should this value be exported.  Export strips fields that a user can not specify.
     */
    readNamespacedHorizontalPodAutoscaler(name, namespace, pretty, exact, _export) {
        const localVarPath = this.basePath + '/apis/autoscaling/v2beta1/namespaces/{namespace}/horizontalpodautoscalers/{name}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling readNamespacedHorizontalPodAutoscaler.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling readNamespacedHorizontalPodAutoscaler.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (exact !== undefined) {
            queryParameters['exact'] = exact;
        }
        if (_export !== undefined) {
            queryParameters['export'] = _export;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * read status of the specified HorizontalPodAutoscaler
     * @param name name of the HorizontalPodAutoscaler
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    readNamespacedHorizontalPodAutoscalerStatus(name, namespace, pretty) {
        const localVarPath = this.basePath + '/apis/autoscaling/v2beta1/namespaces/{namespace}/horizontalpodautoscalers/{name}/status'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling readNamespacedHorizontalPodAutoscalerStatus.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling readNamespacedHorizontalPodAutoscalerStatus.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * replace the specified HorizontalPodAutoscaler
     * @param name name of the HorizontalPodAutoscaler
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    replaceNamespacedHorizontalPodAutoscaler(name, namespace, body, pretty) {
        const localVarPath = this.basePath + '/apis/autoscaling/v2beta1/namespaces/{namespace}/horizontalpodautoscalers/{name}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling replaceNamespacedHorizontalPodAutoscaler.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling replaceNamespacedHorizontalPodAutoscaler.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling replaceNamespacedHorizontalPodAutoscaler.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * replace status of the specified HorizontalPodAutoscaler
     * @param name name of the HorizontalPodAutoscaler
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    replaceNamespacedHorizontalPodAutoscalerStatus(name, namespace, body, pretty) {
        const localVarPath = this.basePath + '/apis/autoscaling/v2beta1/namespaces/{namespace}/horizontalpodautoscalers/{name}/status'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling replaceNamespacedHorizontalPodAutoscalerStatus.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling replaceNamespacedHorizontalPodAutoscalerStatus.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling replaceNamespacedHorizontalPodAutoscalerStatus.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
exports.Autoscaling_v2beta1Api = Autoscaling_v2beta1Api;
var BatchApiApiKeys;
(function (BatchApiApiKeys) {
    BatchApiApiKeys[BatchApiApiKeys["BearerToken"] = 0] = "BearerToken";
})(BatchApiApiKeys = exports.BatchApiApiKeys || (exports.BatchApiApiKeys = {}));
class BatchApi {
    constructor(basePathOrUsername, password, basePath) {
        this._basePath = defaultBasePath;
        this.defaultHeaders = {};
        this._useQuerystring = false;
        this.authentications = {
            'default': new VoidAuth(),
            'BearerToken': new ApiKeyAuth('header', 'authorization'),
        };
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        }
        else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername;
            }
        }
    }
    set useQuerystring(value) {
        this._useQuerystring = value;
    }
    set basePath(basePath) {
        this._basePath = basePath;
    }
    get basePath() {
        return this._basePath;
    }
    setDefaultAuthentication(auth) {
        this.authentications.default = auth;
    }
    setApiKey(key, value) {
        this.authentications[BatchApiApiKeys[key]].apiKey = value;
    }
    /**
     * get information of a group
     */
    getAPIGroup() {
        const localVarPath = this.basePath + '/apis/batch/';
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        let useFormData = false;
        let requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
exports.BatchApi = BatchApi;
var Batch_v1ApiApiKeys;
(function (Batch_v1ApiApiKeys) {
    Batch_v1ApiApiKeys[Batch_v1ApiApiKeys["BearerToken"] = 0] = "BearerToken";
})(Batch_v1ApiApiKeys = exports.Batch_v1ApiApiKeys || (exports.Batch_v1ApiApiKeys = {}));
class Batch_v1Api {
    constructor(basePathOrUsername, password, basePath) {
        this._basePath = defaultBasePath;
        this.defaultHeaders = {};
        this._useQuerystring = false;
        this.authentications = {
            'default': new VoidAuth(),
            'BearerToken': new ApiKeyAuth('header', 'authorization'),
        };
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        }
        else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername;
            }
        }
    }
    set useQuerystring(value) {
        this._useQuerystring = value;
    }
    set basePath(basePath) {
        this._basePath = basePath;
    }
    get basePath() {
        return this._basePath;
    }
    setDefaultAuthentication(auth) {
        this.authentications.default = auth;
    }
    setApiKey(key, value) {
        this.authentications[Batch_v1ApiApiKeys[key]].apiKey = value;
    }
    /**
     * create a Job
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    createNamespacedJob(namespace, body, pretty) {
        const localVarPath = this.basePath + '/apis/batch/v1/namespaces/{namespace}/jobs'
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling createNamespacedJob.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling createNamespacedJob.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * delete collection of Job
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param includeUninitialized If true, partially initialized resources are included in the response.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param timeoutSeconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    deleteCollectionNamespacedJob(namespace, pretty, _continue, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch) {
        const localVarPath = this.basePath + '/apis/batch/v1/namespaces/{namespace}/jobs'
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling deleteCollectionNamespacedJob.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (_continue !== undefined) {
            queryParameters['continue'] = _continue;
        }
        if (fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = fieldSelector;
        }
        if (includeUninitialized !== undefined) {
            queryParameters['includeUninitialized'] = includeUninitialized;
        }
        if (labelSelector !== undefined) {
            queryParameters['labelSelector'] = labelSelector;
        }
        if (limit !== undefined) {
            queryParameters['limit'] = limit;
        }
        if (resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = resourceVersion;
        }
        if (timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = timeoutSeconds;
        }
        if (watch !== undefined) {
            queryParameters['watch'] = watch;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * delete a Job
     * @param name name of the Job
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param gracePeriodSeconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @param orphanDependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @param propagationPolicy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
     */
    deleteNamespacedJob(name, namespace, body, pretty, gracePeriodSeconds, orphanDependents, propagationPolicy) {
        const localVarPath = this.basePath + '/apis/batch/v1/namespaces/{namespace}/jobs/{name}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling deleteNamespacedJob.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling deleteNamespacedJob.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling deleteNamespacedJob.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (gracePeriodSeconds !== undefined) {
            queryParameters['gracePeriodSeconds'] = gracePeriodSeconds;
        }
        if (orphanDependents !== undefined) {
            queryParameters['orphanDependents'] = orphanDependents;
        }
        if (propagationPolicy !== undefined) {
            queryParameters['propagationPolicy'] = propagationPolicy;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * get available resources
     */
    getAPIResources() {
        const localVarPath = this.basePath + '/apis/batch/v1/';
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        let useFormData = false;
        let requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * list or watch objects of kind Job
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param includeUninitialized If true, partially initialized resources are included in the response.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param timeoutSeconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    listJobForAllNamespaces(_continue, fieldSelector, includeUninitialized, labelSelector, limit, pretty, resourceVersion, timeoutSeconds, watch) {
        const localVarPath = this.basePath + '/apis/batch/v1/jobs';
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        if (_continue !== undefined) {
            queryParameters['continue'] = _continue;
        }
        if (fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = fieldSelector;
        }
        if (includeUninitialized !== undefined) {
            queryParameters['includeUninitialized'] = includeUninitialized;
        }
        if (labelSelector !== undefined) {
            queryParameters['labelSelector'] = labelSelector;
        }
        if (limit !== undefined) {
            queryParameters['limit'] = limit;
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = resourceVersion;
        }
        if (timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = timeoutSeconds;
        }
        if (watch !== undefined) {
            queryParameters['watch'] = watch;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * list or watch objects of kind Job
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param includeUninitialized If true, partially initialized resources are included in the response.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param timeoutSeconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    listNamespacedJob(namespace, pretty, _continue, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch) {
        const localVarPath = this.basePath + '/apis/batch/v1/namespaces/{namespace}/jobs'
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling listNamespacedJob.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (_continue !== undefined) {
            queryParameters['continue'] = _continue;
        }
        if (fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = fieldSelector;
        }
        if (includeUninitialized !== undefined) {
            queryParameters['includeUninitialized'] = includeUninitialized;
        }
        if (labelSelector !== undefined) {
            queryParameters['labelSelector'] = labelSelector;
        }
        if (limit !== undefined) {
            queryParameters['limit'] = limit;
        }
        if (resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = resourceVersion;
        }
        if (timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = timeoutSeconds;
        }
        if (watch !== undefined) {
            queryParameters['watch'] = watch;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * partially update the specified Job
     * @param name name of the Job
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    patchNamespacedJob(name, namespace, body, pretty) {
        const localVarPath = this.basePath + '/apis/batch/v1/namespaces/{namespace}/jobs/{name}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling patchNamespacedJob.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling patchNamespacedJob.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling patchNamespacedJob.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'PATCH',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * partially update status of the specified Job
     * @param name name of the Job
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    patchNamespacedJobStatus(name, namespace, body, pretty) {
        const localVarPath = this.basePath + '/apis/batch/v1/namespaces/{namespace}/jobs/{name}/status'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling patchNamespacedJobStatus.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling patchNamespacedJobStatus.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling patchNamespacedJobStatus.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'PATCH',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * read the specified Job
     * @param name name of the Job
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param exact Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;.
     * @param _export Should this value be exported.  Export strips fields that a user can not specify.
     */
    readNamespacedJob(name, namespace, pretty, exact, _export) {
        const localVarPath = this.basePath + '/apis/batch/v1/namespaces/{namespace}/jobs/{name}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling readNamespacedJob.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling readNamespacedJob.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (exact !== undefined) {
            queryParameters['exact'] = exact;
        }
        if (_export !== undefined) {
            queryParameters['export'] = _export;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * read status of the specified Job
     * @param name name of the Job
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    readNamespacedJobStatus(name, namespace, pretty) {
        const localVarPath = this.basePath + '/apis/batch/v1/namespaces/{namespace}/jobs/{name}/status'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling readNamespacedJobStatus.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling readNamespacedJobStatus.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * replace the specified Job
     * @param name name of the Job
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    replaceNamespacedJob(name, namespace, body, pretty) {
        const localVarPath = this.basePath + '/apis/batch/v1/namespaces/{namespace}/jobs/{name}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling replaceNamespacedJob.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling replaceNamespacedJob.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling replaceNamespacedJob.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * replace status of the specified Job
     * @param name name of the Job
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    replaceNamespacedJobStatus(name, namespace, body, pretty) {
        const localVarPath = this.basePath + '/apis/batch/v1/namespaces/{namespace}/jobs/{name}/status'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling replaceNamespacedJobStatus.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling replaceNamespacedJobStatus.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling replaceNamespacedJobStatus.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
exports.Batch_v1Api = Batch_v1Api;
var Batch_v1beta1ApiApiKeys;
(function (Batch_v1beta1ApiApiKeys) {
    Batch_v1beta1ApiApiKeys[Batch_v1beta1ApiApiKeys["BearerToken"] = 0] = "BearerToken";
})(Batch_v1beta1ApiApiKeys = exports.Batch_v1beta1ApiApiKeys || (exports.Batch_v1beta1ApiApiKeys = {}));
class Batch_v1beta1Api {
    constructor(basePathOrUsername, password, basePath) {
        this._basePath = defaultBasePath;
        this.defaultHeaders = {};
        this._useQuerystring = false;
        this.authentications = {
            'default': new VoidAuth(),
            'BearerToken': new ApiKeyAuth('header', 'authorization'),
        };
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        }
        else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername;
            }
        }
    }
    set useQuerystring(value) {
        this._useQuerystring = value;
    }
    set basePath(basePath) {
        this._basePath = basePath;
    }
    get basePath() {
        return this._basePath;
    }
    setDefaultAuthentication(auth) {
        this.authentications.default = auth;
    }
    setApiKey(key, value) {
        this.authentications[Batch_v1beta1ApiApiKeys[key]].apiKey = value;
    }
    /**
     * create a CronJob
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    createNamespacedCronJob(namespace, body, pretty) {
        const localVarPath = this.basePath + '/apis/batch/v1beta1/namespaces/{namespace}/cronjobs'
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling createNamespacedCronJob.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling createNamespacedCronJob.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * delete collection of CronJob
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param includeUninitialized If true, partially initialized resources are included in the response.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param timeoutSeconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    deleteCollectionNamespacedCronJob(namespace, pretty, _continue, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch) {
        const localVarPath = this.basePath + '/apis/batch/v1beta1/namespaces/{namespace}/cronjobs'
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling deleteCollectionNamespacedCronJob.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (_continue !== undefined) {
            queryParameters['continue'] = _continue;
        }
        if (fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = fieldSelector;
        }
        if (includeUninitialized !== undefined) {
            queryParameters['includeUninitialized'] = includeUninitialized;
        }
        if (labelSelector !== undefined) {
            queryParameters['labelSelector'] = labelSelector;
        }
        if (limit !== undefined) {
            queryParameters['limit'] = limit;
        }
        if (resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = resourceVersion;
        }
        if (timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = timeoutSeconds;
        }
        if (watch !== undefined) {
            queryParameters['watch'] = watch;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * delete a CronJob
     * @param name name of the CronJob
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param gracePeriodSeconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @param orphanDependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @param propagationPolicy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
     */
    deleteNamespacedCronJob(name, namespace, body, pretty, gracePeriodSeconds, orphanDependents, propagationPolicy) {
        const localVarPath = this.basePath + '/apis/batch/v1beta1/namespaces/{namespace}/cronjobs/{name}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling deleteNamespacedCronJob.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling deleteNamespacedCronJob.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling deleteNamespacedCronJob.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (gracePeriodSeconds !== undefined) {
            queryParameters['gracePeriodSeconds'] = gracePeriodSeconds;
        }
        if (orphanDependents !== undefined) {
            queryParameters['orphanDependents'] = orphanDependents;
        }
        if (propagationPolicy !== undefined) {
            queryParameters['propagationPolicy'] = propagationPolicy;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * get available resources
     */
    getAPIResources() {
        const localVarPath = this.basePath + '/apis/batch/v1beta1/';
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        let useFormData = false;
        let requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * list or watch objects of kind CronJob
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param includeUninitialized If true, partially initialized resources are included in the response.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param timeoutSeconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    listCronJobForAllNamespaces(_continue, fieldSelector, includeUninitialized, labelSelector, limit, pretty, resourceVersion, timeoutSeconds, watch) {
        const localVarPath = this.basePath + '/apis/batch/v1beta1/cronjobs';
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        if (_continue !== undefined) {
            queryParameters['continue'] = _continue;
        }
        if (fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = fieldSelector;
        }
        if (includeUninitialized !== undefined) {
            queryParameters['includeUninitialized'] = includeUninitialized;
        }
        if (labelSelector !== undefined) {
            queryParameters['labelSelector'] = labelSelector;
        }
        if (limit !== undefined) {
            queryParameters['limit'] = limit;
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = resourceVersion;
        }
        if (timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = timeoutSeconds;
        }
        if (watch !== undefined) {
            queryParameters['watch'] = watch;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * list or watch objects of kind CronJob
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param includeUninitialized If true, partially initialized resources are included in the response.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param timeoutSeconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    listNamespacedCronJob(namespace, pretty, _continue, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch) {
        const localVarPath = this.basePath + '/apis/batch/v1beta1/namespaces/{namespace}/cronjobs'
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling listNamespacedCronJob.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (_continue !== undefined) {
            queryParameters['continue'] = _continue;
        }
        if (fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = fieldSelector;
        }
        if (includeUninitialized !== undefined) {
            queryParameters['includeUninitialized'] = includeUninitialized;
        }
        if (labelSelector !== undefined) {
            queryParameters['labelSelector'] = labelSelector;
        }
        if (limit !== undefined) {
            queryParameters['limit'] = limit;
        }
        if (resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = resourceVersion;
        }
        if (timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = timeoutSeconds;
        }
        if (watch !== undefined) {
            queryParameters['watch'] = watch;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * partially update the specified CronJob
     * @param name name of the CronJob
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    patchNamespacedCronJob(name, namespace, body, pretty) {
        const localVarPath = this.basePath + '/apis/batch/v1beta1/namespaces/{namespace}/cronjobs/{name}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling patchNamespacedCronJob.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling patchNamespacedCronJob.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling patchNamespacedCronJob.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'PATCH',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * partially update status of the specified CronJob
     * @param name name of the CronJob
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    patchNamespacedCronJobStatus(name, namespace, body, pretty) {
        const localVarPath = this.basePath + '/apis/batch/v1beta1/namespaces/{namespace}/cronjobs/{name}/status'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling patchNamespacedCronJobStatus.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling patchNamespacedCronJobStatus.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling patchNamespacedCronJobStatus.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'PATCH',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * read the specified CronJob
     * @param name name of the CronJob
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param exact Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;.
     * @param _export Should this value be exported.  Export strips fields that a user can not specify.
     */
    readNamespacedCronJob(name, namespace, pretty, exact, _export) {
        const localVarPath = this.basePath + '/apis/batch/v1beta1/namespaces/{namespace}/cronjobs/{name}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling readNamespacedCronJob.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling readNamespacedCronJob.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (exact !== undefined) {
            queryParameters['exact'] = exact;
        }
        if (_export !== undefined) {
            queryParameters['export'] = _export;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * read status of the specified CronJob
     * @param name name of the CronJob
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    readNamespacedCronJobStatus(name, namespace, pretty) {
        const localVarPath = this.basePath + '/apis/batch/v1beta1/namespaces/{namespace}/cronjobs/{name}/status'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling readNamespacedCronJobStatus.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling readNamespacedCronJobStatus.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * replace the specified CronJob
     * @param name name of the CronJob
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    replaceNamespacedCronJob(name, namespace, body, pretty) {
        const localVarPath = this.basePath + '/apis/batch/v1beta1/namespaces/{namespace}/cronjobs/{name}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling replaceNamespacedCronJob.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling replaceNamespacedCronJob.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling replaceNamespacedCronJob.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * replace status of the specified CronJob
     * @param name name of the CronJob
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    replaceNamespacedCronJobStatus(name, namespace, body, pretty) {
        const localVarPath = this.basePath + '/apis/batch/v1beta1/namespaces/{namespace}/cronjobs/{name}/status'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling replaceNamespacedCronJobStatus.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling replaceNamespacedCronJobStatus.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling replaceNamespacedCronJobStatus.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
exports.Batch_v1beta1Api = Batch_v1beta1Api;
var Batch_v2alpha1ApiApiKeys;
(function (Batch_v2alpha1ApiApiKeys) {
    Batch_v2alpha1ApiApiKeys[Batch_v2alpha1ApiApiKeys["BearerToken"] = 0] = "BearerToken";
})(Batch_v2alpha1ApiApiKeys = exports.Batch_v2alpha1ApiApiKeys || (exports.Batch_v2alpha1ApiApiKeys = {}));
class Batch_v2alpha1Api {
    constructor(basePathOrUsername, password, basePath) {
        this._basePath = defaultBasePath;
        this.defaultHeaders = {};
        this._useQuerystring = false;
        this.authentications = {
            'default': new VoidAuth(),
            'BearerToken': new ApiKeyAuth('header', 'authorization'),
        };
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        }
        else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername;
            }
        }
    }
    set useQuerystring(value) {
        this._useQuerystring = value;
    }
    set basePath(basePath) {
        this._basePath = basePath;
    }
    get basePath() {
        return this._basePath;
    }
    setDefaultAuthentication(auth) {
        this.authentications.default = auth;
    }
    setApiKey(key, value) {
        this.authentications[Batch_v2alpha1ApiApiKeys[key]].apiKey = value;
    }
    /**
     * create a CronJob
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    createNamespacedCronJob(namespace, body, pretty) {
        const localVarPath = this.basePath + '/apis/batch/v2alpha1/namespaces/{namespace}/cronjobs'
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling createNamespacedCronJob.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling createNamespacedCronJob.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * delete collection of CronJob
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param includeUninitialized If true, partially initialized resources are included in the response.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param timeoutSeconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    deleteCollectionNamespacedCronJob(namespace, pretty, _continue, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch) {
        const localVarPath = this.basePath + '/apis/batch/v2alpha1/namespaces/{namespace}/cronjobs'
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling deleteCollectionNamespacedCronJob.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (_continue !== undefined) {
            queryParameters['continue'] = _continue;
        }
        if (fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = fieldSelector;
        }
        if (includeUninitialized !== undefined) {
            queryParameters['includeUninitialized'] = includeUninitialized;
        }
        if (labelSelector !== undefined) {
            queryParameters['labelSelector'] = labelSelector;
        }
        if (limit !== undefined) {
            queryParameters['limit'] = limit;
        }
        if (resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = resourceVersion;
        }
        if (timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = timeoutSeconds;
        }
        if (watch !== undefined) {
            queryParameters['watch'] = watch;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * delete a CronJob
     * @param name name of the CronJob
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param gracePeriodSeconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @param orphanDependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @param propagationPolicy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
     */
    deleteNamespacedCronJob(name, namespace, body, pretty, gracePeriodSeconds, orphanDependents, propagationPolicy) {
        const localVarPath = this.basePath + '/apis/batch/v2alpha1/namespaces/{namespace}/cronjobs/{name}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling deleteNamespacedCronJob.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling deleteNamespacedCronJob.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling deleteNamespacedCronJob.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (gracePeriodSeconds !== undefined) {
            queryParameters['gracePeriodSeconds'] = gracePeriodSeconds;
        }
        if (orphanDependents !== undefined) {
            queryParameters['orphanDependents'] = orphanDependents;
        }
        if (propagationPolicy !== undefined) {
            queryParameters['propagationPolicy'] = propagationPolicy;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * get available resources
     */
    getAPIResources() {
        const localVarPath = this.basePath + '/apis/batch/v2alpha1/';
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        let useFormData = false;
        let requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * list or watch objects of kind CronJob
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param includeUninitialized If true, partially initialized resources are included in the response.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param timeoutSeconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    listCronJobForAllNamespaces(_continue, fieldSelector, includeUninitialized, labelSelector, limit, pretty, resourceVersion, timeoutSeconds, watch) {
        const localVarPath = this.basePath + '/apis/batch/v2alpha1/cronjobs';
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        if (_continue !== undefined) {
            queryParameters['continue'] = _continue;
        }
        if (fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = fieldSelector;
        }
        if (includeUninitialized !== undefined) {
            queryParameters['includeUninitialized'] = includeUninitialized;
        }
        if (labelSelector !== undefined) {
            queryParameters['labelSelector'] = labelSelector;
        }
        if (limit !== undefined) {
            queryParameters['limit'] = limit;
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = resourceVersion;
        }
        if (timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = timeoutSeconds;
        }
        if (watch !== undefined) {
            queryParameters['watch'] = watch;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * list or watch objects of kind CronJob
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param includeUninitialized If true, partially initialized resources are included in the response.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param timeoutSeconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    listNamespacedCronJob(namespace, pretty, _continue, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch) {
        const localVarPath = this.basePath + '/apis/batch/v2alpha1/namespaces/{namespace}/cronjobs'
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling listNamespacedCronJob.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (_continue !== undefined) {
            queryParameters['continue'] = _continue;
        }
        if (fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = fieldSelector;
        }
        if (includeUninitialized !== undefined) {
            queryParameters['includeUninitialized'] = includeUninitialized;
        }
        if (labelSelector !== undefined) {
            queryParameters['labelSelector'] = labelSelector;
        }
        if (limit !== undefined) {
            queryParameters['limit'] = limit;
        }
        if (resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = resourceVersion;
        }
        if (timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = timeoutSeconds;
        }
        if (watch !== undefined) {
            queryParameters['watch'] = watch;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * partially update the specified CronJob
     * @param name name of the CronJob
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    patchNamespacedCronJob(name, namespace, body, pretty) {
        const localVarPath = this.basePath + '/apis/batch/v2alpha1/namespaces/{namespace}/cronjobs/{name}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling patchNamespacedCronJob.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling patchNamespacedCronJob.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling patchNamespacedCronJob.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'PATCH',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * partially update status of the specified CronJob
     * @param name name of the CronJob
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    patchNamespacedCronJobStatus(name, namespace, body, pretty) {
        const localVarPath = this.basePath + '/apis/batch/v2alpha1/namespaces/{namespace}/cronjobs/{name}/status'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling patchNamespacedCronJobStatus.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling patchNamespacedCronJobStatus.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling patchNamespacedCronJobStatus.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'PATCH',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * read the specified CronJob
     * @param name name of the CronJob
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param exact Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;.
     * @param _export Should this value be exported.  Export strips fields that a user can not specify.
     */
    readNamespacedCronJob(name, namespace, pretty, exact, _export) {
        const localVarPath = this.basePath + '/apis/batch/v2alpha1/namespaces/{namespace}/cronjobs/{name}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling readNamespacedCronJob.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling readNamespacedCronJob.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (exact !== undefined) {
            queryParameters['exact'] = exact;
        }
        if (_export !== undefined) {
            queryParameters['export'] = _export;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * read status of the specified CronJob
     * @param name name of the CronJob
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    readNamespacedCronJobStatus(name, namespace, pretty) {
        const localVarPath = this.basePath + '/apis/batch/v2alpha1/namespaces/{namespace}/cronjobs/{name}/status'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling readNamespacedCronJobStatus.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling readNamespacedCronJobStatus.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * replace the specified CronJob
     * @param name name of the CronJob
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    replaceNamespacedCronJob(name, namespace, body, pretty) {
        const localVarPath = this.basePath + '/apis/batch/v2alpha1/namespaces/{namespace}/cronjobs/{name}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling replaceNamespacedCronJob.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling replaceNamespacedCronJob.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling replaceNamespacedCronJob.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * replace status of the specified CronJob
     * @param name name of the CronJob
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    replaceNamespacedCronJobStatus(name, namespace, body, pretty) {
        const localVarPath = this.basePath + '/apis/batch/v2alpha1/namespaces/{namespace}/cronjobs/{name}/status'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling replaceNamespacedCronJobStatus.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling replaceNamespacedCronJobStatus.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling replaceNamespacedCronJobStatus.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
exports.Batch_v2alpha1Api = Batch_v2alpha1Api;
var CertificatesApiApiKeys;
(function (CertificatesApiApiKeys) {
    CertificatesApiApiKeys[CertificatesApiApiKeys["BearerToken"] = 0] = "BearerToken";
})(CertificatesApiApiKeys = exports.CertificatesApiApiKeys || (exports.CertificatesApiApiKeys = {}));
class CertificatesApi {
    constructor(basePathOrUsername, password, basePath) {
        this._basePath = defaultBasePath;
        this.defaultHeaders = {};
        this._useQuerystring = false;
        this.authentications = {
            'default': new VoidAuth(),
            'BearerToken': new ApiKeyAuth('header', 'authorization'),
        };
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        }
        else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername;
            }
        }
    }
    set useQuerystring(value) {
        this._useQuerystring = value;
    }
    set basePath(basePath) {
        this._basePath = basePath;
    }
    get basePath() {
        return this._basePath;
    }
    setDefaultAuthentication(auth) {
        this.authentications.default = auth;
    }
    setApiKey(key, value) {
        this.authentications[CertificatesApiApiKeys[key]].apiKey = value;
    }
    /**
     * get information of a group
     */
    getAPIGroup() {
        const localVarPath = this.basePath + '/apis/certificates.k8s.io/';
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        let useFormData = false;
        let requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
exports.CertificatesApi = CertificatesApi;
var Certificates_v1beta1ApiApiKeys;
(function (Certificates_v1beta1ApiApiKeys) {
    Certificates_v1beta1ApiApiKeys[Certificates_v1beta1ApiApiKeys["BearerToken"] = 0] = "BearerToken";
})(Certificates_v1beta1ApiApiKeys = exports.Certificates_v1beta1ApiApiKeys || (exports.Certificates_v1beta1ApiApiKeys = {}));
class Certificates_v1beta1Api {
    constructor(basePathOrUsername, password, basePath) {
        this._basePath = defaultBasePath;
        this.defaultHeaders = {};
        this._useQuerystring = false;
        this.authentications = {
            'default': new VoidAuth(),
            'BearerToken': new ApiKeyAuth('header', 'authorization'),
        };
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        }
        else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername;
            }
        }
    }
    set useQuerystring(value) {
        this._useQuerystring = value;
    }
    set basePath(basePath) {
        this._basePath = basePath;
    }
    get basePath() {
        return this._basePath;
    }
    setDefaultAuthentication(auth) {
        this.authentications.default = auth;
    }
    setApiKey(key, value) {
        this.authentications[Certificates_v1beta1ApiApiKeys[key]].apiKey = value;
    }
    /**
     * create a CertificateSigningRequest
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    createCertificateSigningRequest(body, pretty) {
        const localVarPath = this.basePath + '/apis/certificates.k8s.io/v1beta1/certificatesigningrequests';
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling createCertificateSigningRequest.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * delete a CertificateSigningRequest
     * @param name name of the CertificateSigningRequest
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param gracePeriodSeconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @param orphanDependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @param propagationPolicy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
     */
    deleteCertificateSigningRequest(name, body, pretty, gracePeriodSeconds, orphanDependents, propagationPolicy) {
        const localVarPath = this.basePath + '/apis/certificates.k8s.io/v1beta1/certificatesigningrequests/{name}'
            .replace('{' + 'name' + '}', String(name));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling deleteCertificateSigningRequest.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling deleteCertificateSigningRequest.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (gracePeriodSeconds !== undefined) {
            queryParameters['gracePeriodSeconds'] = gracePeriodSeconds;
        }
        if (orphanDependents !== undefined) {
            queryParameters['orphanDependents'] = orphanDependents;
        }
        if (propagationPolicy !== undefined) {
            queryParameters['propagationPolicy'] = propagationPolicy;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * delete collection of CertificateSigningRequest
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param includeUninitialized If true, partially initialized resources are included in the response.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param timeoutSeconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    deleteCollectionCertificateSigningRequest(pretty, _continue, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch) {
        const localVarPath = this.basePath + '/apis/certificates.k8s.io/v1beta1/certificatesigningrequests';
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (_continue !== undefined) {
            queryParameters['continue'] = _continue;
        }
        if (fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = fieldSelector;
        }
        if (includeUninitialized !== undefined) {
            queryParameters['includeUninitialized'] = includeUninitialized;
        }
        if (labelSelector !== undefined) {
            queryParameters['labelSelector'] = labelSelector;
        }
        if (limit !== undefined) {
            queryParameters['limit'] = limit;
        }
        if (resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = resourceVersion;
        }
        if (timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = timeoutSeconds;
        }
        if (watch !== undefined) {
            queryParameters['watch'] = watch;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * get available resources
     */
    getAPIResources() {
        const localVarPath = this.basePath + '/apis/certificates.k8s.io/v1beta1/';
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        let useFormData = false;
        let requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * list or watch objects of kind CertificateSigningRequest
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param includeUninitialized If true, partially initialized resources are included in the response.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param timeoutSeconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    listCertificateSigningRequest(pretty, _continue, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch) {
        const localVarPath = this.basePath + '/apis/certificates.k8s.io/v1beta1/certificatesigningrequests';
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (_continue !== undefined) {
            queryParameters['continue'] = _continue;
        }
        if (fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = fieldSelector;
        }
        if (includeUninitialized !== undefined) {
            queryParameters['includeUninitialized'] = includeUninitialized;
        }
        if (labelSelector !== undefined) {
            queryParameters['labelSelector'] = labelSelector;
        }
        if (limit !== undefined) {
            queryParameters['limit'] = limit;
        }
        if (resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = resourceVersion;
        }
        if (timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = timeoutSeconds;
        }
        if (watch !== undefined) {
            queryParameters['watch'] = watch;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * partially update the specified CertificateSigningRequest
     * @param name name of the CertificateSigningRequest
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    patchCertificateSigningRequest(name, body, pretty) {
        const localVarPath = this.basePath + '/apis/certificates.k8s.io/v1beta1/certificatesigningrequests/{name}'
            .replace('{' + 'name' + '}', String(name));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling patchCertificateSigningRequest.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling patchCertificateSigningRequest.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'PATCH',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * partially update status of the specified CertificateSigningRequest
     * @param name name of the CertificateSigningRequest
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    patchCertificateSigningRequestStatus(name, body, pretty) {
        const localVarPath = this.basePath + '/apis/certificates.k8s.io/v1beta1/certificatesigningrequests/{name}/status'
            .replace('{' + 'name' + '}', String(name));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling patchCertificateSigningRequestStatus.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling patchCertificateSigningRequestStatus.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'PATCH',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * read the specified CertificateSigningRequest
     * @param name name of the CertificateSigningRequest
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param exact Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;.
     * @param _export Should this value be exported.  Export strips fields that a user can not specify.
     */
    readCertificateSigningRequest(name, pretty, exact, _export) {
        const localVarPath = this.basePath + '/apis/certificates.k8s.io/v1beta1/certificatesigningrequests/{name}'
            .replace('{' + 'name' + '}', String(name));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling readCertificateSigningRequest.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (exact !== undefined) {
            queryParameters['exact'] = exact;
        }
        if (_export !== undefined) {
            queryParameters['export'] = _export;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * read status of the specified CertificateSigningRequest
     * @param name name of the CertificateSigningRequest
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    readCertificateSigningRequestStatus(name, pretty) {
        const localVarPath = this.basePath + '/apis/certificates.k8s.io/v1beta1/certificatesigningrequests/{name}/status'
            .replace('{' + 'name' + '}', String(name));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling readCertificateSigningRequestStatus.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * replace the specified CertificateSigningRequest
     * @param name name of the CertificateSigningRequest
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    replaceCertificateSigningRequest(name, body, pretty) {
        const localVarPath = this.basePath + '/apis/certificates.k8s.io/v1beta1/certificatesigningrequests/{name}'
            .replace('{' + 'name' + '}', String(name));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling replaceCertificateSigningRequest.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling replaceCertificateSigningRequest.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * replace approval of the specified CertificateSigningRequest
     * @param name name of the CertificateSigningRequest
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    replaceCertificateSigningRequestApproval(name, body, pretty) {
        const localVarPath = this.basePath + '/apis/certificates.k8s.io/v1beta1/certificatesigningrequests/{name}/approval'
            .replace('{' + 'name' + '}', String(name));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling replaceCertificateSigningRequestApproval.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling replaceCertificateSigningRequestApproval.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * replace status of the specified CertificateSigningRequest
     * @param name name of the CertificateSigningRequest
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    replaceCertificateSigningRequestStatus(name, body, pretty) {
        const localVarPath = this.basePath + '/apis/certificates.k8s.io/v1beta1/certificatesigningrequests/{name}/status'
            .replace('{' + 'name' + '}', String(name));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling replaceCertificateSigningRequestStatus.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling replaceCertificateSigningRequestStatus.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
exports.Certificates_v1beta1Api = Certificates_v1beta1Api;
var CoreApiApiKeys;
(function (CoreApiApiKeys) {
    CoreApiApiKeys[CoreApiApiKeys["BearerToken"] = 0] = "BearerToken";
})(CoreApiApiKeys = exports.CoreApiApiKeys || (exports.CoreApiApiKeys = {}));
class CoreApi {
    constructor(basePathOrUsername, password, basePath) {
        this._basePath = defaultBasePath;
        this.defaultHeaders = {};
        this._useQuerystring = false;
        this.authentications = {
            'default': new VoidAuth(),
            'BearerToken': new ApiKeyAuth('header', 'authorization'),
        };
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        }
        else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername;
            }
        }
    }
    set useQuerystring(value) {
        this._useQuerystring = value;
    }
    set basePath(basePath) {
        this._basePath = basePath;
    }
    get basePath() {
        return this._basePath;
    }
    setDefaultAuthentication(auth) {
        this.authentications.default = auth;
    }
    setApiKey(key, value) {
        this.authentications[CoreApiApiKeys[key]].apiKey = value;
    }
    /**
     * get available API versions
     */
    getAPIVersions() {
        const localVarPath = this.basePath + '/api/';
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        let useFormData = false;
        let requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
exports.CoreApi = CoreApi;
var Core_v1ApiApiKeys;
(function (Core_v1ApiApiKeys) {
    Core_v1ApiApiKeys[Core_v1ApiApiKeys["BearerToken"] = 0] = "BearerToken";
})(Core_v1ApiApiKeys = exports.Core_v1ApiApiKeys || (exports.Core_v1ApiApiKeys = {}));
class Core_v1Api {
    constructor(basePathOrUsername, password, basePath) {
        this._basePath = defaultBasePath;
        this.defaultHeaders = {};
        this._useQuerystring = false;
        this.authentications = {
            'default': new VoidAuth(),
            'BearerToken': new ApiKeyAuth('header', 'authorization'),
        };
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        }
        else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername;
            }
        }
    }
    set useQuerystring(value) {
        this._useQuerystring = value;
    }
    set basePath(basePath) {
        this._basePath = basePath;
    }
    get basePath() {
        return this._basePath;
    }
    setDefaultAuthentication(auth) {
        this.authentications.default = auth;
    }
    setApiKey(key, value) {
        this.authentications[Core_v1ApiApiKeys[key]].apiKey = value;
    }
    /**
     * connect DELETE requests to proxy of Pod
     * @param name name of the Pod
     * @param namespace object name and auth scope, such as for teams and projects
     * @param path Path is the URL path to use for the current proxy request to pod.
     */
    connectDeleteNamespacedPodProxy(name, namespace, path) {
        const localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/pods/{name}/proxy'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling connectDeleteNamespacedPodProxy.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling connectDeleteNamespacedPodProxy.');
        }
        if (path !== undefined) {
            queryParameters['path'] = path;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * connect DELETE requests to proxy of Pod
     * @param name name of the Pod
     * @param namespace object name and auth scope, such as for teams and projects
     * @param path path to the resource
     * @param path2 Path is the URL path to use for the current proxy request to pod.
     */
    connectDeleteNamespacedPodProxyWithPath(name, namespace, path, path2) {
        const localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/pods/{name}/proxy/{path}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace))
            .replace('{' + 'path' + '}', String(path));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling connectDeleteNamespacedPodProxyWithPath.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling connectDeleteNamespacedPodProxyWithPath.');
        }
        // verify required parameter 'path' is not null or undefined
        if (path === null || path === undefined) {
            throw new Error('Required parameter path was null or undefined when calling connectDeleteNamespacedPodProxyWithPath.');
        }
        if (path2 !== undefined) {
            queryParameters['path'] = path2;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * connect DELETE requests to proxy of Service
     * @param name name of the Service
     * @param namespace object name and auth scope, such as for teams and projects
     * @param path Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q&#x3D;user:kimchy. Path is _search?q&#x3D;user:kimchy.
     */
    connectDeleteNamespacedServiceProxy(name, namespace, path) {
        const localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/services/{name}/proxy'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling connectDeleteNamespacedServiceProxy.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling connectDeleteNamespacedServiceProxy.');
        }
        if (path !== undefined) {
            queryParameters['path'] = path;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * connect DELETE requests to proxy of Service
     * @param name name of the Service
     * @param namespace object name and auth scope, such as for teams and projects
     * @param path path to the resource
     * @param path2 Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q&#x3D;user:kimchy. Path is _search?q&#x3D;user:kimchy.
     */
    connectDeleteNamespacedServiceProxyWithPath(name, namespace, path, path2) {
        const localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/services/{name}/proxy/{path}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace))
            .replace('{' + 'path' + '}', String(path));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling connectDeleteNamespacedServiceProxyWithPath.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling connectDeleteNamespacedServiceProxyWithPath.');
        }
        // verify required parameter 'path' is not null or undefined
        if (path === null || path === undefined) {
            throw new Error('Required parameter path was null or undefined when calling connectDeleteNamespacedServiceProxyWithPath.');
        }
        if (path2 !== undefined) {
            queryParameters['path'] = path2;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * connect DELETE requests to proxy of Node
     * @param name name of the Node
     * @param path Path is the URL path to use for the current proxy request to node.
     */
    connectDeleteNodeProxy(name, path) {
        const localVarPath = this.basePath + '/api/v1/nodes/{name}/proxy'
            .replace('{' + 'name' + '}', String(name));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling connectDeleteNodeProxy.');
        }
        if (path !== undefined) {
            queryParameters['path'] = path;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * connect DELETE requests to proxy of Node
     * @param name name of the Node
     * @param path path to the resource
     * @param path2 Path is the URL path to use for the current proxy request to node.
     */
    connectDeleteNodeProxyWithPath(name, path, path2) {
        const localVarPath = this.basePath + '/api/v1/nodes/{name}/proxy/{path}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'path' + '}', String(path));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling connectDeleteNodeProxyWithPath.');
        }
        // verify required parameter 'path' is not null or undefined
        if (path === null || path === undefined) {
            throw new Error('Required parameter path was null or undefined when calling connectDeleteNodeProxyWithPath.');
        }
        if (path2 !== undefined) {
            queryParameters['path'] = path2;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * connect GET requests to attach of Pod
     * @param name name of the Pod
     * @param namespace object name and auth scope, such as for teams and projects
     * @param container The container in which to execute the command. Defaults to only container if there is only one container in the pod.
     * @param stderr Stderr if true indicates that stderr is to be redirected for the attach call. Defaults to true.
     * @param stdin Stdin if true, redirects the standard input stream of the pod for this call. Defaults to false.
     * @param stdout Stdout if true indicates that stdout is to be redirected for the attach call. Defaults to true.
     * @param tty TTY if true indicates that a tty will be allocated for the attach call. This is passed through the container runtime so the tty is allocated on the worker node by the container runtime. Defaults to false.
     */
    connectGetNamespacedPodAttach(name, namespace, container, stderr, stdin, stdout, tty) {
        const localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/pods/{name}/attach'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling connectGetNamespacedPodAttach.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling connectGetNamespacedPodAttach.');
        }
        if (container !== undefined) {
            queryParameters['container'] = container;
        }
        if (stderr !== undefined) {
            queryParameters['stderr'] = stderr;
        }
        if (stdin !== undefined) {
            queryParameters['stdin'] = stdin;
        }
        if (stdout !== undefined) {
            queryParameters['stdout'] = stdout;
        }
        if (tty !== undefined) {
            queryParameters['tty'] = tty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * connect GET requests to exec of Pod
     * @param name name of the Pod
     * @param namespace object name and auth scope, such as for teams and projects
     * @param command Command is the remote command to execute. argv array. Not executed within a shell.
     * @param container Container in which to execute the command. Defaults to only container if there is only one container in the pod.
     * @param stderr Redirect the standard error stream of the pod for this call. Defaults to true.
     * @param stdin Redirect the standard input stream of the pod for this call. Defaults to false.
     * @param stdout Redirect the standard output stream of the pod for this call. Defaults to true.
     * @param tty TTY if true indicates that a tty will be allocated for the exec call. Defaults to false.
     */
    connectGetNamespacedPodExec(name, namespace, command, container, stderr, stdin, stdout, tty) {
        const localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/pods/{name}/exec'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling connectGetNamespacedPodExec.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling connectGetNamespacedPodExec.');
        }
        if (command !== undefined) {
            queryParameters['command'] = command;
        }
        if (container !== undefined) {
            queryParameters['container'] = container;
        }
        if (stderr !== undefined) {
            queryParameters['stderr'] = stderr;
        }
        if (stdin !== undefined) {
            queryParameters['stdin'] = stdin;
        }
        if (stdout !== undefined) {
            queryParameters['stdout'] = stdout;
        }
        if (tty !== undefined) {
            queryParameters['tty'] = tty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * connect GET requests to portforward of Pod
     * @param name name of the Pod
     * @param namespace object name and auth scope, such as for teams and projects
     * @param ports List of ports to forward Required when using WebSockets
     */
    connectGetNamespacedPodPortforward(name, namespace, ports) {
        const localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/pods/{name}/portforward'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling connectGetNamespacedPodPortforward.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling connectGetNamespacedPodPortforward.');
        }
        if (ports !== undefined) {
            queryParameters['ports'] = ports;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * connect GET requests to proxy of Pod
     * @param name name of the Pod
     * @param namespace object name and auth scope, such as for teams and projects
     * @param path Path is the URL path to use for the current proxy request to pod.
     */
    connectGetNamespacedPodProxy(name, namespace, path) {
        const localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/pods/{name}/proxy'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling connectGetNamespacedPodProxy.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling connectGetNamespacedPodProxy.');
        }
        if (path !== undefined) {
            queryParameters['path'] = path;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * connect GET requests to proxy of Pod
     * @param name name of the Pod
     * @param namespace object name and auth scope, such as for teams and projects
     * @param path path to the resource
     * @param path2 Path is the URL path to use for the current proxy request to pod.
     */
    connectGetNamespacedPodProxyWithPath(name, namespace, path, path2) {
        const localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/pods/{name}/proxy/{path}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace))
            .replace('{' + 'path' + '}', String(path));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling connectGetNamespacedPodProxyWithPath.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling connectGetNamespacedPodProxyWithPath.');
        }
        // verify required parameter 'path' is not null or undefined
        if (path === null || path === undefined) {
            throw new Error('Required parameter path was null or undefined when calling connectGetNamespacedPodProxyWithPath.');
        }
        if (path2 !== undefined) {
            queryParameters['path'] = path2;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * connect GET requests to proxy of Service
     * @param name name of the Service
     * @param namespace object name and auth scope, such as for teams and projects
     * @param path Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q&#x3D;user:kimchy. Path is _search?q&#x3D;user:kimchy.
     */
    connectGetNamespacedServiceProxy(name, namespace, path) {
        const localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/services/{name}/proxy'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling connectGetNamespacedServiceProxy.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling connectGetNamespacedServiceProxy.');
        }
        if (path !== undefined) {
            queryParameters['path'] = path;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * connect GET requests to proxy of Service
     * @param name name of the Service
     * @param namespace object name and auth scope, such as for teams and projects
     * @param path path to the resource
     * @param path2 Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q&#x3D;user:kimchy. Path is _search?q&#x3D;user:kimchy.
     */
    connectGetNamespacedServiceProxyWithPath(name, namespace, path, path2) {
        const localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/services/{name}/proxy/{path}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace))
            .replace('{' + 'path' + '}', String(path));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling connectGetNamespacedServiceProxyWithPath.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling connectGetNamespacedServiceProxyWithPath.');
        }
        // verify required parameter 'path' is not null or undefined
        if (path === null || path === undefined) {
            throw new Error('Required parameter path was null or undefined when calling connectGetNamespacedServiceProxyWithPath.');
        }
        if (path2 !== undefined) {
            queryParameters['path'] = path2;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * connect GET requests to proxy of Node
     * @param name name of the Node
     * @param path Path is the URL path to use for the current proxy request to node.
     */
    connectGetNodeProxy(name, path) {
        const localVarPath = this.basePath + '/api/v1/nodes/{name}/proxy'
            .replace('{' + 'name' + '}', String(name));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling connectGetNodeProxy.');
        }
        if (path !== undefined) {
            queryParameters['path'] = path;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * connect GET requests to proxy of Node
     * @param name name of the Node
     * @param path path to the resource
     * @param path2 Path is the URL path to use for the current proxy request to node.
     */
    connectGetNodeProxyWithPath(name, path, path2) {
        const localVarPath = this.basePath + '/api/v1/nodes/{name}/proxy/{path}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'path' + '}', String(path));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling connectGetNodeProxyWithPath.');
        }
        // verify required parameter 'path' is not null or undefined
        if (path === null || path === undefined) {
            throw new Error('Required parameter path was null or undefined when calling connectGetNodeProxyWithPath.');
        }
        if (path2 !== undefined) {
            queryParameters['path'] = path2;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * connect HEAD requests to proxy of Pod
     * @param name name of the Pod
     * @param namespace object name and auth scope, such as for teams and projects
     * @param path Path is the URL path to use for the current proxy request to pod.
     */
    connectHeadNamespacedPodProxy(name, namespace, path) {
        const localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/pods/{name}/proxy'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling connectHeadNamespacedPodProxy.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling connectHeadNamespacedPodProxy.');
        }
        if (path !== undefined) {
            queryParameters['path'] = path;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'HEAD',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * connect HEAD requests to proxy of Pod
     * @param name name of the Pod
     * @param namespace object name and auth scope, such as for teams and projects
     * @param path path to the resource
     * @param path2 Path is the URL path to use for the current proxy request to pod.
     */
    connectHeadNamespacedPodProxyWithPath(name, namespace, path, path2) {
        const localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/pods/{name}/proxy/{path}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace))
            .replace('{' + 'path' + '}', String(path));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling connectHeadNamespacedPodProxyWithPath.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling connectHeadNamespacedPodProxyWithPath.');
        }
        // verify required parameter 'path' is not null or undefined
        if (path === null || path === undefined) {
            throw new Error('Required parameter path was null or undefined when calling connectHeadNamespacedPodProxyWithPath.');
        }
        if (path2 !== undefined) {
            queryParameters['path'] = path2;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'HEAD',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * connect HEAD requests to proxy of Service
     * @param name name of the Service
     * @param namespace object name and auth scope, such as for teams and projects
     * @param path Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q&#x3D;user:kimchy. Path is _search?q&#x3D;user:kimchy.
     */
    connectHeadNamespacedServiceProxy(name, namespace, path) {
        const localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/services/{name}/proxy'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling connectHeadNamespacedServiceProxy.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling connectHeadNamespacedServiceProxy.');
        }
        if (path !== undefined) {
            queryParameters['path'] = path;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'HEAD',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * connect HEAD requests to proxy of Service
     * @param name name of the Service
     * @param namespace object name and auth scope, such as for teams and projects
     * @param path path to the resource
     * @param path2 Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q&#x3D;user:kimchy. Path is _search?q&#x3D;user:kimchy.
     */
    connectHeadNamespacedServiceProxyWithPath(name, namespace, path, path2) {
        const localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/services/{name}/proxy/{path}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace))
            .replace('{' + 'path' + '}', String(path));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling connectHeadNamespacedServiceProxyWithPath.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling connectHeadNamespacedServiceProxyWithPath.');
        }
        // verify required parameter 'path' is not null or undefined
        if (path === null || path === undefined) {
            throw new Error('Required parameter path was null or undefined when calling connectHeadNamespacedServiceProxyWithPath.');
        }
        if (path2 !== undefined) {
            queryParameters['path'] = path2;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'HEAD',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * connect HEAD requests to proxy of Node
     * @param name name of the Node
     * @param path Path is the URL path to use for the current proxy request to node.
     */
    connectHeadNodeProxy(name, path) {
        const localVarPath = this.basePath + '/api/v1/nodes/{name}/proxy'
            .replace('{' + 'name' + '}', String(name));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling connectHeadNodeProxy.');
        }
        if (path !== undefined) {
            queryParameters['path'] = path;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'HEAD',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * connect HEAD requests to proxy of Node
     * @param name name of the Node
     * @param path path to the resource
     * @param path2 Path is the URL path to use for the current proxy request to node.
     */
    connectHeadNodeProxyWithPath(name, path, path2) {
        const localVarPath = this.basePath + '/api/v1/nodes/{name}/proxy/{path}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'path' + '}', String(path));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling connectHeadNodeProxyWithPath.');
        }
        // verify required parameter 'path' is not null or undefined
        if (path === null || path === undefined) {
            throw new Error('Required parameter path was null or undefined when calling connectHeadNodeProxyWithPath.');
        }
        if (path2 !== undefined) {
            queryParameters['path'] = path2;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'HEAD',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * connect OPTIONS requests to proxy of Pod
     * @param name name of the Pod
     * @param namespace object name and auth scope, such as for teams and projects
     * @param path Path is the URL path to use for the current proxy request to pod.
     */
    connectOptionsNamespacedPodProxy(name, namespace, path) {
        const localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/pods/{name}/proxy'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling connectOptionsNamespacedPodProxy.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling connectOptionsNamespacedPodProxy.');
        }
        if (path !== undefined) {
            queryParameters['path'] = path;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'OPTIONS',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * connect OPTIONS requests to proxy of Pod
     * @param name name of the Pod
     * @param namespace object name and auth scope, such as for teams and projects
     * @param path path to the resource
     * @param path2 Path is the URL path to use for the current proxy request to pod.
     */
    connectOptionsNamespacedPodProxyWithPath(name, namespace, path, path2) {
        const localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/pods/{name}/proxy/{path}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace))
            .replace('{' + 'path' + '}', String(path));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling connectOptionsNamespacedPodProxyWithPath.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling connectOptionsNamespacedPodProxyWithPath.');
        }
        // verify required parameter 'path' is not null or undefined
        if (path === null || path === undefined) {
            throw new Error('Required parameter path was null or undefined when calling connectOptionsNamespacedPodProxyWithPath.');
        }
        if (path2 !== undefined) {
            queryParameters['path'] = path2;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'OPTIONS',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * connect OPTIONS requests to proxy of Service
     * @param name name of the Service
     * @param namespace object name and auth scope, such as for teams and projects
     * @param path Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q&#x3D;user:kimchy. Path is _search?q&#x3D;user:kimchy.
     */
    connectOptionsNamespacedServiceProxy(name, namespace, path) {
        const localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/services/{name}/proxy'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling connectOptionsNamespacedServiceProxy.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling connectOptionsNamespacedServiceProxy.');
        }
        if (path !== undefined) {
            queryParameters['path'] = path;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'OPTIONS',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * connect OPTIONS requests to proxy of Service
     * @param name name of the Service
     * @param namespace object name and auth scope, such as for teams and projects
     * @param path path to the resource
     * @param path2 Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q&#x3D;user:kimchy. Path is _search?q&#x3D;user:kimchy.
     */
    connectOptionsNamespacedServiceProxyWithPath(name, namespace, path, path2) {
        const localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/services/{name}/proxy/{path}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace))
            .replace('{' + 'path' + '}', String(path));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling connectOptionsNamespacedServiceProxyWithPath.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling connectOptionsNamespacedServiceProxyWithPath.');
        }
        // verify required parameter 'path' is not null or undefined
        if (path === null || path === undefined) {
            throw new Error('Required parameter path was null or undefined when calling connectOptionsNamespacedServiceProxyWithPath.');
        }
        if (path2 !== undefined) {
            queryParameters['path'] = path2;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'OPTIONS',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * connect OPTIONS requests to proxy of Node
     * @param name name of the Node
     * @param path Path is the URL path to use for the current proxy request to node.
     */
    connectOptionsNodeProxy(name, path) {
        const localVarPath = this.basePath + '/api/v1/nodes/{name}/proxy'
            .replace('{' + 'name' + '}', String(name));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling connectOptionsNodeProxy.');
        }
        if (path !== undefined) {
            queryParameters['path'] = path;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'OPTIONS',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * connect OPTIONS requests to proxy of Node
     * @param name name of the Node
     * @param path path to the resource
     * @param path2 Path is the URL path to use for the current proxy request to node.
     */
    connectOptionsNodeProxyWithPath(name, path, path2) {
        const localVarPath = this.basePath + '/api/v1/nodes/{name}/proxy/{path}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'path' + '}', String(path));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling connectOptionsNodeProxyWithPath.');
        }
        // verify required parameter 'path' is not null or undefined
        if (path === null || path === undefined) {
            throw new Error('Required parameter path was null or undefined when calling connectOptionsNodeProxyWithPath.');
        }
        if (path2 !== undefined) {
            queryParameters['path'] = path2;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'OPTIONS',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * connect PATCH requests to proxy of Pod
     * @param name name of the Pod
     * @param namespace object name and auth scope, such as for teams and projects
     * @param path Path is the URL path to use for the current proxy request to pod.
     */
    connectPatchNamespacedPodProxy(name, namespace, path) {
        const localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/pods/{name}/proxy'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling connectPatchNamespacedPodProxy.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling connectPatchNamespacedPodProxy.');
        }
        if (path !== undefined) {
            queryParameters['path'] = path;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'PATCH',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * connect PATCH requests to proxy of Pod
     * @param name name of the Pod
     * @param namespace object name and auth scope, such as for teams and projects
     * @param path path to the resource
     * @param path2 Path is the URL path to use for the current proxy request to pod.
     */
    connectPatchNamespacedPodProxyWithPath(name, namespace, path, path2) {
        const localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/pods/{name}/proxy/{path}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace))
            .replace('{' + 'path' + '}', String(path));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling connectPatchNamespacedPodProxyWithPath.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling connectPatchNamespacedPodProxyWithPath.');
        }
        // verify required parameter 'path' is not null or undefined
        if (path === null || path === undefined) {
            throw new Error('Required parameter path was null or undefined when calling connectPatchNamespacedPodProxyWithPath.');
        }
        if (path2 !== undefined) {
            queryParameters['path'] = path2;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'PATCH',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * connect PATCH requests to proxy of Service
     * @param name name of the Service
     * @param namespace object name and auth scope, such as for teams and projects
     * @param path Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q&#x3D;user:kimchy. Path is _search?q&#x3D;user:kimchy.
     */
    connectPatchNamespacedServiceProxy(name, namespace, path) {
        const localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/services/{name}/proxy'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling connectPatchNamespacedServiceProxy.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling connectPatchNamespacedServiceProxy.');
        }
        if (path !== undefined) {
            queryParameters['path'] = path;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'PATCH',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * connect PATCH requests to proxy of Service
     * @param name name of the Service
     * @param namespace object name and auth scope, such as for teams and projects
     * @param path path to the resource
     * @param path2 Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q&#x3D;user:kimchy. Path is _search?q&#x3D;user:kimchy.
     */
    connectPatchNamespacedServiceProxyWithPath(name, namespace, path, path2) {
        const localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/services/{name}/proxy/{path}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace))
            .replace('{' + 'path' + '}', String(path));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling connectPatchNamespacedServiceProxyWithPath.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling connectPatchNamespacedServiceProxyWithPath.');
        }
        // verify required parameter 'path' is not null or undefined
        if (path === null || path === undefined) {
            throw new Error('Required parameter path was null or undefined when calling connectPatchNamespacedServiceProxyWithPath.');
        }
        if (path2 !== undefined) {
            queryParameters['path'] = path2;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'PATCH',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * connect PATCH requests to proxy of Node
     * @param name name of the Node
     * @param path Path is the URL path to use for the current proxy request to node.
     */
    connectPatchNodeProxy(name, path) {
        const localVarPath = this.basePath + '/api/v1/nodes/{name}/proxy'
            .replace('{' + 'name' + '}', String(name));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling connectPatchNodeProxy.');
        }
        if (path !== undefined) {
            queryParameters['path'] = path;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'PATCH',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * connect PATCH requests to proxy of Node
     * @param name name of the Node
     * @param path path to the resource
     * @param path2 Path is the URL path to use for the current proxy request to node.
     */
    connectPatchNodeProxyWithPath(name, path, path2) {
        const localVarPath = this.basePath + '/api/v1/nodes/{name}/proxy/{path}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'path' + '}', String(path));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling connectPatchNodeProxyWithPath.');
        }
        // verify required parameter 'path' is not null or undefined
        if (path === null || path === undefined) {
            throw new Error('Required parameter path was null or undefined when calling connectPatchNodeProxyWithPath.');
        }
        if (path2 !== undefined) {
            queryParameters['path'] = path2;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'PATCH',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * connect POST requests to attach of Pod
     * @param name name of the Pod
     * @param namespace object name and auth scope, such as for teams and projects
     * @param container The container in which to execute the command. Defaults to only container if there is only one container in the pod.
     * @param stderr Stderr if true indicates that stderr is to be redirected for the attach call. Defaults to true.
     * @param stdin Stdin if true, redirects the standard input stream of the pod for this call. Defaults to false.
     * @param stdout Stdout if true indicates that stdout is to be redirected for the attach call. Defaults to true.
     * @param tty TTY if true indicates that a tty will be allocated for the attach call. This is passed through the container runtime so the tty is allocated on the worker node by the container runtime. Defaults to false.
     */
    connectPostNamespacedPodAttach(name, namespace, container, stderr, stdin, stdout, tty) {
        const localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/pods/{name}/attach'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling connectPostNamespacedPodAttach.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling connectPostNamespacedPodAttach.');
        }
        if (container !== undefined) {
            queryParameters['container'] = container;
        }
        if (stderr !== undefined) {
            queryParameters['stderr'] = stderr;
        }
        if (stdin !== undefined) {
            queryParameters['stdin'] = stdin;
        }
        if (stdout !== undefined) {
            queryParameters['stdout'] = stdout;
        }
        if (tty !== undefined) {
            queryParameters['tty'] = tty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * connect POST requests to exec of Pod
     * @param name name of the Pod
     * @param namespace object name and auth scope, such as for teams and projects
     * @param command Command is the remote command to execute. argv array. Not executed within a shell.
     * @param container Container in which to execute the command. Defaults to only container if there is only one container in the pod.
     * @param stderr Redirect the standard error stream of the pod for this call. Defaults to true.
     * @param stdin Redirect the standard input stream of the pod for this call. Defaults to false.
     * @param stdout Redirect the standard output stream of the pod for this call. Defaults to true.
     * @param tty TTY if true indicates that a tty will be allocated for the exec call. Defaults to false.
     */
    connectPostNamespacedPodExec(name, namespace, command, container, stderr, stdin, stdout, tty) {
        const localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/pods/{name}/exec'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling connectPostNamespacedPodExec.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling connectPostNamespacedPodExec.');
        }
        if (command !== undefined) {
            queryParameters['command'] = command;
        }
        if (container !== undefined) {
            queryParameters['container'] = container;
        }
        if (stderr !== undefined) {
            queryParameters['stderr'] = stderr;
        }
        if (stdin !== undefined) {
            queryParameters['stdin'] = stdin;
        }
        if (stdout !== undefined) {
            queryParameters['stdout'] = stdout;
        }
        if (tty !== undefined) {
            queryParameters['tty'] = tty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * connect POST requests to portforward of Pod
     * @param name name of the Pod
     * @param namespace object name and auth scope, such as for teams and projects
     * @param ports List of ports to forward Required when using WebSockets
     */
    connectPostNamespacedPodPortforward(name, namespace, ports) {
        const localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/pods/{name}/portforward'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling connectPostNamespacedPodPortforward.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling connectPostNamespacedPodPortforward.');
        }
        if (ports !== undefined) {
            queryParameters['ports'] = ports;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * connect POST requests to proxy of Pod
     * @param name name of the Pod
     * @param namespace object name and auth scope, such as for teams and projects
     * @param path Path is the URL path to use for the current proxy request to pod.
     */
    connectPostNamespacedPodProxy(name, namespace, path) {
        const localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/pods/{name}/proxy'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling connectPostNamespacedPodProxy.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling connectPostNamespacedPodProxy.');
        }
        if (path !== undefined) {
            queryParameters['path'] = path;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * connect POST requests to proxy of Pod
     * @param name name of the Pod
     * @param namespace object name and auth scope, such as for teams and projects
     * @param path path to the resource
     * @param path2 Path is the URL path to use for the current proxy request to pod.
     */
    connectPostNamespacedPodProxyWithPath(name, namespace, path, path2) {
        const localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/pods/{name}/proxy/{path}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace))
            .replace('{' + 'path' + '}', String(path));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling connectPostNamespacedPodProxyWithPath.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling connectPostNamespacedPodProxyWithPath.');
        }
        // verify required parameter 'path' is not null or undefined
        if (path === null || path === undefined) {
            throw new Error('Required parameter path was null or undefined when calling connectPostNamespacedPodProxyWithPath.');
        }
        if (path2 !== undefined) {
            queryParameters['path'] = path2;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * connect POST requests to proxy of Service
     * @param name name of the Service
     * @param namespace object name and auth scope, such as for teams and projects
     * @param path Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q&#x3D;user:kimchy. Path is _search?q&#x3D;user:kimchy.
     */
    connectPostNamespacedServiceProxy(name, namespace, path) {
        const localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/services/{name}/proxy'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling connectPostNamespacedServiceProxy.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling connectPostNamespacedServiceProxy.');
        }
        if (path !== undefined) {
            queryParameters['path'] = path;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * connect POST requests to proxy of Service
     * @param name name of the Service
     * @param namespace object name and auth scope, such as for teams and projects
     * @param path path to the resource
     * @param path2 Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q&#x3D;user:kimchy. Path is _search?q&#x3D;user:kimchy.
     */
    connectPostNamespacedServiceProxyWithPath(name, namespace, path, path2) {
        const localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/services/{name}/proxy/{path}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace))
            .replace('{' + 'path' + '}', String(path));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling connectPostNamespacedServiceProxyWithPath.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling connectPostNamespacedServiceProxyWithPath.');
        }
        // verify required parameter 'path' is not null or undefined
        if (path === null || path === undefined) {
            throw new Error('Required parameter path was null or undefined when calling connectPostNamespacedServiceProxyWithPath.');
        }
        if (path2 !== undefined) {
            queryParameters['path'] = path2;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * connect POST requests to proxy of Node
     * @param name name of the Node
     * @param path Path is the URL path to use for the current proxy request to node.
     */
    connectPostNodeProxy(name, path) {
        const localVarPath = this.basePath + '/api/v1/nodes/{name}/proxy'
            .replace('{' + 'name' + '}', String(name));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling connectPostNodeProxy.');
        }
        if (path !== undefined) {
            queryParameters['path'] = path;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * connect POST requests to proxy of Node
     * @param name name of the Node
     * @param path path to the resource
     * @param path2 Path is the URL path to use for the current proxy request to node.
     */
    connectPostNodeProxyWithPath(name, path, path2) {
        const localVarPath = this.basePath + '/api/v1/nodes/{name}/proxy/{path}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'path' + '}', String(path));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling connectPostNodeProxyWithPath.');
        }
        // verify required parameter 'path' is not null or undefined
        if (path === null || path === undefined) {
            throw new Error('Required parameter path was null or undefined when calling connectPostNodeProxyWithPath.');
        }
        if (path2 !== undefined) {
            queryParameters['path'] = path2;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * connect PUT requests to proxy of Pod
     * @param name name of the Pod
     * @param namespace object name and auth scope, such as for teams and projects
     * @param path Path is the URL path to use for the current proxy request to pod.
     */
    connectPutNamespacedPodProxy(name, namespace, path) {
        const localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/pods/{name}/proxy'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling connectPutNamespacedPodProxy.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling connectPutNamespacedPodProxy.');
        }
        if (path !== undefined) {
            queryParameters['path'] = path;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * connect PUT requests to proxy of Pod
     * @param name name of the Pod
     * @param namespace object name and auth scope, such as for teams and projects
     * @param path path to the resource
     * @param path2 Path is the URL path to use for the current proxy request to pod.
     */
    connectPutNamespacedPodProxyWithPath(name, namespace, path, path2) {
        const localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/pods/{name}/proxy/{path}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace))
            .replace('{' + 'path' + '}', String(path));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling connectPutNamespacedPodProxyWithPath.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling connectPutNamespacedPodProxyWithPath.');
        }
        // verify required parameter 'path' is not null or undefined
        if (path === null || path === undefined) {
            throw new Error('Required parameter path was null or undefined when calling connectPutNamespacedPodProxyWithPath.');
        }
        if (path2 !== undefined) {
            queryParameters['path'] = path2;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * connect PUT requests to proxy of Service
     * @param name name of the Service
     * @param namespace object name and auth scope, such as for teams and projects
     * @param path Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q&#x3D;user:kimchy. Path is _search?q&#x3D;user:kimchy.
     */
    connectPutNamespacedServiceProxy(name, namespace, path) {
        const localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/services/{name}/proxy'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling connectPutNamespacedServiceProxy.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling connectPutNamespacedServiceProxy.');
        }
        if (path !== undefined) {
            queryParameters['path'] = path;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * connect PUT requests to proxy of Service
     * @param name name of the Service
     * @param namespace object name and auth scope, such as for teams and projects
     * @param path path to the resource
     * @param path2 Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q&#x3D;user:kimchy. Path is _search?q&#x3D;user:kimchy.
     */
    connectPutNamespacedServiceProxyWithPath(name, namespace, path, path2) {
        const localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/services/{name}/proxy/{path}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace))
            .replace('{' + 'path' + '}', String(path));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling connectPutNamespacedServiceProxyWithPath.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling connectPutNamespacedServiceProxyWithPath.');
        }
        // verify required parameter 'path' is not null or undefined
        if (path === null || path === undefined) {
            throw new Error('Required parameter path was null or undefined when calling connectPutNamespacedServiceProxyWithPath.');
        }
        if (path2 !== undefined) {
            queryParameters['path'] = path2;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * connect PUT requests to proxy of Node
     * @param name name of the Node
     * @param path Path is the URL path to use for the current proxy request to node.
     */
    connectPutNodeProxy(name, path) {
        const localVarPath = this.basePath + '/api/v1/nodes/{name}/proxy'
            .replace('{' + 'name' + '}', String(name));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling connectPutNodeProxy.');
        }
        if (path !== undefined) {
            queryParameters['path'] = path;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * connect PUT requests to proxy of Node
     * @param name name of the Node
     * @param path path to the resource
     * @param path2 Path is the URL path to use for the current proxy request to node.
     */
    connectPutNodeProxyWithPath(name, path, path2) {
        const localVarPath = this.basePath + '/api/v1/nodes/{name}/proxy/{path}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'path' + '}', String(path));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling connectPutNodeProxyWithPath.');
        }
        // verify required parameter 'path' is not null or undefined
        if (path === null || path === undefined) {
            throw new Error('Required parameter path was null or undefined when calling connectPutNodeProxyWithPath.');
        }
        if (path2 !== undefined) {
            queryParameters['path'] = path2;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * create a Namespace
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    createNamespace(body, pretty) {
        const localVarPath = this.basePath + '/api/v1/namespaces';
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling createNamespace.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * create a Binding
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    createNamespacedBinding(namespace, body, pretty) {
        const localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/bindings'
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling createNamespacedBinding.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling createNamespacedBinding.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * create a ConfigMap
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    createNamespacedConfigMap(namespace, body, pretty) {
        const localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/configmaps'
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling createNamespacedConfigMap.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling createNamespacedConfigMap.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * create Endpoints
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    createNamespacedEndpoints(namespace, body, pretty) {
        const localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/endpoints'
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling createNamespacedEndpoints.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling createNamespacedEndpoints.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * create an Event
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    createNamespacedEvent(namespace, body, pretty) {
        const localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/events'
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling createNamespacedEvent.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling createNamespacedEvent.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * create a LimitRange
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    createNamespacedLimitRange(namespace, body, pretty) {
        const localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/limitranges'
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling createNamespacedLimitRange.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling createNamespacedLimitRange.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * create a PersistentVolumeClaim
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    createNamespacedPersistentVolumeClaim(namespace, body, pretty) {
        const localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/persistentvolumeclaims'
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling createNamespacedPersistentVolumeClaim.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling createNamespacedPersistentVolumeClaim.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * create a Pod
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    createNamespacedPod(namespace, body, pretty) {
        const localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/pods'
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling createNamespacedPod.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling createNamespacedPod.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * create binding of a Pod
     * @param name name of the Binding
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    createNamespacedPodBinding(name, namespace, body, pretty) {
        const localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/pods/{name}/binding'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling createNamespacedPodBinding.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling createNamespacedPodBinding.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling createNamespacedPodBinding.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * create eviction of a Pod
     * @param name name of the Eviction
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    createNamespacedPodEviction(name, namespace, body, pretty) {
        const localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/pods/{name}/eviction'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling createNamespacedPodEviction.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling createNamespacedPodEviction.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling createNamespacedPodEviction.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * create a PodTemplate
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    createNamespacedPodTemplate(namespace, body, pretty) {
        const localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/podtemplates'
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling createNamespacedPodTemplate.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling createNamespacedPodTemplate.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * create a ReplicationController
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    createNamespacedReplicationController(namespace, body, pretty) {
        const localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/replicationcontrollers'
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling createNamespacedReplicationController.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling createNamespacedReplicationController.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * create a ResourceQuota
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    createNamespacedResourceQuota(namespace, body, pretty) {
        const localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/resourcequotas'
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling createNamespacedResourceQuota.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling createNamespacedResourceQuota.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * create a Secret
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    createNamespacedSecret(namespace, body, pretty) {
        const localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/secrets'
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling createNamespacedSecret.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling createNamespacedSecret.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * create a Service
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    createNamespacedService(namespace, body, pretty) {
        const localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/services'
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling createNamespacedService.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling createNamespacedService.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * create a ServiceAccount
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    createNamespacedServiceAccount(namespace, body, pretty) {
        const localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/serviceaccounts'
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling createNamespacedServiceAccount.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling createNamespacedServiceAccount.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * create a Node
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    createNode(body, pretty) {
        const localVarPath = this.basePath + '/api/v1/nodes';
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling createNode.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * create a PersistentVolume
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    createPersistentVolume(body, pretty) {
        const localVarPath = this.basePath + '/api/v1/persistentvolumes';
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling createPersistentVolume.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * delete collection of ConfigMap
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param includeUninitialized If true, partially initialized resources are included in the response.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param timeoutSeconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    deleteCollectionNamespacedConfigMap(namespace, pretty, _continue, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch) {
        const localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/configmaps'
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling deleteCollectionNamespacedConfigMap.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (_continue !== undefined) {
            queryParameters['continue'] = _continue;
        }
        if (fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = fieldSelector;
        }
        if (includeUninitialized !== undefined) {
            queryParameters['includeUninitialized'] = includeUninitialized;
        }
        if (labelSelector !== undefined) {
            queryParameters['labelSelector'] = labelSelector;
        }
        if (limit !== undefined) {
            queryParameters['limit'] = limit;
        }
        if (resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = resourceVersion;
        }
        if (timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = timeoutSeconds;
        }
        if (watch !== undefined) {
            queryParameters['watch'] = watch;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * delete collection of Endpoints
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param includeUninitialized If true, partially initialized resources are included in the response.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param timeoutSeconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    deleteCollectionNamespacedEndpoints(namespace, pretty, _continue, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch) {
        const localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/endpoints'
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling deleteCollectionNamespacedEndpoints.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (_continue !== undefined) {
            queryParameters['continue'] = _continue;
        }
        if (fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = fieldSelector;
        }
        if (includeUninitialized !== undefined) {
            queryParameters['includeUninitialized'] = includeUninitialized;
        }
        if (labelSelector !== undefined) {
            queryParameters['labelSelector'] = labelSelector;
        }
        if (limit !== undefined) {
            queryParameters['limit'] = limit;
        }
        if (resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = resourceVersion;
        }
        if (timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = timeoutSeconds;
        }
        if (watch !== undefined) {
            queryParameters['watch'] = watch;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * delete collection of Event
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param includeUninitialized If true, partially initialized resources are included in the response.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param timeoutSeconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    deleteCollectionNamespacedEvent(namespace, pretty, _continue, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch) {
        const localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/events'
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling deleteCollectionNamespacedEvent.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (_continue !== undefined) {
            queryParameters['continue'] = _continue;
        }
        if (fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = fieldSelector;
        }
        if (includeUninitialized !== undefined) {
            queryParameters['includeUninitialized'] = includeUninitialized;
        }
        if (labelSelector !== undefined) {
            queryParameters['labelSelector'] = labelSelector;
        }
        if (limit !== undefined) {
            queryParameters['limit'] = limit;
        }
        if (resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = resourceVersion;
        }
        if (timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = timeoutSeconds;
        }
        if (watch !== undefined) {
            queryParameters['watch'] = watch;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * delete collection of LimitRange
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param includeUninitialized If true, partially initialized resources are included in the response.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param timeoutSeconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    deleteCollectionNamespacedLimitRange(namespace, pretty, _continue, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch) {
        const localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/limitranges'
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling deleteCollectionNamespacedLimitRange.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (_continue !== undefined) {
            queryParameters['continue'] = _continue;
        }
        if (fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = fieldSelector;
        }
        if (includeUninitialized !== undefined) {
            queryParameters['includeUninitialized'] = includeUninitialized;
        }
        if (labelSelector !== undefined) {
            queryParameters['labelSelector'] = labelSelector;
        }
        if (limit !== undefined) {
            queryParameters['limit'] = limit;
        }
        if (resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = resourceVersion;
        }
        if (timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = timeoutSeconds;
        }
        if (watch !== undefined) {
            queryParameters['watch'] = watch;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * delete collection of PersistentVolumeClaim
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param includeUninitialized If true, partially initialized resources are included in the response.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param timeoutSeconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    deleteCollectionNamespacedPersistentVolumeClaim(namespace, pretty, _continue, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch) {
        const localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/persistentvolumeclaims'
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling deleteCollectionNamespacedPersistentVolumeClaim.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (_continue !== undefined) {
            queryParameters['continue'] = _continue;
        }
        if (fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = fieldSelector;
        }
        if (includeUninitialized !== undefined) {
            queryParameters['includeUninitialized'] = includeUninitialized;
        }
        if (labelSelector !== undefined) {
            queryParameters['labelSelector'] = labelSelector;
        }
        if (limit !== undefined) {
            queryParameters['limit'] = limit;
        }
        if (resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = resourceVersion;
        }
        if (timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = timeoutSeconds;
        }
        if (watch !== undefined) {
            queryParameters['watch'] = watch;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * delete collection of Pod
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param includeUninitialized If true, partially initialized resources are included in the response.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param timeoutSeconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    deleteCollectionNamespacedPod(namespace, pretty, _continue, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch) {
        const localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/pods'
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling deleteCollectionNamespacedPod.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (_continue !== undefined) {
            queryParameters['continue'] = _continue;
        }
        if (fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = fieldSelector;
        }
        if (includeUninitialized !== undefined) {
            queryParameters['includeUninitialized'] = includeUninitialized;
        }
        if (labelSelector !== undefined) {
            queryParameters['labelSelector'] = labelSelector;
        }
        if (limit !== undefined) {
            queryParameters['limit'] = limit;
        }
        if (resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = resourceVersion;
        }
        if (timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = timeoutSeconds;
        }
        if (watch !== undefined) {
            queryParameters['watch'] = watch;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * delete collection of PodTemplate
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param includeUninitialized If true, partially initialized resources are included in the response.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param timeoutSeconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    deleteCollectionNamespacedPodTemplate(namespace, pretty, _continue, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch) {
        const localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/podtemplates'
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling deleteCollectionNamespacedPodTemplate.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (_continue !== undefined) {
            queryParameters['continue'] = _continue;
        }
        if (fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = fieldSelector;
        }
        if (includeUninitialized !== undefined) {
            queryParameters['includeUninitialized'] = includeUninitialized;
        }
        if (labelSelector !== undefined) {
            queryParameters['labelSelector'] = labelSelector;
        }
        if (limit !== undefined) {
            queryParameters['limit'] = limit;
        }
        if (resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = resourceVersion;
        }
        if (timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = timeoutSeconds;
        }
        if (watch !== undefined) {
            queryParameters['watch'] = watch;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * delete collection of ReplicationController
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param includeUninitialized If true, partially initialized resources are included in the response.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param timeoutSeconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    deleteCollectionNamespacedReplicationController(namespace, pretty, _continue, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch) {
        const localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/replicationcontrollers'
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling deleteCollectionNamespacedReplicationController.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (_continue !== undefined) {
            queryParameters['continue'] = _continue;
        }
        if (fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = fieldSelector;
        }
        if (includeUninitialized !== undefined) {
            queryParameters['includeUninitialized'] = includeUninitialized;
        }
        if (labelSelector !== undefined) {
            queryParameters['labelSelector'] = labelSelector;
        }
        if (limit !== undefined) {
            queryParameters['limit'] = limit;
        }
        if (resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = resourceVersion;
        }
        if (timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = timeoutSeconds;
        }
        if (watch !== undefined) {
            queryParameters['watch'] = watch;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * delete collection of ResourceQuota
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param includeUninitialized If true, partially initialized resources are included in the response.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param timeoutSeconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    deleteCollectionNamespacedResourceQuota(namespace, pretty, _continue, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch) {
        const localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/resourcequotas'
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling deleteCollectionNamespacedResourceQuota.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (_continue !== undefined) {
            queryParameters['continue'] = _continue;
        }
        if (fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = fieldSelector;
        }
        if (includeUninitialized !== undefined) {
            queryParameters['includeUninitialized'] = includeUninitialized;
        }
        if (labelSelector !== undefined) {
            queryParameters['labelSelector'] = labelSelector;
        }
        if (limit !== undefined) {
            queryParameters['limit'] = limit;
        }
        if (resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = resourceVersion;
        }
        if (timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = timeoutSeconds;
        }
        if (watch !== undefined) {
            queryParameters['watch'] = watch;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * delete collection of Secret
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param includeUninitialized If true, partially initialized resources are included in the response.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param timeoutSeconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    deleteCollectionNamespacedSecret(namespace, pretty, _continue, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch) {
        const localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/secrets'
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling deleteCollectionNamespacedSecret.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (_continue !== undefined) {
            queryParameters['continue'] = _continue;
        }
        if (fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = fieldSelector;
        }
        if (includeUninitialized !== undefined) {
            queryParameters['includeUninitialized'] = includeUninitialized;
        }
        if (labelSelector !== undefined) {
            queryParameters['labelSelector'] = labelSelector;
        }
        if (limit !== undefined) {
            queryParameters['limit'] = limit;
        }
        if (resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = resourceVersion;
        }
        if (timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = timeoutSeconds;
        }
        if (watch !== undefined) {
            queryParameters['watch'] = watch;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * delete collection of ServiceAccount
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param includeUninitialized If true, partially initialized resources are included in the response.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param timeoutSeconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    deleteCollectionNamespacedServiceAccount(namespace, pretty, _continue, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch) {
        const localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/serviceaccounts'
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling deleteCollectionNamespacedServiceAccount.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (_continue !== undefined) {
            queryParameters['continue'] = _continue;
        }
        if (fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = fieldSelector;
        }
        if (includeUninitialized !== undefined) {
            queryParameters['includeUninitialized'] = includeUninitialized;
        }
        if (labelSelector !== undefined) {
            queryParameters['labelSelector'] = labelSelector;
        }
        if (limit !== undefined) {
            queryParameters['limit'] = limit;
        }
        if (resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = resourceVersion;
        }
        if (timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = timeoutSeconds;
        }
        if (watch !== undefined) {
            queryParameters['watch'] = watch;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * delete collection of Node
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param includeUninitialized If true, partially initialized resources are included in the response.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param timeoutSeconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    deleteCollectionNode(pretty, _continue, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch) {
        const localVarPath = this.basePath + '/api/v1/nodes';
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (_continue !== undefined) {
            queryParameters['continue'] = _continue;
        }
        if (fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = fieldSelector;
        }
        if (includeUninitialized !== undefined) {
            queryParameters['includeUninitialized'] = includeUninitialized;
        }
        if (labelSelector !== undefined) {
            queryParameters['labelSelector'] = labelSelector;
        }
        if (limit !== undefined) {
            queryParameters['limit'] = limit;
        }
        if (resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = resourceVersion;
        }
        if (timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = timeoutSeconds;
        }
        if (watch !== undefined) {
            queryParameters['watch'] = watch;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * delete collection of PersistentVolume
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param includeUninitialized If true, partially initialized resources are included in the response.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param timeoutSeconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    deleteCollectionPersistentVolume(pretty, _continue, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch) {
        const localVarPath = this.basePath + '/api/v1/persistentvolumes';
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (_continue !== undefined) {
            queryParameters['continue'] = _continue;
        }
        if (fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = fieldSelector;
        }
        if (includeUninitialized !== undefined) {
            queryParameters['includeUninitialized'] = includeUninitialized;
        }
        if (labelSelector !== undefined) {
            queryParameters['labelSelector'] = labelSelector;
        }
        if (limit !== undefined) {
            queryParameters['limit'] = limit;
        }
        if (resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = resourceVersion;
        }
        if (timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = timeoutSeconds;
        }
        if (watch !== undefined) {
            queryParameters['watch'] = watch;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * delete a Namespace
     * @param name name of the Namespace
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param gracePeriodSeconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @param orphanDependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @param propagationPolicy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
     */
    deleteNamespace(name, body, pretty, gracePeriodSeconds, orphanDependents, propagationPolicy) {
        const localVarPath = this.basePath + '/api/v1/namespaces/{name}'
            .replace('{' + 'name' + '}', String(name));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling deleteNamespace.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling deleteNamespace.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (gracePeriodSeconds !== undefined) {
            queryParameters['gracePeriodSeconds'] = gracePeriodSeconds;
        }
        if (orphanDependents !== undefined) {
            queryParameters['orphanDependents'] = orphanDependents;
        }
        if (propagationPolicy !== undefined) {
            queryParameters['propagationPolicy'] = propagationPolicy;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * delete a ConfigMap
     * @param name name of the ConfigMap
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param gracePeriodSeconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @param orphanDependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @param propagationPolicy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
     */
    deleteNamespacedConfigMap(name, namespace, body, pretty, gracePeriodSeconds, orphanDependents, propagationPolicy) {
        const localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/configmaps/{name}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling deleteNamespacedConfigMap.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling deleteNamespacedConfigMap.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling deleteNamespacedConfigMap.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (gracePeriodSeconds !== undefined) {
            queryParameters['gracePeriodSeconds'] = gracePeriodSeconds;
        }
        if (orphanDependents !== undefined) {
            queryParameters['orphanDependents'] = orphanDependents;
        }
        if (propagationPolicy !== undefined) {
            queryParameters['propagationPolicy'] = propagationPolicy;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * delete Endpoints
     * @param name name of the Endpoints
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param gracePeriodSeconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @param orphanDependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @param propagationPolicy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
     */
    deleteNamespacedEndpoints(name, namespace, body, pretty, gracePeriodSeconds, orphanDependents, propagationPolicy) {
        const localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/endpoints/{name}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling deleteNamespacedEndpoints.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling deleteNamespacedEndpoints.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling deleteNamespacedEndpoints.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (gracePeriodSeconds !== undefined) {
            queryParameters['gracePeriodSeconds'] = gracePeriodSeconds;
        }
        if (orphanDependents !== undefined) {
            queryParameters['orphanDependents'] = orphanDependents;
        }
        if (propagationPolicy !== undefined) {
            queryParameters['propagationPolicy'] = propagationPolicy;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * delete an Event
     * @param name name of the Event
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param gracePeriodSeconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @param orphanDependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @param propagationPolicy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
     */
    deleteNamespacedEvent(name, namespace, body, pretty, gracePeriodSeconds, orphanDependents, propagationPolicy) {
        const localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/events/{name}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling deleteNamespacedEvent.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling deleteNamespacedEvent.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling deleteNamespacedEvent.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (gracePeriodSeconds !== undefined) {
            queryParameters['gracePeriodSeconds'] = gracePeriodSeconds;
        }
        if (orphanDependents !== undefined) {
            queryParameters['orphanDependents'] = orphanDependents;
        }
        if (propagationPolicy !== undefined) {
            queryParameters['propagationPolicy'] = propagationPolicy;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * delete a LimitRange
     * @param name name of the LimitRange
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param gracePeriodSeconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @param orphanDependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @param propagationPolicy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
     */
    deleteNamespacedLimitRange(name, namespace, body, pretty, gracePeriodSeconds, orphanDependents, propagationPolicy) {
        const localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/limitranges/{name}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling deleteNamespacedLimitRange.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling deleteNamespacedLimitRange.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling deleteNamespacedLimitRange.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (gracePeriodSeconds !== undefined) {
            queryParameters['gracePeriodSeconds'] = gracePeriodSeconds;
        }
        if (orphanDependents !== undefined) {
            queryParameters['orphanDependents'] = orphanDependents;
        }
        if (propagationPolicy !== undefined) {
            queryParameters['propagationPolicy'] = propagationPolicy;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * delete a PersistentVolumeClaim
     * @param name name of the PersistentVolumeClaim
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param gracePeriodSeconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @param orphanDependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @param propagationPolicy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
     */
    deleteNamespacedPersistentVolumeClaim(name, namespace, body, pretty, gracePeriodSeconds, orphanDependents, propagationPolicy) {
        const localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/persistentvolumeclaims/{name}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling deleteNamespacedPersistentVolumeClaim.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling deleteNamespacedPersistentVolumeClaim.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling deleteNamespacedPersistentVolumeClaim.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (gracePeriodSeconds !== undefined) {
            queryParameters['gracePeriodSeconds'] = gracePeriodSeconds;
        }
        if (orphanDependents !== undefined) {
            queryParameters['orphanDependents'] = orphanDependents;
        }
        if (propagationPolicy !== undefined) {
            queryParameters['propagationPolicy'] = propagationPolicy;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * delete a Pod
     * @param name name of the Pod
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param gracePeriodSeconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @param orphanDependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @param propagationPolicy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
     */
    deleteNamespacedPod(name, namespace, body, pretty, gracePeriodSeconds, orphanDependents, propagationPolicy) {
        const localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/pods/{name}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling deleteNamespacedPod.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling deleteNamespacedPod.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling deleteNamespacedPod.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (gracePeriodSeconds !== undefined) {
            queryParameters['gracePeriodSeconds'] = gracePeriodSeconds;
        }
        if (orphanDependents !== undefined) {
            queryParameters['orphanDependents'] = orphanDependents;
        }
        if (propagationPolicy !== undefined) {
            queryParameters['propagationPolicy'] = propagationPolicy;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * delete a PodTemplate
     * @param name name of the PodTemplate
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param gracePeriodSeconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @param orphanDependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @param propagationPolicy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
     */
    deleteNamespacedPodTemplate(name, namespace, body, pretty, gracePeriodSeconds, orphanDependents, propagationPolicy) {
        const localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/podtemplates/{name}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling deleteNamespacedPodTemplate.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling deleteNamespacedPodTemplate.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling deleteNamespacedPodTemplate.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (gracePeriodSeconds !== undefined) {
            queryParameters['gracePeriodSeconds'] = gracePeriodSeconds;
        }
        if (orphanDependents !== undefined) {
            queryParameters['orphanDependents'] = orphanDependents;
        }
        if (propagationPolicy !== undefined) {
            queryParameters['propagationPolicy'] = propagationPolicy;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * delete a ReplicationController
     * @param name name of the ReplicationController
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param gracePeriodSeconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @param orphanDependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @param propagationPolicy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
     */
    deleteNamespacedReplicationController(name, namespace, body, pretty, gracePeriodSeconds, orphanDependents, propagationPolicy) {
        const localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/replicationcontrollers/{name}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling deleteNamespacedReplicationController.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling deleteNamespacedReplicationController.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling deleteNamespacedReplicationController.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (gracePeriodSeconds !== undefined) {
            queryParameters['gracePeriodSeconds'] = gracePeriodSeconds;
        }
        if (orphanDependents !== undefined) {
            queryParameters['orphanDependents'] = orphanDependents;
        }
        if (propagationPolicy !== undefined) {
            queryParameters['propagationPolicy'] = propagationPolicy;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * delete a ResourceQuota
     * @param name name of the ResourceQuota
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param gracePeriodSeconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @param orphanDependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @param propagationPolicy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
     */
    deleteNamespacedResourceQuota(name, namespace, body, pretty, gracePeriodSeconds, orphanDependents, propagationPolicy) {
        const localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/resourcequotas/{name}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling deleteNamespacedResourceQuota.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling deleteNamespacedResourceQuota.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling deleteNamespacedResourceQuota.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (gracePeriodSeconds !== undefined) {
            queryParameters['gracePeriodSeconds'] = gracePeriodSeconds;
        }
        if (orphanDependents !== undefined) {
            queryParameters['orphanDependents'] = orphanDependents;
        }
        if (propagationPolicy !== undefined) {
            queryParameters['propagationPolicy'] = propagationPolicy;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * delete a Secret
     * @param name name of the Secret
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param gracePeriodSeconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @param orphanDependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @param propagationPolicy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
     */
    deleteNamespacedSecret(name, namespace, body, pretty, gracePeriodSeconds, orphanDependents, propagationPolicy) {
        const localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/secrets/{name}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling deleteNamespacedSecret.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling deleteNamespacedSecret.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling deleteNamespacedSecret.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (gracePeriodSeconds !== undefined) {
            queryParameters['gracePeriodSeconds'] = gracePeriodSeconds;
        }
        if (orphanDependents !== undefined) {
            queryParameters['orphanDependents'] = orphanDependents;
        }
        if (propagationPolicy !== undefined) {
            queryParameters['propagationPolicy'] = propagationPolicy;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * delete a Service
     * @param name name of the Service
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param gracePeriodSeconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @param orphanDependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @param propagationPolicy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
     */
    deleteNamespacedService(name, namespace, body, pretty, gracePeriodSeconds, orphanDependents, propagationPolicy) {
        const localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/services/{name}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling deleteNamespacedService.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling deleteNamespacedService.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling deleteNamespacedService.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (gracePeriodSeconds !== undefined) {
            queryParameters['gracePeriodSeconds'] = gracePeriodSeconds;
        }
        if (orphanDependents !== undefined) {
            queryParameters['orphanDependents'] = orphanDependents;
        }
        if (propagationPolicy !== undefined) {
            queryParameters['propagationPolicy'] = propagationPolicy;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * delete a ServiceAccount
     * @param name name of the ServiceAccount
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param gracePeriodSeconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @param orphanDependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @param propagationPolicy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
     */
    deleteNamespacedServiceAccount(name, namespace, body, pretty, gracePeriodSeconds, orphanDependents, propagationPolicy) {
        const localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/serviceaccounts/{name}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling deleteNamespacedServiceAccount.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling deleteNamespacedServiceAccount.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling deleteNamespacedServiceAccount.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (gracePeriodSeconds !== undefined) {
            queryParameters['gracePeriodSeconds'] = gracePeriodSeconds;
        }
        if (orphanDependents !== undefined) {
            queryParameters['orphanDependents'] = orphanDependents;
        }
        if (propagationPolicy !== undefined) {
            queryParameters['propagationPolicy'] = propagationPolicy;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * delete a Node
     * @param name name of the Node
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param gracePeriodSeconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @param orphanDependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @param propagationPolicy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
     */
    deleteNode(name, body, pretty, gracePeriodSeconds, orphanDependents, propagationPolicy) {
        const localVarPath = this.basePath + '/api/v1/nodes/{name}'
            .replace('{' + 'name' + '}', String(name));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling deleteNode.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling deleteNode.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (gracePeriodSeconds !== undefined) {
            queryParameters['gracePeriodSeconds'] = gracePeriodSeconds;
        }
        if (orphanDependents !== undefined) {
            queryParameters['orphanDependents'] = orphanDependents;
        }
        if (propagationPolicy !== undefined) {
            queryParameters['propagationPolicy'] = propagationPolicy;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * delete a PersistentVolume
     * @param name name of the PersistentVolume
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param gracePeriodSeconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @param orphanDependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @param propagationPolicy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
     */
    deletePersistentVolume(name, body, pretty, gracePeriodSeconds, orphanDependents, propagationPolicy) {
        const localVarPath = this.basePath + '/api/v1/persistentvolumes/{name}'
            .replace('{' + 'name' + '}', String(name));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling deletePersistentVolume.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling deletePersistentVolume.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (gracePeriodSeconds !== undefined) {
            queryParameters['gracePeriodSeconds'] = gracePeriodSeconds;
        }
        if (orphanDependents !== undefined) {
            queryParameters['orphanDependents'] = orphanDependents;
        }
        if (propagationPolicy !== undefined) {
            queryParameters['propagationPolicy'] = propagationPolicy;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * get available resources
     */
    getAPIResources() {
        const localVarPath = this.basePath + '/api/v1/';
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        let useFormData = false;
        let requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * list objects of kind ComponentStatus
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param includeUninitialized If true, partially initialized resources are included in the response.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param timeoutSeconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    listComponentStatus(_continue, fieldSelector, includeUninitialized, labelSelector, limit, pretty, resourceVersion, timeoutSeconds, watch) {
        const localVarPath = this.basePath + '/api/v1/componentstatuses';
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        if (_continue !== undefined) {
            queryParameters['continue'] = _continue;
        }
        if (fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = fieldSelector;
        }
        if (includeUninitialized !== undefined) {
            queryParameters['includeUninitialized'] = includeUninitialized;
        }
        if (labelSelector !== undefined) {
            queryParameters['labelSelector'] = labelSelector;
        }
        if (limit !== undefined) {
            queryParameters['limit'] = limit;
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = resourceVersion;
        }
        if (timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = timeoutSeconds;
        }
        if (watch !== undefined) {
            queryParameters['watch'] = watch;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * list or watch objects of kind ConfigMap
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param includeUninitialized If true, partially initialized resources are included in the response.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param timeoutSeconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    listConfigMapForAllNamespaces(_continue, fieldSelector, includeUninitialized, labelSelector, limit, pretty, resourceVersion, timeoutSeconds, watch) {
        const localVarPath = this.basePath + '/api/v1/configmaps';
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        if (_continue !== undefined) {
            queryParameters['continue'] = _continue;
        }
        if (fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = fieldSelector;
        }
        if (includeUninitialized !== undefined) {
            queryParameters['includeUninitialized'] = includeUninitialized;
        }
        if (labelSelector !== undefined) {
            queryParameters['labelSelector'] = labelSelector;
        }
        if (limit !== undefined) {
            queryParameters['limit'] = limit;
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = resourceVersion;
        }
        if (timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = timeoutSeconds;
        }
        if (watch !== undefined) {
            queryParameters['watch'] = watch;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * list or watch objects of kind Endpoints
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param includeUninitialized If true, partially initialized resources are included in the response.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param timeoutSeconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    listEndpointsForAllNamespaces(_continue, fieldSelector, includeUninitialized, labelSelector, limit, pretty, resourceVersion, timeoutSeconds, watch) {
        const localVarPath = this.basePath + '/api/v1/endpoints';
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        if (_continue !== undefined) {
            queryParameters['continue'] = _continue;
        }
        if (fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = fieldSelector;
        }
        if (includeUninitialized !== undefined) {
            queryParameters['includeUninitialized'] = includeUninitialized;
        }
        if (labelSelector !== undefined) {
            queryParameters['labelSelector'] = labelSelector;
        }
        if (limit !== undefined) {
            queryParameters['limit'] = limit;
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = resourceVersion;
        }
        if (timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = timeoutSeconds;
        }
        if (watch !== undefined) {
            queryParameters['watch'] = watch;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * list or watch objects of kind Event
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param includeUninitialized If true, partially initialized resources are included in the response.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param timeoutSeconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    listEventForAllNamespaces(_continue, fieldSelector, includeUninitialized, labelSelector, limit, pretty, resourceVersion, timeoutSeconds, watch) {
        const localVarPath = this.basePath + '/api/v1/events';
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        if (_continue !== undefined) {
            queryParameters['continue'] = _continue;
        }
        if (fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = fieldSelector;
        }
        if (includeUninitialized !== undefined) {
            queryParameters['includeUninitialized'] = includeUninitialized;
        }
        if (labelSelector !== undefined) {
            queryParameters['labelSelector'] = labelSelector;
        }
        if (limit !== undefined) {
            queryParameters['limit'] = limit;
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = resourceVersion;
        }
        if (timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = timeoutSeconds;
        }
        if (watch !== undefined) {
            queryParameters['watch'] = watch;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * list or watch objects of kind LimitRange
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param includeUninitialized If true, partially initialized resources are included in the response.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param timeoutSeconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    listLimitRangeForAllNamespaces(_continue, fieldSelector, includeUninitialized, labelSelector, limit, pretty, resourceVersion, timeoutSeconds, watch) {
        const localVarPath = this.basePath + '/api/v1/limitranges';
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        if (_continue !== undefined) {
            queryParameters['continue'] = _continue;
        }
        if (fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = fieldSelector;
        }
        if (includeUninitialized !== undefined) {
            queryParameters['includeUninitialized'] = includeUninitialized;
        }
        if (labelSelector !== undefined) {
            queryParameters['labelSelector'] = labelSelector;
        }
        if (limit !== undefined) {
            queryParameters['limit'] = limit;
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = resourceVersion;
        }
        if (timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = timeoutSeconds;
        }
        if (watch !== undefined) {
            queryParameters['watch'] = watch;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * list or watch objects of kind Namespace
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param includeUninitialized If true, partially initialized resources are included in the response.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param timeoutSeconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    listNamespace(pretty, _continue, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch) {
        const localVarPath = this.basePath + '/api/v1/namespaces';
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (_continue !== undefined) {
            queryParameters['continue'] = _continue;
        }
        if (fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = fieldSelector;
        }
        if (includeUninitialized !== undefined) {
            queryParameters['includeUninitialized'] = includeUninitialized;
        }
        if (labelSelector !== undefined) {
            queryParameters['labelSelector'] = labelSelector;
        }
        if (limit !== undefined) {
            queryParameters['limit'] = limit;
        }
        if (resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = resourceVersion;
        }
        if (timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = timeoutSeconds;
        }
        if (watch !== undefined) {
            queryParameters['watch'] = watch;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * list or watch objects of kind ConfigMap
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param includeUninitialized If true, partially initialized resources are included in the response.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param timeoutSeconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    listNamespacedConfigMap(namespace, pretty, _continue, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch) {
        const localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/configmaps'
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling listNamespacedConfigMap.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (_continue !== undefined) {
            queryParameters['continue'] = _continue;
        }
        if (fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = fieldSelector;
        }
        if (includeUninitialized !== undefined) {
            queryParameters['includeUninitialized'] = includeUninitialized;
        }
        if (labelSelector !== undefined) {
            queryParameters['labelSelector'] = labelSelector;
        }
        if (limit !== undefined) {
            queryParameters['limit'] = limit;
        }
        if (resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = resourceVersion;
        }
        if (timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = timeoutSeconds;
        }
        if (watch !== undefined) {
            queryParameters['watch'] = watch;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * list or watch objects of kind Endpoints
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param includeUninitialized If true, partially initialized resources are included in the response.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param timeoutSeconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    listNamespacedEndpoints(namespace, pretty, _continue, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch) {
        const localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/endpoints'
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling listNamespacedEndpoints.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (_continue !== undefined) {
            queryParameters['continue'] = _continue;
        }
        if (fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = fieldSelector;
        }
        if (includeUninitialized !== undefined) {
            queryParameters['includeUninitialized'] = includeUninitialized;
        }
        if (labelSelector !== undefined) {
            queryParameters['labelSelector'] = labelSelector;
        }
        if (limit !== undefined) {
            queryParameters['limit'] = limit;
        }
        if (resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = resourceVersion;
        }
        if (timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = timeoutSeconds;
        }
        if (watch !== undefined) {
            queryParameters['watch'] = watch;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * list or watch objects of kind Event
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param includeUninitialized If true, partially initialized resources are included in the response.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param timeoutSeconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    listNamespacedEvent(namespace, pretty, _continue, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch) {
        const localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/events'
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling listNamespacedEvent.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (_continue !== undefined) {
            queryParameters['continue'] = _continue;
        }
        if (fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = fieldSelector;
        }
        if (includeUninitialized !== undefined) {
            queryParameters['includeUninitialized'] = includeUninitialized;
        }
        if (labelSelector !== undefined) {
            queryParameters['labelSelector'] = labelSelector;
        }
        if (limit !== undefined) {
            queryParameters['limit'] = limit;
        }
        if (resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = resourceVersion;
        }
        if (timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = timeoutSeconds;
        }
        if (watch !== undefined) {
            queryParameters['watch'] = watch;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * list or watch objects of kind LimitRange
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param includeUninitialized If true, partially initialized resources are included in the response.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param timeoutSeconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    listNamespacedLimitRange(namespace, pretty, _continue, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch) {
        const localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/limitranges'
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling listNamespacedLimitRange.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (_continue !== undefined) {
            queryParameters['continue'] = _continue;
        }
        if (fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = fieldSelector;
        }
        if (includeUninitialized !== undefined) {
            queryParameters['includeUninitialized'] = includeUninitialized;
        }
        if (labelSelector !== undefined) {
            queryParameters['labelSelector'] = labelSelector;
        }
        if (limit !== undefined) {
            queryParameters['limit'] = limit;
        }
        if (resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = resourceVersion;
        }
        if (timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = timeoutSeconds;
        }
        if (watch !== undefined) {
            queryParameters['watch'] = watch;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * list or watch objects of kind PersistentVolumeClaim
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param includeUninitialized If true, partially initialized resources are included in the response.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param timeoutSeconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    listNamespacedPersistentVolumeClaim(namespace, pretty, _continue, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch) {
        const localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/persistentvolumeclaims'
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling listNamespacedPersistentVolumeClaim.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (_continue !== undefined) {
            queryParameters['continue'] = _continue;
        }
        if (fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = fieldSelector;
        }
        if (includeUninitialized !== undefined) {
            queryParameters['includeUninitialized'] = includeUninitialized;
        }
        if (labelSelector !== undefined) {
            queryParameters['labelSelector'] = labelSelector;
        }
        if (limit !== undefined) {
            queryParameters['limit'] = limit;
        }
        if (resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = resourceVersion;
        }
        if (timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = timeoutSeconds;
        }
        if (watch !== undefined) {
            queryParameters['watch'] = watch;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * list or watch objects of kind Pod
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param includeUninitialized If true, partially initialized resources are included in the response.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param timeoutSeconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    listNamespacedPod(namespace, pretty, _continue, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch) {
        const localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/pods'
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling listNamespacedPod.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (_continue !== undefined) {
            queryParameters['continue'] = _continue;
        }
        if (fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = fieldSelector;
        }
        if (includeUninitialized !== undefined) {
            queryParameters['includeUninitialized'] = includeUninitialized;
        }
        if (labelSelector !== undefined) {
            queryParameters['labelSelector'] = labelSelector;
        }
        if (limit !== undefined) {
            queryParameters['limit'] = limit;
        }
        if (resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = resourceVersion;
        }
        if (timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = timeoutSeconds;
        }
        if (watch !== undefined) {
            queryParameters['watch'] = watch;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * list or watch objects of kind PodTemplate
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param includeUninitialized If true, partially initialized resources are included in the response.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param timeoutSeconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    listNamespacedPodTemplate(namespace, pretty, _continue, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch) {
        const localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/podtemplates'
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling listNamespacedPodTemplate.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (_continue !== undefined) {
            queryParameters['continue'] = _continue;
        }
        if (fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = fieldSelector;
        }
        if (includeUninitialized !== undefined) {
            queryParameters['includeUninitialized'] = includeUninitialized;
        }
        if (labelSelector !== undefined) {
            queryParameters['labelSelector'] = labelSelector;
        }
        if (limit !== undefined) {
            queryParameters['limit'] = limit;
        }
        if (resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = resourceVersion;
        }
        if (timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = timeoutSeconds;
        }
        if (watch !== undefined) {
            queryParameters['watch'] = watch;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * list or watch objects of kind ReplicationController
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param includeUninitialized If true, partially initialized resources are included in the response.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param timeoutSeconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    listNamespacedReplicationController(namespace, pretty, _continue, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch) {
        const localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/replicationcontrollers'
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling listNamespacedReplicationController.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (_continue !== undefined) {
            queryParameters['continue'] = _continue;
        }
        if (fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = fieldSelector;
        }
        if (includeUninitialized !== undefined) {
            queryParameters['includeUninitialized'] = includeUninitialized;
        }
        if (labelSelector !== undefined) {
            queryParameters['labelSelector'] = labelSelector;
        }
        if (limit !== undefined) {
            queryParameters['limit'] = limit;
        }
        if (resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = resourceVersion;
        }
        if (timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = timeoutSeconds;
        }
        if (watch !== undefined) {
            queryParameters['watch'] = watch;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * list or watch objects of kind ResourceQuota
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param includeUninitialized If true, partially initialized resources are included in the response.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param timeoutSeconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    listNamespacedResourceQuota(namespace, pretty, _continue, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch) {
        const localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/resourcequotas'
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling listNamespacedResourceQuota.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (_continue !== undefined) {
            queryParameters['continue'] = _continue;
        }
        if (fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = fieldSelector;
        }
        if (includeUninitialized !== undefined) {
            queryParameters['includeUninitialized'] = includeUninitialized;
        }
        if (labelSelector !== undefined) {
            queryParameters['labelSelector'] = labelSelector;
        }
        if (limit !== undefined) {
            queryParameters['limit'] = limit;
        }
        if (resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = resourceVersion;
        }
        if (timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = timeoutSeconds;
        }
        if (watch !== undefined) {
            queryParameters['watch'] = watch;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * list or watch objects of kind Secret
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param includeUninitialized If true, partially initialized resources are included in the response.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param timeoutSeconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    listNamespacedSecret(namespace, pretty, _continue, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch) {
        const localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/secrets'
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling listNamespacedSecret.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (_continue !== undefined) {
            queryParameters['continue'] = _continue;
        }
        if (fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = fieldSelector;
        }
        if (includeUninitialized !== undefined) {
            queryParameters['includeUninitialized'] = includeUninitialized;
        }
        if (labelSelector !== undefined) {
            queryParameters['labelSelector'] = labelSelector;
        }
        if (limit !== undefined) {
            queryParameters['limit'] = limit;
        }
        if (resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = resourceVersion;
        }
        if (timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = timeoutSeconds;
        }
        if (watch !== undefined) {
            queryParameters['watch'] = watch;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * list or watch objects of kind Service
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param includeUninitialized If true, partially initialized resources are included in the response.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param timeoutSeconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    listNamespacedService(namespace, pretty, _continue, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch) {
        const localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/services'
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling listNamespacedService.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (_continue !== undefined) {
            queryParameters['continue'] = _continue;
        }
        if (fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = fieldSelector;
        }
        if (includeUninitialized !== undefined) {
            queryParameters['includeUninitialized'] = includeUninitialized;
        }
        if (labelSelector !== undefined) {
            queryParameters['labelSelector'] = labelSelector;
        }
        if (limit !== undefined) {
            queryParameters['limit'] = limit;
        }
        if (resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = resourceVersion;
        }
        if (timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = timeoutSeconds;
        }
        if (watch !== undefined) {
            queryParameters['watch'] = watch;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * list or watch objects of kind ServiceAccount
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param includeUninitialized If true, partially initialized resources are included in the response.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param timeoutSeconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    listNamespacedServiceAccount(namespace, pretty, _continue, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch) {
        const localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/serviceaccounts'
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling listNamespacedServiceAccount.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (_continue !== undefined) {
            queryParameters['continue'] = _continue;
        }
        if (fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = fieldSelector;
        }
        if (includeUninitialized !== undefined) {
            queryParameters['includeUninitialized'] = includeUninitialized;
        }
        if (labelSelector !== undefined) {
            queryParameters['labelSelector'] = labelSelector;
        }
        if (limit !== undefined) {
            queryParameters['limit'] = limit;
        }
        if (resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = resourceVersion;
        }
        if (timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = timeoutSeconds;
        }
        if (watch !== undefined) {
            queryParameters['watch'] = watch;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * list or watch objects of kind Node
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param includeUninitialized If true, partially initialized resources are included in the response.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param timeoutSeconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    listNode(pretty, _continue, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch) {
        const localVarPath = this.basePath + '/api/v1/nodes';
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (_continue !== undefined) {
            queryParameters['continue'] = _continue;
        }
        if (fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = fieldSelector;
        }
        if (includeUninitialized !== undefined) {
            queryParameters['includeUninitialized'] = includeUninitialized;
        }
        if (labelSelector !== undefined) {
            queryParameters['labelSelector'] = labelSelector;
        }
        if (limit !== undefined) {
            queryParameters['limit'] = limit;
        }
        if (resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = resourceVersion;
        }
        if (timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = timeoutSeconds;
        }
        if (watch !== undefined) {
            queryParameters['watch'] = watch;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * list or watch objects of kind PersistentVolume
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param includeUninitialized If true, partially initialized resources are included in the response.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param timeoutSeconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    listPersistentVolume(pretty, _continue, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch) {
        const localVarPath = this.basePath + '/api/v1/persistentvolumes';
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (_continue !== undefined) {
            queryParameters['continue'] = _continue;
        }
        if (fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = fieldSelector;
        }
        if (includeUninitialized !== undefined) {
            queryParameters['includeUninitialized'] = includeUninitialized;
        }
        if (labelSelector !== undefined) {
            queryParameters['labelSelector'] = labelSelector;
        }
        if (limit !== undefined) {
            queryParameters['limit'] = limit;
        }
        if (resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = resourceVersion;
        }
        if (timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = timeoutSeconds;
        }
        if (watch !== undefined) {
            queryParameters['watch'] = watch;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * list or watch objects of kind PersistentVolumeClaim
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param includeUninitialized If true, partially initialized resources are included in the response.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param timeoutSeconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    listPersistentVolumeClaimForAllNamespaces(_continue, fieldSelector, includeUninitialized, labelSelector, limit, pretty, resourceVersion, timeoutSeconds, watch) {
        const localVarPath = this.basePath + '/api/v1/persistentvolumeclaims';
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        if (_continue !== undefined) {
            queryParameters['continue'] = _continue;
        }
        if (fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = fieldSelector;
        }
        if (includeUninitialized !== undefined) {
            queryParameters['includeUninitialized'] = includeUninitialized;
        }
        if (labelSelector !== undefined) {
            queryParameters['labelSelector'] = labelSelector;
        }
        if (limit !== undefined) {
            queryParameters['limit'] = limit;
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = resourceVersion;
        }
        if (timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = timeoutSeconds;
        }
        if (watch !== undefined) {
            queryParameters['watch'] = watch;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * list or watch objects of kind Pod
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param includeUninitialized If true, partially initialized resources are included in the response.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param timeoutSeconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    listPodForAllNamespaces(_continue, fieldSelector, includeUninitialized, labelSelector, limit, pretty, resourceVersion, timeoutSeconds, watch) {
        const localVarPath = this.basePath + '/api/v1/pods';
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        if (_continue !== undefined) {
            queryParameters['continue'] = _continue;
        }
        if (fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = fieldSelector;
        }
        if (includeUninitialized !== undefined) {
            queryParameters['includeUninitialized'] = includeUninitialized;
        }
        if (labelSelector !== undefined) {
            queryParameters['labelSelector'] = labelSelector;
        }
        if (limit !== undefined) {
            queryParameters['limit'] = limit;
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = resourceVersion;
        }
        if (timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = timeoutSeconds;
        }
        if (watch !== undefined) {
            queryParameters['watch'] = watch;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * list or watch objects of kind PodTemplate
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param includeUninitialized If true, partially initialized resources are included in the response.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param timeoutSeconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    listPodTemplateForAllNamespaces(_continue, fieldSelector, includeUninitialized, labelSelector, limit, pretty, resourceVersion, timeoutSeconds, watch) {
        const localVarPath = this.basePath + '/api/v1/podtemplates';
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        if (_continue !== undefined) {
            queryParameters['continue'] = _continue;
        }
        if (fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = fieldSelector;
        }
        if (includeUninitialized !== undefined) {
            queryParameters['includeUninitialized'] = includeUninitialized;
        }
        if (labelSelector !== undefined) {
            queryParameters['labelSelector'] = labelSelector;
        }
        if (limit !== undefined) {
            queryParameters['limit'] = limit;
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = resourceVersion;
        }
        if (timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = timeoutSeconds;
        }
        if (watch !== undefined) {
            queryParameters['watch'] = watch;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * list or watch objects of kind ReplicationController
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param includeUninitialized If true, partially initialized resources are included in the response.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param timeoutSeconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    listReplicationControllerForAllNamespaces(_continue, fieldSelector, includeUninitialized, labelSelector, limit, pretty, resourceVersion, timeoutSeconds, watch) {
        const localVarPath = this.basePath + '/api/v1/replicationcontrollers';
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        if (_continue !== undefined) {
            queryParameters['continue'] = _continue;
        }
        if (fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = fieldSelector;
        }
        if (includeUninitialized !== undefined) {
            queryParameters['includeUninitialized'] = includeUninitialized;
        }
        if (labelSelector !== undefined) {
            queryParameters['labelSelector'] = labelSelector;
        }
        if (limit !== undefined) {
            queryParameters['limit'] = limit;
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = resourceVersion;
        }
        if (timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = timeoutSeconds;
        }
        if (watch !== undefined) {
            queryParameters['watch'] = watch;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * list or watch objects of kind ResourceQuota
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param includeUninitialized If true, partially initialized resources are included in the response.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param timeoutSeconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    listResourceQuotaForAllNamespaces(_continue, fieldSelector, includeUninitialized, labelSelector, limit, pretty, resourceVersion, timeoutSeconds, watch) {
        const localVarPath = this.basePath + '/api/v1/resourcequotas';
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        if (_continue !== undefined) {
            queryParameters['continue'] = _continue;
        }
        if (fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = fieldSelector;
        }
        if (includeUninitialized !== undefined) {
            queryParameters['includeUninitialized'] = includeUninitialized;
        }
        if (labelSelector !== undefined) {
            queryParameters['labelSelector'] = labelSelector;
        }
        if (limit !== undefined) {
            queryParameters['limit'] = limit;
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = resourceVersion;
        }
        if (timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = timeoutSeconds;
        }
        if (watch !== undefined) {
            queryParameters['watch'] = watch;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * list or watch objects of kind Secret
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param includeUninitialized If true, partially initialized resources are included in the response.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param timeoutSeconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    listSecretForAllNamespaces(_continue, fieldSelector, includeUninitialized, labelSelector, limit, pretty, resourceVersion, timeoutSeconds, watch) {
        const localVarPath = this.basePath + '/api/v1/secrets';
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        if (_continue !== undefined) {
            queryParameters['continue'] = _continue;
        }
        if (fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = fieldSelector;
        }
        if (includeUninitialized !== undefined) {
            queryParameters['includeUninitialized'] = includeUninitialized;
        }
        if (labelSelector !== undefined) {
            queryParameters['labelSelector'] = labelSelector;
        }
        if (limit !== undefined) {
            queryParameters['limit'] = limit;
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = resourceVersion;
        }
        if (timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = timeoutSeconds;
        }
        if (watch !== undefined) {
            queryParameters['watch'] = watch;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * list or watch objects of kind ServiceAccount
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param includeUninitialized If true, partially initialized resources are included in the response.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param timeoutSeconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    listServiceAccountForAllNamespaces(_continue, fieldSelector, includeUninitialized, labelSelector, limit, pretty, resourceVersion, timeoutSeconds, watch) {
        const localVarPath = this.basePath + '/api/v1/serviceaccounts';
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        if (_continue !== undefined) {
            queryParameters['continue'] = _continue;
        }
        if (fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = fieldSelector;
        }
        if (includeUninitialized !== undefined) {
            queryParameters['includeUninitialized'] = includeUninitialized;
        }
        if (labelSelector !== undefined) {
            queryParameters['labelSelector'] = labelSelector;
        }
        if (limit !== undefined) {
            queryParameters['limit'] = limit;
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = resourceVersion;
        }
        if (timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = timeoutSeconds;
        }
        if (watch !== undefined) {
            queryParameters['watch'] = watch;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * list or watch objects of kind Service
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param includeUninitialized If true, partially initialized resources are included in the response.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param timeoutSeconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    listServiceForAllNamespaces(_continue, fieldSelector, includeUninitialized, labelSelector, limit, pretty, resourceVersion, timeoutSeconds, watch) {
        const localVarPath = this.basePath + '/api/v1/services';
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        if (_continue !== undefined) {
            queryParameters['continue'] = _continue;
        }
        if (fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = fieldSelector;
        }
        if (includeUninitialized !== undefined) {
            queryParameters['includeUninitialized'] = includeUninitialized;
        }
        if (labelSelector !== undefined) {
            queryParameters['labelSelector'] = labelSelector;
        }
        if (limit !== undefined) {
            queryParameters['limit'] = limit;
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = resourceVersion;
        }
        if (timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = timeoutSeconds;
        }
        if (watch !== undefined) {
            queryParameters['watch'] = watch;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * partially update the specified Namespace
     * @param name name of the Namespace
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    patchNamespace(name, body, pretty) {
        const localVarPath = this.basePath + '/api/v1/namespaces/{name}'
            .replace('{' + 'name' + '}', String(name));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling patchNamespace.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling patchNamespace.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'PATCH',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * partially update status of the specified Namespace
     * @param name name of the Namespace
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    patchNamespaceStatus(name, body, pretty) {
        const localVarPath = this.basePath + '/api/v1/namespaces/{name}/status'
            .replace('{' + 'name' + '}', String(name));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling patchNamespaceStatus.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling patchNamespaceStatus.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'PATCH',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * partially update the specified ConfigMap
     * @param name name of the ConfigMap
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    patchNamespacedConfigMap(name, namespace, body, pretty) {
        const localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/configmaps/{name}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling patchNamespacedConfigMap.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling patchNamespacedConfigMap.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling patchNamespacedConfigMap.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'PATCH',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * partially update the specified Endpoints
     * @param name name of the Endpoints
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    patchNamespacedEndpoints(name, namespace, body, pretty) {
        const localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/endpoints/{name}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling patchNamespacedEndpoints.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling patchNamespacedEndpoints.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling patchNamespacedEndpoints.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'PATCH',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * partially update the specified Event
     * @param name name of the Event
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    patchNamespacedEvent(name, namespace, body, pretty) {
        const localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/events/{name}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling patchNamespacedEvent.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling patchNamespacedEvent.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling patchNamespacedEvent.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'PATCH',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * partially update the specified LimitRange
     * @param name name of the LimitRange
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    patchNamespacedLimitRange(name, namespace, body, pretty) {
        const localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/limitranges/{name}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling patchNamespacedLimitRange.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling patchNamespacedLimitRange.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling patchNamespacedLimitRange.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'PATCH',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * partially update the specified PersistentVolumeClaim
     * @param name name of the PersistentVolumeClaim
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    patchNamespacedPersistentVolumeClaim(name, namespace, body, pretty) {
        const localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/persistentvolumeclaims/{name}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling patchNamespacedPersistentVolumeClaim.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling patchNamespacedPersistentVolumeClaim.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling patchNamespacedPersistentVolumeClaim.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'PATCH',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * partially update status of the specified PersistentVolumeClaim
     * @param name name of the PersistentVolumeClaim
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    patchNamespacedPersistentVolumeClaimStatus(name, namespace, body, pretty) {
        const localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/persistentvolumeclaims/{name}/status'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling patchNamespacedPersistentVolumeClaimStatus.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling patchNamespacedPersistentVolumeClaimStatus.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling patchNamespacedPersistentVolumeClaimStatus.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'PATCH',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * partially update the specified Pod
     * @param name name of the Pod
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    patchNamespacedPod(name, namespace, body, pretty) {
        const localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/pods/{name}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling patchNamespacedPod.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling patchNamespacedPod.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling patchNamespacedPod.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'PATCH',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * partially update status of the specified Pod
     * @param name name of the Pod
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    patchNamespacedPodStatus(name, namespace, body, pretty) {
        const localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/pods/{name}/status'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling patchNamespacedPodStatus.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling patchNamespacedPodStatus.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling patchNamespacedPodStatus.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'PATCH',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * partially update the specified PodTemplate
     * @param name name of the PodTemplate
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    patchNamespacedPodTemplate(name, namespace, body, pretty) {
        const localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/podtemplates/{name}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling patchNamespacedPodTemplate.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling patchNamespacedPodTemplate.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling patchNamespacedPodTemplate.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'PATCH',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * partially update the specified ReplicationController
     * @param name name of the ReplicationController
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    patchNamespacedReplicationController(name, namespace, body, pretty) {
        const localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/replicationcontrollers/{name}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling patchNamespacedReplicationController.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling patchNamespacedReplicationController.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling patchNamespacedReplicationController.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'PATCH',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * partially update scale of the specified ReplicationController
     * @param name name of the Scale
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    patchNamespacedReplicationControllerScale(name, namespace, body, pretty) {
        const localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/replicationcontrollers/{name}/scale'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling patchNamespacedReplicationControllerScale.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling patchNamespacedReplicationControllerScale.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling patchNamespacedReplicationControllerScale.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'PATCH',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * partially update status of the specified ReplicationController
     * @param name name of the ReplicationController
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    patchNamespacedReplicationControllerStatus(name, namespace, body, pretty) {
        const localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/replicationcontrollers/{name}/status'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling patchNamespacedReplicationControllerStatus.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling patchNamespacedReplicationControllerStatus.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling patchNamespacedReplicationControllerStatus.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'PATCH',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * partially update the specified ResourceQuota
     * @param name name of the ResourceQuota
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    patchNamespacedResourceQuota(name, namespace, body, pretty) {
        const localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/resourcequotas/{name}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling patchNamespacedResourceQuota.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling patchNamespacedResourceQuota.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling patchNamespacedResourceQuota.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'PATCH',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * partially update status of the specified ResourceQuota
     * @param name name of the ResourceQuota
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    patchNamespacedResourceQuotaStatus(name, namespace, body, pretty) {
        const localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/resourcequotas/{name}/status'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling patchNamespacedResourceQuotaStatus.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling patchNamespacedResourceQuotaStatus.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling patchNamespacedResourceQuotaStatus.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'PATCH',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * partially update the specified Secret
     * @param name name of the Secret
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    patchNamespacedSecret(name, namespace, body, pretty) {
        const localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/secrets/{name}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling patchNamespacedSecret.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling patchNamespacedSecret.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling patchNamespacedSecret.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'PATCH',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * partially update the specified Service
     * @param name name of the Service
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    patchNamespacedService(name, namespace, body, pretty) {
        const localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/services/{name}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling patchNamespacedService.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling patchNamespacedService.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling patchNamespacedService.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'PATCH',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * partially update the specified ServiceAccount
     * @param name name of the ServiceAccount
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    patchNamespacedServiceAccount(name, namespace, body, pretty) {
        const localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/serviceaccounts/{name}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling patchNamespacedServiceAccount.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling patchNamespacedServiceAccount.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling patchNamespacedServiceAccount.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'PATCH',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * partially update status of the specified Service
     * @param name name of the Service
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    patchNamespacedServiceStatus(name, namespace, body, pretty) {
        const localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/services/{name}/status'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling patchNamespacedServiceStatus.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling patchNamespacedServiceStatus.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling patchNamespacedServiceStatus.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'PATCH',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * partially update the specified Node
     * @param name name of the Node
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    patchNode(name, body, pretty) {
        const localVarPath = this.basePath + '/api/v1/nodes/{name}'
            .replace('{' + 'name' + '}', String(name));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling patchNode.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling patchNode.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'PATCH',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * partially update status of the specified Node
     * @param name name of the Node
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    patchNodeStatus(name, body, pretty) {
        const localVarPath = this.basePath + '/api/v1/nodes/{name}/status'
            .replace('{' + 'name' + '}', String(name));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling patchNodeStatus.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling patchNodeStatus.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'PATCH',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * partially update the specified PersistentVolume
     * @param name name of the PersistentVolume
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    patchPersistentVolume(name, body, pretty) {
        const localVarPath = this.basePath + '/api/v1/persistentvolumes/{name}'
            .replace('{' + 'name' + '}', String(name));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling patchPersistentVolume.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling patchPersistentVolume.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'PATCH',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * partially update status of the specified PersistentVolume
     * @param name name of the PersistentVolume
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    patchPersistentVolumeStatus(name, body, pretty) {
        const localVarPath = this.basePath + '/api/v1/persistentvolumes/{name}/status'
            .replace('{' + 'name' + '}', String(name));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling patchPersistentVolumeStatus.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling patchPersistentVolumeStatus.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'PATCH',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * read the specified ComponentStatus
     * @param name name of the ComponentStatus
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    readComponentStatus(name, pretty) {
        const localVarPath = this.basePath + '/api/v1/componentstatuses/{name}'
            .replace('{' + 'name' + '}', String(name));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling readComponentStatus.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * read the specified Namespace
     * @param name name of the Namespace
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param exact Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;.
     * @param _export Should this value be exported.  Export strips fields that a user can not specify.
     */
    readNamespace(name, pretty, exact, _export) {
        const localVarPath = this.basePath + '/api/v1/namespaces/{name}'
            .replace('{' + 'name' + '}', String(name));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling readNamespace.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (exact !== undefined) {
            queryParameters['exact'] = exact;
        }
        if (_export !== undefined) {
            queryParameters['export'] = _export;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * read status of the specified Namespace
     * @param name name of the Namespace
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    readNamespaceStatus(name, pretty) {
        const localVarPath = this.basePath + '/api/v1/namespaces/{name}/status'
            .replace('{' + 'name' + '}', String(name));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling readNamespaceStatus.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * read the specified ConfigMap
     * @param name name of the ConfigMap
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param exact Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;.
     * @param _export Should this value be exported.  Export strips fields that a user can not specify.
     */
    readNamespacedConfigMap(name, namespace, pretty, exact, _export) {
        const localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/configmaps/{name}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling readNamespacedConfigMap.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling readNamespacedConfigMap.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (exact !== undefined) {
            queryParameters['exact'] = exact;
        }
        if (_export !== undefined) {
            queryParameters['export'] = _export;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * read the specified Endpoints
     * @param name name of the Endpoints
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param exact Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;.
     * @param _export Should this value be exported.  Export strips fields that a user can not specify.
     */
    readNamespacedEndpoints(name, namespace, pretty, exact, _export) {
        const localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/endpoints/{name}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling readNamespacedEndpoints.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling readNamespacedEndpoints.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (exact !== undefined) {
            queryParameters['exact'] = exact;
        }
        if (_export !== undefined) {
            queryParameters['export'] = _export;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * read the specified Event
     * @param name name of the Event
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param exact Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;.
     * @param _export Should this value be exported.  Export strips fields that a user can not specify.
     */
    readNamespacedEvent(name, namespace, pretty, exact, _export) {
        const localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/events/{name}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling readNamespacedEvent.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling readNamespacedEvent.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (exact !== undefined) {
            queryParameters['exact'] = exact;
        }
        if (_export !== undefined) {
            queryParameters['export'] = _export;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * read the specified LimitRange
     * @param name name of the LimitRange
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param exact Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;.
     * @param _export Should this value be exported.  Export strips fields that a user can not specify.
     */
    readNamespacedLimitRange(name, namespace, pretty, exact, _export) {
        const localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/limitranges/{name}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling readNamespacedLimitRange.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling readNamespacedLimitRange.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (exact !== undefined) {
            queryParameters['exact'] = exact;
        }
        if (_export !== undefined) {
            queryParameters['export'] = _export;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * read the specified PersistentVolumeClaim
     * @param name name of the PersistentVolumeClaim
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param exact Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;.
     * @param _export Should this value be exported.  Export strips fields that a user can not specify.
     */
    readNamespacedPersistentVolumeClaim(name, namespace, pretty, exact, _export) {
        const localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/persistentvolumeclaims/{name}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling readNamespacedPersistentVolumeClaim.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling readNamespacedPersistentVolumeClaim.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (exact !== undefined) {
            queryParameters['exact'] = exact;
        }
        if (_export !== undefined) {
            queryParameters['export'] = _export;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * read status of the specified PersistentVolumeClaim
     * @param name name of the PersistentVolumeClaim
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    readNamespacedPersistentVolumeClaimStatus(name, namespace, pretty) {
        const localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/persistentvolumeclaims/{name}/status'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling readNamespacedPersistentVolumeClaimStatus.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling readNamespacedPersistentVolumeClaimStatus.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * read the specified Pod
     * @param name name of the Pod
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param exact Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;.
     * @param _export Should this value be exported.  Export strips fields that a user can not specify.
     */
    readNamespacedPod(name, namespace, pretty, exact, _export) {
        const localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/pods/{name}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling readNamespacedPod.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling readNamespacedPod.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (exact !== undefined) {
            queryParameters['exact'] = exact;
        }
        if (_export !== undefined) {
            queryParameters['export'] = _export;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * read log of the specified Pod
     * @param name name of the Pod
     * @param namespace object name and auth scope, such as for teams and projects
     * @param container The container for which to stream logs. Defaults to only container if there is one container in the pod.
     * @param follow Follow the log stream of the pod. Defaults to false.
     * @param limitBytes If set, the number of bytes to read from the server before terminating the log output. This may not display a complete final line of logging, and may return slightly more or slightly less than the specified limit.
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param previous Return previous terminated container logs. Defaults to false.
     * @param sinceSeconds A relative time in seconds before the current time from which to show logs. If this value precedes the time a pod was started, only logs since the pod start will be returned. If this value is in the future, no logs will be returned. Only one of sinceSeconds or sinceTime may be specified.
     * @param tailLines If set, the number of lines from the end of the logs to show. If not specified, logs are shown from the creation of the container or sinceSeconds or sinceTime
     * @param timestamps If true, add an RFC3339 or RFC3339Nano timestamp at the beginning of every line of log output. Defaults to false.
     */
    readNamespacedPodLog(name, namespace, container, follow, limitBytes, pretty, previous, sinceSeconds, tailLines, timestamps) {
        const localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/pods/{name}/log'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling readNamespacedPodLog.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling readNamespacedPodLog.');
        }
        if (container !== undefined) {
            queryParameters['container'] = container;
        }
        if (follow !== undefined) {
            queryParameters['follow'] = follow;
        }
        if (limitBytes !== undefined) {
            queryParameters['limitBytes'] = limitBytes;
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (previous !== undefined) {
            queryParameters['previous'] = previous;
        }
        if (sinceSeconds !== undefined) {
            queryParameters['sinceSeconds'] = sinceSeconds;
        }
        if (tailLines !== undefined) {
            queryParameters['tailLines'] = tailLines;
        }
        if (timestamps !== undefined) {
            queryParameters['timestamps'] = timestamps;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * read status of the specified Pod
     * @param name name of the Pod
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    readNamespacedPodStatus(name, namespace, pretty) {
        const localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/pods/{name}/status'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling readNamespacedPodStatus.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling readNamespacedPodStatus.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * read the specified PodTemplate
     * @param name name of the PodTemplate
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param exact Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;.
     * @param _export Should this value be exported.  Export strips fields that a user can not specify.
     */
    readNamespacedPodTemplate(name, namespace, pretty, exact, _export) {
        const localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/podtemplates/{name}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling readNamespacedPodTemplate.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling readNamespacedPodTemplate.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (exact !== undefined) {
            queryParameters['exact'] = exact;
        }
        if (_export !== undefined) {
            queryParameters['export'] = _export;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * read the specified ReplicationController
     * @param name name of the ReplicationController
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param exact Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;.
     * @param _export Should this value be exported.  Export strips fields that a user can not specify.
     */
    readNamespacedReplicationController(name, namespace, pretty, exact, _export) {
        const localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/replicationcontrollers/{name}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling readNamespacedReplicationController.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling readNamespacedReplicationController.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (exact !== undefined) {
            queryParameters['exact'] = exact;
        }
        if (_export !== undefined) {
            queryParameters['export'] = _export;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * read scale of the specified ReplicationController
     * @param name name of the Scale
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    readNamespacedReplicationControllerScale(name, namespace, pretty) {
        const localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/replicationcontrollers/{name}/scale'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling readNamespacedReplicationControllerScale.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling readNamespacedReplicationControllerScale.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * read status of the specified ReplicationController
     * @param name name of the ReplicationController
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    readNamespacedReplicationControllerStatus(name, namespace, pretty) {
        const localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/replicationcontrollers/{name}/status'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling readNamespacedReplicationControllerStatus.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling readNamespacedReplicationControllerStatus.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * read the specified ResourceQuota
     * @param name name of the ResourceQuota
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param exact Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;.
     * @param _export Should this value be exported.  Export strips fields that a user can not specify.
     */
    readNamespacedResourceQuota(name, namespace, pretty, exact, _export) {
        const localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/resourcequotas/{name}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling readNamespacedResourceQuota.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling readNamespacedResourceQuota.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (exact !== undefined) {
            queryParameters['exact'] = exact;
        }
        if (_export !== undefined) {
            queryParameters['export'] = _export;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * read status of the specified ResourceQuota
     * @param name name of the ResourceQuota
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    readNamespacedResourceQuotaStatus(name, namespace, pretty) {
        const localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/resourcequotas/{name}/status'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling readNamespacedResourceQuotaStatus.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling readNamespacedResourceQuotaStatus.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * read the specified Secret
     * @param name name of the Secret
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param exact Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;.
     * @param _export Should this value be exported.  Export strips fields that a user can not specify.
     */
    readNamespacedSecret(name, namespace, pretty, exact, _export) {
        const localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/secrets/{name}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling readNamespacedSecret.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling readNamespacedSecret.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (exact !== undefined) {
            queryParameters['exact'] = exact;
        }
        if (_export !== undefined) {
            queryParameters['export'] = _export;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * read the specified Service
     * @param name name of the Service
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param exact Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;.
     * @param _export Should this value be exported.  Export strips fields that a user can not specify.
     */
    readNamespacedService(name, namespace, pretty, exact, _export) {
        const localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/services/{name}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling readNamespacedService.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling readNamespacedService.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (exact !== undefined) {
            queryParameters['exact'] = exact;
        }
        if (_export !== undefined) {
            queryParameters['export'] = _export;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * read the specified ServiceAccount
     * @param name name of the ServiceAccount
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param exact Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;.
     * @param _export Should this value be exported.  Export strips fields that a user can not specify.
     */
    readNamespacedServiceAccount(name, namespace, pretty, exact, _export) {
        const localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/serviceaccounts/{name}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling readNamespacedServiceAccount.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling readNamespacedServiceAccount.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (exact !== undefined) {
            queryParameters['exact'] = exact;
        }
        if (_export !== undefined) {
            queryParameters['export'] = _export;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * read status of the specified Service
     * @param name name of the Service
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    readNamespacedServiceStatus(name, namespace, pretty) {
        const localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/services/{name}/status'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling readNamespacedServiceStatus.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling readNamespacedServiceStatus.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * read the specified Node
     * @param name name of the Node
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param exact Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;.
     * @param _export Should this value be exported.  Export strips fields that a user can not specify.
     */
    readNode(name, pretty, exact, _export) {
        const localVarPath = this.basePath + '/api/v1/nodes/{name}'
            .replace('{' + 'name' + '}', String(name));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling readNode.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (exact !== undefined) {
            queryParameters['exact'] = exact;
        }
        if (_export !== undefined) {
            queryParameters['export'] = _export;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * read status of the specified Node
     * @param name name of the Node
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    readNodeStatus(name, pretty) {
        const localVarPath = this.basePath + '/api/v1/nodes/{name}/status'
            .replace('{' + 'name' + '}', String(name));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling readNodeStatus.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * read the specified PersistentVolume
     * @param name name of the PersistentVolume
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param exact Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;.
     * @param _export Should this value be exported.  Export strips fields that a user can not specify.
     */
    readPersistentVolume(name, pretty, exact, _export) {
        const localVarPath = this.basePath + '/api/v1/persistentvolumes/{name}'
            .replace('{' + 'name' + '}', String(name));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling readPersistentVolume.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (exact !== undefined) {
            queryParameters['exact'] = exact;
        }
        if (_export !== undefined) {
            queryParameters['export'] = _export;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * read status of the specified PersistentVolume
     * @param name name of the PersistentVolume
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    readPersistentVolumeStatus(name, pretty) {
        const localVarPath = this.basePath + '/api/v1/persistentvolumes/{name}/status'
            .replace('{' + 'name' + '}', String(name));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling readPersistentVolumeStatus.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * replace the specified Namespace
     * @param name name of the Namespace
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    replaceNamespace(name, body, pretty) {
        const localVarPath = this.basePath + '/api/v1/namespaces/{name}'
            .replace('{' + 'name' + '}', String(name));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling replaceNamespace.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling replaceNamespace.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * replace finalize of the specified Namespace
     * @param name name of the Namespace
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    replaceNamespaceFinalize(name, body, pretty) {
        const localVarPath = this.basePath + '/api/v1/namespaces/{name}/finalize'
            .replace('{' + 'name' + '}', String(name));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling replaceNamespaceFinalize.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling replaceNamespaceFinalize.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * replace status of the specified Namespace
     * @param name name of the Namespace
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    replaceNamespaceStatus(name, body, pretty) {
        const localVarPath = this.basePath + '/api/v1/namespaces/{name}/status'
            .replace('{' + 'name' + '}', String(name));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling replaceNamespaceStatus.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling replaceNamespaceStatus.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * replace the specified ConfigMap
     * @param name name of the ConfigMap
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    replaceNamespacedConfigMap(name, namespace, body, pretty) {
        const localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/configmaps/{name}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling replaceNamespacedConfigMap.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling replaceNamespacedConfigMap.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling replaceNamespacedConfigMap.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * replace the specified Endpoints
     * @param name name of the Endpoints
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    replaceNamespacedEndpoints(name, namespace, body, pretty) {
        const localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/endpoints/{name}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling replaceNamespacedEndpoints.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling replaceNamespacedEndpoints.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling replaceNamespacedEndpoints.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * replace the specified Event
     * @param name name of the Event
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    replaceNamespacedEvent(name, namespace, body, pretty) {
        const localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/events/{name}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling replaceNamespacedEvent.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling replaceNamespacedEvent.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling replaceNamespacedEvent.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * replace the specified LimitRange
     * @param name name of the LimitRange
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    replaceNamespacedLimitRange(name, namespace, body, pretty) {
        const localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/limitranges/{name}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling replaceNamespacedLimitRange.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling replaceNamespacedLimitRange.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling replaceNamespacedLimitRange.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * replace the specified PersistentVolumeClaim
     * @param name name of the PersistentVolumeClaim
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    replaceNamespacedPersistentVolumeClaim(name, namespace, body, pretty) {
        const localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/persistentvolumeclaims/{name}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling replaceNamespacedPersistentVolumeClaim.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling replaceNamespacedPersistentVolumeClaim.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling replaceNamespacedPersistentVolumeClaim.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * replace status of the specified PersistentVolumeClaim
     * @param name name of the PersistentVolumeClaim
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    replaceNamespacedPersistentVolumeClaimStatus(name, namespace, body, pretty) {
        const localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/persistentvolumeclaims/{name}/status'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling replaceNamespacedPersistentVolumeClaimStatus.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling replaceNamespacedPersistentVolumeClaimStatus.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling replaceNamespacedPersistentVolumeClaimStatus.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * replace the specified Pod
     * @param name name of the Pod
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    replaceNamespacedPod(name, namespace, body, pretty) {
        const localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/pods/{name}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling replaceNamespacedPod.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling replaceNamespacedPod.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling replaceNamespacedPod.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * replace status of the specified Pod
     * @param name name of the Pod
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    replaceNamespacedPodStatus(name, namespace, body, pretty) {
        const localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/pods/{name}/status'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling replaceNamespacedPodStatus.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling replaceNamespacedPodStatus.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling replaceNamespacedPodStatus.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * replace the specified PodTemplate
     * @param name name of the PodTemplate
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    replaceNamespacedPodTemplate(name, namespace, body, pretty) {
        const localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/podtemplates/{name}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling replaceNamespacedPodTemplate.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling replaceNamespacedPodTemplate.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling replaceNamespacedPodTemplate.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * replace the specified ReplicationController
     * @param name name of the ReplicationController
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    replaceNamespacedReplicationController(name, namespace, body, pretty) {
        const localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/replicationcontrollers/{name}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling replaceNamespacedReplicationController.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling replaceNamespacedReplicationController.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling replaceNamespacedReplicationController.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * replace scale of the specified ReplicationController
     * @param name name of the Scale
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    replaceNamespacedReplicationControllerScale(name, namespace, body, pretty) {
        const localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/replicationcontrollers/{name}/scale'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling replaceNamespacedReplicationControllerScale.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling replaceNamespacedReplicationControllerScale.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling replaceNamespacedReplicationControllerScale.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * replace status of the specified ReplicationController
     * @param name name of the ReplicationController
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    replaceNamespacedReplicationControllerStatus(name, namespace, body, pretty) {
        const localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/replicationcontrollers/{name}/status'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling replaceNamespacedReplicationControllerStatus.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling replaceNamespacedReplicationControllerStatus.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling replaceNamespacedReplicationControllerStatus.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * replace the specified ResourceQuota
     * @param name name of the ResourceQuota
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    replaceNamespacedResourceQuota(name, namespace, body, pretty) {
        const localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/resourcequotas/{name}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling replaceNamespacedResourceQuota.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling replaceNamespacedResourceQuota.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling replaceNamespacedResourceQuota.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * replace status of the specified ResourceQuota
     * @param name name of the ResourceQuota
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    replaceNamespacedResourceQuotaStatus(name, namespace, body, pretty) {
        const localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/resourcequotas/{name}/status'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling replaceNamespacedResourceQuotaStatus.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling replaceNamespacedResourceQuotaStatus.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling replaceNamespacedResourceQuotaStatus.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * replace the specified Secret
     * @param name name of the Secret
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    replaceNamespacedSecret(name, namespace, body, pretty) {
        const localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/secrets/{name}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling replaceNamespacedSecret.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling replaceNamespacedSecret.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling replaceNamespacedSecret.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * replace the specified Service
     * @param name name of the Service
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    replaceNamespacedService(name, namespace, body, pretty) {
        const localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/services/{name}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling replaceNamespacedService.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling replaceNamespacedService.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling replaceNamespacedService.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * replace the specified ServiceAccount
     * @param name name of the ServiceAccount
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    replaceNamespacedServiceAccount(name, namespace, body, pretty) {
        const localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/serviceaccounts/{name}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling replaceNamespacedServiceAccount.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling replaceNamespacedServiceAccount.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling replaceNamespacedServiceAccount.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * replace status of the specified Service
     * @param name name of the Service
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    replaceNamespacedServiceStatus(name, namespace, body, pretty) {
        const localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/services/{name}/status'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling replaceNamespacedServiceStatus.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling replaceNamespacedServiceStatus.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling replaceNamespacedServiceStatus.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * replace the specified Node
     * @param name name of the Node
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    replaceNode(name, body, pretty) {
        const localVarPath = this.basePath + '/api/v1/nodes/{name}'
            .replace('{' + 'name' + '}', String(name));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling replaceNode.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling replaceNode.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * replace status of the specified Node
     * @param name name of the Node
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    replaceNodeStatus(name, body, pretty) {
        const localVarPath = this.basePath + '/api/v1/nodes/{name}/status'
            .replace('{' + 'name' + '}', String(name));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling replaceNodeStatus.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling replaceNodeStatus.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * replace the specified PersistentVolume
     * @param name name of the PersistentVolume
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    replacePersistentVolume(name, body, pretty) {
        const localVarPath = this.basePath + '/api/v1/persistentvolumes/{name}'
            .replace('{' + 'name' + '}', String(name));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling replacePersistentVolume.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling replacePersistentVolume.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * replace status of the specified PersistentVolume
     * @param name name of the PersistentVolume
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    replacePersistentVolumeStatus(name, body, pretty) {
        const localVarPath = this.basePath + '/api/v1/persistentvolumes/{name}/status'
            .replace('{' + 'name' + '}', String(name));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling replacePersistentVolumeStatus.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling replacePersistentVolumeStatus.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
exports.Core_v1Api = Core_v1Api;
var Custom_objectsApiApiKeys;
(function (Custom_objectsApiApiKeys) {
    Custom_objectsApiApiKeys[Custom_objectsApiApiKeys["BearerToken"] = 0] = "BearerToken";
})(Custom_objectsApiApiKeys = exports.Custom_objectsApiApiKeys || (exports.Custom_objectsApiApiKeys = {}));
class Custom_objectsApi {
    constructor(basePathOrUsername, password, basePath) {
        this._basePath = defaultBasePath;
        this.defaultHeaders = {};
        this._useQuerystring = false;
        this.authentications = {
            'default': new VoidAuth(),
            'BearerToken': new ApiKeyAuth('header', 'authorization'),
        };
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        }
        else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername;
            }
        }
    }
    set useQuerystring(value) {
        this._useQuerystring = value;
    }
    set basePath(basePath) {
        this._basePath = basePath;
    }
    get basePath() {
        return this._basePath;
    }
    setDefaultAuthentication(auth) {
        this.authentications.default = auth;
    }
    setApiKey(key, value) {
        this.authentications[Custom_objectsApiApiKeys[key]].apiKey = value;
    }
    /**
     * Creates a cluster scoped Custom object
     * @param group The custom resource&#39;s group name
     * @param version The custom resource&#39;s version
     * @param plural The custom resource&#39;s plural name. For TPRs this would be lowercase plural kind.
     * @param body The JSON schema of the Resource to create.
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    createClusterCustomObject(group, version, plural, body, pretty) {
        const localVarPath = this.basePath + '/apis/{group}/{version}/{plural}'
            .replace('{' + 'group' + '}', String(group))
            .replace('{' + 'version' + '}', String(version))
            .replace('{' + 'plural' + '}', String(plural));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'group' is not null or undefined
        if (group === null || group === undefined) {
            throw new Error('Required parameter group was null or undefined when calling createClusterCustomObject.');
        }
        // verify required parameter 'version' is not null or undefined
        if (version === null || version === undefined) {
            throw new Error('Required parameter version was null or undefined when calling createClusterCustomObject.');
        }
        // verify required parameter 'plural' is not null or undefined
        if (plural === null || plural === undefined) {
            throw new Error('Required parameter plural was null or undefined when calling createClusterCustomObject.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling createClusterCustomObject.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Creates a namespace scoped Custom object
     * @param group The custom resource&#39;s group name
     * @param version The custom resource&#39;s version
     * @param namespace The custom resource&#39;s namespace
     * @param plural The custom resource&#39;s plural name. For TPRs this would be lowercase plural kind.
     * @param body The JSON schema of the Resource to create.
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    createNamespacedCustomObject(group, version, namespace, plural, body, pretty) {
        const localVarPath = this.basePath + '/apis/{group}/{version}/namespaces/{namespace}/{plural}'
            .replace('{' + 'group' + '}', String(group))
            .replace('{' + 'version' + '}', String(version))
            .replace('{' + 'namespace' + '}', String(namespace))
            .replace('{' + 'plural' + '}', String(plural));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'group' is not null or undefined
        if (group === null || group === undefined) {
            throw new Error('Required parameter group was null or undefined when calling createNamespacedCustomObject.');
        }
        // verify required parameter 'version' is not null or undefined
        if (version === null || version === undefined) {
            throw new Error('Required parameter version was null or undefined when calling createNamespacedCustomObject.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling createNamespacedCustomObject.');
        }
        // verify required parameter 'plural' is not null or undefined
        if (plural === null || plural === undefined) {
            throw new Error('Required parameter plural was null or undefined when calling createNamespacedCustomObject.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling createNamespacedCustomObject.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Deletes the specified cluster scoped custom object
     * @param group the custom resource&#39;s group
     * @param version the custom resource&#39;s version
     * @param plural the custom object&#39;s plural name. For TPRs this would be lowercase plural kind.
     * @param name the custom object&#39;s name
     * @param body
     * @param gracePeriodSeconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @param orphanDependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @param propagationPolicy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy.
     */
    deleteClusterCustomObject(group, version, plural, name, body, gracePeriodSeconds, orphanDependents, propagationPolicy) {
        const localVarPath = this.basePath + '/apis/{group}/{version}/{plural}/{name}'
            .replace('{' + 'group' + '}', String(group))
            .replace('{' + 'version' + '}', String(version))
            .replace('{' + 'plural' + '}', String(plural))
            .replace('{' + 'name' + '}', String(name));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'group' is not null or undefined
        if (group === null || group === undefined) {
            throw new Error('Required parameter group was null or undefined when calling deleteClusterCustomObject.');
        }
        // verify required parameter 'version' is not null or undefined
        if (version === null || version === undefined) {
            throw new Error('Required parameter version was null or undefined when calling deleteClusterCustomObject.');
        }
        // verify required parameter 'plural' is not null or undefined
        if (plural === null || plural === undefined) {
            throw new Error('Required parameter plural was null or undefined when calling deleteClusterCustomObject.');
        }
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling deleteClusterCustomObject.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling deleteClusterCustomObject.');
        }
        if (gracePeriodSeconds !== undefined) {
            queryParameters['gracePeriodSeconds'] = gracePeriodSeconds;
        }
        if (orphanDependents !== undefined) {
            queryParameters['orphanDependents'] = orphanDependents;
        }
        if (propagationPolicy !== undefined) {
            queryParameters['propagationPolicy'] = propagationPolicy;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Deletes the specified namespace scoped custom object
     * @param group the custom resource&#39;s group
     * @param version the custom resource&#39;s version
     * @param namespace The custom resource&#39;s namespace
     * @param plural the custom resource&#39;s plural name. For TPRs this would be lowercase plural kind.
     * @param name the custom object&#39;s name
     * @param body
     * @param gracePeriodSeconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @param orphanDependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @param propagationPolicy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy.
     */
    deleteNamespacedCustomObject(group, version, namespace, plural, name, body, gracePeriodSeconds, orphanDependents, propagationPolicy) {
        const localVarPath = this.basePath + '/apis/{group}/{version}/namespaces/{namespace}/{plural}/{name}'
            .replace('{' + 'group' + '}', String(group))
            .replace('{' + 'version' + '}', String(version))
            .replace('{' + 'namespace' + '}', String(namespace))
            .replace('{' + 'plural' + '}', String(plural))
            .replace('{' + 'name' + '}', String(name));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'group' is not null or undefined
        if (group === null || group === undefined) {
            throw new Error('Required parameter group was null or undefined when calling deleteNamespacedCustomObject.');
        }
        // verify required parameter 'version' is not null or undefined
        if (version === null || version === undefined) {
            throw new Error('Required parameter version was null or undefined when calling deleteNamespacedCustomObject.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling deleteNamespacedCustomObject.');
        }
        // verify required parameter 'plural' is not null or undefined
        if (plural === null || plural === undefined) {
            throw new Error('Required parameter plural was null or undefined when calling deleteNamespacedCustomObject.');
        }
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling deleteNamespacedCustomObject.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling deleteNamespacedCustomObject.');
        }
        if (gracePeriodSeconds !== undefined) {
            queryParameters['gracePeriodSeconds'] = gracePeriodSeconds;
        }
        if (orphanDependents !== undefined) {
            queryParameters['orphanDependents'] = orphanDependents;
        }
        if (propagationPolicy !== undefined) {
            queryParameters['propagationPolicy'] = propagationPolicy;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Returns a cluster scoped custom object
     * @param group the custom resource&#39;s group
     * @param version the custom resource&#39;s version
     * @param plural the custom object&#39;s plural name. For TPRs this would be lowercase plural kind.
     * @param name the custom object&#39;s name
     */
    getClusterCustomObject(group, version, plural, name) {
        const localVarPath = this.basePath + '/apis/{group}/{version}/{plural}/{name}'
            .replace('{' + 'group' + '}', String(group))
            .replace('{' + 'version' + '}', String(version))
            .replace('{' + 'plural' + '}', String(plural))
            .replace('{' + 'name' + '}', String(name));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'group' is not null or undefined
        if (group === null || group === undefined) {
            throw new Error('Required parameter group was null or undefined when calling getClusterCustomObject.');
        }
        // verify required parameter 'version' is not null or undefined
        if (version === null || version === undefined) {
            throw new Error('Required parameter version was null or undefined when calling getClusterCustomObject.');
        }
        // verify required parameter 'plural' is not null or undefined
        if (plural === null || plural === undefined) {
            throw new Error('Required parameter plural was null or undefined when calling getClusterCustomObject.');
        }
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling getClusterCustomObject.');
        }
        let useFormData = false;
        let requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * read scale of the specified custom object
     * @param group the custom resource&#39;s group
     * @param version the custom resource&#39;s version
     * @param plural the custom resource&#39;s plural name. For TPRs this would be lowercase plural kind.
     * @param name the custom object&#39;s name
     */
    getClusterCustomObjectScale(group, version, plural, name) {
        const localVarPath = this.basePath + '/apis/{group}/{version}/{plural}/{name}/scale'
            .replace('{' + 'group' + '}', String(group))
            .replace('{' + 'version' + '}', String(version))
            .replace('{' + 'plural' + '}', String(plural))
            .replace('{' + 'name' + '}', String(name));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'group' is not null or undefined
        if (group === null || group === undefined) {
            throw new Error('Required parameter group was null or undefined when calling getClusterCustomObjectScale.');
        }
        // verify required parameter 'version' is not null or undefined
        if (version === null || version === undefined) {
            throw new Error('Required parameter version was null or undefined when calling getClusterCustomObjectScale.');
        }
        // verify required parameter 'plural' is not null or undefined
        if (plural === null || plural === undefined) {
            throw new Error('Required parameter plural was null or undefined when calling getClusterCustomObjectScale.');
        }
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling getClusterCustomObjectScale.');
        }
        let useFormData = false;
        let requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * read status of the specified cluster scoped custom object
     * @param group the custom resource&#39;s group
     * @param version the custom resource&#39;s version
     * @param plural the custom resource&#39;s plural name. For TPRs this would be lowercase plural kind.
     * @param name the custom object&#39;s name
     */
    getClusterCustomObjectStatus(group, version, plural, name) {
        const localVarPath = this.basePath + '/apis/{group}/{version}/{plural}/{name}/status'
            .replace('{' + 'group' + '}', String(group))
            .replace('{' + 'version' + '}', String(version))
            .replace('{' + 'plural' + '}', String(plural))
            .replace('{' + 'name' + '}', String(name));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'group' is not null or undefined
        if (group === null || group === undefined) {
            throw new Error('Required parameter group was null or undefined when calling getClusterCustomObjectStatus.');
        }
        // verify required parameter 'version' is not null or undefined
        if (version === null || version === undefined) {
            throw new Error('Required parameter version was null or undefined when calling getClusterCustomObjectStatus.');
        }
        // verify required parameter 'plural' is not null or undefined
        if (plural === null || plural === undefined) {
            throw new Error('Required parameter plural was null or undefined when calling getClusterCustomObjectStatus.');
        }
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling getClusterCustomObjectStatus.');
        }
        let useFormData = false;
        let requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Returns a namespace scoped custom object
     * @param group the custom resource&#39;s group
     * @param version the custom resource&#39;s version
     * @param namespace The custom resource&#39;s namespace
     * @param plural the custom resource&#39;s plural name. For TPRs this would be lowercase plural kind.
     * @param name the custom object&#39;s name
     */
    getNamespacedCustomObject(group, version, namespace, plural, name) {
        const localVarPath = this.basePath + '/apis/{group}/{version}/namespaces/{namespace}/{plural}/{name}'
            .replace('{' + 'group' + '}', String(group))
            .replace('{' + 'version' + '}', String(version))
            .replace('{' + 'namespace' + '}', String(namespace))
            .replace('{' + 'plural' + '}', String(plural))
            .replace('{' + 'name' + '}', String(name));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'group' is not null or undefined
        if (group === null || group === undefined) {
            throw new Error('Required parameter group was null or undefined when calling getNamespacedCustomObject.');
        }
        // verify required parameter 'version' is not null or undefined
        if (version === null || version === undefined) {
            throw new Error('Required parameter version was null or undefined when calling getNamespacedCustomObject.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling getNamespacedCustomObject.');
        }
        // verify required parameter 'plural' is not null or undefined
        if (plural === null || plural === undefined) {
            throw new Error('Required parameter plural was null or undefined when calling getNamespacedCustomObject.');
        }
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling getNamespacedCustomObject.');
        }
        let useFormData = false;
        let requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * read scale of the specified namespace scoped custom object
     * @param group the custom resource&#39;s group
     * @param version the custom resource&#39;s version
     * @param namespace The custom resource&#39;s namespace
     * @param plural the custom resource&#39;s plural name. For TPRs this would be lowercase plural kind.
     * @param name the custom object&#39;s name
     */
    getNamespacedCustomObjectScale(group, version, namespace, plural, name) {
        const localVarPath = this.basePath + '/apis/{group}/{version}/namespaces/{namespace}/{plural}/{name}/scale'
            .replace('{' + 'group' + '}', String(group))
            .replace('{' + 'version' + '}', String(version))
            .replace('{' + 'namespace' + '}', String(namespace))
            .replace('{' + 'plural' + '}', String(plural))
            .replace('{' + 'name' + '}', String(name));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'group' is not null or undefined
        if (group === null || group === undefined) {
            throw new Error('Required parameter group was null or undefined when calling getNamespacedCustomObjectScale.');
        }
        // verify required parameter 'version' is not null or undefined
        if (version === null || version === undefined) {
            throw new Error('Required parameter version was null or undefined when calling getNamespacedCustomObjectScale.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling getNamespacedCustomObjectScale.');
        }
        // verify required parameter 'plural' is not null or undefined
        if (plural === null || plural === undefined) {
            throw new Error('Required parameter plural was null or undefined when calling getNamespacedCustomObjectScale.');
        }
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling getNamespacedCustomObjectScale.');
        }
        let useFormData = false;
        let requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * read status of the specified namespace scoped custom object
     * @param group the custom resource&#39;s group
     * @param version the custom resource&#39;s version
     * @param namespace The custom resource&#39;s namespace
     * @param plural the custom resource&#39;s plural name. For TPRs this would be lowercase plural kind.
     * @param name the custom object&#39;s name
     */
    getNamespacedCustomObjectStatus(group, version, namespace, plural, name) {
        const localVarPath = this.basePath + '/apis/{group}/{version}/namespaces/{namespace}/{plural}/{name}/status'
            .replace('{' + 'group' + '}', String(group))
            .replace('{' + 'version' + '}', String(version))
            .replace('{' + 'namespace' + '}', String(namespace))
            .replace('{' + 'plural' + '}', String(plural))
            .replace('{' + 'name' + '}', String(name));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'group' is not null or undefined
        if (group === null || group === undefined) {
            throw new Error('Required parameter group was null or undefined when calling getNamespacedCustomObjectStatus.');
        }
        // verify required parameter 'version' is not null or undefined
        if (version === null || version === undefined) {
            throw new Error('Required parameter version was null or undefined when calling getNamespacedCustomObjectStatus.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling getNamespacedCustomObjectStatus.');
        }
        // verify required parameter 'plural' is not null or undefined
        if (plural === null || plural === undefined) {
            throw new Error('Required parameter plural was null or undefined when calling getNamespacedCustomObjectStatus.');
        }
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling getNamespacedCustomObjectStatus.');
        }
        let useFormData = false;
        let requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * list or watch cluster scoped custom objects
     * @param group The custom resource&#39;s group name
     * @param version The custom resource&#39;s version
     * @param plural The custom resource&#39;s plural name. For TPRs this would be lowercase plural kind.
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications.
     */
    listClusterCustomObject(group, version, plural, pretty, labelSelector, resourceVersion, watch) {
        const localVarPath = this.basePath + '/apis/{group}/{version}/{plural}'
            .replace('{' + 'group' + '}', String(group))
            .replace('{' + 'version' + '}', String(version))
            .replace('{' + 'plural' + '}', String(plural));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'group' is not null or undefined
        if (group === null || group === undefined) {
            throw new Error('Required parameter group was null or undefined when calling listClusterCustomObject.');
        }
        // verify required parameter 'version' is not null or undefined
        if (version === null || version === undefined) {
            throw new Error('Required parameter version was null or undefined when calling listClusterCustomObject.');
        }
        // verify required parameter 'plural' is not null or undefined
        if (plural === null || plural === undefined) {
            throw new Error('Required parameter plural was null or undefined when calling listClusterCustomObject.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (labelSelector !== undefined) {
            queryParameters['labelSelector'] = labelSelector;
        }
        if (resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = resourceVersion;
        }
        if (watch !== undefined) {
            queryParameters['watch'] = watch;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * list or watch namespace scoped custom objects
     * @param group The custom resource&#39;s group name
     * @param version The custom resource&#39;s version
     * @param namespace The custom resource&#39;s namespace
     * @param plural The custom resource&#39;s plural name. For TPRs this would be lowercase plural kind.
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications.
     */
    listNamespacedCustomObject(group, version, namespace, plural, pretty, labelSelector, resourceVersion, watch) {
        const localVarPath = this.basePath + '/apis/{group}/{version}/namespaces/{namespace}/{plural}'
            .replace('{' + 'group' + '}', String(group))
            .replace('{' + 'version' + '}', String(version))
            .replace('{' + 'namespace' + '}', String(namespace))
            .replace('{' + 'plural' + '}', String(plural));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'group' is not null or undefined
        if (group === null || group === undefined) {
            throw new Error('Required parameter group was null or undefined when calling listNamespacedCustomObject.');
        }
        // verify required parameter 'version' is not null or undefined
        if (version === null || version === undefined) {
            throw new Error('Required parameter version was null or undefined when calling listNamespacedCustomObject.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling listNamespacedCustomObject.');
        }
        // verify required parameter 'plural' is not null or undefined
        if (plural === null || plural === undefined) {
            throw new Error('Required parameter plural was null or undefined when calling listNamespacedCustomObject.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (labelSelector !== undefined) {
            queryParameters['labelSelector'] = labelSelector;
        }
        if (resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = resourceVersion;
        }
        if (watch !== undefined) {
            queryParameters['watch'] = watch;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * patch the specified cluster scoped custom object
     * @param group the custom resource&#39;s group
     * @param version the custom resource&#39;s version
     * @param plural the custom object&#39;s plural name. For TPRs this would be lowercase plural kind.
     * @param name the custom object&#39;s name
     * @param body The JSON schema of the Resource to patch.
     */
    patchClusterCustomObject(group, version, plural, name, body) {
        const localVarPath = this.basePath + '/apis/{group}/{version}/{plural}/{name}'
            .replace('{' + 'group' + '}', String(group))
            .replace('{' + 'version' + '}', String(version))
            .replace('{' + 'plural' + '}', String(plural))
            .replace('{' + 'name' + '}', String(name));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'group' is not null or undefined
        if (group === null || group === undefined) {
            throw new Error('Required parameter group was null or undefined when calling patchClusterCustomObject.');
        }
        // verify required parameter 'version' is not null or undefined
        if (version === null || version === undefined) {
            throw new Error('Required parameter version was null or undefined when calling patchClusterCustomObject.');
        }
        // verify required parameter 'plural' is not null or undefined
        if (plural === null || plural === undefined) {
            throw new Error('Required parameter plural was null or undefined when calling patchClusterCustomObject.');
        }
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling patchClusterCustomObject.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling patchClusterCustomObject.');
        }
        let useFormData = false;
        let requestOptions = {
            method: 'PATCH',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * partially update scale of the specified cluster scoped custom object
     * @param group the custom resource&#39;s group
     * @param version the custom resource&#39;s version
     * @param plural the custom resource&#39;s plural name. For TPRs this would be lowercase plural kind.
     * @param name the custom object&#39;s name
     * @param body
     */
    patchClusterCustomObjectScale(group, version, plural, name, body) {
        const localVarPath = this.basePath + '/apis/{group}/{version}/{plural}/{name}/scale'
            .replace('{' + 'group' + '}', String(group))
            .replace('{' + 'version' + '}', String(version))
            .replace('{' + 'plural' + '}', String(plural))
            .replace('{' + 'name' + '}', String(name));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'group' is not null or undefined
        if (group === null || group === undefined) {
            throw new Error('Required parameter group was null or undefined when calling patchClusterCustomObjectScale.');
        }
        // verify required parameter 'version' is not null or undefined
        if (version === null || version === undefined) {
            throw new Error('Required parameter version was null or undefined when calling patchClusterCustomObjectScale.');
        }
        // verify required parameter 'plural' is not null or undefined
        if (plural === null || plural === undefined) {
            throw new Error('Required parameter plural was null or undefined when calling patchClusterCustomObjectScale.');
        }
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling patchClusterCustomObjectScale.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling patchClusterCustomObjectScale.');
        }
        let useFormData = false;
        let requestOptions = {
            method: 'PATCH',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * partially update status of the specified cluster scoped custom object
     * @param group the custom resource&#39;s group
     * @param version the custom resource&#39;s version
     * @param plural the custom resource&#39;s plural name. For TPRs this would be lowercase plural kind.
     * @param name the custom object&#39;s name
     * @param body
     */
    patchClusterCustomObjectStatus(group, version, plural, name, body) {
        const localVarPath = this.basePath + '/apis/{group}/{version}/{plural}/{name}/status'
            .replace('{' + 'group' + '}', String(group))
            .replace('{' + 'version' + '}', String(version))
            .replace('{' + 'plural' + '}', String(plural))
            .replace('{' + 'name' + '}', String(name));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'group' is not null or undefined
        if (group === null || group === undefined) {
            throw new Error('Required parameter group was null or undefined when calling patchClusterCustomObjectStatus.');
        }
        // verify required parameter 'version' is not null or undefined
        if (version === null || version === undefined) {
            throw new Error('Required parameter version was null or undefined when calling patchClusterCustomObjectStatus.');
        }
        // verify required parameter 'plural' is not null or undefined
        if (plural === null || plural === undefined) {
            throw new Error('Required parameter plural was null or undefined when calling patchClusterCustomObjectStatus.');
        }
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling patchClusterCustomObjectStatus.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling patchClusterCustomObjectStatus.');
        }
        let useFormData = false;
        let requestOptions = {
            method: 'PATCH',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * patch the specified namespace scoped custom object
     * @param group the custom resource&#39;s group
     * @param version the custom resource&#39;s version
     * @param namespace The custom resource&#39;s namespace
     * @param plural the custom resource&#39;s plural name. For TPRs this would be lowercase plural kind.
     * @param name the custom object&#39;s name
     * @param body The JSON schema of the Resource to patch.
     */
    patchNamespacedCustomObject(group, version, namespace, plural, name, body) {
        const localVarPath = this.basePath + '/apis/{group}/{version}/namespaces/{namespace}/{plural}/{name}'
            .replace('{' + 'group' + '}', String(group))
            .replace('{' + 'version' + '}', String(version))
            .replace('{' + 'namespace' + '}', String(namespace))
            .replace('{' + 'plural' + '}', String(plural))
            .replace('{' + 'name' + '}', String(name));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'group' is not null or undefined
        if (group === null || group === undefined) {
            throw new Error('Required parameter group was null or undefined when calling patchNamespacedCustomObject.');
        }
        // verify required parameter 'version' is not null or undefined
        if (version === null || version === undefined) {
            throw new Error('Required parameter version was null or undefined when calling patchNamespacedCustomObject.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling patchNamespacedCustomObject.');
        }
        // verify required parameter 'plural' is not null or undefined
        if (plural === null || plural === undefined) {
            throw new Error('Required parameter plural was null or undefined when calling patchNamespacedCustomObject.');
        }
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling patchNamespacedCustomObject.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling patchNamespacedCustomObject.');
        }
        let useFormData = false;
        let requestOptions = {
            method: 'PATCH',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * partially update scale of the specified namespace scoped custom object
     * @param group the custom resource&#39;s group
     * @param version the custom resource&#39;s version
     * @param namespace The custom resource&#39;s namespace
     * @param plural the custom resource&#39;s plural name. For TPRs this would be lowercase plural kind.
     * @param name the custom object&#39;s name
     * @param body
     */
    patchNamespacedCustomObjectScale(group, version, namespace, plural, name, body) {
        const localVarPath = this.basePath + '/apis/{group}/{version}/namespaces/{namespace}/{plural}/{name}/scale'
            .replace('{' + 'group' + '}', String(group))
            .replace('{' + 'version' + '}', String(version))
            .replace('{' + 'namespace' + '}', String(namespace))
            .replace('{' + 'plural' + '}', String(plural))
            .replace('{' + 'name' + '}', String(name));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'group' is not null or undefined
        if (group === null || group === undefined) {
            throw new Error('Required parameter group was null or undefined when calling patchNamespacedCustomObjectScale.');
        }
        // verify required parameter 'version' is not null or undefined
        if (version === null || version === undefined) {
            throw new Error('Required parameter version was null or undefined when calling patchNamespacedCustomObjectScale.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling patchNamespacedCustomObjectScale.');
        }
        // verify required parameter 'plural' is not null or undefined
        if (plural === null || plural === undefined) {
            throw new Error('Required parameter plural was null or undefined when calling patchNamespacedCustomObjectScale.');
        }
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling patchNamespacedCustomObjectScale.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling patchNamespacedCustomObjectScale.');
        }
        let useFormData = false;
        let requestOptions = {
            method: 'PATCH',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * partially update status of the specified namespace scoped custom object
     * @param group the custom resource&#39;s group
     * @param version the custom resource&#39;s version
     * @param namespace The custom resource&#39;s namespace
     * @param plural the custom resource&#39;s plural name. For TPRs this would be lowercase plural kind.
     * @param name the custom object&#39;s name
     * @param body
     */
    patchNamespacedCustomObjectStatus(group, version, namespace, plural, name, body) {
        const localVarPath = this.basePath + '/apis/{group}/{version}/namespaces/{namespace}/{plural}/{name}/status'
            .replace('{' + 'group' + '}', String(group))
            .replace('{' + 'version' + '}', String(version))
            .replace('{' + 'namespace' + '}', String(namespace))
            .replace('{' + 'plural' + '}', String(plural))
            .replace('{' + 'name' + '}', String(name));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'group' is not null or undefined
        if (group === null || group === undefined) {
            throw new Error('Required parameter group was null or undefined when calling patchNamespacedCustomObjectStatus.');
        }
        // verify required parameter 'version' is not null or undefined
        if (version === null || version === undefined) {
            throw new Error('Required parameter version was null or undefined when calling patchNamespacedCustomObjectStatus.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling patchNamespacedCustomObjectStatus.');
        }
        // verify required parameter 'plural' is not null or undefined
        if (plural === null || plural === undefined) {
            throw new Error('Required parameter plural was null or undefined when calling patchNamespacedCustomObjectStatus.');
        }
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling patchNamespacedCustomObjectStatus.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling patchNamespacedCustomObjectStatus.');
        }
        let useFormData = false;
        let requestOptions = {
            method: 'PATCH',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * replace the specified cluster scoped custom object
     * @param group the custom resource&#39;s group
     * @param version the custom resource&#39;s version
     * @param plural the custom object&#39;s plural name. For TPRs this would be lowercase plural kind.
     * @param name the custom object&#39;s name
     * @param body The JSON schema of the Resource to replace.
     */
    replaceClusterCustomObject(group, version, plural, name, body) {
        const localVarPath = this.basePath + '/apis/{group}/{version}/{plural}/{name}'
            .replace('{' + 'group' + '}', String(group))
            .replace('{' + 'version' + '}', String(version))
            .replace('{' + 'plural' + '}', String(plural))
            .replace('{' + 'name' + '}', String(name));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'group' is not null or undefined
        if (group === null || group === undefined) {
            throw new Error('Required parameter group was null or undefined when calling replaceClusterCustomObject.');
        }
        // verify required parameter 'version' is not null or undefined
        if (version === null || version === undefined) {
            throw new Error('Required parameter version was null or undefined when calling replaceClusterCustomObject.');
        }
        // verify required parameter 'plural' is not null or undefined
        if (plural === null || plural === undefined) {
            throw new Error('Required parameter plural was null or undefined when calling replaceClusterCustomObject.');
        }
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling replaceClusterCustomObject.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling replaceClusterCustomObject.');
        }
        let useFormData = false;
        let requestOptions = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * replace scale of the specified cluster scoped custom object
     * @param group the custom resource&#39;s group
     * @param version the custom resource&#39;s version
     * @param plural the custom resource&#39;s plural name. For TPRs this would be lowercase plural kind.
     * @param name the custom object&#39;s name
     * @param body
     */
    replaceClusterCustomObjectScale(group, version, plural, name, body) {
        const localVarPath = this.basePath + '/apis/{group}/{version}/{plural}/{name}/scale'
            .replace('{' + 'group' + '}', String(group))
            .replace('{' + 'version' + '}', String(version))
            .replace('{' + 'plural' + '}', String(plural))
            .replace('{' + 'name' + '}', String(name));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'group' is not null or undefined
        if (group === null || group === undefined) {
            throw new Error('Required parameter group was null or undefined when calling replaceClusterCustomObjectScale.');
        }
        // verify required parameter 'version' is not null or undefined
        if (version === null || version === undefined) {
            throw new Error('Required parameter version was null or undefined when calling replaceClusterCustomObjectScale.');
        }
        // verify required parameter 'plural' is not null or undefined
        if (plural === null || plural === undefined) {
            throw new Error('Required parameter plural was null or undefined when calling replaceClusterCustomObjectScale.');
        }
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling replaceClusterCustomObjectScale.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling replaceClusterCustomObjectScale.');
        }
        let useFormData = false;
        let requestOptions = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * replace status of the cluster scoped specified custom object
     * @param group the custom resource&#39;s group
     * @param version the custom resource&#39;s version
     * @param plural the custom resource&#39;s plural name. For TPRs this would be lowercase plural kind.
     * @param name the custom object&#39;s name
     * @param body
     */
    replaceClusterCustomObjectStatus(group, version, plural, name, body) {
        const localVarPath = this.basePath + '/apis/{group}/{version}/{plural}/{name}/status'
            .replace('{' + 'group' + '}', String(group))
            .replace('{' + 'version' + '}', String(version))
            .replace('{' + 'plural' + '}', String(plural))
            .replace('{' + 'name' + '}', String(name));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'group' is not null or undefined
        if (group === null || group === undefined) {
            throw new Error('Required parameter group was null or undefined when calling replaceClusterCustomObjectStatus.');
        }
        // verify required parameter 'version' is not null or undefined
        if (version === null || version === undefined) {
            throw new Error('Required parameter version was null or undefined when calling replaceClusterCustomObjectStatus.');
        }
        // verify required parameter 'plural' is not null or undefined
        if (plural === null || plural === undefined) {
            throw new Error('Required parameter plural was null or undefined when calling replaceClusterCustomObjectStatus.');
        }
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling replaceClusterCustomObjectStatus.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling replaceClusterCustomObjectStatus.');
        }
        let useFormData = false;
        let requestOptions = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * replace the specified namespace scoped custom object
     * @param group the custom resource&#39;s group
     * @param version the custom resource&#39;s version
     * @param namespace The custom resource&#39;s namespace
     * @param plural the custom resource&#39;s plural name. For TPRs this would be lowercase plural kind.
     * @param name the custom object&#39;s name
     * @param body The JSON schema of the Resource to replace.
     */
    replaceNamespacedCustomObject(group, version, namespace, plural, name, body) {
        const localVarPath = this.basePath + '/apis/{group}/{version}/namespaces/{namespace}/{plural}/{name}'
            .replace('{' + 'group' + '}', String(group))
            .replace('{' + 'version' + '}', String(version))
            .replace('{' + 'namespace' + '}', String(namespace))
            .replace('{' + 'plural' + '}', String(plural))
            .replace('{' + 'name' + '}', String(name));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'group' is not null or undefined
        if (group === null || group === undefined) {
            throw new Error('Required parameter group was null or undefined when calling replaceNamespacedCustomObject.');
        }
        // verify required parameter 'version' is not null or undefined
        if (version === null || version === undefined) {
            throw new Error('Required parameter version was null or undefined when calling replaceNamespacedCustomObject.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling replaceNamespacedCustomObject.');
        }
        // verify required parameter 'plural' is not null or undefined
        if (plural === null || plural === undefined) {
            throw new Error('Required parameter plural was null or undefined when calling replaceNamespacedCustomObject.');
        }
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling replaceNamespacedCustomObject.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling replaceNamespacedCustomObject.');
        }
        let useFormData = false;
        let requestOptions = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * replace scale of the specified namespace scoped custom object
     * @param group the custom resource&#39;s group
     * @param version the custom resource&#39;s version
     * @param namespace The custom resource&#39;s namespace
     * @param plural the custom resource&#39;s plural name. For TPRs this would be lowercase plural kind.
     * @param name the custom object&#39;s name
     * @param body
     */
    replaceNamespacedCustomObjectScale(group, version, namespace, plural, name, body) {
        const localVarPath = this.basePath + '/apis/{group}/{version}/namespaces/{namespace}/{plural}/{name}/scale'
            .replace('{' + 'group' + '}', String(group))
            .replace('{' + 'version' + '}', String(version))
            .replace('{' + 'namespace' + '}', String(namespace))
            .replace('{' + 'plural' + '}', String(plural))
            .replace('{' + 'name' + '}', String(name));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'group' is not null or undefined
        if (group === null || group === undefined) {
            throw new Error('Required parameter group was null or undefined when calling replaceNamespacedCustomObjectScale.');
        }
        // verify required parameter 'version' is not null or undefined
        if (version === null || version === undefined) {
            throw new Error('Required parameter version was null or undefined when calling replaceNamespacedCustomObjectScale.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling replaceNamespacedCustomObjectScale.');
        }
        // verify required parameter 'plural' is not null or undefined
        if (plural === null || plural === undefined) {
            throw new Error('Required parameter plural was null or undefined when calling replaceNamespacedCustomObjectScale.');
        }
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling replaceNamespacedCustomObjectScale.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling replaceNamespacedCustomObjectScale.');
        }
        let useFormData = false;
        let requestOptions = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * replace status of the specified namespace scoped custom object
     * @param group the custom resource&#39;s group
     * @param version the custom resource&#39;s version
     * @param namespace The custom resource&#39;s namespace
     * @param plural the custom resource&#39;s plural name. For TPRs this would be lowercase plural kind.
     * @param name the custom object&#39;s name
     * @param body
     */
    replaceNamespacedCustomObjectStatus(group, version, namespace, plural, name, body) {
        const localVarPath = this.basePath + '/apis/{group}/{version}/namespaces/{namespace}/{plural}/{name}/status'
            .replace('{' + 'group' + '}', String(group))
            .replace('{' + 'version' + '}', String(version))
            .replace('{' + 'namespace' + '}', String(namespace))
            .replace('{' + 'plural' + '}', String(plural))
            .replace('{' + 'name' + '}', String(name));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'group' is not null or undefined
        if (group === null || group === undefined) {
            throw new Error('Required parameter group was null or undefined when calling replaceNamespacedCustomObjectStatus.');
        }
        // verify required parameter 'version' is not null or undefined
        if (version === null || version === undefined) {
            throw new Error('Required parameter version was null or undefined when calling replaceNamespacedCustomObjectStatus.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling replaceNamespacedCustomObjectStatus.');
        }
        // verify required parameter 'plural' is not null or undefined
        if (plural === null || plural === undefined) {
            throw new Error('Required parameter plural was null or undefined when calling replaceNamespacedCustomObjectStatus.');
        }
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling replaceNamespacedCustomObjectStatus.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling replaceNamespacedCustomObjectStatus.');
        }
        let useFormData = false;
        let requestOptions = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
exports.Custom_objectsApi = Custom_objectsApi;
var EventsApiApiKeys;
(function (EventsApiApiKeys) {
    EventsApiApiKeys[EventsApiApiKeys["BearerToken"] = 0] = "BearerToken";
})(EventsApiApiKeys = exports.EventsApiApiKeys || (exports.EventsApiApiKeys = {}));
class EventsApi {
    constructor(basePathOrUsername, password, basePath) {
        this._basePath = defaultBasePath;
        this.defaultHeaders = {};
        this._useQuerystring = false;
        this.authentications = {
            'default': new VoidAuth(),
            'BearerToken': new ApiKeyAuth('header', 'authorization'),
        };
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        }
        else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername;
            }
        }
    }
    set useQuerystring(value) {
        this._useQuerystring = value;
    }
    set basePath(basePath) {
        this._basePath = basePath;
    }
    get basePath() {
        return this._basePath;
    }
    setDefaultAuthentication(auth) {
        this.authentications.default = auth;
    }
    setApiKey(key, value) {
        this.authentications[EventsApiApiKeys[key]].apiKey = value;
    }
    /**
     * get information of a group
     */
    getAPIGroup() {
        const localVarPath = this.basePath + '/apis/events.k8s.io/';
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        let useFormData = false;
        let requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
exports.EventsApi = EventsApi;
var Events_v1beta1ApiApiKeys;
(function (Events_v1beta1ApiApiKeys) {
    Events_v1beta1ApiApiKeys[Events_v1beta1ApiApiKeys["BearerToken"] = 0] = "BearerToken";
})(Events_v1beta1ApiApiKeys = exports.Events_v1beta1ApiApiKeys || (exports.Events_v1beta1ApiApiKeys = {}));
class Events_v1beta1Api {
    constructor(basePathOrUsername, password, basePath) {
        this._basePath = defaultBasePath;
        this.defaultHeaders = {};
        this._useQuerystring = false;
        this.authentications = {
            'default': new VoidAuth(),
            'BearerToken': new ApiKeyAuth('header', 'authorization'),
        };
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        }
        else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername;
            }
        }
    }
    set useQuerystring(value) {
        this._useQuerystring = value;
    }
    set basePath(basePath) {
        this._basePath = basePath;
    }
    get basePath() {
        return this._basePath;
    }
    setDefaultAuthentication(auth) {
        this.authentications.default = auth;
    }
    setApiKey(key, value) {
        this.authentications[Events_v1beta1ApiApiKeys[key]].apiKey = value;
    }
    /**
     * create an Event
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    createNamespacedEvent(namespace, body, pretty) {
        const localVarPath = this.basePath + '/apis/events.k8s.io/v1beta1/namespaces/{namespace}/events'
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling createNamespacedEvent.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling createNamespacedEvent.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * delete collection of Event
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param includeUninitialized If true, partially initialized resources are included in the response.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param timeoutSeconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    deleteCollectionNamespacedEvent(namespace, pretty, _continue, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch) {
        const localVarPath = this.basePath + '/apis/events.k8s.io/v1beta1/namespaces/{namespace}/events'
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling deleteCollectionNamespacedEvent.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (_continue !== undefined) {
            queryParameters['continue'] = _continue;
        }
        if (fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = fieldSelector;
        }
        if (includeUninitialized !== undefined) {
            queryParameters['includeUninitialized'] = includeUninitialized;
        }
        if (labelSelector !== undefined) {
            queryParameters['labelSelector'] = labelSelector;
        }
        if (limit !== undefined) {
            queryParameters['limit'] = limit;
        }
        if (resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = resourceVersion;
        }
        if (timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = timeoutSeconds;
        }
        if (watch !== undefined) {
            queryParameters['watch'] = watch;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * delete an Event
     * @param name name of the Event
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param gracePeriodSeconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @param orphanDependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @param propagationPolicy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
     */
    deleteNamespacedEvent(name, namespace, body, pretty, gracePeriodSeconds, orphanDependents, propagationPolicy) {
        const localVarPath = this.basePath + '/apis/events.k8s.io/v1beta1/namespaces/{namespace}/events/{name}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling deleteNamespacedEvent.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling deleteNamespacedEvent.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling deleteNamespacedEvent.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (gracePeriodSeconds !== undefined) {
            queryParameters['gracePeriodSeconds'] = gracePeriodSeconds;
        }
        if (orphanDependents !== undefined) {
            queryParameters['orphanDependents'] = orphanDependents;
        }
        if (propagationPolicy !== undefined) {
            queryParameters['propagationPolicy'] = propagationPolicy;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * get available resources
     */
    getAPIResources() {
        const localVarPath = this.basePath + '/apis/events.k8s.io/v1beta1/';
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        let useFormData = false;
        let requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * list or watch objects of kind Event
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param includeUninitialized If true, partially initialized resources are included in the response.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param timeoutSeconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    listEventForAllNamespaces(_continue, fieldSelector, includeUninitialized, labelSelector, limit, pretty, resourceVersion, timeoutSeconds, watch) {
        const localVarPath = this.basePath + '/apis/events.k8s.io/v1beta1/events';
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        if (_continue !== undefined) {
            queryParameters['continue'] = _continue;
        }
        if (fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = fieldSelector;
        }
        if (includeUninitialized !== undefined) {
            queryParameters['includeUninitialized'] = includeUninitialized;
        }
        if (labelSelector !== undefined) {
            queryParameters['labelSelector'] = labelSelector;
        }
        if (limit !== undefined) {
            queryParameters['limit'] = limit;
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = resourceVersion;
        }
        if (timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = timeoutSeconds;
        }
        if (watch !== undefined) {
            queryParameters['watch'] = watch;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * list or watch objects of kind Event
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param includeUninitialized If true, partially initialized resources are included in the response.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param timeoutSeconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    listNamespacedEvent(namespace, pretty, _continue, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch) {
        const localVarPath = this.basePath + '/apis/events.k8s.io/v1beta1/namespaces/{namespace}/events'
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling listNamespacedEvent.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (_continue !== undefined) {
            queryParameters['continue'] = _continue;
        }
        if (fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = fieldSelector;
        }
        if (includeUninitialized !== undefined) {
            queryParameters['includeUninitialized'] = includeUninitialized;
        }
        if (labelSelector !== undefined) {
            queryParameters['labelSelector'] = labelSelector;
        }
        if (limit !== undefined) {
            queryParameters['limit'] = limit;
        }
        if (resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = resourceVersion;
        }
        if (timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = timeoutSeconds;
        }
        if (watch !== undefined) {
            queryParameters['watch'] = watch;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * partially update the specified Event
     * @param name name of the Event
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    patchNamespacedEvent(name, namespace, body, pretty) {
        const localVarPath = this.basePath + '/apis/events.k8s.io/v1beta1/namespaces/{namespace}/events/{name}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling patchNamespacedEvent.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling patchNamespacedEvent.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling patchNamespacedEvent.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'PATCH',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * read the specified Event
     * @param name name of the Event
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param exact Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;.
     * @param _export Should this value be exported.  Export strips fields that a user can not specify.
     */
    readNamespacedEvent(name, namespace, pretty, exact, _export) {
        const localVarPath = this.basePath + '/apis/events.k8s.io/v1beta1/namespaces/{namespace}/events/{name}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling readNamespacedEvent.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling readNamespacedEvent.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (exact !== undefined) {
            queryParameters['exact'] = exact;
        }
        if (_export !== undefined) {
            queryParameters['export'] = _export;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * replace the specified Event
     * @param name name of the Event
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    replaceNamespacedEvent(name, namespace, body, pretty) {
        const localVarPath = this.basePath + '/apis/events.k8s.io/v1beta1/namespaces/{namespace}/events/{name}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling replaceNamespacedEvent.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling replaceNamespacedEvent.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling replaceNamespacedEvent.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
exports.Events_v1beta1Api = Events_v1beta1Api;
var ExtensionsApiApiKeys;
(function (ExtensionsApiApiKeys) {
    ExtensionsApiApiKeys[ExtensionsApiApiKeys["BearerToken"] = 0] = "BearerToken";
})(ExtensionsApiApiKeys = exports.ExtensionsApiApiKeys || (exports.ExtensionsApiApiKeys = {}));
class ExtensionsApi {
    constructor(basePathOrUsername, password, basePath) {
        this._basePath = defaultBasePath;
        this.defaultHeaders = {};
        this._useQuerystring = false;
        this.authentications = {
            'default': new VoidAuth(),
            'BearerToken': new ApiKeyAuth('header', 'authorization'),
        };
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        }
        else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername;
            }
        }
    }
    set useQuerystring(value) {
        this._useQuerystring = value;
    }
    set basePath(basePath) {
        this._basePath = basePath;
    }
    get basePath() {
        return this._basePath;
    }
    setDefaultAuthentication(auth) {
        this.authentications.default = auth;
    }
    setApiKey(key, value) {
        this.authentications[ExtensionsApiApiKeys[key]].apiKey = value;
    }
    /**
     * get information of a group
     */
    getAPIGroup() {
        const localVarPath = this.basePath + '/apis/extensions/';
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        let useFormData = false;
        let requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
exports.ExtensionsApi = ExtensionsApi;
var Extensions_v1beta1ApiApiKeys;
(function (Extensions_v1beta1ApiApiKeys) {
    Extensions_v1beta1ApiApiKeys[Extensions_v1beta1ApiApiKeys["BearerToken"] = 0] = "BearerToken";
})(Extensions_v1beta1ApiApiKeys = exports.Extensions_v1beta1ApiApiKeys || (exports.Extensions_v1beta1ApiApiKeys = {}));
class Extensions_v1beta1Api {
    constructor(basePathOrUsername, password, basePath) {
        this._basePath = defaultBasePath;
        this.defaultHeaders = {};
        this._useQuerystring = false;
        this.authentications = {
            'default': new VoidAuth(),
            'BearerToken': new ApiKeyAuth('header', 'authorization'),
        };
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        }
        else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername;
            }
        }
    }
    set useQuerystring(value) {
        this._useQuerystring = value;
    }
    set basePath(basePath) {
        this._basePath = basePath;
    }
    get basePath() {
        return this._basePath;
    }
    setDefaultAuthentication(auth) {
        this.authentications.default = auth;
    }
    setApiKey(key, value) {
        this.authentications[Extensions_v1beta1ApiApiKeys[key]].apiKey = value;
    }
    /**
     * create a DaemonSet
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    createNamespacedDaemonSet(namespace, body, pretty) {
        const localVarPath = this.basePath + '/apis/extensions/v1beta1/namespaces/{namespace}/daemonsets'
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling createNamespacedDaemonSet.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling createNamespacedDaemonSet.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * create a Deployment
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    createNamespacedDeployment(namespace, body, pretty) {
        const localVarPath = this.basePath + '/apis/extensions/v1beta1/namespaces/{namespace}/deployments'
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling createNamespacedDeployment.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling createNamespacedDeployment.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * create rollback of a Deployment
     * @param name name of the DeploymentRollback
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    createNamespacedDeploymentRollback(name, namespace, body, pretty) {
        const localVarPath = this.basePath + '/apis/extensions/v1beta1/namespaces/{namespace}/deployments/{name}/rollback'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling createNamespacedDeploymentRollback.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling createNamespacedDeploymentRollback.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling createNamespacedDeploymentRollback.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * create an Ingress
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    createNamespacedIngress(namespace, body, pretty) {
        const localVarPath = this.basePath + '/apis/extensions/v1beta1/namespaces/{namespace}/ingresses'
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling createNamespacedIngress.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling createNamespacedIngress.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * create a NetworkPolicy
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    createNamespacedNetworkPolicy(namespace, body, pretty) {
        const localVarPath = this.basePath + '/apis/extensions/v1beta1/namespaces/{namespace}/networkpolicies'
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling createNamespacedNetworkPolicy.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling createNamespacedNetworkPolicy.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * create a ReplicaSet
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    createNamespacedReplicaSet(namespace, body, pretty) {
        const localVarPath = this.basePath + '/apis/extensions/v1beta1/namespaces/{namespace}/replicasets'
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling createNamespacedReplicaSet.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling createNamespacedReplicaSet.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * create a PodSecurityPolicy
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    createPodSecurityPolicy(body, pretty) {
        const localVarPath = this.basePath + '/apis/extensions/v1beta1/podsecuritypolicies';
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling createPodSecurityPolicy.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * delete collection of DaemonSet
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param includeUninitialized If true, partially initialized resources are included in the response.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param timeoutSeconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    deleteCollectionNamespacedDaemonSet(namespace, pretty, _continue, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch) {
        const localVarPath = this.basePath + '/apis/extensions/v1beta1/namespaces/{namespace}/daemonsets'
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling deleteCollectionNamespacedDaemonSet.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (_continue !== undefined) {
            queryParameters['continue'] = _continue;
        }
        if (fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = fieldSelector;
        }
        if (includeUninitialized !== undefined) {
            queryParameters['includeUninitialized'] = includeUninitialized;
        }
        if (labelSelector !== undefined) {
            queryParameters['labelSelector'] = labelSelector;
        }
        if (limit !== undefined) {
            queryParameters['limit'] = limit;
        }
        if (resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = resourceVersion;
        }
        if (timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = timeoutSeconds;
        }
        if (watch !== undefined) {
            queryParameters['watch'] = watch;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * delete collection of Deployment
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param includeUninitialized If true, partially initialized resources are included in the response.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param timeoutSeconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    deleteCollectionNamespacedDeployment(namespace, pretty, _continue, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch) {
        const localVarPath = this.basePath + '/apis/extensions/v1beta1/namespaces/{namespace}/deployments'
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling deleteCollectionNamespacedDeployment.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (_continue !== undefined) {
            queryParameters['continue'] = _continue;
        }
        if (fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = fieldSelector;
        }
        if (includeUninitialized !== undefined) {
            queryParameters['includeUninitialized'] = includeUninitialized;
        }
        if (labelSelector !== undefined) {
            queryParameters['labelSelector'] = labelSelector;
        }
        if (limit !== undefined) {
            queryParameters['limit'] = limit;
        }
        if (resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = resourceVersion;
        }
        if (timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = timeoutSeconds;
        }
        if (watch !== undefined) {
            queryParameters['watch'] = watch;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * delete collection of Ingress
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param includeUninitialized If true, partially initialized resources are included in the response.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param timeoutSeconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    deleteCollectionNamespacedIngress(namespace, pretty, _continue, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch) {
        const localVarPath = this.basePath + '/apis/extensions/v1beta1/namespaces/{namespace}/ingresses'
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling deleteCollectionNamespacedIngress.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (_continue !== undefined) {
            queryParameters['continue'] = _continue;
        }
        if (fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = fieldSelector;
        }
        if (includeUninitialized !== undefined) {
            queryParameters['includeUninitialized'] = includeUninitialized;
        }
        if (labelSelector !== undefined) {
            queryParameters['labelSelector'] = labelSelector;
        }
        if (limit !== undefined) {
            queryParameters['limit'] = limit;
        }
        if (resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = resourceVersion;
        }
        if (timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = timeoutSeconds;
        }
        if (watch !== undefined) {
            queryParameters['watch'] = watch;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * delete collection of NetworkPolicy
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param includeUninitialized If true, partially initialized resources are included in the response.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param timeoutSeconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    deleteCollectionNamespacedNetworkPolicy(namespace, pretty, _continue, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch) {
        const localVarPath = this.basePath + '/apis/extensions/v1beta1/namespaces/{namespace}/networkpolicies'
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling deleteCollectionNamespacedNetworkPolicy.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (_continue !== undefined) {
            queryParameters['continue'] = _continue;
        }
        if (fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = fieldSelector;
        }
        if (includeUninitialized !== undefined) {
            queryParameters['includeUninitialized'] = includeUninitialized;
        }
        if (labelSelector !== undefined) {
            queryParameters['labelSelector'] = labelSelector;
        }
        if (limit !== undefined) {
            queryParameters['limit'] = limit;
        }
        if (resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = resourceVersion;
        }
        if (timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = timeoutSeconds;
        }
        if (watch !== undefined) {
            queryParameters['watch'] = watch;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * delete collection of ReplicaSet
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param includeUninitialized If true, partially initialized resources are included in the response.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param timeoutSeconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    deleteCollectionNamespacedReplicaSet(namespace, pretty, _continue, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch) {
        const localVarPath = this.basePath + '/apis/extensions/v1beta1/namespaces/{namespace}/replicasets'
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling deleteCollectionNamespacedReplicaSet.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (_continue !== undefined) {
            queryParameters['continue'] = _continue;
        }
        if (fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = fieldSelector;
        }
        if (includeUninitialized !== undefined) {
            queryParameters['includeUninitialized'] = includeUninitialized;
        }
        if (labelSelector !== undefined) {
            queryParameters['labelSelector'] = labelSelector;
        }
        if (limit !== undefined) {
            queryParameters['limit'] = limit;
        }
        if (resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = resourceVersion;
        }
        if (timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = timeoutSeconds;
        }
        if (watch !== undefined) {
            queryParameters['watch'] = watch;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * delete collection of PodSecurityPolicy
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param includeUninitialized If true, partially initialized resources are included in the response.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param timeoutSeconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    deleteCollectionPodSecurityPolicy(pretty, _continue, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch) {
        const localVarPath = this.basePath + '/apis/extensions/v1beta1/podsecuritypolicies';
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (_continue !== undefined) {
            queryParameters['continue'] = _continue;
        }
        if (fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = fieldSelector;
        }
        if (includeUninitialized !== undefined) {
            queryParameters['includeUninitialized'] = includeUninitialized;
        }
        if (labelSelector !== undefined) {
            queryParameters['labelSelector'] = labelSelector;
        }
        if (limit !== undefined) {
            queryParameters['limit'] = limit;
        }
        if (resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = resourceVersion;
        }
        if (timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = timeoutSeconds;
        }
        if (watch !== undefined) {
            queryParameters['watch'] = watch;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * delete a DaemonSet
     * @param name name of the DaemonSet
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param gracePeriodSeconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @param orphanDependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @param propagationPolicy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
     */
    deleteNamespacedDaemonSet(name, namespace, body, pretty, gracePeriodSeconds, orphanDependents, propagationPolicy) {
        const localVarPath = this.basePath + '/apis/extensions/v1beta1/namespaces/{namespace}/daemonsets/{name}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling deleteNamespacedDaemonSet.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling deleteNamespacedDaemonSet.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling deleteNamespacedDaemonSet.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (gracePeriodSeconds !== undefined) {
            queryParameters['gracePeriodSeconds'] = gracePeriodSeconds;
        }
        if (orphanDependents !== undefined) {
            queryParameters['orphanDependents'] = orphanDependents;
        }
        if (propagationPolicy !== undefined) {
            queryParameters['propagationPolicy'] = propagationPolicy;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * delete a Deployment
     * @param name name of the Deployment
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param gracePeriodSeconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @param orphanDependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @param propagationPolicy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
     */
    deleteNamespacedDeployment(name, namespace, body, pretty, gracePeriodSeconds, orphanDependents, propagationPolicy) {
        const localVarPath = this.basePath + '/apis/extensions/v1beta1/namespaces/{namespace}/deployments/{name}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling deleteNamespacedDeployment.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling deleteNamespacedDeployment.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling deleteNamespacedDeployment.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (gracePeriodSeconds !== undefined) {
            queryParameters['gracePeriodSeconds'] = gracePeriodSeconds;
        }
        if (orphanDependents !== undefined) {
            queryParameters['orphanDependents'] = orphanDependents;
        }
        if (propagationPolicy !== undefined) {
            queryParameters['propagationPolicy'] = propagationPolicy;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * delete an Ingress
     * @param name name of the Ingress
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param gracePeriodSeconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @param orphanDependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @param propagationPolicy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
     */
    deleteNamespacedIngress(name, namespace, body, pretty, gracePeriodSeconds, orphanDependents, propagationPolicy) {
        const localVarPath = this.basePath + '/apis/extensions/v1beta1/namespaces/{namespace}/ingresses/{name}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling deleteNamespacedIngress.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling deleteNamespacedIngress.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling deleteNamespacedIngress.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (gracePeriodSeconds !== undefined) {
            queryParameters['gracePeriodSeconds'] = gracePeriodSeconds;
        }
        if (orphanDependents !== undefined) {
            queryParameters['orphanDependents'] = orphanDependents;
        }
        if (propagationPolicy !== undefined) {
            queryParameters['propagationPolicy'] = propagationPolicy;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * delete a NetworkPolicy
     * @param name name of the NetworkPolicy
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param gracePeriodSeconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @param orphanDependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @param propagationPolicy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
     */
    deleteNamespacedNetworkPolicy(name, namespace, body, pretty, gracePeriodSeconds, orphanDependents, propagationPolicy) {
        const localVarPath = this.basePath + '/apis/extensions/v1beta1/namespaces/{namespace}/networkpolicies/{name}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling deleteNamespacedNetworkPolicy.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling deleteNamespacedNetworkPolicy.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling deleteNamespacedNetworkPolicy.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (gracePeriodSeconds !== undefined) {
            queryParameters['gracePeriodSeconds'] = gracePeriodSeconds;
        }
        if (orphanDependents !== undefined) {
            queryParameters['orphanDependents'] = orphanDependents;
        }
        if (propagationPolicy !== undefined) {
            queryParameters['propagationPolicy'] = propagationPolicy;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * delete a ReplicaSet
     * @param name name of the ReplicaSet
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param gracePeriodSeconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @param orphanDependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @param propagationPolicy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
     */
    deleteNamespacedReplicaSet(name, namespace, body, pretty, gracePeriodSeconds, orphanDependents, propagationPolicy) {
        const localVarPath = this.basePath + '/apis/extensions/v1beta1/namespaces/{namespace}/replicasets/{name}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling deleteNamespacedReplicaSet.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling deleteNamespacedReplicaSet.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling deleteNamespacedReplicaSet.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (gracePeriodSeconds !== undefined) {
            queryParameters['gracePeriodSeconds'] = gracePeriodSeconds;
        }
        if (orphanDependents !== undefined) {
            queryParameters['orphanDependents'] = orphanDependents;
        }
        if (propagationPolicy !== undefined) {
            queryParameters['propagationPolicy'] = propagationPolicy;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * delete a PodSecurityPolicy
     * @param name name of the PodSecurityPolicy
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param gracePeriodSeconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @param orphanDependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @param propagationPolicy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
     */
    deletePodSecurityPolicy(name, body, pretty, gracePeriodSeconds, orphanDependents, propagationPolicy) {
        const localVarPath = this.basePath + '/apis/extensions/v1beta1/podsecuritypolicies/{name}'
            .replace('{' + 'name' + '}', String(name));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling deletePodSecurityPolicy.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling deletePodSecurityPolicy.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (gracePeriodSeconds !== undefined) {
            queryParameters['gracePeriodSeconds'] = gracePeriodSeconds;
        }
        if (orphanDependents !== undefined) {
            queryParameters['orphanDependents'] = orphanDependents;
        }
        if (propagationPolicy !== undefined) {
            queryParameters['propagationPolicy'] = propagationPolicy;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * get available resources
     */
    getAPIResources() {
        const localVarPath = this.basePath + '/apis/extensions/v1beta1/';
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        let useFormData = false;
        let requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * list or watch objects of kind DaemonSet
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param includeUninitialized If true, partially initialized resources are included in the response.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param timeoutSeconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    listDaemonSetForAllNamespaces(_continue, fieldSelector, includeUninitialized, labelSelector, limit, pretty, resourceVersion, timeoutSeconds, watch) {
        const localVarPath = this.basePath + '/apis/extensions/v1beta1/daemonsets';
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        if (_continue !== undefined) {
            queryParameters['continue'] = _continue;
        }
        if (fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = fieldSelector;
        }
        if (includeUninitialized !== undefined) {
            queryParameters['includeUninitialized'] = includeUninitialized;
        }
        if (labelSelector !== undefined) {
            queryParameters['labelSelector'] = labelSelector;
        }
        if (limit !== undefined) {
            queryParameters['limit'] = limit;
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = resourceVersion;
        }
        if (timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = timeoutSeconds;
        }
        if (watch !== undefined) {
            queryParameters['watch'] = watch;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * list or watch objects of kind Deployment
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param includeUninitialized If true, partially initialized resources are included in the response.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param timeoutSeconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    listDeploymentForAllNamespaces(_continue, fieldSelector, includeUninitialized, labelSelector, limit, pretty, resourceVersion, timeoutSeconds, watch) {
        const localVarPath = this.basePath + '/apis/extensions/v1beta1/deployments';
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        if (_continue !== undefined) {
            queryParameters['continue'] = _continue;
        }
        if (fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = fieldSelector;
        }
        if (includeUninitialized !== undefined) {
            queryParameters['includeUninitialized'] = includeUninitialized;
        }
        if (labelSelector !== undefined) {
            queryParameters['labelSelector'] = labelSelector;
        }
        if (limit !== undefined) {
            queryParameters['limit'] = limit;
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = resourceVersion;
        }
        if (timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = timeoutSeconds;
        }
        if (watch !== undefined) {
            queryParameters['watch'] = watch;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * list or watch objects of kind Ingress
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param includeUninitialized If true, partially initialized resources are included in the response.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param timeoutSeconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    listIngressForAllNamespaces(_continue, fieldSelector, includeUninitialized, labelSelector, limit, pretty, resourceVersion, timeoutSeconds, watch) {
        const localVarPath = this.basePath + '/apis/extensions/v1beta1/ingresses';
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        if (_continue !== undefined) {
            queryParameters['continue'] = _continue;
        }
        if (fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = fieldSelector;
        }
        if (includeUninitialized !== undefined) {
            queryParameters['includeUninitialized'] = includeUninitialized;
        }
        if (labelSelector !== undefined) {
            queryParameters['labelSelector'] = labelSelector;
        }
        if (limit !== undefined) {
            queryParameters['limit'] = limit;
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = resourceVersion;
        }
        if (timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = timeoutSeconds;
        }
        if (watch !== undefined) {
            queryParameters['watch'] = watch;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * list or watch objects of kind DaemonSet
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param includeUninitialized If true, partially initialized resources are included in the response.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param timeoutSeconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    listNamespacedDaemonSet(namespace, pretty, _continue, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch) {
        const localVarPath = this.basePath + '/apis/extensions/v1beta1/namespaces/{namespace}/daemonsets'
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling listNamespacedDaemonSet.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (_continue !== undefined) {
            queryParameters['continue'] = _continue;
        }
        if (fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = fieldSelector;
        }
        if (includeUninitialized !== undefined) {
            queryParameters['includeUninitialized'] = includeUninitialized;
        }
        if (labelSelector !== undefined) {
            queryParameters['labelSelector'] = labelSelector;
        }
        if (limit !== undefined) {
            queryParameters['limit'] = limit;
        }
        if (resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = resourceVersion;
        }
        if (timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = timeoutSeconds;
        }
        if (watch !== undefined) {
            queryParameters['watch'] = watch;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * list or watch objects of kind Deployment
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param includeUninitialized If true, partially initialized resources are included in the response.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param timeoutSeconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    listNamespacedDeployment(namespace, pretty, _continue, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch) {
        const localVarPath = this.basePath + '/apis/extensions/v1beta1/namespaces/{namespace}/deployments'
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling listNamespacedDeployment.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (_continue !== undefined) {
            queryParameters['continue'] = _continue;
        }
        if (fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = fieldSelector;
        }
        if (includeUninitialized !== undefined) {
            queryParameters['includeUninitialized'] = includeUninitialized;
        }
        if (labelSelector !== undefined) {
            queryParameters['labelSelector'] = labelSelector;
        }
        if (limit !== undefined) {
            queryParameters['limit'] = limit;
        }
        if (resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = resourceVersion;
        }
        if (timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = timeoutSeconds;
        }
        if (watch !== undefined) {
            queryParameters['watch'] = watch;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * list or watch objects of kind Ingress
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param includeUninitialized If true, partially initialized resources are included in the response.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param timeoutSeconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    listNamespacedIngress(namespace, pretty, _continue, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch) {
        const localVarPath = this.basePath + '/apis/extensions/v1beta1/namespaces/{namespace}/ingresses'
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling listNamespacedIngress.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (_continue !== undefined) {
            queryParameters['continue'] = _continue;
        }
        if (fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = fieldSelector;
        }
        if (includeUninitialized !== undefined) {
            queryParameters['includeUninitialized'] = includeUninitialized;
        }
        if (labelSelector !== undefined) {
            queryParameters['labelSelector'] = labelSelector;
        }
        if (limit !== undefined) {
            queryParameters['limit'] = limit;
        }
        if (resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = resourceVersion;
        }
        if (timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = timeoutSeconds;
        }
        if (watch !== undefined) {
            queryParameters['watch'] = watch;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * list or watch objects of kind NetworkPolicy
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param includeUninitialized If true, partially initialized resources are included in the response.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param timeoutSeconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    listNamespacedNetworkPolicy(namespace, pretty, _continue, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch) {
        const localVarPath = this.basePath + '/apis/extensions/v1beta1/namespaces/{namespace}/networkpolicies'
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling listNamespacedNetworkPolicy.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (_continue !== undefined) {
            queryParameters['continue'] = _continue;
        }
        if (fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = fieldSelector;
        }
        if (includeUninitialized !== undefined) {
            queryParameters['includeUninitialized'] = includeUninitialized;
        }
        if (labelSelector !== undefined) {
            queryParameters['labelSelector'] = labelSelector;
        }
        if (limit !== undefined) {
            queryParameters['limit'] = limit;
        }
        if (resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = resourceVersion;
        }
        if (timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = timeoutSeconds;
        }
        if (watch !== undefined) {
            queryParameters['watch'] = watch;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * list or watch objects of kind ReplicaSet
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param includeUninitialized If true, partially initialized resources are included in the response.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param timeoutSeconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    listNamespacedReplicaSet(namespace, pretty, _continue, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch) {
        const localVarPath = this.basePath + '/apis/extensions/v1beta1/namespaces/{namespace}/replicasets'
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling listNamespacedReplicaSet.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (_continue !== undefined) {
            queryParameters['continue'] = _continue;
        }
        if (fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = fieldSelector;
        }
        if (includeUninitialized !== undefined) {
            queryParameters['includeUninitialized'] = includeUninitialized;
        }
        if (labelSelector !== undefined) {
            queryParameters['labelSelector'] = labelSelector;
        }
        if (limit !== undefined) {
            queryParameters['limit'] = limit;
        }
        if (resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = resourceVersion;
        }
        if (timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = timeoutSeconds;
        }
        if (watch !== undefined) {
            queryParameters['watch'] = watch;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * list or watch objects of kind NetworkPolicy
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param includeUninitialized If true, partially initialized resources are included in the response.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param timeoutSeconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    listNetworkPolicyForAllNamespaces(_continue, fieldSelector, includeUninitialized, labelSelector, limit, pretty, resourceVersion, timeoutSeconds, watch) {
        const localVarPath = this.basePath + '/apis/extensions/v1beta1/networkpolicies';
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        if (_continue !== undefined) {
            queryParameters['continue'] = _continue;
        }
        if (fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = fieldSelector;
        }
        if (includeUninitialized !== undefined) {
            queryParameters['includeUninitialized'] = includeUninitialized;
        }
        if (labelSelector !== undefined) {
            queryParameters['labelSelector'] = labelSelector;
        }
        if (limit !== undefined) {
            queryParameters['limit'] = limit;
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = resourceVersion;
        }
        if (timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = timeoutSeconds;
        }
        if (watch !== undefined) {
            queryParameters['watch'] = watch;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * list or watch objects of kind PodSecurityPolicy
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param includeUninitialized If true, partially initialized resources are included in the response.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param timeoutSeconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    listPodSecurityPolicy(pretty, _continue, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch) {
        const localVarPath = this.basePath + '/apis/extensions/v1beta1/podsecuritypolicies';
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (_continue !== undefined) {
            queryParameters['continue'] = _continue;
        }
        if (fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = fieldSelector;
        }
        if (includeUninitialized !== undefined) {
            queryParameters['includeUninitialized'] = includeUninitialized;
        }
        if (labelSelector !== undefined) {
            queryParameters['labelSelector'] = labelSelector;
        }
        if (limit !== undefined) {
            queryParameters['limit'] = limit;
        }
        if (resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = resourceVersion;
        }
        if (timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = timeoutSeconds;
        }
        if (watch !== undefined) {
            queryParameters['watch'] = watch;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * list or watch objects of kind ReplicaSet
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param includeUninitialized If true, partially initialized resources are included in the response.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param timeoutSeconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    listReplicaSetForAllNamespaces(_continue, fieldSelector, includeUninitialized, labelSelector, limit, pretty, resourceVersion, timeoutSeconds, watch) {
        const localVarPath = this.basePath + '/apis/extensions/v1beta1/replicasets';
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        if (_continue !== undefined) {
            queryParameters['continue'] = _continue;
        }
        if (fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = fieldSelector;
        }
        if (includeUninitialized !== undefined) {
            queryParameters['includeUninitialized'] = includeUninitialized;
        }
        if (labelSelector !== undefined) {
            queryParameters['labelSelector'] = labelSelector;
        }
        if (limit !== undefined) {
            queryParameters['limit'] = limit;
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = resourceVersion;
        }
        if (timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = timeoutSeconds;
        }
        if (watch !== undefined) {
            queryParameters['watch'] = watch;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * partially update the specified DaemonSet
     * @param name name of the DaemonSet
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    patchNamespacedDaemonSet(name, namespace, body, pretty) {
        const localVarPath = this.basePath + '/apis/extensions/v1beta1/namespaces/{namespace}/daemonsets/{name}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling patchNamespacedDaemonSet.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling patchNamespacedDaemonSet.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling patchNamespacedDaemonSet.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'PATCH',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * partially update status of the specified DaemonSet
     * @param name name of the DaemonSet
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    patchNamespacedDaemonSetStatus(name, namespace, body, pretty) {
        const localVarPath = this.basePath + '/apis/extensions/v1beta1/namespaces/{namespace}/daemonsets/{name}/status'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling patchNamespacedDaemonSetStatus.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling patchNamespacedDaemonSetStatus.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling patchNamespacedDaemonSetStatus.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'PATCH',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * partially update the specified Deployment
     * @param name name of the Deployment
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    patchNamespacedDeployment(name, namespace, body, pretty) {
        const localVarPath = this.basePath + '/apis/extensions/v1beta1/namespaces/{namespace}/deployments/{name}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling patchNamespacedDeployment.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling patchNamespacedDeployment.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling patchNamespacedDeployment.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'PATCH',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * partially update scale of the specified Deployment
     * @param name name of the Scale
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    patchNamespacedDeploymentScale(name, namespace, body, pretty) {
        const localVarPath = this.basePath + '/apis/extensions/v1beta1/namespaces/{namespace}/deployments/{name}/scale'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling patchNamespacedDeploymentScale.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling patchNamespacedDeploymentScale.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling patchNamespacedDeploymentScale.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'PATCH',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * partially update status of the specified Deployment
     * @param name name of the Deployment
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    patchNamespacedDeploymentStatus(name, namespace, body, pretty) {
        const localVarPath = this.basePath + '/apis/extensions/v1beta1/namespaces/{namespace}/deployments/{name}/status'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling patchNamespacedDeploymentStatus.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling patchNamespacedDeploymentStatus.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling patchNamespacedDeploymentStatus.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'PATCH',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * partially update the specified Ingress
     * @param name name of the Ingress
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    patchNamespacedIngress(name, namespace, body, pretty) {
        const localVarPath = this.basePath + '/apis/extensions/v1beta1/namespaces/{namespace}/ingresses/{name}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling patchNamespacedIngress.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling patchNamespacedIngress.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling patchNamespacedIngress.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'PATCH',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * partially update status of the specified Ingress
     * @param name name of the Ingress
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    patchNamespacedIngressStatus(name, namespace, body, pretty) {
        const localVarPath = this.basePath + '/apis/extensions/v1beta1/namespaces/{namespace}/ingresses/{name}/status'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling patchNamespacedIngressStatus.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling patchNamespacedIngressStatus.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling patchNamespacedIngressStatus.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'PATCH',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * partially update the specified NetworkPolicy
     * @param name name of the NetworkPolicy
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    patchNamespacedNetworkPolicy(name, namespace, body, pretty) {
        const localVarPath = this.basePath + '/apis/extensions/v1beta1/namespaces/{namespace}/networkpolicies/{name}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling patchNamespacedNetworkPolicy.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling patchNamespacedNetworkPolicy.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling patchNamespacedNetworkPolicy.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'PATCH',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * partially update the specified ReplicaSet
     * @param name name of the ReplicaSet
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    patchNamespacedReplicaSet(name, namespace, body, pretty) {
        const localVarPath = this.basePath + '/apis/extensions/v1beta1/namespaces/{namespace}/replicasets/{name}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling patchNamespacedReplicaSet.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling patchNamespacedReplicaSet.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling patchNamespacedReplicaSet.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'PATCH',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * partially update scale of the specified ReplicaSet
     * @param name name of the Scale
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    patchNamespacedReplicaSetScale(name, namespace, body, pretty) {
        const localVarPath = this.basePath + '/apis/extensions/v1beta1/namespaces/{namespace}/replicasets/{name}/scale'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling patchNamespacedReplicaSetScale.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling patchNamespacedReplicaSetScale.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling patchNamespacedReplicaSetScale.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'PATCH',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * partially update status of the specified ReplicaSet
     * @param name name of the ReplicaSet
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    patchNamespacedReplicaSetStatus(name, namespace, body, pretty) {
        const localVarPath = this.basePath + '/apis/extensions/v1beta1/namespaces/{namespace}/replicasets/{name}/status'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling patchNamespacedReplicaSetStatus.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling patchNamespacedReplicaSetStatus.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling patchNamespacedReplicaSetStatus.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'PATCH',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * partially update scale of the specified ReplicationControllerDummy
     * @param name name of the Scale
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    patchNamespacedReplicationControllerDummyScale(name, namespace, body, pretty) {
        const localVarPath = this.basePath + '/apis/extensions/v1beta1/namespaces/{namespace}/replicationcontrollers/{name}/scale'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling patchNamespacedReplicationControllerDummyScale.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling patchNamespacedReplicationControllerDummyScale.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling patchNamespacedReplicationControllerDummyScale.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'PATCH',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * partially update the specified PodSecurityPolicy
     * @param name name of the PodSecurityPolicy
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    patchPodSecurityPolicy(name, body, pretty) {
        const localVarPath = this.basePath + '/apis/extensions/v1beta1/podsecuritypolicies/{name}'
            .replace('{' + 'name' + '}', String(name));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling patchPodSecurityPolicy.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling patchPodSecurityPolicy.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'PATCH',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * read the specified DaemonSet
     * @param name name of the DaemonSet
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param exact Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;.
     * @param _export Should this value be exported.  Export strips fields that a user can not specify.
     */
    readNamespacedDaemonSet(name, namespace, pretty, exact, _export) {
        const localVarPath = this.basePath + '/apis/extensions/v1beta1/namespaces/{namespace}/daemonsets/{name}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling readNamespacedDaemonSet.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling readNamespacedDaemonSet.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (exact !== undefined) {
            queryParameters['exact'] = exact;
        }
        if (_export !== undefined) {
            queryParameters['export'] = _export;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * read status of the specified DaemonSet
     * @param name name of the DaemonSet
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    readNamespacedDaemonSetStatus(name, namespace, pretty) {
        const localVarPath = this.basePath + '/apis/extensions/v1beta1/namespaces/{namespace}/daemonsets/{name}/status'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling readNamespacedDaemonSetStatus.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling readNamespacedDaemonSetStatus.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * read the specified Deployment
     * @param name name of the Deployment
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param exact Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;.
     * @param _export Should this value be exported.  Export strips fields that a user can not specify.
     */
    readNamespacedDeployment(name, namespace, pretty, exact, _export) {
        const localVarPath = this.basePath + '/apis/extensions/v1beta1/namespaces/{namespace}/deployments/{name}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling readNamespacedDeployment.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling readNamespacedDeployment.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (exact !== undefined) {
            queryParameters['exact'] = exact;
        }
        if (_export !== undefined) {
            queryParameters['export'] = _export;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * read scale of the specified Deployment
     * @param name name of the Scale
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    readNamespacedDeploymentScale(name, namespace, pretty) {
        const localVarPath = this.basePath + '/apis/extensions/v1beta1/namespaces/{namespace}/deployments/{name}/scale'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling readNamespacedDeploymentScale.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling readNamespacedDeploymentScale.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * read status of the specified Deployment
     * @param name name of the Deployment
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    readNamespacedDeploymentStatus(name, namespace, pretty) {
        const localVarPath = this.basePath + '/apis/extensions/v1beta1/namespaces/{namespace}/deployments/{name}/status'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling readNamespacedDeploymentStatus.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling readNamespacedDeploymentStatus.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * read the specified Ingress
     * @param name name of the Ingress
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param exact Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;.
     * @param _export Should this value be exported.  Export strips fields that a user can not specify.
     */
    readNamespacedIngress(name, namespace, pretty, exact, _export) {
        const localVarPath = this.basePath + '/apis/extensions/v1beta1/namespaces/{namespace}/ingresses/{name}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling readNamespacedIngress.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling readNamespacedIngress.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (exact !== undefined) {
            queryParameters['exact'] = exact;
        }
        if (_export !== undefined) {
            queryParameters['export'] = _export;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * read status of the specified Ingress
     * @param name name of the Ingress
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    readNamespacedIngressStatus(name, namespace, pretty) {
        const localVarPath = this.basePath + '/apis/extensions/v1beta1/namespaces/{namespace}/ingresses/{name}/status'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling readNamespacedIngressStatus.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling readNamespacedIngressStatus.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * read the specified NetworkPolicy
     * @param name name of the NetworkPolicy
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param exact Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;.
     * @param _export Should this value be exported.  Export strips fields that a user can not specify.
     */
    readNamespacedNetworkPolicy(name, namespace, pretty, exact, _export) {
        const localVarPath = this.basePath + '/apis/extensions/v1beta1/namespaces/{namespace}/networkpolicies/{name}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling readNamespacedNetworkPolicy.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling readNamespacedNetworkPolicy.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (exact !== undefined) {
            queryParameters['exact'] = exact;
        }
        if (_export !== undefined) {
            queryParameters['export'] = _export;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * read the specified ReplicaSet
     * @param name name of the ReplicaSet
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param exact Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;.
     * @param _export Should this value be exported.  Export strips fields that a user can not specify.
     */
    readNamespacedReplicaSet(name, namespace, pretty, exact, _export) {
        const localVarPath = this.basePath + '/apis/extensions/v1beta1/namespaces/{namespace}/replicasets/{name}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling readNamespacedReplicaSet.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling readNamespacedReplicaSet.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (exact !== undefined) {
            queryParameters['exact'] = exact;
        }
        if (_export !== undefined) {
            queryParameters['export'] = _export;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * read scale of the specified ReplicaSet
     * @param name name of the Scale
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    readNamespacedReplicaSetScale(name, namespace, pretty) {
        const localVarPath = this.basePath + '/apis/extensions/v1beta1/namespaces/{namespace}/replicasets/{name}/scale'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling readNamespacedReplicaSetScale.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling readNamespacedReplicaSetScale.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * read status of the specified ReplicaSet
     * @param name name of the ReplicaSet
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    readNamespacedReplicaSetStatus(name, namespace, pretty) {
        const localVarPath = this.basePath + '/apis/extensions/v1beta1/namespaces/{namespace}/replicasets/{name}/status'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling readNamespacedReplicaSetStatus.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling readNamespacedReplicaSetStatus.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * read scale of the specified ReplicationControllerDummy
     * @param name name of the Scale
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    readNamespacedReplicationControllerDummyScale(name, namespace, pretty) {
        const localVarPath = this.basePath + '/apis/extensions/v1beta1/namespaces/{namespace}/replicationcontrollers/{name}/scale'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling readNamespacedReplicationControllerDummyScale.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling readNamespacedReplicationControllerDummyScale.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * read the specified PodSecurityPolicy
     * @param name name of the PodSecurityPolicy
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param exact Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;.
     * @param _export Should this value be exported.  Export strips fields that a user can not specify.
     */
    readPodSecurityPolicy(name, pretty, exact, _export) {
        const localVarPath = this.basePath + '/apis/extensions/v1beta1/podsecuritypolicies/{name}'
            .replace('{' + 'name' + '}', String(name));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling readPodSecurityPolicy.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (exact !== undefined) {
            queryParameters['exact'] = exact;
        }
        if (_export !== undefined) {
            queryParameters['export'] = _export;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * replace the specified DaemonSet
     * @param name name of the DaemonSet
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    replaceNamespacedDaemonSet(name, namespace, body, pretty) {
        const localVarPath = this.basePath + '/apis/extensions/v1beta1/namespaces/{namespace}/daemonsets/{name}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling replaceNamespacedDaemonSet.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling replaceNamespacedDaemonSet.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling replaceNamespacedDaemonSet.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * replace status of the specified DaemonSet
     * @param name name of the DaemonSet
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    replaceNamespacedDaemonSetStatus(name, namespace, body, pretty) {
        const localVarPath = this.basePath + '/apis/extensions/v1beta1/namespaces/{namespace}/daemonsets/{name}/status'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling replaceNamespacedDaemonSetStatus.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling replaceNamespacedDaemonSetStatus.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling replaceNamespacedDaemonSetStatus.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * replace the specified Deployment
     * @param name name of the Deployment
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    replaceNamespacedDeployment(name, namespace, body, pretty) {
        const localVarPath = this.basePath + '/apis/extensions/v1beta1/namespaces/{namespace}/deployments/{name}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling replaceNamespacedDeployment.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling replaceNamespacedDeployment.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling replaceNamespacedDeployment.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * replace scale of the specified Deployment
     * @param name name of the Scale
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    replaceNamespacedDeploymentScale(name, namespace, body, pretty) {
        const localVarPath = this.basePath + '/apis/extensions/v1beta1/namespaces/{namespace}/deployments/{name}/scale'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling replaceNamespacedDeploymentScale.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling replaceNamespacedDeploymentScale.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling replaceNamespacedDeploymentScale.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * replace status of the specified Deployment
     * @param name name of the Deployment
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    replaceNamespacedDeploymentStatus(name, namespace, body, pretty) {
        const localVarPath = this.basePath + '/apis/extensions/v1beta1/namespaces/{namespace}/deployments/{name}/status'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling replaceNamespacedDeploymentStatus.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling replaceNamespacedDeploymentStatus.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling replaceNamespacedDeploymentStatus.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * replace the specified Ingress
     * @param name name of the Ingress
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    replaceNamespacedIngress(name, namespace, body, pretty) {
        const localVarPath = this.basePath + '/apis/extensions/v1beta1/namespaces/{namespace}/ingresses/{name}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling replaceNamespacedIngress.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling replaceNamespacedIngress.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling replaceNamespacedIngress.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * replace status of the specified Ingress
     * @param name name of the Ingress
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    replaceNamespacedIngressStatus(name, namespace, body, pretty) {
        const localVarPath = this.basePath + '/apis/extensions/v1beta1/namespaces/{namespace}/ingresses/{name}/status'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling replaceNamespacedIngressStatus.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling replaceNamespacedIngressStatus.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling replaceNamespacedIngressStatus.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * replace the specified NetworkPolicy
     * @param name name of the NetworkPolicy
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    replaceNamespacedNetworkPolicy(name, namespace, body, pretty) {
        const localVarPath = this.basePath + '/apis/extensions/v1beta1/namespaces/{namespace}/networkpolicies/{name}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling replaceNamespacedNetworkPolicy.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling replaceNamespacedNetworkPolicy.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling replaceNamespacedNetworkPolicy.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * replace the specified ReplicaSet
     * @param name name of the ReplicaSet
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    replaceNamespacedReplicaSet(name, namespace, body, pretty) {
        const localVarPath = this.basePath + '/apis/extensions/v1beta1/namespaces/{namespace}/replicasets/{name}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling replaceNamespacedReplicaSet.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling replaceNamespacedReplicaSet.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling replaceNamespacedReplicaSet.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * replace scale of the specified ReplicaSet
     * @param name name of the Scale
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    replaceNamespacedReplicaSetScale(name, namespace, body, pretty) {
        const localVarPath = this.basePath + '/apis/extensions/v1beta1/namespaces/{namespace}/replicasets/{name}/scale'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling replaceNamespacedReplicaSetScale.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling replaceNamespacedReplicaSetScale.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling replaceNamespacedReplicaSetScale.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * replace status of the specified ReplicaSet
     * @param name name of the ReplicaSet
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    replaceNamespacedReplicaSetStatus(name, namespace, body, pretty) {
        const localVarPath = this.basePath + '/apis/extensions/v1beta1/namespaces/{namespace}/replicasets/{name}/status'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling replaceNamespacedReplicaSetStatus.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling replaceNamespacedReplicaSetStatus.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling replaceNamespacedReplicaSetStatus.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * replace scale of the specified ReplicationControllerDummy
     * @param name name of the Scale
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    replaceNamespacedReplicationControllerDummyScale(name, namespace, body, pretty) {
        const localVarPath = this.basePath + '/apis/extensions/v1beta1/namespaces/{namespace}/replicationcontrollers/{name}/scale'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling replaceNamespacedReplicationControllerDummyScale.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling replaceNamespacedReplicationControllerDummyScale.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling replaceNamespacedReplicationControllerDummyScale.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * replace the specified PodSecurityPolicy
     * @param name name of the PodSecurityPolicy
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    replacePodSecurityPolicy(name, body, pretty) {
        const localVarPath = this.basePath + '/apis/extensions/v1beta1/podsecuritypolicies/{name}'
            .replace('{' + 'name' + '}', String(name));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling replacePodSecurityPolicy.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling replacePodSecurityPolicy.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
exports.Extensions_v1beta1Api = Extensions_v1beta1Api;
var LogsApiApiKeys;
(function (LogsApiApiKeys) {
    LogsApiApiKeys[LogsApiApiKeys["BearerToken"] = 0] = "BearerToken";
})(LogsApiApiKeys = exports.LogsApiApiKeys || (exports.LogsApiApiKeys = {}));
class LogsApi {
    constructor(basePathOrUsername, password, basePath) {
        this._basePath = defaultBasePath;
        this.defaultHeaders = {};
        this._useQuerystring = false;
        this.authentications = {
            'default': new VoidAuth(),
            'BearerToken': new ApiKeyAuth('header', 'authorization'),
        };
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        }
        else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername;
            }
        }
    }
    set useQuerystring(value) {
        this._useQuerystring = value;
    }
    set basePath(basePath) {
        this._basePath = basePath;
    }
    get basePath() {
        return this._basePath;
    }
    setDefaultAuthentication(auth) {
        this.authentications.default = auth;
    }
    setApiKey(key, value) {
        this.authentications[LogsApiApiKeys[key]].apiKey = value;
    }
    /**
     *
     * @param logpath path to the log
     */
    logFileHandler(logpath) {
        const localVarPath = this.basePath + '/logs/{logpath}'
            .replace('{' + 'logpath' + '}', String(logpath));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'logpath' is not null or undefined
        if (logpath === null || logpath === undefined) {
            throw new Error('Required parameter logpath was null or undefined when calling logFileHandler.');
        }
        let useFormData = false;
        let requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     *
     */
    logFileListHandler() {
        const localVarPath = this.basePath + '/logs/';
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        let useFormData = false;
        let requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
exports.LogsApi = LogsApi;
var NetworkingApiApiKeys;
(function (NetworkingApiApiKeys) {
    NetworkingApiApiKeys[NetworkingApiApiKeys["BearerToken"] = 0] = "BearerToken";
})(NetworkingApiApiKeys = exports.NetworkingApiApiKeys || (exports.NetworkingApiApiKeys = {}));
class NetworkingApi {
    constructor(basePathOrUsername, password, basePath) {
        this._basePath = defaultBasePath;
        this.defaultHeaders = {};
        this._useQuerystring = false;
        this.authentications = {
            'default': new VoidAuth(),
            'BearerToken': new ApiKeyAuth('header', 'authorization'),
        };
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        }
        else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername;
            }
        }
    }
    set useQuerystring(value) {
        this._useQuerystring = value;
    }
    set basePath(basePath) {
        this._basePath = basePath;
    }
    get basePath() {
        return this._basePath;
    }
    setDefaultAuthentication(auth) {
        this.authentications.default = auth;
    }
    setApiKey(key, value) {
        this.authentications[NetworkingApiApiKeys[key]].apiKey = value;
    }
    /**
     * get information of a group
     */
    getAPIGroup() {
        const localVarPath = this.basePath + '/apis/networking.k8s.io/';
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        let useFormData = false;
        let requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
exports.NetworkingApi = NetworkingApi;
var Networking_v1ApiApiKeys;
(function (Networking_v1ApiApiKeys) {
    Networking_v1ApiApiKeys[Networking_v1ApiApiKeys["BearerToken"] = 0] = "BearerToken";
})(Networking_v1ApiApiKeys = exports.Networking_v1ApiApiKeys || (exports.Networking_v1ApiApiKeys = {}));
class Networking_v1Api {
    constructor(basePathOrUsername, password, basePath) {
        this._basePath = defaultBasePath;
        this.defaultHeaders = {};
        this._useQuerystring = false;
        this.authentications = {
            'default': new VoidAuth(),
            'BearerToken': new ApiKeyAuth('header', 'authorization'),
        };
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        }
        else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername;
            }
        }
    }
    set useQuerystring(value) {
        this._useQuerystring = value;
    }
    set basePath(basePath) {
        this._basePath = basePath;
    }
    get basePath() {
        return this._basePath;
    }
    setDefaultAuthentication(auth) {
        this.authentications.default = auth;
    }
    setApiKey(key, value) {
        this.authentications[Networking_v1ApiApiKeys[key]].apiKey = value;
    }
    /**
     * create a NetworkPolicy
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    createNamespacedNetworkPolicy(namespace, body, pretty) {
        const localVarPath = this.basePath + '/apis/networking.k8s.io/v1/namespaces/{namespace}/networkpolicies'
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling createNamespacedNetworkPolicy.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling createNamespacedNetworkPolicy.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * delete collection of NetworkPolicy
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param includeUninitialized If true, partially initialized resources are included in the response.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param timeoutSeconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    deleteCollectionNamespacedNetworkPolicy(namespace, pretty, _continue, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch) {
        const localVarPath = this.basePath + '/apis/networking.k8s.io/v1/namespaces/{namespace}/networkpolicies'
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling deleteCollectionNamespacedNetworkPolicy.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (_continue !== undefined) {
            queryParameters['continue'] = _continue;
        }
        if (fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = fieldSelector;
        }
        if (includeUninitialized !== undefined) {
            queryParameters['includeUninitialized'] = includeUninitialized;
        }
        if (labelSelector !== undefined) {
            queryParameters['labelSelector'] = labelSelector;
        }
        if (limit !== undefined) {
            queryParameters['limit'] = limit;
        }
        if (resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = resourceVersion;
        }
        if (timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = timeoutSeconds;
        }
        if (watch !== undefined) {
            queryParameters['watch'] = watch;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * delete a NetworkPolicy
     * @param name name of the NetworkPolicy
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param gracePeriodSeconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @param orphanDependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @param propagationPolicy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
     */
    deleteNamespacedNetworkPolicy(name, namespace, body, pretty, gracePeriodSeconds, orphanDependents, propagationPolicy) {
        const localVarPath = this.basePath + '/apis/networking.k8s.io/v1/namespaces/{namespace}/networkpolicies/{name}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling deleteNamespacedNetworkPolicy.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling deleteNamespacedNetworkPolicy.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling deleteNamespacedNetworkPolicy.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (gracePeriodSeconds !== undefined) {
            queryParameters['gracePeriodSeconds'] = gracePeriodSeconds;
        }
        if (orphanDependents !== undefined) {
            queryParameters['orphanDependents'] = orphanDependents;
        }
        if (propagationPolicy !== undefined) {
            queryParameters['propagationPolicy'] = propagationPolicy;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * get available resources
     */
    getAPIResources() {
        const localVarPath = this.basePath + '/apis/networking.k8s.io/v1/';
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        let useFormData = false;
        let requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * list or watch objects of kind NetworkPolicy
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param includeUninitialized If true, partially initialized resources are included in the response.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param timeoutSeconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    listNamespacedNetworkPolicy(namespace, pretty, _continue, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch) {
        const localVarPath = this.basePath + '/apis/networking.k8s.io/v1/namespaces/{namespace}/networkpolicies'
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling listNamespacedNetworkPolicy.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (_continue !== undefined) {
            queryParameters['continue'] = _continue;
        }
        if (fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = fieldSelector;
        }
        if (includeUninitialized !== undefined) {
            queryParameters['includeUninitialized'] = includeUninitialized;
        }
        if (labelSelector !== undefined) {
            queryParameters['labelSelector'] = labelSelector;
        }
        if (limit !== undefined) {
            queryParameters['limit'] = limit;
        }
        if (resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = resourceVersion;
        }
        if (timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = timeoutSeconds;
        }
        if (watch !== undefined) {
            queryParameters['watch'] = watch;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * list or watch objects of kind NetworkPolicy
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param includeUninitialized If true, partially initialized resources are included in the response.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param timeoutSeconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    listNetworkPolicyForAllNamespaces(_continue, fieldSelector, includeUninitialized, labelSelector, limit, pretty, resourceVersion, timeoutSeconds, watch) {
        const localVarPath = this.basePath + '/apis/networking.k8s.io/v1/networkpolicies';
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        if (_continue !== undefined) {
            queryParameters['continue'] = _continue;
        }
        if (fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = fieldSelector;
        }
        if (includeUninitialized !== undefined) {
            queryParameters['includeUninitialized'] = includeUninitialized;
        }
        if (labelSelector !== undefined) {
            queryParameters['labelSelector'] = labelSelector;
        }
        if (limit !== undefined) {
            queryParameters['limit'] = limit;
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = resourceVersion;
        }
        if (timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = timeoutSeconds;
        }
        if (watch !== undefined) {
            queryParameters['watch'] = watch;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * partially update the specified NetworkPolicy
     * @param name name of the NetworkPolicy
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    patchNamespacedNetworkPolicy(name, namespace, body, pretty) {
        const localVarPath = this.basePath + '/apis/networking.k8s.io/v1/namespaces/{namespace}/networkpolicies/{name}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling patchNamespacedNetworkPolicy.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling patchNamespacedNetworkPolicy.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling patchNamespacedNetworkPolicy.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'PATCH',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * read the specified NetworkPolicy
     * @param name name of the NetworkPolicy
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param exact Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;.
     * @param _export Should this value be exported.  Export strips fields that a user can not specify.
     */
    readNamespacedNetworkPolicy(name, namespace, pretty, exact, _export) {
        const localVarPath = this.basePath + '/apis/networking.k8s.io/v1/namespaces/{namespace}/networkpolicies/{name}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling readNamespacedNetworkPolicy.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling readNamespacedNetworkPolicy.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (exact !== undefined) {
            queryParameters['exact'] = exact;
        }
        if (_export !== undefined) {
            queryParameters['export'] = _export;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * replace the specified NetworkPolicy
     * @param name name of the NetworkPolicy
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    replaceNamespacedNetworkPolicy(name, namespace, body, pretty) {
        const localVarPath = this.basePath + '/apis/networking.k8s.io/v1/namespaces/{namespace}/networkpolicies/{name}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling replaceNamespacedNetworkPolicy.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling replaceNamespacedNetworkPolicy.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling replaceNamespacedNetworkPolicy.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
exports.Networking_v1Api = Networking_v1Api;
var PolicyApiApiKeys;
(function (PolicyApiApiKeys) {
    PolicyApiApiKeys[PolicyApiApiKeys["BearerToken"] = 0] = "BearerToken";
})(PolicyApiApiKeys = exports.PolicyApiApiKeys || (exports.PolicyApiApiKeys = {}));
class PolicyApi {
    constructor(basePathOrUsername, password, basePath) {
        this._basePath = defaultBasePath;
        this.defaultHeaders = {};
        this._useQuerystring = false;
        this.authentications = {
            'default': new VoidAuth(),
            'BearerToken': new ApiKeyAuth('header', 'authorization'),
        };
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        }
        else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername;
            }
        }
    }
    set useQuerystring(value) {
        this._useQuerystring = value;
    }
    set basePath(basePath) {
        this._basePath = basePath;
    }
    get basePath() {
        return this._basePath;
    }
    setDefaultAuthentication(auth) {
        this.authentications.default = auth;
    }
    setApiKey(key, value) {
        this.authentications[PolicyApiApiKeys[key]].apiKey = value;
    }
    /**
     * get information of a group
     */
    getAPIGroup() {
        const localVarPath = this.basePath + '/apis/policy/';
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        let useFormData = false;
        let requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
exports.PolicyApi = PolicyApi;
var Policy_v1beta1ApiApiKeys;
(function (Policy_v1beta1ApiApiKeys) {
    Policy_v1beta1ApiApiKeys[Policy_v1beta1ApiApiKeys["BearerToken"] = 0] = "BearerToken";
})(Policy_v1beta1ApiApiKeys = exports.Policy_v1beta1ApiApiKeys || (exports.Policy_v1beta1ApiApiKeys = {}));
class Policy_v1beta1Api {
    constructor(basePathOrUsername, password, basePath) {
        this._basePath = defaultBasePath;
        this.defaultHeaders = {};
        this._useQuerystring = false;
        this.authentications = {
            'default': new VoidAuth(),
            'BearerToken': new ApiKeyAuth('header', 'authorization'),
        };
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        }
        else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername;
            }
        }
    }
    set useQuerystring(value) {
        this._useQuerystring = value;
    }
    set basePath(basePath) {
        this._basePath = basePath;
    }
    get basePath() {
        return this._basePath;
    }
    setDefaultAuthentication(auth) {
        this.authentications.default = auth;
    }
    setApiKey(key, value) {
        this.authentications[Policy_v1beta1ApiApiKeys[key]].apiKey = value;
    }
    /**
     * create a PodDisruptionBudget
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    createNamespacedPodDisruptionBudget(namespace, body, pretty) {
        const localVarPath = this.basePath + '/apis/policy/v1beta1/namespaces/{namespace}/poddisruptionbudgets'
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling createNamespacedPodDisruptionBudget.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling createNamespacedPodDisruptionBudget.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * create a PodSecurityPolicy
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    createPodSecurityPolicy(body, pretty) {
        const localVarPath = this.basePath + '/apis/policy/v1beta1/podsecuritypolicies';
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling createPodSecurityPolicy.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * delete collection of PodDisruptionBudget
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param includeUninitialized If true, partially initialized resources are included in the response.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param timeoutSeconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    deleteCollectionNamespacedPodDisruptionBudget(namespace, pretty, _continue, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch) {
        const localVarPath = this.basePath + '/apis/policy/v1beta1/namespaces/{namespace}/poddisruptionbudgets'
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling deleteCollectionNamespacedPodDisruptionBudget.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (_continue !== undefined) {
            queryParameters['continue'] = _continue;
        }
        if (fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = fieldSelector;
        }
        if (includeUninitialized !== undefined) {
            queryParameters['includeUninitialized'] = includeUninitialized;
        }
        if (labelSelector !== undefined) {
            queryParameters['labelSelector'] = labelSelector;
        }
        if (limit !== undefined) {
            queryParameters['limit'] = limit;
        }
        if (resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = resourceVersion;
        }
        if (timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = timeoutSeconds;
        }
        if (watch !== undefined) {
            queryParameters['watch'] = watch;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * delete collection of PodSecurityPolicy
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param includeUninitialized If true, partially initialized resources are included in the response.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param timeoutSeconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    deleteCollectionPodSecurityPolicy(pretty, _continue, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch) {
        const localVarPath = this.basePath + '/apis/policy/v1beta1/podsecuritypolicies';
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (_continue !== undefined) {
            queryParameters['continue'] = _continue;
        }
        if (fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = fieldSelector;
        }
        if (includeUninitialized !== undefined) {
            queryParameters['includeUninitialized'] = includeUninitialized;
        }
        if (labelSelector !== undefined) {
            queryParameters['labelSelector'] = labelSelector;
        }
        if (limit !== undefined) {
            queryParameters['limit'] = limit;
        }
        if (resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = resourceVersion;
        }
        if (timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = timeoutSeconds;
        }
        if (watch !== undefined) {
            queryParameters['watch'] = watch;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * delete a PodDisruptionBudget
     * @param name name of the PodDisruptionBudget
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param gracePeriodSeconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @param orphanDependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @param propagationPolicy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
     */
    deleteNamespacedPodDisruptionBudget(name, namespace, body, pretty, gracePeriodSeconds, orphanDependents, propagationPolicy) {
        const localVarPath = this.basePath + '/apis/policy/v1beta1/namespaces/{namespace}/poddisruptionbudgets/{name}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling deleteNamespacedPodDisruptionBudget.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling deleteNamespacedPodDisruptionBudget.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling deleteNamespacedPodDisruptionBudget.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (gracePeriodSeconds !== undefined) {
            queryParameters['gracePeriodSeconds'] = gracePeriodSeconds;
        }
        if (orphanDependents !== undefined) {
            queryParameters['orphanDependents'] = orphanDependents;
        }
        if (propagationPolicy !== undefined) {
            queryParameters['propagationPolicy'] = propagationPolicy;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * delete a PodSecurityPolicy
     * @param name name of the PodSecurityPolicy
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param gracePeriodSeconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @param orphanDependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @param propagationPolicy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
     */
    deletePodSecurityPolicy(name, body, pretty, gracePeriodSeconds, orphanDependents, propagationPolicy) {
        const localVarPath = this.basePath + '/apis/policy/v1beta1/podsecuritypolicies/{name}'
            .replace('{' + 'name' + '}', String(name));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling deletePodSecurityPolicy.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling deletePodSecurityPolicy.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (gracePeriodSeconds !== undefined) {
            queryParameters['gracePeriodSeconds'] = gracePeriodSeconds;
        }
        if (orphanDependents !== undefined) {
            queryParameters['orphanDependents'] = orphanDependents;
        }
        if (propagationPolicy !== undefined) {
            queryParameters['propagationPolicy'] = propagationPolicy;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * get available resources
     */
    getAPIResources() {
        const localVarPath = this.basePath + '/apis/policy/v1beta1/';
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        let useFormData = false;
        let requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * list or watch objects of kind PodDisruptionBudget
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param includeUninitialized If true, partially initialized resources are included in the response.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param timeoutSeconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    listNamespacedPodDisruptionBudget(namespace, pretty, _continue, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch) {
        const localVarPath = this.basePath + '/apis/policy/v1beta1/namespaces/{namespace}/poddisruptionbudgets'
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling listNamespacedPodDisruptionBudget.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (_continue !== undefined) {
            queryParameters['continue'] = _continue;
        }
        if (fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = fieldSelector;
        }
        if (includeUninitialized !== undefined) {
            queryParameters['includeUninitialized'] = includeUninitialized;
        }
        if (labelSelector !== undefined) {
            queryParameters['labelSelector'] = labelSelector;
        }
        if (limit !== undefined) {
            queryParameters['limit'] = limit;
        }
        if (resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = resourceVersion;
        }
        if (timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = timeoutSeconds;
        }
        if (watch !== undefined) {
            queryParameters['watch'] = watch;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * list or watch objects of kind PodDisruptionBudget
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param includeUninitialized If true, partially initialized resources are included in the response.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param timeoutSeconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    listPodDisruptionBudgetForAllNamespaces(_continue, fieldSelector, includeUninitialized, labelSelector, limit, pretty, resourceVersion, timeoutSeconds, watch) {
        const localVarPath = this.basePath + '/apis/policy/v1beta1/poddisruptionbudgets';
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        if (_continue !== undefined) {
            queryParameters['continue'] = _continue;
        }
        if (fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = fieldSelector;
        }
        if (includeUninitialized !== undefined) {
            queryParameters['includeUninitialized'] = includeUninitialized;
        }
        if (labelSelector !== undefined) {
            queryParameters['labelSelector'] = labelSelector;
        }
        if (limit !== undefined) {
            queryParameters['limit'] = limit;
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = resourceVersion;
        }
        if (timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = timeoutSeconds;
        }
        if (watch !== undefined) {
            queryParameters['watch'] = watch;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * list or watch objects of kind PodSecurityPolicy
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param includeUninitialized If true, partially initialized resources are included in the response.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param timeoutSeconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    listPodSecurityPolicy(pretty, _continue, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch) {
        const localVarPath = this.basePath + '/apis/policy/v1beta1/podsecuritypolicies';
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (_continue !== undefined) {
            queryParameters['continue'] = _continue;
        }
        if (fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = fieldSelector;
        }
        if (includeUninitialized !== undefined) {
            queryParameters['includeUninitialized'] = includeUninitialized;
        }
        if (labelSelector !== undefined) {
            queryParameters['labelSelector'] = labelSelector;
        }
        if (limit !== undefined) {
            queryParameters['limit'] = limit;
        }
        if (resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = resourceVersion;
        }
        if (timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = timeoutSeconds;
        }
        if (watch !== undefined) {
            queryParameters['watch'] = watch;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * partially update the specified PodDisruptionBudget
     * @param name name of the PodDisruptionBudget
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    patchNamespacedPodDisruptionBudget(name, namespace, body, pretty) {
        const localVarPath = this.basePath + '/apis/policy/v1beta1/namespaces/{namespace}/poddisruptionbudgets/{name}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling patchNamespacedPodDisruptionBudget.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling patchNamespacedPodDisruptionBudget.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling patchNamespacedPodDisruptionBudget.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'PATCH',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * partially update status of the specified PodDisruptionBudget
     * @param name name of the PodDisruptionBudget
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    patchNamespacedPodDisruptionBudgetStatus(name, namespace, body, pretty) {
        const localVarPath = this.basePath + '/apis/policy/v1beta1/namespaces/{namespace}/poddisruptionbudgets/{name}/status'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling patchNamespacedPodDisruptionBudgetStatus.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling patchNamespacedPodDisruptionBudgetStatus.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling patchNamespacedPodDisruptionBudgetStatus.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'PATCH',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * partially update the specified PodSecurityPolicy
     * @param name name of the PodSecurityPolicy
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    patchPodSecurityPolicy(name, body, pretty) {
        const localVarPath = this.basePath + '/apis/policy/v1beta1/podsecuritypolicies/{name}'
            .replace('{' + 'name' + '}', String(name));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling patchPodSecurityPolicy.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling patchPodSecurityPolicy.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'PATCH',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * read the specified PodDisruptionBudget
     * @param name name of the PodDisruptionBudget
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param exact Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;.
     * @param _export Should this value be exported.  Export strips fields that a user can not specify.
     */
    readNamespacedPodDisruptionBudget(name, namespace, pretty, exact, _export) {
        const localVarPath = this.basePath + '/apis/policy/v1beta1/namespaces/{namespace}/poddisruptionbudgets/{name}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling readNamespacedPodDisruptionBudget.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling readNamespacedPodDisruptionBudget.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (exact !== undefined) {
            queryParameters['exact'] = exact;
        }
        if (_export !== undefined) {
            queryParameters['export'] = _export;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * read status of the specified PodDisruptionBudget
     * @param name name of the PodDisruptionBudget
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    readNamespacedPodDisruptionBudgetStatus(name, namespace, pretty) {
        const localVarPath = this.basePath + '/apis/policy/v1beta1/namespaces/{namespace}/poddisruptionbudgets/{name}/status'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling readNamespacedPodDisruptionBudgetStatus.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling readNamespacedPodDisruptionBudgetStatus.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * read the specified PodSecurityPolicy
     * @param name name of the PodSecurityPolicy
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param exact Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;.
     * @param _export Should this value be exported.  Export strips fields that a user can not specify.
     */
    readPodSecurityPolicy(name, pretty, exact, _export) {
        const localVarPath = this.basePath + '/apis/policy/v1beta1/podsecuritypolicies/{name}'
            .replace('{' + 'name' + '}', String(name));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling readPodSecurityPolicy.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (exact !== undefined) {
            queryParameters['exact'] = exact;
        }
        if (_export !== undefined) {
            queryParameters['export'] = _export;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * replace the specified PodDisruptionBudget
     * @param name name of the PodDisruptionBudget
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    replaceNamespacedPodDisruptionBudget(name, namespace, body, pretty) {
        const localVarPath = this.basePath + '/apis/policy/v1beta1/namespaces/{namespace}/poddisruptionbudgets/{name}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling replaceNamespacedPodDisruptionBudget.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling replaceNamespacedPodDisruptionBudget.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling replaceNamespacedPodDisruptionBudget.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * replace status of the specified PodDisruptionBudget
     * @param name name of the PodDisruptionBudget
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    replaceNamespacedPodDisruptionBudgetStatus(name, namespace, body, pretty) {
        const localVarPath = this.basePath + '/apis/policy/v1beta1/namespaces/{namespace}/poddisruptionbudgets/{name}/status'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling replaceNamespacedPodDisruptionBudgetStatus.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling replaceNamespacedPodDisruptionBudgetStatus.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling replaceNamespacedPodDisruptionBudgetStatus.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * replace the specified PodSecurityPolicy
     * @param name name of the PodSecurityPolicy
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    replacePodSecurityPolicy(name, body, pretty) {
        const localVarPath = this.basePath + '/apis/policy/v1beta1/podsecuritypolicies/{name}'
            .replace('{' + 'name' + '}', String(name));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling replacePodSecurityPolicy.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling replacePodSecurityPolicy.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
exports.Policy_v1beta1Api = Policy_v1beta1Api;
var RbacAuthorizationApiApiKeys;
(function (RbacAuthorizationApiApiKeys) {
    RbacAuthorizationApiApiKeys[RbacAuthorizationApiApiKeys["BearerToken"] = 0] = "BearerToken";
})(RbacAuthorizationApiApiKeys = exports.RbacAuthorizationApiApiKeys || (exports.RbacAuthorizationApiApiKeys = {}));
class RbacAuthorizationApi {
    constructor(basePathOrUsername, password, basePath) {
        this._basePath = defaultBasePath;
        this.defaultHeaders = {};
        this._useQuerystring = false;
        this.authentications = {
            'default': new VoidAuth(),
            'BearerToken': new ApiKeyAuth('header', 'authorization'),
        };
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        }
        else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername;
            }
        }
    }
    set useQuerystring(value) {
        this._useQuerystring = value;
    }
    set basePath(basePath) {
        this._basePath = basePath;
    }
    get basePath() {
        return this._basePath;
    }
    setDefaultAuthentication(auth) {
        this.authentications.default = auth;
    }
    setApiKey(key, value) {
        this.authentications[RbacAuthorizationApiApiKeys[key]].apiKey = value;
    }
    /**
     * get information of a group
     */
    getAPIGroup() {
        const localVarPath = this.basePath + '/apis/rbac.authorization.k8s.io/';
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        let useFormData = false;
        let requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
exports.RbacAuthorizationApi = RbacAuthorizationApi;
var RbacAuthorization_v1ApiApiKeys;
(function (RbacAuthorization_v1ApiApiKeys) {
    RbacAuthorization_v1ApiApiKeys[RbacAuthorization_v1ApiApiKeys["BearerToken"] = 0] = "BearerToken";
})(RbacAuthorization_v1ApiApiKeys = exports.RbacAuthorization_v1ApiApiKeys || (exports.RbacAuthorization_v1ApiApiKeys = {}));
class RbacAuthorization_v1Api {
    constructor(basePathOrUsername, password, basePath) {
        this._basePath = defaultBasePath;
        this.defaultHeaders = {};
        this._useQuerystring = false;
        this.authentications = {
            'default': new VoidAuth(),
            'BearerToken': new ApiKeyAuth('header', 'authorization'),
        };
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        }
        else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername;
            }
        }
    }
    set useQuerystring(value) {
        this._useQuerystring = value;
    }
    set basePath(basePath) {
        this._basePath = basePath;
    }
    get basePath() {
        return this._basePath;
    }
    setDefaultAuthentication(auth) {
        this.authentications.default = auth;
    }
    setApiKey(key, value) {
        this.authentications[RbacAuthorization_v1ApiApiKeys[key]].apiKey = value;
    }
    /**
     * create a ClusterRole
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    createClusterRole(body, pretty) {
        const localVarPath = this.basePath + '/apis/rbac.authorization.k8s.io/v1/clusterroles';
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling createClusterRole.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * create a ClusterRoleBinding
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    createClusterRoleBinding(body, pretty) {
        const localVarPath = this.basePath + '/apis/rbac.authorization.k8s.io/v1/clusterrolebindings';
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling createClusterRoleBinding.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * create a Role
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    createNamespacedRole(namespace, body, pretty) {
        const localVarPath = this.basePath + '/apis/rbac.authorization.k8s.io/v1/namespaces/{namespace}/roles'
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling createNamespacedRole.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling createNamespacedRole.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * create a RoleBinding
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    createNamespacedRoleBinding(namespace, body, pretty) {
        const localVarPath = this.basePath + '/apis/rbac.authorization.k8s.io/v1/namespaces/{namespace}/rolebindings'
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling createNamespacedRoleBinding.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling createNamespacedRoleBinding.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * delete a ClusterRole
     * @param name name of the ClusterRole
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param gracePeriodSeconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @param orphanDependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @param propagationPolicy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
     */
    deleteClusterRole(name, body, pretty, gracePeriodSeconds, orphanDependents, propagationPolicy) {
        const localVarPath = this.basePath + '/apis/rbac.authorization.k8s.io/v1/clusterroles/{name}'
            .replace('{' + 'name' + '}', String(name));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling deleteClusterRole.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling deleteClusterRole.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (gracePeriodSeconds !== undefined) {
            queryParameters['gracePeriodSeconds'] = gracePeriodSeconds;
        }
        if (orphanDependents !== undefined) {
            queryParameters['orphanDependents'] = orphanDependents;
        }
        if (propagationPolicy !== undefined) {
            queryParameters['propagationPolicy'] = propagationPolicy;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * delete a ClusterRoleBinding
     * @param name name of the ClusterRoleBinding
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param gracePeriodSeconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @param orphanDependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @param propagationPolicy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
     */
    deleteClusterRoleBinding(name, body, pretty, gracePeriodSeconds, orphanDependents, propagationPolicy) {
        const localVarPath = this.basePath + '/apis/rbac.authorization.k8s.io/v1/clusterrolebindings/{name}'
            .replace('{' + 'name' + '}', String(name));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling deleteClusterRoleBinding.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling deleteClusterRoleBinding.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (gracePeriodSeconds !== undefined) {
            queryParameters['gracePeriodSeconds'] = gracePeriodSeconds;
        }
        if (orphanDependents !== undefined) {
            queryParameters['orphanDependents'] = orphanDependents;
        }
        if (propagationPolicy !== undefined) {
            queryParameters['propagationPolicy'] = propagationPolicy;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * delete collection of ClusterRole
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param includeUninitialized If true, partially initialized resources are included in the response.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param timeoutSeconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    deleteCollectionClusterRole(pretty, _continue, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch) {
        const localVarPath = this.basePath + '/apis/rbac.authorization.k8s.io/v1/clusterroles';
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (_continue !== undefined) {
            queryParameters['continue'] = _continue;
        }
        if (fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = fieldSelector;
        }
        if (includeUninitialized !== undefined) {
            queryParameters['includeUninitialized'] = includeUninitialized;
        }
        if (labelSelector !== undefined) {
            queryParameters['labelSelector'] = labelSelector;
        }
        if (limit !== undefined) {
            queryParameters['limit'] = limit;
        }
        if (resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = resourceVersion;
        }
        if (timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = timeoutSeconds;
        }
        if (watch !== undefined) {
            queryParameters['watch'] = watch;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * delete collection of ClusterRoleBinding
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param includeUninitialized If true, partially initialized resources are included in the response.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param timeoutSeconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    deleteCollectionClusterRoleBinding(pretty, _continue, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch) {
        const localVarPath = this.basePath + '/apis/rbac.authorization.k8s.io/v1/clusterrolebindings';
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (_continue !== undefined) {
            queryParameters['continue'] = _continue;
        }
        if (fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = fieldSelector;
        }
        if (includeUninitialized !== undefined) {
            queryParameters['includeUninitialized'] = includeUninitialized;
        }
        if (labelSelector !== undefined) {
            queryParameters['labelSelector'] = labelSelector;
        }
        if (limit !== undefined) {
            queryParameters['limit'] = limit;
        }
        if (resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = resourceVersion;
        }
        if (timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = timeoutSeconds;
        }
        if (watch !== undefined) {
            queryParameters['watch'] = watch;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * delete collection of Role
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param includeUninitialized If true, partially initialized resources are included in the response.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param timeoutSeconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    deleteCollectionNamespacedRole(namespace, pretty, _continue, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch) {
        const localVarPath = this.basePath + '/apis/rbac.authorization.k8s.io/v1/namespaces/{namespace}/roles'
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling deleteCollectionNamespacedRole.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (_continue !== undefined) {
            queryParameters['continue'] = _continue;
        }
        if (fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = fieldSelector;
        }
        if (includeUninitialized !== undefined) {
            queryParameters['includeUninitialized'] = includeUninitialized;
        }
        if (labelSelector !== undefined) {
            queryParameters['labelSelector'] = labelSelector;
        }
        if (limit !== undefined) {
            queryParameters['limit'] = limit;
        }
        if (resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = resourceVersion;
        }
        if (timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = timeoutSeconds;
        }
        if (watch !== undefined) {
            queryParameters['watch'] = watch;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * delete collection of RoleBinding
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param includeUninitialized If true, partially initialized resources are included in the response.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param timeoutSeconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    deleteCollectionNamespacedRoleBinding(namespace, pretty, _continue, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch) {
        const localVarPath = this.basePath + '/apis/rbac.authorization.k8s.io/v1/namespaces/{namespace}/rolebindings'
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling deleteCollectionNamespacedRoleBinding.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (_continue !== undefined) {
            queryParameters['continue'] = _continue;
        }
        if (fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = fieldSelector;
        }
        if (includeUninitialized !== undefined) {
            queryParameters['includeUninitialized'] = includeUninitialized;
        }
        if (labelSelector !== undefined) {
            queryParameters['labelSelector'] = labelSelector;
        }
        if (limit !== undefined) {
            queryParameters['limit'] = limit;
        }
        if (resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = resourceVersion;
        }
        if (timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = timeoutSeconds;
        }
        if (watch !== undefined) {
            queryParameters['watch'] = watch;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * delete a Role
     * @param name name of the Role
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param gracePeriodSeconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @param orphanDependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @param propagationPolicy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
     */
    deleteNamespacedRole(name, namespace, body, pretty, gracePeriodSeconds, orphanDependents, propagationPolicy) {
        const localVarPath = this.basePath + '/apis/rbac.authorization.k8s.io/v1/namespaces/{namespace}/roles/{name}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling deleteNamespacedRole.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling deleteNamespacedRole.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling deleteNamespacedRole.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (gracePeriodSeconds !== undefined) {
            queryParameters['gracePeriodSeconds'] = gracePeriodSeconds;
        }
        if (orphanDependents !== undefined) {
            queryParameters['orphanDependents'] = orphanDependents;
        }
        if (propagationPolicy !== undefined) {
            queryParameters['propagationPolicy'] = propagationPolicy;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * delete a RoleBinding
     * @param name name of the RoleBinding
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param gracePeriodSeconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @param orphanDependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @param propagationPolicy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
     */
    deleteNamespacedRoleBinding(name, namespace, body, pretty, gracePeriodSeconds, orphanDependents, propagationPolicy) {
        const localVarPath = this.basePath + '/apis/rbac.authorization.k8s.io/v1/namespaces/{namespace}/rolebindings/{name}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling deleteNamespacedRoleBinding.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling deleteNamespacedRoleBinding.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling deleteNamespacedRoleBinding.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (gracePeriodSeconds !== undefined) {
            queryParameters['gracePeriodSeconds'] = gracePeriodSeconds;
        }
        if (orphanDependents !== undefined) {
            queryParameters['orphanDependents'] = orphanDependents;
        }
        if (propagationPolicy !== undefined) {
            queryParameters['propagationPolicy'] = propagationPolicy;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * get available resources
     */
    getAPIResources() {
        const localVarPath = this.basePath + '/apis/rbac.authorization.k8s.io/v1/';
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        let useFormData = false;
        let requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * list or watch objects of kind ClusterRole
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param includeUninitialized If true, partially initialized resources are included in the response.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param timeoutSeconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    listClusterRole(pretty, _continue, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch) {
        const localVarPath = this.basePath + '/apis/rbac.authorization.k8s.io/v1/clusterroles';
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (_continue !== undefined) {
            queryParameters['continue'] = _continue;
        }
        if (fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = fieldSelector;
        }
        if (includeUninitialized !== undefined) {
            queryParameters['includeUninitialized'] = includeUninitialized;
        }
        if (labelSelector !== undefined) {
            queryParameters['labelSelector'] = labelSelector;
        }
        if (limit !== undefined) {
            queryParameters['limit'] = limit;
        }
        if (resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = resourceVersion;
        }
        if (timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = timeoutSeconds;
        }
        if (watch !== undefined) {
            queryParameters['watch'] = watch;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * list or watch objects of kind ClusterRoleBinding
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param includeUninitialized If true, partially initialized resources are included in the response.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param timeoutSeconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    listClusterRoleBinding(pretty, _continue, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch) {
        const localVarPath = this.basePath + '/apis/rbac.authorization.k8s.io/v1/clusterrolebindings';
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (_continue !== undefined) {
            queryParameters['continue'] = _continue;
        }
        if (fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = fieldSelector;
        }
        if (includeUninitialized !== undefined) {
            queryParameters['includeUninitialized'] = includeUninitialized;
        }
        if (labelSelector !== undefined) {
            queryParameters['labelSelector'] = labelSelector;
        }
        if (limit !== undefined) {
            queryParameters['limit'] = limit;
        }
        if (resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = resourceVersion;
        }
        if (timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = timeoutSeconds;
        }
        if (watch !== undefined) {
            queryParameters['watch'] = watch;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * list or watch objects of kind Role
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param includeUninitialized If true, partially initialized resources are included in the response.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param timeoutSeconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    listNamespacedRole(namespace, pretty, _continue, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch) {
        const localVarPath = this.basePath + '/apis/rbac.authorization.k8s.io/v1/namespaces/{namespace}/roles'
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling listNamespacedRole.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (_continue !== undefined) {
            queryParameters['continue'] = _continue;
        }
        if (fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = fieldSelector;
        }
        if (includeUninitialized !== undefined) {
            queryParameters['includeUninitialized'] = includeUninitialized;
        }
        if (labelSelector !== undefined) {
            queryParameters['labelSelector'] = labelSelector;
        }
        if (limit !== undefined) {
            queryParameters['limit'] = limit;
        }
        if (resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = resourceVersion;
        }
        if (timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = timeoutSeconds;
        }
        if (watch !== undefined) {
            queryParameters['watch'] = watch;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * list or watch objects of kind RoleBinding
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param includeUninitialized If true, partially initialized resources are included in the response.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param timeoutSeconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    listNamespacedRoleBinding(namespace, pretty, _continue, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch) {
        const localVarPath = this.basePath + '/apis/rbac.authorization.k8s.io/v1/namespaces/{namespace}/rolebindings'
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling listNamespacedRoleBinding.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (_continue !== undefined) {
            queryParameters['continue'] = _continue;
        }
        if (fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = fieldSelector;
        }
        if (includeUninitialized !== undefined) {
            queryParameters['includeUninitialized'] = includeUninitialized;
        }
        if (labelSelector !== undefined) {
            queryParameters['labelSelector'] = labelSelector;
        }
        if (limit !== undefined) {
            queryParameters['limit'] = limit;
        }
        if (resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = resourceVersion;
        }
        if (timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = timeoutSeconds;
        }
        if (watch !== undefined) {
            queryParameters['watch'] = watch;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * list or watch objects of kind RoleBinding
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param includeUninitialized If true, partially initialized resources are included in the response.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param timeoutSeconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    listRoleBindingForAllNamespaces(_continue, fieldSelector, includeUninitialized, labelSelector, limit, pretty, resourceVersion, timeoutSeconds, watch) {
        const localVarPath = this.basePath + '/apis/rbac.authorization.k8s.io/v1/rolebindings';
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        if (_continue !== undefined) {
            queryParameters['continue'] = _continue;
        }
        if (fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = fieldSelector;
        }
        if (includeUninitialized !== undefined) {
            queryParameters['includeUninitialized'] = includeUninitialized;
        }
        if (labelSelector !== undefined) {
            queryParameters['labelSelector'] = labelSelector;
        }
        if (limit !== undefined) {
            queryParameters['limit'] = limit;
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = resourceVersion;
        }
        if (timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = timeoutSeconds;
        }
        if (watch !== undefined) {
            queryParameters['watch'] = watch;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * list or watch objects of kind Role
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param includeUninitialized If true, partially initialized resources are included in the response.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param timeoutSeconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    listRoleForAllNamespaces(_continue, fieldSelector, includeUninitialized, labelSelector, limit, pretty, resourceVersion, timeoutSeconds, watch) {
        const localVarPath = this.basePath + '/apis/rbac.authorization.k8s.io/v1/roles';
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        if (_continue !== undefined) {
            queryParameters['continue'] = _continue;
        }
        if (fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = fieldSelector;
        }
        if (includeUninitialized !== undefined) {
            queryParameters['includeUninitialized'] = includeUninitialized;
        }
        if (labelSelector !== undefined) {
            queryParameters['labelSelector'] = labelSelector;
        }
        if (limit !== undefined) {
            queryParameters['limit'] = limit;
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = resourceVersion;
        }
        if (timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = timeoutSeconds;
        }
        if (watch !== undefined) {
            queryParameters['watch'] = watch;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * partially update the specified ClusterRole
     * @param name name of the ClusterRole
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    patchClusterRole(name, body, pretty) {
        const localVarPath = this.basePath + '/apis/rbac.authorization.k8s.io/v1/clusterroles/{name}'
            .replace('{' + 'name' + '}', String(name));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling patchClusterRole.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling patchClusterRole.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'PATCH',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * partially update the specified ClusterRoleBinding
     * @param name name of the ClusterRoleBinding
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    patchClusterRoleBinding(name, body, pretty) {
        const localVarPath = this.basePath + '/apis/rbac.authorization.k8s.io/v1/clusterrolebindings/{name}'
            .replace('{' + 'name' + '}', String(name));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling patchClusterRoleBinding.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling patchClusterRoleBinding.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'PATCH',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * partially update the specified Role
     * @param name name of the Role
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    patchNamespacedRole(name, namespace, body, pretty) {
        const localVarPath = this.basePath + '/apis/rbac.authorization.k8s.io/v1/namespaces/{namespace}/roles/{name}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling patchNamespacedRole.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling patchNamespacedRole.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling patchNamespacedRole.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'PATCH',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * partially update the specified RoleBinding
     * @param name name of the RoleBinding
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    patchNamespacedRoleBinding(name, namespace, body, pretty) {
        const localVarPath = this.basePath + '/apis/rbac.authorization.k8s.io/v1/namespaces/{namespace}/rolebindings/{name}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling patchNamespacedRoleBinding.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling patchNamespacedRoleBinding.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling patchNamespacedRoleBinding.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'PATCH',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * read the specified ClusterRole
     * @param name name of the ClusterRole
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    readClusterRole(name, pretty) {
        const localVarPath = this.basePath + '/apis/rbac.authorization.k8s.io/v1/clusterroles/{name}'
            .replace('{' + 'name' + '}', String(name));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling readClusterRole.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * read the specified ClusterRoleBinding
     * @param name name of the ClusterRoleBinding
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    readClusterRoleBinding(name, pretty) {
        const localVarPath = this.basePath + '/apis/rbac.authorization.k8s.io/v1/clusterrolebindings/{name}'
            .replace('{' + 'name' + '}', String(name));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling readClusterRoleBinding.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * read the specified Role
     * @param name name of the Role
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    readNamespacedRole(name, namespace, pretty) {
        const localVarPath = this.basePath + '/apis/rbac.authorization.k8s.io/v1/namespaces/{namespace}/roles/{name}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling readNamespacedRole.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling readNamespacedRole.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * read the specified RoleBinding
     * @param name name of the RoleBinding
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    readNamespacedRoleBinding(name, namespace, pretty) {
        const localVarPath = this.basePath + '/apis/rbac.authorization.k8s.io/v1/namespaces/{namespace}/rolebindings/{name}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling readNamespacedRoleBinding.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling readNamespacedRoleBinding.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * replace the specified ClusterRole
     * @param name name of the ClusterRole
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    replaceClusterRole(name, body, pretty) {
        const localVarPath = this.basePath + '/apis/rbac.authorization.k8s.io/v1/clusterroles/{name}'
            .replace('{' + 'name' + '}', String(name));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling replaceClusterRole.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling replaceClusterRole.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * replace the specified ClusterRoleBinding
     * @param name name of the ClusterRoleBinding
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    replaceClusterRoleBinding(name, body, pretty) {
        const localVarPath = this.basePath + '/apis/rbac.authorization.k8s.io/v1/clusterrolebindings/{name}'
            .replace('{' + 'name' + '}', String(name));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling replaceClusterRoleBinding.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling replaceClusterRoleBinding.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * replace the specified Role
     * @param name name of the Role
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    replaceNamespacedRole(name, namespace, body, pretty) {
        const localVarPath = this.basePath + '/apis/rbac.authorization.k8s.io/v1/namespaces/{namespace}/roles/{name}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling replaceNamespacedRole.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling replaceNamespacedRole.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling replaceNamespacedRole.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * replace the specified RoleBinding
     * @param name name of the RoleBinding
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    replaceNamespacedRoleBinding(name, namespace, body, pretty) {
        const localVarPath = this.basePath + '/apis/rbac.authorization.k8s.io/v1/namespaces/{namespace}/rolebindings/{name}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling replaceNamespacedRoleBinding.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling replaceNamespacedRoleBinding.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling replaceNamespacedRoleBinding.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
exports.RbacAuthorization_v1Api = RbacAuthorization_v1Api;
var RbacAuthorization_v1alpha1ApiApiKeys;
(function (RbacAuthorization_v1alpha1ApiApiKeys) {
    RbacAuthorization_v1alpha1ApiApiKeys[RbacAuthorization_v1alpha1ApiApiKeys["BearerToken"] = 0] = "BearerToken";
})(RbacAuthorization_v1alpha1ApiApiKeys = exports.RbacAuthorization_v1alpha1ApiApiKeys || (exports.RbacAuthorization_v1alpha1ApiApiKeys = {}));
class RbacAuthorization_v1alpha1Api {
    constructor(basePathOrUsername, password, basePath) {
        this._basePath = defaultBasePath;
        this.defaultHeaders = {};
        this._useQuerystring = false;
        this.authentications = {
            'default': new VoidAuth(),
            'BearerToken': new ApiKeyAuth('header', 'authorization'),
        };
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        }
        else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername;
            }
        }
    }
    set useQuerystring(value) {
        this._useQuerystring = value;
    }
    set basePath(basePath) {
        this._basePath = basePath;
    }
    get basePath() {
        return this._basePath;
    }
    setDefaultAuthentication(auth) {
        this.authentications.default = auth;
    }
    setApiKey(key, value) {
        this.authentications[RbacAuthorization_v1alpha1ApiApiKeys[key]].apiKey = value;
    }
    /**
     * create a ClusterRole
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    createClusterRole(body, pretty) {
        const localVarPath = this.basePath + '/apis/rbac.authorization.k8s.io/v1alpha1/clusterroles';
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling createClusterRole.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * create a ClusterRoleBinding
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    createClusterRoleBinding(body, pretty) {
        const localVarPath = this.basePath + '/apis/rbac.authorization.k8s.io/v1alpha1/clusterrolebindings';
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling createClusterRoleBinding.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * create a Role
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    createNamespacedRole(namespace, body, pretty) {
        const localVarPath = this.basePath + '/apis/rbac.authorization.k8s.io/v1alpha1/namespaces/{namespace}/roles'
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling createNamespacedRole.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling createNamespacedRole.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * create a RoleBinding
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    createNamespacedRoleBinding(namespace, body, pretty) {
        const localVarPath = this.basePath + '/apis/rbac.authorization.k8s.io/v1alpha1/namespaces/{namespace}/rolebindings'
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling createNamespacedRoleBinding.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling createNamespacedRoleBinding.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * delete a ClusterRole
     * @param name name of the ClusterRole
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param gracePeriodSeconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @param orphanDependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @param propagationPolicy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
     */
    deleteClusterRole(name, body, pretty, gracePeriodSeconds, orphanDependents, propagationPolicy) {
        const localVarPath = this.basePath + '/apis/rbac.authorization.k8s.io/v1alpha1/clusterroles/{name}'
            .replace('{' + 'name' + '}', String(name));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling deleteClusterRole.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling deleteClusterRole.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (gracePeriodSeconds !== undefined) {
            queryParameters['gracePeriodSeconds'] = gracePeriodSeconds;
        }
        if (orphanDependents !== undefined) {
            queryParameters['orphanDependents'] = orphanDependents;
        }
        if (propagationPolicy !== undefined) {
            queryParameters['propagationPolicy'] = propagationPolicy;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * delete a ClusterRoleBinding
     * @param name name of the ClusterRoleBinding
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param gracePeriodSeconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @param orphanDependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @param propagationPolicy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
     */
    deleteClusterRoleBinding(name, body, pretty, gracePeriodSeconds, orphanDependents, propagationPolicy) {
        const localVarPath = this.basePath + '/apis/rbac.authorization.k8s.io/v1alpha1/clusterrolebindings/{name}'
            .replace('{' + 'name' + '}', String(name));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling deleteClusterRoleBinding.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling deleteClusterRoleBinding.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (gracePeriodSeconds !== undefined) {
            queryParameters['gracePeriodSeconds'] = gracePeriodSeconds;
        }
        if (orphanDependents !== undefined) {
            queryParameters['orphanDependents'] = orphanDependents;
        }
        if (propagationPolicy !== undefined) {
            queryParameters['propagationPolicy'] = propagationPolicy;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * delete collection of ClusterRole
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param includeUninitialized If true, partially initialized resources are included in the response.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param timeoutSeconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    deleteCollectionClusterRole(pretty, _continue, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch) {
        const localVarPath = this.basePath + '/apis/rbac.authorization.k8s.io/v1alpha1/clusterroles';
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (_continue !== undefined) {
            queryParameters['continue'] = _continue;
        }
        if (fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = fieldSelector;
        }
        if (includeUninitialized !== undefined) {
            queryParameters['includeUninitialized'] = includeUninitialized;
        }
        if (labelSelector !== undefined) {
            queryParameters['labelSelector'] = labelSelector;
        }
        if (limit !== undefined) {
            queryParameters['limit'] = limit;
        }
        if (resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = resourceVersion;
        }
        if (timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = timeoutSeconds;
        }
        if (watch !== undefined) {
            queryParameters['watch'] = watch;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * delete collection of ClusterRoleBinding
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param includeUninitialized If true, partially initialized resources are included in the response.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param timeoutSeconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    deleteCollectionClusterRoleBinding(pretty, _continue, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch) {
        const localVarPath = this.basePath + '/apis/rbac.authorization.k8s.io/v1alpha1/clusterrolebindings';
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (_continue !== undefined) {
            queryParameters['continue'] = _continue;
        }
        if (fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = fieldSelector;
        }
        if (includeUninitialized !== undefined) {
            queryParameters['includeUninitialized'] = includeUninitialized;
        }
        if (labelSelector !== undefined) {
            queryParameters['labelSelector'] = labelSelector;
        }
        if (limit !== undefined) {
            queryParameters['limit'] = limit;
        }
        if (resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = resourceVersion;
        }
        if (timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = timeoutSeconds;
        }
        if (watch !== undefined) {
            queryParameters['watch'] = watch;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * delete collection of Role
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param includeUninitialized If true, partially initialized resources are included in the response.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param timeoutSeconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    deleteCollectionNamespacedRole(namespace, pretty, _continue, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch) {
        const localVarPath = this.basePath + '/apis/rbac.authorization.k8s.io/v1alpha1/namespaces/{namespace}/roles'
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling deleteCollectionNamespacedRole.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (_continue !== undefined) {
            queryParameters['continue'] = _continue;
        }
        if (fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = fieldSelector;
        }
        if (includeUninitialized !== undefined) {
            queryParameters['includeUninitialized'] = includeUninitialized;
        }
        if (labelSelector !== undefined) {
            queryParameters['labelSelector'] = labelSelector;
        }
        if (limit !== undefined) {
            queryParameters['limit'] = limit;
        }
        if (resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = resourceVersion;
        }
        if (timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = timeoutSeconds;
        }
        if (watch !== undefined) {
            queryParameters['watch'] = watch;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * delete collection of RoleBinding
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param includeUninitialized If true, partially initialized resources are included in the response.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param timeoutSeconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    deleteCollectionNamespacedRoleBinding(namespace, pretty, _continue, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch) {
        const localVarPath = this.basePath + '/apis/rbac.authorization.k8s.io/v1alpha1/namespaces/{namespace}/rolebindings'
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling deleteCollectionNamespacedRoleBinding.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (_continue !== undefined) {
            queryParameters['continue'] = _continue;
        }
        if (fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = fieldSelector;
        }
        if (includeUninitialized !== undefined) {
            queryParameters['includeUninitialized'] = includeUninitialized;
        }
        if (labelSelector !== undefined) {
            queryParameters['labelSelector'] = labelSelector;
        }
        if (limit !== undefined) {
            queryParameters['limit'] = limit;
        }
        if (resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = resourceVersion;
        }
        if (timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = timeoutSeconds;
        }
        if (watch !== undefined) {
            queryParameters['watch'] = watch;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * delete a Role
     * @param name name of the Role
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param gracePeriodSeconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @param orphanDependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @param propagationPolicy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
     */
    deleteNamespacedRole(name, namespace, body, pretty, gracePeriodSeconds, orphanDependents, propagationPolicy) {
        const localVarPath = this.basePath + '/apis/rbac.authorization.k8s.io/v1alpha1/namespaces/{namespace}/roles/{name}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling deleteNamespacedRole.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling deleteNamespacedRole.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling deleteNamespacedRole.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (gracePeriodSeconds !== undefined) {
            queryParameters['gracePeriodSeconds'] = gracePeriodSeconds;
        }
        if (orphanDependents !== undefined) {
            queryParameters['orphanDependents'] = orphanDependents;
        }
        if (propagationPolicy !== undefined) {
            queryParameters['propagationPolicy'] = propagationPolicy;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * delete a RoleBinding
     * @param name name of the RoleBinding
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param gracePeriodSeconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @param orphanDependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @param propagationPolicy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
     */
    deleteNamespacedRoleBinding(name, namespace, body, pretty, gracePeriodSeconds, orphanDependents, propagationPolicy) {
        const localVarPath = this.basePath + '/apis/rbac.authorization.k8s.io/v1alpha1/namespaces/{namespace}/rolebindings/{name}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling deleteNamespacedRoleBinding.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling deleteNamespacedRoleBinding.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling deleteNamespacedRoleBinding.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (gracePeriodSeconds !== undefined) {
            queryParameters['gracePeriodSeconds'] = gracePeriodSeconds;
        }
        if (orphanDependents !== undefined) {
            queryParameters['orphanDependents'] = orphanDependents;
        }
        if (propagationPolicy !== undefined) {
            queryParameters['propagationPolicy'] = propagationPolicy;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * get available resources
     */
    getAPIResources() {
        const localVarPath = this.basePath + '/apis/rbac.authorization.k8s.io/v1alpha1/';
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        let useFormData = false;
        let requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * list or watch objects of kind ClusterRole
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param includeUninitialized If true, partially initialized resources are included in the response.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param timeoutSeconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    listClusterRole(pretty, _continue, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch) {
        const localVarPath = this.basePath + '/apis/rbac.authorization.k8s.io/v1alpha1/clusterroles';
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (_continue !== undefined) {
            queryParameters['continue'] = _continue;
        }
        if (fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = fieldSelector;
        }
        if (includeUninitialized !== undefined) {
            queryParameters['includeUninitialized'] = includeUninitialized;
        }
        if (labelSelector !== undefined) {
            queryParameters['labelSelector'] = labelSelector;
        }
        if (limit !== undefined) {
            queryParameters['limit'] = limit;
        }
        if (resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = resourceVersion;
        }
        if (timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = timeoutSeconds;
        }
        if (watch !== undefined) {
            queryParameters['watch'] = watch;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * list or watch objects of kind ClusterRoleBinding
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param includeUninitialized If true, partially initialized resources are included in the response.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param timeoutSeconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    listClusterRoleBinding(pretty, _continue, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch) {
        const localVarPath = this.basePath + '/apis/rbac.authorization.k8s.io/v1alpha1/clusterrolebindings';
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (_continue !== undefined) {
            queryParameters['continue'] = _continue;
        }
        if (fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = fieldSelector;
        }
        if (includeUninitialized !== undefined) {
            queryParameters['includeUninitialized'] = includeUninitialized;
        }
        if (labelSelector !== undefined) {
            queryParameters['labelSelector'] = labelSelector;
        }
        if (limit !== undefined) {
            queryParameters['limit'] = limit;
        }
        if (resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = resourceVersion;
        }
        if (timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = timeoutSeconds;
        }
        if (watch !== undefined) {
            queryParameters['watch'] = watch;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * list or watch objects of kind Role
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param includeUninitialized If true, partially initialized resources are included in the response.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param timeoutSeconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    listNamespacedRole(namespace, pretty, _continue, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch) {
        const localVarPath = this.basePath + '/apis/rbac.authorization.k8s.io/v1alpha1/namespaces/{namespace}/roles'
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling listNamespacedRole.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (_continue !== undefined) {
            queryParameters['continue'] = _continue;
        }
        if (fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = fieldSelector;
        }
        if (includeUninitialized !== undefined) {
            queryParameters['includeUninitialized'] = includeUninitialized;
        }
        if (labelSelector !== undefined) {
            queryParameters['labelSelector'] = labelSelector;
        }
        if (limit !== undefined) {
            queryParameters['limit'] = limit;
        }
        if (resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = resourceVersion;
        }
        if (timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = timeoutSeconds;
        }
        if (watch !== undefined) {
            queryParameters['watch'] = watch;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * list or watch objects of kind RoleBinding
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param includeUninitialized If true, partially initialized resources are included in the response.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param timeoutSeconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    listNamespacedRoleBinding(namespace, pretty, _continue, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch) {
        const localVarPath = this.basePath + '/apis/rbac.authorization.k8s.io/v1alpha1/namespaces/{namespace}/rolebindings'
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling listNamespacedRoleBinding.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (_continue !== undefined) {
            queryParameters['continue'] = _continue;
        }
        if (fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = fieldSelector;
        }
        if (includeUninitialized !== undefined) {
            queryParameters['includeUninitialized'] = includeUninitialized;
        }
        if (labelSelector !== undefined) {
            queryParameters['labelSelector'] = labelSelector;
        }
        if (limit !== undefined) {
            queryParameters['limit'] = limit;
        }
        if (resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = resourceVersion;
        }
        if (timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = timeoutSeconds;
        }
        if (watch !== undefined) {
            queryParameters['watch'] = watch;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * list or watch objects of kind RoleBinding
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param includeUninitialized If true, partially initialized resources are included in the response.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param timeoutSeconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    listRoleBindingForAllNamespaces(_continue, fieldSelector, includeUninitialized, labelSelector, limit, pretty, resourceVersion, timeoutSeconds, watch) {
        const localVarPath = this.basePath + '/apis/rbac.authorization.k8s.io/v1alpha1/rolebindings';
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        if (_continue !== undefined) {
            queryParameters['continue'] = _continue;
        }
        if (fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = fieldSelector;
        }
        if (includeUninitialized !== undefined) {
            queryParameters['includeUninitialized'] = includeUninitialized;
        }
        if (labelSelector !== undefined) {
            queryParameters['labelSelector'] = labelSelector;
        }
        if (limit !== undefined) {
            queryParameters['limit'] = limit;
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = resourceVersion;
        }
        if (timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = timeoutSeconds;
        }
        if (watch !== undefined) {
            queryParameters['watch'] = watch;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * list or watch objects of kind Role
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param includeUninitialized If true, partially initialized resources are included in the response.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param timeoutSeconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    listRoleForAllNamespaces(_continue, fieldSelector, includeUninitialized, labelSelector, limit, pretty, resourceVersion, timeoutSeconds, watch) {
        const localVarPath = this.basePath + '/apis/rbac.authorization.k8s.io/v1alpha1/roles';
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        if (_continue !== undefined) {
            queryParameters['continue'] = _continue;
        }
        if (fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = fieldSelector;
        }
        if (includeUninitialized !== undefined) {
            queryParameters['includeUninitialized'] = includeUninitialized;
        }
        if (labelSelector !== undefined) {
            queryParameters['labelSelector'] = labelSelector;
        }
        if (limit !== undefined) {
            queryParameters['limit'] = limit;
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = resourceVersion;
        }
        if (timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = timeoutSeconds;
        }
        if (watch !== undefined) {
            queryParameters['watch'] = watch;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * partially update the specified ClusterRole
     * @param name name of the ClusterRole
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    patchClusterRole(name, body, pretty) {
        const localVarPath = this.basePath + '/apis/rbac.authorization.k8s.io/v1alpha1/clusterroles/{name}'
            .replace('{' + 'name' + '}', String(name));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling patchClusterRole.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling patchClusterRole.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'PATCH',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * partially update the specified ClusterRoleBinding
     * @param name name of the ClusterRoleBinding
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    patchClusterRoleBinding(name, body, pretty) {
        const localVarPath = this.basePath + '/apis/rbac.authorization.k8s.io/v1alpha1/clusterrolebindings/{name}'
            .replace('{' + 'name' + '}', String(name));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling patchClusterRoleBinding.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling patchClusterRoleBinding.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'PATCH',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * partially update the specified Role
     * @param name name of the Role
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    patchNamespacedRole(name, namespace, body, pretty) {
        const localVarPath = this.basePath + '/apis/rbac.authorization.k8s.io/v1alpha1/namespaces/{namespace}/roles/{name}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling patchNamespacedRole.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling patchNamespacedRole.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling patchNamespacedRole.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'PATCH',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * partially update the specified RoleBinding
     * @param name name of the RoleBinding
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    patchNamespacedRoleBinding(name, namespace, body, pretty) {
        const localVarPath = this.basePath + '/apis/rbac.authorization.k8s.io/v1alpha1/namespaces/{namespace}/rolebindings/{name}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling patchNamespacedRoleBinding.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling patchNamespacedRoleBinding.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling patchNamespacedRoleBinding.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'PATCH',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * read the specified ClusterRole
     * @param name name of the ClusterRole
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    readClusterRole(name, pretty) {
        const localVarPath = this.basePath + '/apis/rbac.authorization.k8s.io/v1alpha1/clusterroles/{name}'
            .replace('{' + 'name' + '}', String(name));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling readClusterRole.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * read the specified ClusterRoleBinding
     * @param name name of the ClusterRoleBinding
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    readClusterRoleBinding(name, pretty) {
        const localVarPath = this.basePath + '/apis/rbac.authorization.k8s.io/v1alpha1/clusterrolebindings/{name}'
            .replace('{' + 'name' + '}', String(name));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling readClusterRoleBinding.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * read the specified Role
     * @param name name of the Role
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    readNamespacedRole(name, namespace, pretty) {
        const localVarPath = this.basePath + '/apis/rbac.authorization.k8s.io/v1alpha1/namespaces/{namespace}/roles/{name}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling readNamespacedRole.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling readNamespacedRole.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * read the specified RoleBinding
     * @param name name of the RoleBinding
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    readNamespacedRoleBinding(name, namespace, pretty) {
        const localVarPath = this.basePath + '/apis/rbac.authorization.k8s.io/v1alpha1/namespaces/{namespace}/rolebindings/{name}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling readNamespacedRoleBinding.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling readNamespacedRoleBinding.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * replace the specified ClusterRole
     * @param name name of the ClusterRole
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    replaceClusterRole(name, body, pretty) {
        const localVarPath = this.basePath + '/apis/rbac.authorization.k8s.io/v1alpha1/clusterroles/{name}'
            .replace('{' + 'name' + '}', String(name));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling replaceClusterRole.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling replaceClusterRole.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * replace the specified ClusterRoleBinding
     * @param name name of the ClusterRoleBinding
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    replaceClusterRoleBinding(name, body, pretty) {
        const localVarPath = this.basePath + '/apis/rbac.authorization.k8s.io/v1alpha1/clusterrolebindings/{name}'
            .replace('{' + 'name' + '}', String(name));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling replaceClusterRoleBinding.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling replaceClusterRoleBinding.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * replace the specified Role
     * @param name name of the Role
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    replaceNamespacedRole(name, namespace, body, pretty) {
        const localVarPath = this.basePath + '/apis/rbac.authorization.k8s.io/v1alpha1/namespaces/{namespace}/roles/{name}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling replaceNamespacedRole.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling replaceNamespacedRole.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling replaceNamespacedRole.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * replace the specified RoleBinding
     * @param name name of the RoleBinding
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    replaceNamespacedRoleBinding(name, namespace, body, pretty) {
        const localVarPath = this.basePath + '/apis/rbac.authorization.k8s.io/v1alpha1/namespaces/{namespace}/rolebindings/{name}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling replaceNamespacedRoleBinding.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling replaceNamespacedRoleBinding.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling replaceNamespacedRoleBinding.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
exports.RbacAuthorization_v1alpha1Api = RbacAuthorization_v1alpha1Api;
var RbacAuthorization_v1beta1ApiApiKeys;
(function (RbacAuthorization_v1beta1ApiApiKeys) {
    RbacAuthorization_v1beta1ApiApiKeys[RbacAuthorization_v1beta1ApiApiKeys["BearerToken"] = 0] = "BearerToken";
})(RbacAuthorization_v1beta1ApiApiKeys = exports.RbacAuthorization_v1beta1ApiApiKeys || (exports.RbacAuthorization_v1beta1ApiApiKeys = {}));
class RbacAuthorization_v1beta1Api {
    constructor(basePathOrUsername, password, basePath) {
        this._basePath = defaultBasePath;
        this.defaultHeaders = {};
        this._useQuerystring = false;
        this.authentications = {
            'default': new VoidAuth(),
            'BearerToken': new ApiKeyAuth('header', 'authorization'),
        };
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        }
        else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername;
            }
        }
    }
    set useQuerystring(value) {
        this._useQuerystring = value;
    }
    set basePath(basePath) {
        this._basePath = basePath;
    }
    get basePath() {
        return this._basePath;
    }
    setDefaultAuthentication(auth) {
        this.authentications.default = auth;
    }
    setApiKey(key, value) {
        this.authentications[RbacAuthorization_v1beta1ApiApiKeys[key]].apiKey = value;
    }
    /**
     * create a ClusterRole
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    createClusterRole(body, pretty) {
        const localVarPath = this.basePath + '/apis/rbac.authorization.k8s.io/v1beta1/clusterroles';
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling createClusterRole.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * create a ClusterRoleBinding
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    createClusterRoleBinding(body, pretty) {
        const localVarPath = this.basePath + '/apis/rbac.authorization.k8s.io/v1beta1/clusterrolebindings';
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling createClusterRoleBinding.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * create a Role
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    createNamespacedRole(namespace, body, pretty) {
        const localVarPath = this.basePath + '/apis/rbac.authorization.k8s.io/v1beta1/namespaces/{namespace}/roles'
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling createNamespacedRole.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling createNamespacedRole.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * create a RoleBinding
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    createNamespacedRoleBinding(namespace, body, pretty) {
        const localVarPath = this.basePath + '/apis/rbac.authorization.k8s.io/v1beta1/namespaces/{namespace}/rolebindings'
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling createNamespacedRoleBinding.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling createNamespacedRoleBinding.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * delete a ClusterRole
     * @param name name of the ClusterRole
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param gracePeriodSeconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @param orphanDependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @param propagationPolicy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
     */
    deleteClusterRole(name, body, pretty, gracePeriodSeconds, orphanDependents, propagationPolicy) {
        const localVarPath = this.basePath + '/apis/rbac.authorization.k8s.io/v1beta1/clusterroles/{name}'
            .replace('{' + 'name' + '}', String(name));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling deleteClusterRole.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling deleteClusterRole.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (gracePeriodSeconds !== undefined) {
            queryParameters['gracePeriodSeconds'] = gracePeriodSeconds;
        }
        if (orphanDependents !== undefined) {
            queryParameters['orphanDependents'] = orphanDependents;
        }
        if (propagationPolicy !== undefined) {
            queryParameters['propagationPolicy'] = propagationPolicy;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * delete a ClusterRoleBinding
     * @param name name of the ClusterRoleBinding
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param gracePeriodSeconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @param orphanDependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @param propagationPolicy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
     */
    deleteClusterRoleBinding(name, body, pretty, gracePeriodSeconds, orphanDependents, propagationPolicy) {
        const localVarPath = this.basePath + '/apis/rbac.authorization.k8s.io/v1beta1/clusterrolebindings/{name}'
            .replace('{' + 'name' + '}', String(name));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling deleteClusterRoleBinding.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling deleteClusterRoleBinding.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (gracePeriodSeconds !== undefined) {
            queryParameters['gracePeriodSeconds'] = gracePeriodSeconds;
        }
        if (orphanDependents !== undefined) {
            queryParameters['orphanDependents'] = orphanDependents;
        }
        if (propagationPolicy !== undefined) {
            queryParameters['propagationPolicy'] = propagationPolicy;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * delete collection of ClusterRole
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param includeUninitialized If true, partially initialized resources are included in the response.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param timeoutSeconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    deleteCollectionClusterRole(pretty, _continue, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch) {
        const localVarPath = this.basePath + '/apis/rbac.authorization.k8s.io/v1beta1/clusterroles';
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (_continue !== undefined) {
            queryParameters['continue'] = _continue;
        }
        if (fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = fieldSelector;
        }
        if (includeUninitialized !== undefined) {
            queryParameters['includeUninitialized'] = includeUninitialized;
        }
        if (labelSelector !== undefined) {
            queryParameters['labelSelector'] = labelSelector;
        }
        if (limit !== undefined) {
            queryParameters['limit'] = limit;
        }
        if (resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = resourceVersion;
        }
        if (timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = timeoutSeconds;
        }
        if (watch !== undefined) {
            queryParameters['watch'] = watch;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * delete collection of ClusterRoleBinding
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param includeUninitialized If true, partially initialized resources are included in the response.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param timeoutSeconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    deleteCollectionClusterRoleBinding(pretty, _continue, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch) {
        const localVarPath = this.basePath + '/apis/rbac.authorization.k8s.io/v1beta1/clusterrolebindings';
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (_continue !== undefined) {
            queryParameters['continue'] = _continue;
        }
        if (fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = fieldSelector;
        }
        if (includeUninitialized !== undefined) {
            queryParameters['includeUninitialized'] = includeUninitialized;
        }
        if (labelSelector !== undefined) {
            queryParameters['labelSelector'] = labelSelector;
        }
        if (limit !== undefined) {
            queryParameters['limit'] = limit;
        }
        if (resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = resourceVersion;
        }
        if (timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = timeoutSeconds;
        }
        if (watch !== undefined) {
            queryParameters['watch'] = watch;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * delete collection of Role
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param includeUninitialized If true, partially initialized resources are included in the response.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param timeoutSeconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    deleteCollectionNamespacedRole(namespace, pretty, _continue, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch) {
        const localVarPath = this.basePath + '/apis/rbac.authorization.k8s.io/v1beta1/namespaces/{namespace}/roles'
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling deleteCollectionNamespacedRole.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (_continue !== undefined) {
            queryParameters['continue'] = _continue;
        }
        if (fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = fieldSelector;
        }
        if (includeUninitialized !== undefined) {
            queryParameters['includeUninitialized'] = includeUninitialized;
        }
        if (labelSelector !== undefined) {
            queryParameters['labelSelector'] = labelSelector;
        }
        if (limit !== undefined) {
            queryParameters['limit'] = limit;
        }
        if (resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = resourceVersion;
        }
        if (timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = timeoutSeconds;
        }
        if (watch !== undefined) {
            queryParameters['watch'] = watch;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * delete collection of RoleBinding
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param includeUninitialized If true, partially initialized resources are included in the response.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param timeoutSeconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    deleteCollectionNamespacedRoleBinding(namespace, pretty, _continue, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch) {
        const localVarPath = this.basePath + '/apis/rbac.authorization.k8s.io/v1beta1/namespaces/{namespace}/rolebindings'
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling deleteCollectionNamespacedRoleBinding.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (_continue !== undefined) {
            queryParameters['continue'] = _continue;
        }
        if (fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = fieldSelector;
        }
        if (includeUninitialized !== undefined) {
            queryParameters['includeUninitialized'] = includeUninitialized;
        }
        if (labelSelector !== undefined) {
            queryParameters['labelSelector'] = labelSelector;
        }
        if (limit !== undefined) {
            queryParameters['limit'] = limit;
        }
        if (resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = resourceVersion;
        }
        if (timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = timeoutSeconds;
        }
        if (watch !== undefined) {
            queryParameters['watch'] = watch;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * delete a Role
     * @param name name of the Role
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param gracePeriodSeconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @param orphanDependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @param propagationPolicy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
     */
    deleteNamespacedRole(name, namespace, body, pretty, gracePeriodSeconds, orphanDependents, propagationPolicy) {
        const localVarPath = this.basePath + '/apis/rbac.authorization.k8s.io/v1beta1/namespaces/{namespace}/roles/{name}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling deleteNamespacedRole.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling deleteNamespacedRole.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling deleteNamespacedRole.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (gracePeriodSeconds !== undefined) {
            queryParameters['gracePeriodSeconds'] = gracePeriodSeconds;
        }
        if (orphanDependents !== undefined) {
            queryParameters['orphanDependents'] = orphanDependents;
        }
        if (propagationPolicy !== undefined) {
            queryParameters['propagationPolicy'] = propagationPolicy;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * delete a RoleBinding
     * @param name name of the RoleBinding
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param gracePeriodSeconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @param orphanDependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @param propagationPolicy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
     */
    deleteNamespacedRoleBinding(name, namespace, body, pretty, gracePeriodSeconds, orphanDependents, propagationPolicy) {
        const localVarPath = this.basePath + '/apis/rbac.authorization.k8s.io/v1beta1/namespaces/{namespace}/rolebindings/{name}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling deleteNamespacedRoleBinding.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling deleteNamespacedRoleBinding.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling deleteNamespacedRoleBinding.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (gracePeriodSeconds !== undefined) {
            queryParameters['gracePeriodSeconds'] = gracePeriodSeconds;
        }
        if (orphanDependents !== undefined) {
            queryParameters['orphanDependents'] = orphanDependents;
        }
        if (propagationPolicy !== undefined) {
            queryParameters['propagationPolicy'] = propagationPolicy;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * get available resources
     */
    getAPIResources() {
        const localVarPath = this.basePath + '/apis/rbac.authorization.k8s.io/v1beta1/';
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        let useFormData = false;
        let requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * list or watch objects of kind ClusterRole
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param includeUninitialized If true, partially initialized resources are included in the response.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param timeoutSeconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    listClusterRole(pretty, _continue, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch) {
        const localVarPath = this.basePath + '/apis/rbac.authorization.k8s.io/v1beta1/clusterroles';
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (_continue !== undefined) {
            queryParameters['continue'] = _continue;
        }
        if (fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = fieldSelector;
        }
        if (includeUninitialized !== undefined) {
            queryParameters['includeUninitialized'] = includeUninitialized;
        }
        if (labelSelector !== undefined) {
            queryParameters['labelSelector'] = labelSelector;
        }
        if (limit !== undefined) {
            queryParameters['limit'] = limit;
        }
        if (resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = resourceVersion;
        }
        if (timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = timeoutSeconds;
        }
        if (watch !== undefined) {
            queryParameters['watch'] = watch;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * list or watch objects of kind ClusterRoleBinding
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param includeUninitialized If true, partially initialized resources are included in the response.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param timeoutSeconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    listClusterRoleBinding(pretty, _continue, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch) {
        const localVarPath = this.basePath + '/apis/rbac.authorization.k8s.io/v1beta1/clusterrolebindings';
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (_continue !== undefined) {
            queryParameters['continue'] = _continue;
        }
        if (fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = fieldSelector;
        }
        if (includeUninitialized !== undefined) {
            queryParameters['includeUninitialized'] = includeUninitialized;
        }
        if (labelSelector !== undefined) {
            queryParameters['labelSelector'] = labelSelector;
        }
        if (limit !== undefined) {
            queryParameters['limit'] = limit;
        }
        if (resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = resourceVersion;
        }
        if (timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = timeoutSeconds;
        }
        if (watch !== undefined) {
            queryParameters['watch'] = watch;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * list or watch objects of kind Role
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param includeUninitialized If true, partially initialized resources are included in the response.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param timeoutSeconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    listNamespacedRole(namespace, pretty, _continue, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch) {
        const localVarPath = this.basePath + '/apis/rbac.authorization.k8s.io/v1beta1/namespaces/{namespace}/roles'
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling listNamespacedRole.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (_continue !== undefined) {
            queryParameters['continue'] = _continue;
        }
        if (fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = fieldSelector;
        }
        if (includeUninitialized !== undefined) {
            queryParameters['includeUninitialized'] = includeUninitialized;
        }
        if (labelSelector !== undefined) {
            queryParameters['labelSelector'] = labelSelector;
        }
        if (limit !== undefined) {
            queryParameters['limit'] = limit;
        }
        if (resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = resourceVersion;
        }
        if (timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = timeoutSeconds;
        }
        if (watch !== undefined) {
            queryParameters['watch'] = watch;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * list or watch objects of kind RoleBinding
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param includeUninitialized If true, partially initialized resources are included in the response.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param timeoutSeconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    listNamespacedRoleBinding(namespace, pretty, _continue, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch) {
        const localVarPath = this.basePath + '/apis/rbac.authorization.k8s.io/v1beta1/namespaces/{namespace}/rolebindings'
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling listNamespacedRoleBinding.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (_continue !== undefined) {
            queryParameters['continue'] = _continue;
        }
        if (fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = fieldSelector;
        }
        if (includeUninitialized !== undefined) {
            queryParameters['includeUninitialized'] = includeUninitialized;
        }
        if (labelSelector !== undefined) {
            queryParameters['labelSelector'] = labelSelector;
        }
        if (limit !== undefined) {
            queryParameters['limit'] = limit;
        }
        if (resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = resourceVersion;
        }
        if (timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = timeoutSeconds;
        }
        if (watch !== undefined) {
            queryParameters['watch'] = watch;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * list or watch objects of kind RoleBinding
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param includeUninitialized If true, partially initialized resources are included in the response.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param timeoutSeconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    listRoleBindingForAllNamespaces(_continue, fieldSelector, includeUninitialized, labelSelector, limit, pretty, resourceVersion, timeoutSeconds, watch) {
        const localVarPath = this.basePath + '/apis/rbac.authorization.k8s.io/v1beta1/rolebindings';
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        if (_continue !== undefined) {
            queryParameters['continue'] = _continue;
        }
        if (fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = fieldSelector;
        }
        if (includeUninitialized !== undefined) {
            queryParameters['includeUninitialized'] = includeUninitialized;
        }
        if (labelSelector !== undefined) {
            queryParameters['labelSelector'] = labelSelector;
        }
        if (limit !== undefined) {
            queryParameters['limit'] = limit;
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = resourceVersion;
        }
        if (timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = timeoutSeconds;
        }
        if (watch !== undefined) {
            queryParameters['watch'] = watch;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * list or watch objects of kind Role
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param includeUninitialized If true, partially initialized resources are included in the response.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param timeoutSeconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    listRoleForAllNamespaces(_continue, fieldSelector, includeUninitialized, labelSelector, limit, pretty, resourceVersion, timeoutSeconds, watch) {
        const localVarPath = this.basePath + '/apis/rbac.authorization.k8s.io/v1beta1/roles';
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        if (_continue !== undefined) {
            queryParameters['continue'] = _continue;
        }
        if (fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = fieldSelector;
        }
        if (includeUninitialized !== undefined) {
            queryParameters['includeUninitialized'] = includeUninitialized;
        }
        if (labelSelector !== undefined) {
            queryParameters['labelSelector'] = labelSelector;
        }
        if (limit !== undefined) {
            queryParameters['limit'] = limit;
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = resourceVersion;
        }
        if (timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = timeoutSeconds;
        }
        if (watch !== undefined) {
            queryParameters['watch'] = watch;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * partially update the specified ClusterRole
     * @param name name of the ClusterRole
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    patchClusterRole(name, body, pretty) {
        const localVarPath = this.basePath + '/apis/rbac.authorization.k8s.io/v1beta1/clusterroles/{name}'
            .replace('{' + 'name' + '}', String(name));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling patchClusterRole.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling patchClusterRole.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'PATCH',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * partially update the specified ClusterRoleBinding
     * @param name name of the ClusterRoleBinding
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    patchClusterRoleBinding(name, body, pretty) {
        const localVarPath = this.basePath + '/apis/rbac.authorization.k8s.io/v1beta1/clusterrolebindings/{name}'
            .replace('{' + 'name' + '}', String(name));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling patchClusterRoleBinding.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling patchClusterRoleBinding.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'PATCH',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * partially update the specified Role
     * @param name name of the Role
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    patchNamespacedRole(name, namespace, body, pretty) {
        const localVarPath = this.basePath + '/apis/rbac.authorization.k8s.io/v1beta1/namespaces/{namespace}/roles/{name}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling patchNamespacedRole.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling patchNamespacedRole.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling patchNamespacedRole.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'PATCH',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * partially update the specified RoleBinding
     * @param name name of the RoleBinding
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    patchNamespacedRoleBinding(name, namespace, body, pretty) {
        const localVarPath = this.basePath + '/apis/rbac.authorization.k8s.io/v1beta1/namespaces/{namespace}/rolebindings/{name}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling patchNamespacedRoleBinding.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling patchNamespacedRoleBinding.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling patchNamespacedRoleBinding.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'PATCH',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * read the specified ClusterRole
     * @param name name of the ClusterRole
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    readClusterRole(name, pretty) {
        const localVarPath = this.basePath + '/apis/rbac.authorization.k8s.io/v1beta1/clusterroles/{name}'
            .replace('{' + 'name' + '}', String(name));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling readClusterRole.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * read the specified ClusterRoleBinding
     * @param name name of the ClusterRoleBinding
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    readClusterRoleBinding(name, pretty) {
        const localVarPath = this.basePath + '/apis/rbac.authorization.k8s.io/v1beta1/clusterrolebindings/{name}'
            .replace('{' + 'name' + '}', String(name));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling readClusterRoleBinding.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * read the specified Role
     * @param name name of the Role
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    readNamespacedRole(name, namespace, pretty) {
        const localVarPath = this.basePath + '/apis/rbac.authorization.k8s.io/v1beta1/namespaces/{namespace}/roles/{name}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling readNamespacedRole.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling readNamespacedRole.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * read the specified RoleBinding
     * @param name name of the RoleBinding
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    readNamespacedRoleBinding(name, namespace, pretty) {
        const localVarPath = this.basePath + '/apis/rbac.authorization.k8s.io/v1beta1/namespaces/{namespace}/rolebindings/{name}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling readNamespacedRoleBinding.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling readNamespacedRoleBinding.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * replace the specified ClusterRole
     * @param name name of the ClusterRole
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    replaceClusterRole(name, body, pretty) {
        const localVarPath = this.basePath + '/apis/rbac.authorization.k8s.io/v1beta1/clusterroles/{name}'
            .replace('{' + 'name' + '}', String(name));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling replaceClusterRole.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling replaceClusterRole.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * replace the specified ClusterRoleBinding
     * @param name name of the ClusterRoleBinding
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    replaceClusterRoleBinding(name, body, pretty) {
        const localVarPath = this.basePath + '/apis/rbac.authorization.k8s.io/v1beta1/clusterrolebindings/{name}'
            .replace('{' + 'name' + '}', String(name));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling replaceClusterRoleBinding.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling replaceClusterRoleBinding.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * replace the specified Role
     * @param name name of the Role
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    replaceNamespacedRole(name, namespace, body, pretty) {
        const localVarPath = this.basePath + '/apis/rbac.authorization.k8s.io/v1beta1/namespaces/{namespace}/roles/{name}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling replaceNamespacedRole.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling replaceNamespacedRole.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling replaceNamespacedRole.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * replace the specified RoleBinding
     * @param name name of the RoleBinding
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    replaceNamespacedRoleBinding(name, namespace, body, pretty) {
        const localVarPath = this.basePath + '/apis/rbac.authorization.k8s.io/v1beta1/namespaces/{namespace}/rolebindings/{name}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling replaceNamespacedRoleBinding.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling replaceNamespacedRoleBinding.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling replaceNamespacedRoleBinding.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
exports.RbacAuthorization_v1beta1Api = RbacAuthorization_v1beta1Api;
var SchedulingApiApiKeys;
(function (SchedulingApiApiKeys) {
    SchedulingApiApiKeys[SchedulingApiApiKeys["BearerToken"] = 0] = "BearerToken";
})(SchedulingApiApiKeys = exports.SchedulingApiApiKeys || (exports.SchedulingApiApiKeys = {}));
class SchedulingApi {
    constructor(basePathOrUsername, password, basePath) {
        this._basePath = defaultBasePath;
        this.defaultHeaders = {};
        this._useQuerystring = false;
        this.authentications = {
            'default': new VoidAuth(),
            'BearerToken': new ApiKeyAuth('header', 'authorization'),
        };
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        }
        else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername;
            }
        }
    }
    set useQuerystring(value) {
        this._useQuerystring = value;
    }
    set basePath(basePath) {
        this._basePath = basePath;
    }
    get basePath() {
        return this._basePath;
    }
    setDefaultAuthentication(auth) {
        this.authentications.default = auth;
    }
    setApiKey(key, value) {
        this.authentications[SchedulingApiApiKeys[key]].apiKey = value;
    }
    /**
     * get information of a group
     */
    getAPIGroup() {
        const localVarPath = this.basePath + '/apis/scheduling.k8s.io/';
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        let useFormData = false;
        let requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
exports.SchedulingApi = SchedulingApi;
var Scheduling_v1alpha1ApiApiKeys;
(function (Scheduling_v1alpha1ApiApiKeys) {
    Scheduling_v1alpha1ApiApiKeys[Scheduling_v1alpha1ApiApiKeys["BearerToken"] = 0] = "BearerToken";
})(Scheduling_v1alpha1ApiApiKeys = exports.Scheduling_v1alpha1ApiApiKeys || (exports.Scheduling_v1alpha1ApiApiKeys = {}));
class Scheduling_v1alpha1Api {
    constructor(basePathOrUsername, password, basePath) {
        this._basePath = defaultBasePath;
        this.defaultHeaders = {};
        this._useQuerystring = false;
        this.authentications = {
            'default': new VoidAuth(),
            'BearerToken': new ApiKeyAuth('header', 'authorization'),
        };
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        }
        else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername;
            }
        }
    }
    set useQuerystring(value) {
        this._useQuerystring = value;
    }
    set basePath(basePath) {
        this._basePath = basePath;
    }
    get basePath() {
        return this._basePath;
    }
    setDefaultAuthentication(auth) {
        this.authentications.default = auth;
    }
    setApiKey(key, value) {
        this.authentications[Scheduling_v1alpha1ApiApiKeys[key]].apiKey = value;
    }
    /**
     * create a PriorityClass
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    createPriorityClass(body, pretty) {
        const localVarPath = this.basePath + '/apis/scheduling.k8s.io/v1alpha1/priorityclasses';
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling createPriorityClass.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * delete collection of PriorityClass
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param includeUninitialized If true, partially initialized resources are included in the response.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param timeoutSeconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    deleteCollectionPriorityClass(pretty, _continue, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch) {
        const localVarPath = this.basePath + '/apis/scheduling.k8s.io/v1alpha1/priorityclasses';
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (_continue !== undefined) {
            queryParameters['continue'] = _continue;
        }
        if (fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = fieldSelector;
        }
        if (includeUninitialized !== undefined) {
            queryParameters['includeUninitialized'] = includeUninitialized;
        }
        if (labelSelector !== undefined) {
            queryParameters['labelSelector'] = labelSelector;
        }
        if (limit !== undefined) {
            queryParameters['limit'] = limit;
        }
        if (resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = resourceVersion;
        }
        if (timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = timeoutSeconds;
        }
        if (watch !== undefined) {
            queryParameters['watch'] = watch;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * delete a PriorityClass
     * @param name name of the PriorityClass
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param gracePeriodSeconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @param orphanDependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @param propagationPolicy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
     */
    deletePriorityClass(name, body, pretty, gracePeriodSeconds, orphanDependents, propagationPolicy) {
        const localVarPath = this.basePath + '/apis/scheduling.k8s.io/v1alpha1/priorityclasses/{name}'
            .replace('{' + 'name' + '}', String(name));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling deletePriorityClass.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling deletePriorityClass.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (gracePeriodSeconds !== undefined) {
            queryParameters['gracePeriodSeconds'] = gracePeriodSeconds;
        }
        if (orphanDependents !== undefined) {
            queryParameters['orphanDependents'] = orphanDependents;
        }
        if (propagationPolicy !== undefined) {
            queryParameters['propagationPolicy'] = propagationPolicy;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * get available resources
     */
    getAPIResources() {
        const localVarPath = this.basePath + '/apis/scheduling.k8s.io/v1alpha1/';
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        let useFormData = false;
        let requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * list or watch objects of kind PriorityClass
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param includeUninitialized If true, partially initialized resources are included in the response.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param timeoutSeconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    listPriorityClass(pretty, _continue, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch) {
        const localVarPath = this.basePath + '/apis/scheduling.k8s.io/v1alpha1/priorityclasses';
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (_continue !== undefined) {
            queryParameters['continue'] = _continue;
        }
        if (fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = fieldSelector;
        }
        if (includeUninitialized !== undefined) {
            queryParameters['includeUninitialized'] = includeUninitialized;
        }
        if (labelSelector !== undefined) {
            queryParameters['labelSelector'] = labelSelector;
        }
        if (limit !== undefined) {
            queryParameters['limit'] = limit;
        }
        if (resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = resourceVersion;
        }
        if (timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = timeoutSeconds;
        }
        if (watch !== undefined) {
            queryParameters['watch'] = watch;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * partially update the specified PriorityClass
     * @param name name of the PriorityClass
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    patchPriorityClass(name, body, pretty) {
        const localVarPath = this.basePath + '/apis/scheduling.k8s.io/v1alpha1/priorityclasses/{name}'
            .replace('{' + 'name' + '}', String(name));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling patchPriorityClass.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling patchPriorityClass.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'PATCH',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * read the specified PriorityClass
     * @param name name of the PriorityClass
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param exact Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;.
     * @param _export Should this value be exported.  Export strips fields that a user can not specify.
     */
    readPriorityClass(name, pretty, exact, _export) {
        const localVarPath = this.basePath + '/apis/scheduling.k8s.io/v1alpha1/priorityclasses/{name}'
            .replace('{' + 'name' + '}', String(name));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling readPriorityClass.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (exact !== undefined) {
            queryParameters['exact'] = exact;
        }
        if (_export !== undefined) {
            queryParameters['export'] = _export;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * replace the specified PriorityClass
     * @param name name of the PriorityClass
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    replacePriorityClass(name, body, pretty) {
        const localVarPath = this.basePath + '/apis/scheduling.k8s.io/v1alpha1/priorityclasses/{name}'
            .replace('{' + 'name' + '}', String(name));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling replacePriorityClass.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling replacePriorityClass.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
exports.Scheduling_v1alpha1Api = Scheduling_v1alpha1Api;
var Scheduling_v1beta1ApiApiKeys;
(function (Scheduling_v1beta1ApiApiKeys) {
    Scheduling_v1beta1ApiApiKeys[Scheduling_v1beta1ApiApiKeys["BearerToken"] = 0] = "BearerToken";
})(Scheduling_v1beta1ApiApiKeys = exports.Scheduling_v1beta1ApiApiKeys || (exports.Scheduling_v1beta1ApiApiKeys = {}));
class Scheduling_v1beta1Api {
    constructor(basePathOrUsername, password, basePath) {
        this._basePath = defaultBasePath;
        this.defaultHeaders = {};
        this._useQuerystring = false;
        this.authentications = {
            'default': new VoidAuth(),
            'BearerToken': new ApiKeyAuth('header', 'authorization'),
        };
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        }
        else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername;
            }
        }
    }
    set useQuerystring(value) {
        this._useQuerystring = value;
    }
    set basePath(basePath) {
        this._basePath = basePath;
    }
    get basePath() {
        return this._basePath;
    }
    setDefaultAuthentication(auth) {
        this.authentications.default = auth;
    }
    setApiKey(key, value) {
        this.authentications[Scheduling_v1beta1ApiApiKeys[key]].apiKey = value;
    }
    /**
     * create a PriorityClass
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    createPriorityClass(body, pretty) {
        const localVarPath = this.basePath + '/apis/scheduling.k8s.io/v1beta1/priorityclasses';
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling createPriorityClass.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * delete collection of PriorityClass
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param includeUninitialized If true, partially initialized resources are included in the response.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param timeoutSeconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    deleteCollectionPriorityClass(pretty, _continue, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch) {
        const localVarPath = this.basePath + '/apis/scheduling.k8s.io/v1beta1/priorityclasses';
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (_continue !== undefined) {
            queryParameters['continue'] = _continue;
        }
        if (fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = fieldSelector;
        }
        if (includeUninitialized !== undefined) {
            queryParameters['includeUninitialized'] = includeUninitialized;
        }
        if (labelSelector !== undefined) {
            queryParameters['labelSelector'] = labelSelector;
        }
        if (limit !== undefined) {
            queryParameters['limit'] = limit;
        }
        if (resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = resourceVersion;
        }
        if (timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = timeoutSeconds;
        }
        if (watch !== undefined) {
            queryParameters['watch'] = watch;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * delete a PriorityClass
     * @param name name of the PriorityClass
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param gracePeriodSeconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @param orphanDependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @param propagationPolicy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
     */
    deletePriorityClass(name, body, pretty, gracePeriodSeconds, orphanDependents, propagationPolicy) {
        const localVarPath = this.basePath + '/apis/scheduling.k8s.io/v1beta1/priorityclasses/{name}'
            .replace('{' + 'name' + '}', String(name));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling deletePriorityClass.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling deletePriorityClass.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (gracePeriodSeconds !== undefined) {
            queryParameters['gracePeriodSeconds'] = gracePeriodSeconds;
        }
        if (orphanDependents !== undefined) {
            queryParameters['orphanDependents'] = orphanDependents;
        }
        if (propagationPolicy !== undefined) {
            queryParameters['propagationPolicy'] = propagationPolicy;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * get available resources
     */
    getAPIResources() {
        const localVarPath = this.basePath + '/apis/scheduling.k8s.io/v1beta1/';
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        let useFormData = false;
        let requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * list or watch objects of kind PriorityClass
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param includeUninitialized If true, partially initialized resources are included in the response.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param timeoutSeconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    listPriorityClass(pretty, _continue, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch) {
        const localVarPath = this.basePath + '/apis/scheduling.k8s.io/v1beta1/priorityclasses';
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (_continue !== undefined) {
            queryParameters['continue'] = _continue;
        }
        if (fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = fieldSelector;
        }
        if (includeUninitialized !== undefined) {
            queryParameters['includeUninitialized'] = includeUninitialized;
        }
        if (labelSelector !== undefined) {
            queryParameters['labelSelector'] = labelSelector;
        }
        if (limit !== undefined) {
            queryParameters['limit'] = limit;
        }
        if (resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = resourceVersion;
        }
        if (timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = timeoutSeconds;
        }
        if (watch !== undefined) {
            queryParameters['watch'] = watch;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * partially update the specified PriorityClass
     * @param name name of the PriorityClass
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    patchPriorityClass(name, body, pretty) {
        const localVarPath = this.basePath + '/apis/scheduling.k8s.io/v1beta1/priorityclasses/{name}'
            .replace('{' + 'name' + '}', String(name));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling patchPriorityClass.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling patchPriorityClass.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'PATCH',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * read the specified PriorityClass
     * @param name name of the PriorityClass
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param exact Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;.
     * @param _export Should this value be exported.  Export strips fields that a user can not specify.
     */
    readPriorityClass(name, pretty, exact, _export) {
        const localVarPath = this.basePath + '/apis/scheduling.k8s.io/v1beta1/priorityclasses/{name}'
            .replace('{' + 'name' + '}', String(name));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling readPriorityClass.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (exact !== undefined) {
            queryParameters['exact'] = exact;
        }
        if (_export !== undefined) {
            queryParameters['export'] = _export;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * replace the specified PriorityClass
     * @param name name of the PriorityClass
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    replacePriorityClass(name, body, pretty) {
        const localVarPath = this.basePath + '/apis/scheduling.k8s.io/v1beta1/priorityclasses/{name}'
            .replace('{' + 'name' + '}', String(name));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling replacePriorityClass.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling replacePriorityClass.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
exports.Scheduling_v1beta1Api = Scheduling_v1beta1Api;
var SettingsApiApiKeys;
(function (SettingsApiApiKeys) {
    SettingsApiApiKeys[SettingsApiApiKeys["BearerToken"] = 0] = "BearerToken";
})(SettingsApiApiKeys = exports.SettingsApiApiKeys || (exports.SettingsApiApiKeys = {}));
class SettingsApi {
    constructor(basePathOrUsername, password, basePath) {
        this._basePath = defaultBasePath;
        this.defaultHeaders = {};
        this._useQuerystring = false;
        this.authentications = {
            'default': new VoidAuth(),
            'BearerToken': new ApiKeyAuth('header', 'authorization'),
        };
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        }
        else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername;
            }
        }
    }
    set useQuerystring(value) {
        this._useQuerystring = value;
    }
    set basePath(basePath) {
        this._basePath = basePath;
    }
    get basePath() {
        return this._basePath;
    }
    setDefaultAuthentication(auth) {
        this.authentications.default = auth;
    }
    setApiKey(key, value) {
        this.authentications[SettingsApiApiKeys[key]].apiKey = value;
    }
    /**
     * get information of a group
     */
    getAPIGroup() {
        const localVarPath = this.basePath + '/apis/settings.k8s.io/';
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        let useFormData = false;
        let requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
exports.SettingsApi = SettingsApi;
var Settings_v1alpha1ApiApiKeys;
(function (Settings_v1alpha1ApiApiKeys) {
    Settings_v1alpha1ApiApiKeys[Settings_v1alpha1ApiApiKeys["BearerToken"] = 0] = "BearerToken";
})(Settings_v1alpha1ApiApiKeys = exports.Settings_v1alpha1ApiApiKeys || (exports.Settings_v1alpha1ApiApiKeys = {}));
class Settings_v1alpha1Api {
    constructor(basePathOrUsername, password, basePath) {
        this._basePath = defaultBasePath;
        this.defaultHeaders = {};
        this._useQuerystring = false;
        this.authentications = {
            'default': new VoidAuth(),
            'BearerToken': new ApiKeyAuth('header', 'authorization'),
        };
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        }
        else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername;
            }
        }
    }
    set useQuerystring(value) {
        this._useQuerystring = value;
    }
    set basePath(basePath) {
        this._basePath = basePath;
    }
    get basePath() {
        return this._basePath;
    }
    setDefaultAuthentication(auth) {
        this.authentications.default = auth;
    }
    setApiKey(key, value) {
        this.authentications[Settings_v1alpha1ApiApiKeys[key]].apiKey = value;
    }
    /**
     * create a PodPreset
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    createNamespacedPodPreset(namespace, body, pretty) {
        const localVarPath = this.basePath + '/apis/settings.k8s.io/v1alpha1/namespaces/{namespace}/podpresets'
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling createNamespacedPodPreset.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling createNamespacedPodPreset.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * delete collection of PodPreset
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param includeUninitialized If true, partially initialized resources are included in the response.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param timeoutSeconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    deleteCollectionNamespacedPodPreset(namespace, pretty, _continue, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch) {
        const localVarPath = this.basePath + '/apis/settings.k8s.io/v1alpha1/namespaces/{namespace}/podpresets'
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling deleteCollectionNamespacedPodPreset.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (_continue !== undefined) {
            queryParameters['continue'] = _continue;
        }
        if (fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = fieldSelector;
        }
        if (includeUninitialized !== undefined) {
            queryParameters['includeUninitialized'] = includeUninitialized;
        }
        if (labelSelector !== undefined) {
            queryParameters['labelSelector'] = labelSelector;
        }
        if (limit !== undefined) {
            queryParameters['limit'] = limit;
        }
        if (resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = resourceVersion;
        }
        if (timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = timeoutSeconds;
        }
        if (watch !== undefined) {
            queryParameters['watch'] = watch;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * delete a PodPreset
     * @param name name of the PodPreset
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param gracePeriodSeconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @param orphanDependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @param propagationPolicy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
     */
    deleteNamespacedPodPreset(name, namespace, body, pretty, gracePeriodSeconds, orphanDependents, propagationPolicy) {
        const localVarPath = this.basePath + '/apis/settings.k8s.io/v1alpha1/namespaces/{namespace}/podpresets/{name}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling deleteNamespacedPodPreset.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling deleteNamespacedPodPreset.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling deleteNamespacedPodPreset.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (gracePeriodSeconds !== undefined) {
            queryParameters['gracePeriodSeconds'] = gracePeriodSeconds;
        }
        if (orphanDependents !== undefined) {
            queryParameters['orphanDependents'] = orphanDependents;
        }
        if (propagationPolicy !== undefined) {
            queryParameters['propagationPolicy'] = propagationPolicy;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * get available resources
     */
    getAPIResources() {
        const localVarPath = this.basePath + '/apis/settings.k8s.io/v1alpha1/';
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        let useFormData = false;
        let requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * list or watch objects of kind PodPreset
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param includeUninitialized If true, partially initialized resources are included in the response.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param timeoutSeconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    listNamespacedPodPreset(namespace, pretty, _continue, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch) {
        const localVarPath = this.basePath + '/apis/settings.k8s.io/v1alpha1/namespaces/{namespace}/podpresets'
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling listNamespacedPodPreset.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (_continue !== undefined) {
            queryParameters['continue'] = _continue;
        }
        if (fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = fieldSelector;
        }
        if (includeUninitialized !== undefined) {
            queryParameters['includeUninitialized'] = includeUninitialized;
        }
        if (labelSelector !== undefined) {
            queryParameters['labelSelector'] = labelSelector;
        }
        if (limit !== undefined) {
            queryParameters['limit'] = limit;
        }
        if (resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = resourceVersion;
        }
        if (timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = timeoutSeconds;
        }
        if (watch !== undefined) {
            queryParameters['watch'] = watch;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * list or watch objects of kind PodPreset
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param includeUninitialized If true, partially initialized resources are included in the response.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param timeoutSeconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    listPodPresetForAllNamespaces(_continue, fieldSelector, includeUninitialized, labelSelector, limit, pretty, resourceVersion, timeoutSeconds, watch) {
        const localVarPath = this.basePath + '/apis/settings.k8s.io/v1alpha1/podpresets';
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        if (_continue !== undefined) {
            queryParameters['continue'] = _continue;
        }
        if (fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = fieldSelector;
        }
        if (includeUninitialized !== undefined) {
            queryParameters['includeUninitialized'] = includeUninitialized;
        }
        if (labelSelector !== undefined) {
            queryParameters['labelSelector'] = labelSelector;
        }
        if (limit !== undefined) {
            queryParameters['limit'] = limit;
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = resourceVersion;
        }
        if (timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = timeoutSeconds;
        }
        if (watch !== undefined) {
            queryParameters['watch'] = watch;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * partially update the specified PodPreset
     * @param name name of the PodPreset
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    patchNamespacedPodPreset(name, namespace, body, pretty) {
        const localVarPath = this.basePath + '/apis/settings.k8s.io/v1alpha1/namespaces/{namespace}/podpresets/{name}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling patchNamespacedPodPreset.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling patchNamespacedPodPreset.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling patchNamespacedPodPreset.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'PATCH',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * read the specified PodPreset
     * @param name name of the PodPreset
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param exact Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;.
     * @param _export Should this value be exported.  Export strips fields that a user can not specify.
     */
    readNamespacedPodPreset(name, namespace, pretty, exact, _export) {
        const localVarPath = this.basePath + '/apis/settings.k8s.io/v1alpha1/namespaces/{namespace}/podpresets/{name}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling readNamespacedPodPreset.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling readNamespacedPodPreset.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (exact !== undefined) {
            queryParameters['exact'] = exact;
        }
        if (_export !== undefined) {
            queryParameters['export'] = _export;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * replace the specified PodPreset
     * @param name name of the PodPreset
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    replaceNamespacedPodPreset(name, namespace, body, pretty) {
        const localVarPath = this.basePath + '/apis/settings.k8s.io/v1alpha1/namespaces/{namespace}/podpresets/{name}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling replaceNamespacedPodPreset.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling replaceNamespacedPodPreset.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling replaceNamespacedPodPreset.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
exports.Settings_v1alpha1Api = Settings_v1alpha1Api;
var StorageApiApiKeys;
(function (StorageApiApiKeys) {
    StorageApiApiKeys[StorageApiApiKeys["BearerToken"] = 0] = "BearerToken";
})(StorageApiApiKeys = exports.StorageApiApiKeys || (exports.StorageApiApiKeys = {}));
class StorageApi {
    constructor(basePathOrUsername, password, basePath) {
        this._basePath = defaultBasePath;
        this.defaultHeaders = {};
        this._useQuerystring = false;
        this.authentications = {
            'default': new VoidAuth(),
            'BearerToken': new ApiKeyAuth('header', 'authorization'),
        };
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        }
        else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername;
            }
        }
    }
    set useQuerystring(value) {
        this._useQuerystring = value;
    }
    set basePath(basePath) {
        this._basePath = basePath;
    }
    get basePath() {
        return this._basePath;
    }
    setDefaultAuthentication(auth) {
        this.authentications.default = auth;
    }
    setApiKey(key, value) {
        this.authentications[StorageApiApiKeys[key]].apiKey = value;
    }
    /**
     * get information of a group
     */
    getAPIGroup() {
        const localVarPath = this.basePath + '/apis/storage.k8s.io/';
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        let useFormData = false;
        let requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
exports.StorageApi = StorageApi;
var Storage_v1ApiApiKeys;
(function (Storage_v1ApiApiKeys) {
    Storage_v1ApiApiKeys[Storage_v1ApiApiKeys["BearerToken"] = 0] = "BearerToken";
})(Storage_v1ApiApiKeys = exports.Storage_v1ApiApiKeys || (exports.Storage_v1ApiApiKeys = {}));
class Storage_v1Api {
    constructor(basePathOrUsername, password, basePath) {
        this._basePath = defaultBasePath;
        this.defaultHeaders = {};
        this._useQuerystring = false;
        this.authentications = {
            'default': new VoidAuth(),
            'BearerToken': new ApiKeyAuth('header', 'authorization'),
        };
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        }
        else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername;
            }
        }
    }
    set useQuerystring(value) {
        this._useQuerystring = value;
    }
    set basePath(basePath) {
        this._basePath = basePath;
    }
    get basePath() {
        return this._basePath;
    }
    setDefaultAuthentication(auth) {
        this.authentications.default = auth;
    }
    setApiKey(key, value) {
        this.authentications[Storage_v1ApiApiKeys[key]].apiKey = value;
    }
    /**
     * create a StorageClass
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    createStorageClass(body, pretty) {
        const localVarPath = this.basePath + '/apis/storage.k8s.io/v1/storageclasses';
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling createStorageClass.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * delete collection of StorageClass
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param includeUninitialized If true, partially initialized resources are included in the response.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param timeoutSeconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    deleteCollectionStorageClass(pretty, _continue, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch) {
        const localVarPath = this.basePath + '/apis/storage.k8s.io/v1/storageclasses';
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (_continue !== undefined) {
            queryParameters['continue'] = _continue;
        }
        if (fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = fieldSelector;
        }
        if (includeUninitialized !== undefined) {
            queryParameters['includeUninitialized'] = includeUninitialized;
        }
        if (labelSelector !== undefined) {
            queryParameters['labelSelector'] = labelSelector;
        }
        if (limit !== undefined) {
            queryParameters['limit'] = limit;
        }
        if (resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = resourceVersion;
        }
        if (timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = timeoutSeconds;
        }
        if (watch !== undefined) {
            queryParameters['watch'] = watch;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * delete a StorageClass
     * @param name name of the StorageClass
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param gracePeriodSeconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @param orphanDependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @param propagationPolicy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
     */
    deleteStorageClass(name, body, pretty, gracePeriodSeconds, orphanDependents, propagationPolicy) {
        const localVarPath = this.basePath + '/apis/storage.k8s.io/v1/storageclasses/{name}'
            .replace('{' + 'name' + '}', String(name));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling deleteStorageClass.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling deleteStorageClass.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (gracePeriodSeconds !== undefined) {
            queryParameters['gracePeriodSeconds'] = gracePeriodSeconds;
        }
        if (orphanDependents !== undefined) {
            queryParameters['orphanDependents'] = orphanDependents;
        }
        if (propagationPolicy !== undefined) {
            queryParameters['propagationPolicy'] = propagationPolicy;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * get available resources
     */
    getAPIResources() {
        const localVarPath = this.basePath + '/apis/storage.k8s.io/v1/';
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        let useFormData = false;
        let requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * list or watch objects of kind StorageClass
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param includeUninitialized If true, partially initialized resources are included in the response.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param timeoutSeconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    listStorageClass(pretty, _continue, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch) {
        const localVarPath = this.basePath + '/apis/storage.k8s.io/v1/storageclasses';
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (_continue !== undefined) {
            queryParameters['continue'] = _continue;
        }
        if (fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = fieldSelector;
        }
        if (includeUninitialized !== undefined) {
            queryParameters['includeUninitialized'] = includeUninitialized;
        }
        if (labelSelector !== undefined) {
            queryParameters['labelSelector'] = labelSelector;
        }
        if (limit !== undefined) {
            queryParameters['limit'] = limit;
        }
        if (resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = resourceVersion;
        }
        if (timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = timeoutSeconds;
        }
        if (watch !== undefined) {
            queryParameters['watch'] = watch;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * partially update the specified StorageClass
     * @param name name of the StorageClass
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    patchStorageClass(name, body, pretty) {
        const localVarPath = this.basePath + '/apis/storage.k8s.io/v1/storageclasses/{name}'
            .replace('{' + 'name' + '}', String(name));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling patchStorageClass.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling patchStorageClass.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'PATCH',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * read the specified StorageClass
     * @param name name of the StorageClass
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param exact Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;.
     * @param _export Should this value be exported.  Export strips fields that a user can not specify.
     */
    readStorageClass(name, pretty, exact, _export) {
        const localVarPath = this.basePath + '/apis/storage.k8s.io/v1/storageclasses/{name}'
            .replace('{' + 'name' + '}', String(name));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling readStorageClass.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (exact !== undefined) {
            queryParameters['exact'] = exact;
        }
        if (_export !== undefined) {
            queryParameters['export'] = _export;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * replace the specified StorageClass
     * @param name name of the StorageClass
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    replaceStorageClass(name, body, pretty) {
        const localVarPath = this.basePath + '/apis/storage.k8s.io/v1/storageclasses/{name}'
            .replace('{' + 'name' + '}', String(name));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling replaceStorageClass.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling replaceStorageClass.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
exports.Storage_v1Api = Storage_v1Api;
var Storage_v1alpha1ApiApiKeys;
(function (Storage_v1alpha1ApiApiKeys) {
    Storage_v1alpha1ApiApiKeys[Storage_v1alpha1ApiApiKeys["BearerToken"] = 0] = "BearerToken";
})(Storage_v1alpha1ApiApiKeys = exports.Storage_v1alpha1ApiApiKeys || (exports.Storage_v1alpha1ApiApiKeys = {}));
class Storage_v1alpha1Api {
    constructor(basePathOrUsername, password, basePath) {
        this._basePath = defaultBasePath;
        this.defaultHeaders = {};
        this._useQuerystring = false;
        this.authentications = {
            'default': new VoidAuth(),
            'BearerToken': new ApiKeyAuth('header', 'authorization'),
        };
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        }
        else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername;
            }
        }
    }
    set useQuerystring(value) {
        this._useQuerystring = value;
    }
    set basePath(basePath) {
        this._basePath = basePath;
    }
    get basePath() {
        return this._basePath;
    }
    setDefaultAuthentication(auth) {
        this.authentications.default = auth;
    }
    setApiKey(key, value) {
        this.authentications[Storage_v1alpha1ApiApiKeys[key]].apiKey = value;
    }
    /**
     * create a VolumeAttachment
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    createVolumeAttachment(body, pretty) {
        const localVarPath = this.basePath + '/apis/storage.k8s.io/v1alpha1/volumeattachments';
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling createVolumeAttachment.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * delete collection of VolumeAttachment
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param includeUninitialized If true, partially initialized resources are included in the response.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param timeoutSeconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    deleteCollectionVolumeAttachment(pretty, _continue, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch) {
        const localVarPath = this.basePath + '/apis/storage.k8s.io/v1alpha1/volumeattachments';
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (_continue !== undefined) {
            queryParameters['continue'] = _continue;
        }
        if (fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = fieldSelector;
        }
        if (includeUninitialized !== undefined) {
            queryParameters['includeUninitialized'] = includeUninitialized;
        }
        if (labelSelector !== undefined) {
            queryParameters['labelSelector'] = labelSelector;
        }
        if (limit !== undefined) {
            queryParameters['limit'] = limit;
        }
        if (resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = resourceVersion;
        }
        if (timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = timeoutSeconds;
        }
        if (watch !== undefined) {
            queryParameters['watch'] = watch;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * delete a VolumeAttachment
     * @param name name of the VolumeAttachment
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param gracePeriodSeconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @param orphanDependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @param propagationPolicy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
     */
    deleteVolumeAttachment(name, body, pretty, gracePeriodSeconds, orphanDependents, propagationPolicy) {
        const localVarPath = this.basePath + '/apis/storage.k8s.io/v1alpha1/volumeattachments/{name}'
            .replace('{' + 'name' + '}', String(name));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling deleteVolumeAttachment.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling deleteVolumeAttachment.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (gracePeriodSeconds !== undefined) {
            queryParameters['gracePeriodSeconds'] = gracePeriodSeconds;
        }
        if (orphanDependents !== undefined) {
            queryParameters['orphanDependents'] = orphanDependents;
        }
        if (propagationPolicy !== undefined) {
            queryParameters['propagationPolicy'] = propagationPolicy;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * get available resources
     */
    getAPIResources() {
        const localVarPath = this.basePath + '/apis/storage.k8s.io/v1alpha1/';
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        let useFormData = false;
        let requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * list or watch objects of kind VolumeAttachment
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param includeUninitialized If true, partially initialized resources are included in the response.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param timeoutSeconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    listVolumeAttachment(pretty, _continue, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch) {
        const localVarPath = this.basePath + '/apis/storage.k8s.io/v1alpha1/volumeattachments';
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (_continue !== undefined) {
            queryParameters['continue'] = _continue;
        }
        if (fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = fieldSelector;
        }
        if (includeUninitialized !== undefined) {
            queryParameters['includeUninitialized'] = includeUninitialized;
        }
        if (labelSelector !== undefined) {
            queryParameters['labelSelector'] = labelSelector;
        }
        if (limit !== undefined) {
            queryParameters['limit'] = limit;
        }
        if (resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = resourceVersion;
        }
        if (timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = timeoutSeconds;
        }
        if (watch !== undefined) {
            queryParameters['watch'] = watch;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * partially update the specified VolumeAttachment
     * @param name name of the VolumeAttachment
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    patchVolumeAttachment(name, body, pretty) {
        const localVarPath = this.basePath + '/apis/storage.k8s.io/v1alpha1/volumeattachments/{name}'
            .replace('{' + 'name' + '}', String(name));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling patchVolumeAttachment.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling patchVolumeAttachment.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'PATCH',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * read the specified VolumeAttachment
     * @param name name of the VolumeAttachment
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param exact Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;.
     * @param _export Should this value be exported.  Export strips fields that a user can not specify.
     */
    readVolumeAttachment(name, pretty, exact, _export) {
        const localVarPath = this.basePath + '/apis/storage.k8s.io/v1alpha1/volumeattachments/{name}'
            .replace('{' + 'name' + '}', String(name));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling readVolumeAttachment.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (exact !== undefined) {
            queryParameters['exact'] = exact;
        }
        if (_export !== undefined) {
            queryParameters['export'] = _export;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * replace the specified VolumeAttachment
     * @param name name of the VolumeAttachment
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    replaceVolumeAttachment(name, body, pretty) {
        const localVarPath = this.basePath + '/apis/storage.k8s.io/v1alpha1/volumeattachments/{name}'
            .replace('{' + 'name' + '}', String(name));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling replaceVolumeAttachment.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling replaceVolumeAttachment.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
exports.Storage_v1alpha1Api = Storage_v1alpha1Api;
var Storage_v1beta1ApiApiKeys;
(function (Storage_v1beta1ApiApiKeys) {
    Storage_v1beta1ApiApiKeys[Storage_v1beta1ApiApiKeys["BearerToken"] = 0] = "BearerToken";
})(Storage_v1beta1ApiApiKeys = exports.Storage_v1beta1ApiApiKeys || (exports.Storage_v1beta1ApiApiKeys = {}));
class Storage_v1beta1Api {
    constructor(basePathOrUsername, password, basePath) {
        this._basePath = defaultBasePath;
        this.defaultHeaders = {};
        this._useQuerystring = false;
        this.authentications = {
            'default': new VoidAuth(),
            'BearerToken': new ApiKeyAuth('header', 'authorization'),
        };
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        }
        else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername;
            }
        }
    }
    set useQuerystring(value) {
        this._useQuerystring = value;
    }
    set basePath(basePath) {
        this._basePath = basePath;
    }
    get basePath() {
        return this._basePath;
    }
    setDefaultAuthentication(auth) {
        this.authentications.default = auth;
    }
    setApiKey(key, value) {
        this.authentications[Storage_v1beta1ApiApiKeys[key]].apiKey = value;
    }
    /**
     * create a StorageClass
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    createStorageClass(body, pretty) {
        const localVarPath = this.basePath + '/apis/storage.k8s.io/v1beta1/storageclasses';
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling createStorageClass.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * create a VolumeAttachment
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    createVolumeAttachment(body, pretty) {
        const localVarPath = this.basePath + '/apis/storage.k8s.io/v1beta1/volumeattachments';
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling createVolumeAttachment.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * delete collection of StorageClass
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param includeUninitialized If true, partially initialized resources are included in the response.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param timeoutSeconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    deleteCollectionStorageClass(pretty, _continue, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch) {
        const localVarPath = this.basePath + '/apis/storage.k8s.io/v1beta1/storageclasses';
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (_continue !== undefined) {
            queryParameters['continue'] = _continue;
        }
        if (fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = fieldSelector;
        }
        if (includeUninitialized !== undefined) {
            queryParameters['includeUninitialized'] = includeUninitialized;
        }
        if (labelSelector !== undefined) {
            queryParameters['labelSelector'] = labelSelector;
        }
        if (limit !== undefined) {
            queryParameters['limit'] = limit;
        }
        if (resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = resourceVersion;
        }
        if (timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = timeoutSeconds;
        }
        if (watch !== undefined) {
            queryParameters['watch'] = watch;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * delete collection of VolumeAttachment
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param includeUninitialized If true, partially initialized resources are included in the response.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param timeoutSeconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    deleteCollectionVolumeAttachment(pretty, _continue, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch) {
        const localVarPath = this.basePath + '/apis/storage.k8s.io/v1beta1/volumeattachments';
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (_continue !== undefined) {
            queryParameters['continue'] = _continue;
        }
        if (fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = fieldSelector;
        }
        if (includeUninitialized !== undefined) {
            queryParameters['includeUninitialized'] = includeUninitialized;
        }
        if (labelSelector !== undefined) {
            queryParameters['labelSelector'] = labelSelector;
        }
        if (limit !== undefined) {
            queryParameters['limit'] = limit;
        }
        if (resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = resourceVersion;
        }
        if (timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = timeoutSeconds;
        }
        if (watch !== undefined) {
            queryParameters['watch'] = watch;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * delete a StorageClass
     * @param name name of the StorageClass
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param gracePeriodSeconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @param orphanDependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @param propagationPolicy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
     */
    deleteStorageClass(name, body, pretty, gracePeriodSeconds, orphanDependents, propagationPolicy) {
        const localVarPath = this.basePath + '/apis/storage.k8s.io/v1beta1/storageclasses/{name}'
            .replace('{' + 'name' + '}', String(name));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling deleteStorageClass.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling deleteStorageClass.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (gracePeriodSeconds !== undefined) {
            queryParameters['gracePeriodSeconds'] = gracePeriodSeconds;
        }
        if (orphanDependents !== undefined) {
            queryParameters['orphanDependents'] = orphanDependents;
        }
        if (propagationPolicy !== undefined) {
            queryParameters['propagationPolicy'] = propagationPolicy;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * delete a VolumeAttachment
     * @param name name of the VolumeAttachment
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param gracePeriodSeconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @param orphanDependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @param propagationPolicy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
     */
    deleteVolumeAttachment(name, body, pretty, gracePeriodSeconds, orphanDependents, propagationPolicy) {
        const localVarPath = this.basePath + '/apis/storage.k8s.io/v1beta1/volumeattachments/{name}'
            .replace('{' + 'name' + '}', String(name));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling deleteVolumeAttachment.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling deleteVolumeAttachment.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (gracePeriodSeconds !== undefined) {
            queryParameters['gracePeriodSeconds'] = gracePeriodSeconds;
        }
        if (orphanDependents !== undefined) {
            queryParameters['orphanDependents'] = orphanDependents;
        }
        if (propagationPolicy !== undefined) {
            queryParameters['propagationPolicy'] = propagationPolicy;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * get available resources
     */
    getAPIResources() {
        const localVarPath = this.basePath + '/apis/storage.k8s.io/v1beta1/';
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        let useFormData = false;
        let requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * list or watch objects of kind StorageClass
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param includeUninitialized If true, partially initialized resources are included in the response.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param timeoutSeconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    listStorageClass(pretty, _continue, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch) {
        const localVarPath = this.basePath + '/apis/storage.k8s.io/v1beta1/storageclasses';
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (_continue !== undefined) {
            queryParameters['continue'] = _continue;
        }
        if (fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = fieldSelector;
        }
        if (includeUninitialized !== undefined) {
            queryParameters['includeUninitialized'] = includeUninitialized;
        }
        if (labelSelector !== undefined) {
            queryParameters['labelSelector'] = labelSelector;
        }
        if (limit !== undefined) {
            queryParameters['limit'] = limit;
        }
        if (resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = resourceVersion;
        }
        if (timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = timeoutSeconds;
        }
        if (watch !== undefined) {
            queryParameters['watch'] = watch;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * list or watch objects of kind VolumeAttachment
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param includeUninitialized If true, partially initialized resources are included in the response.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param timeoutSeconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    listVolumeAttachment(pretty, _continue, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch) {
        const localVarPath = this.basePath + '/apis/storage.k8s.io/v1beta1/volumeattachments';
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (_continue !== undefined) {
            queryParameters['continue'] = _continue;
        }
        if (fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = fieldSelector;
        }
        if (includeUninitialized !== undefined) {
            queryParameters['includeUninitialized'] = includeUninitialized;
        }
        if (labelSelector !== undefined) {
            queryParameters['labelSelector'] = labelSelector;
        }
        if (limit !== undefined) {
            queryParameters['limit'] = limit;
        }
        if (resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = resourceVersion;
        }
        if (timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = timeoutSeconds;
        }
        if (watch !== undefined) {
            queryParameters['watch'] = watch;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * partially update the specified StorageClass
     * @param name name of the StorageClass
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    patchStorageClass(name, body, pretty) {
        const localVarPath = this.basePath + '/apis/storage.k8s.io/v1beta1/storageclasses/{name}'
            .replace('{' + 'name' + '}', String(name));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling patchStorageClass.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling patchStorageClass.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'PATCH',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * partially update the specified VolumeAttachment
     * @param name name of the VolumeAttachment
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    patchVolumeAttachment(name, body, pretty) {
        const localVarPath = this.basePath + '/apis/storage.k8s.io/v1beta1/volumeattachments/{name}'
            .replace('{' + 'name' + '}', String(name));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling patchVolumeAttachment.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling patchVolumeAttachment.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'PATCH',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * read the specified StorageClass
     * @param name name of the StorageClass
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param exact Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;.
     * @param _export Should this value be exported.  Export strips fields that a user can not specify.
     */
    readStorageClass(name, pretty, exact, _export) {
        const localVarPath = this.basePath + '/apis/storage.k8s.io/v1beta1/storageclasses/{name}'
            .replace('{' + 'name' + '}', String(name));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling readStorageClass.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (exact !== undefined) {
            queryParameters['exact'] = exact;
        }
        if (_export !== undefined) {
            queryParameters['export'] = _export;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * read the specified VolumeAttachment
     * @param name name of the VolumeAttachment
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param exact Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;.
     * @param _export Should this value be exported.  Export strips fields that a user can not specify.
     */
    readVolumeAttachment(name, pretty, exact, _export) {
        const localVarPath = this.basePath + '/apis/storage.k8s.io/v1beta1/volumeattachments/{name}'
            .replace('{' + 'name' + '}', String(name));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling readVolumeAttachment.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (exact !== undefined) {
            queryParameters['exact'] = exact;
        }
        if (_export !== undefined) {
            queryParameters['export'] = _export;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * replace the specified StorageClass
     * @param name name of the StorageClass
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    replaceStorageClass(name, body, pretty) {
        const localVarPath = this.basePath + '/apis/storage.k8s.io/v1beta1/storageclasses/{name}'
            .replace('{' + 'name' + '}', String(name));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling replaceStorageClass.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling replaceStorageClass.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * replace the specified VolumeAttachment
     * @param name name of the VolumeAttachment
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    replaceVolumeAttachment(name, body, pretty) {
        const localVarPath = this.basePath + '/apis/storage.k8s.io/v1beta1/volumeattachments/{name}'
            .replace('{' + 'name' + '}', String(name));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling replaceVolumeAttachment.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling replaceVolumeAttachment.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
exports.Storage_v1beta1Api = Storage_v1beta1Api;
var VersionApiApiKeys;
(function (VersionApiApiKeys) {
    VersionApiApiKeys[VersionApiApiKeys["BearerToken"] = 0] = "BearerToken";
})(VersionApiApiKeys = exports.VersionApiApiKeys || (exports.VersionApiApiKeys = {}));
class VersionApi {
    constructor(basePathOrUsername, password, basePath) {
        this._basePath = defaultBasePath;
        this.defaultHeaders = {};
        this._useQuerystring = false;
        this.authentications = {
            'default': new VoidAuth(),
            'BearerToken': new ApiKeyAuth('header', 'authorization'),
        };
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        }
        else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername;
            }
        }
    }
    set useQuerystring(value) {
        this._useQuerystring = value;
    }
    set basePath(basePath) {
        this._basePath = basePath;
    }
    get basePath() {
        return this._basePath;
    }
    setDefaultAuthentication(auth) {
        this.authentications.default = auth;
    }
    setApiKey(key, value) {
        this.authentications[VersionApiApiKeys[key]].apiKey = value;
    }
    /**
     * get the code version
     */
    getCode() {
        const localVarPath = this.basePath + '/version/';
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        let useFormData = false;
        let requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
exports.VersionApi = VersionApi;
//# sourceMappingURL=api.js.map