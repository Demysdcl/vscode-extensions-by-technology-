{"version":3,"sources":["../webpack/bootstrap",".././node_modules/applicationinsights/out/AutoCollection/Console.js",".././node_modules/applicationinsights/out/AutoCollection/CorrelationContextManager.js",".././node_modules/applicationinsights/out/AutoCollection/Exceptions.js",".././node_modules/applicationinsights/out/AutoCollection/HttpDependencies.js",".././node_modules/applicationinsights/out/AutoCollection/HttpDependencyParser.js",".././node_modules/applicationinsights/out/AutoCollection/HttpRequestParser.js",".././node_modules/applicationinsights/out/AutoCollection/HttpRequests.js",".././node_modules/applicationinsights/out/AutoCollection/NativePerformance.js",".././node_modules/applicationinsights/out/AutoCollection/Performance.js",".././node_modules/applicationinsights/out/AutoCollection/RequestParser.js",".././node_modules/applicationinsights/out/AutoCollection/diagnostic-channel/bunyan.sub.js",".././node_modules/applicationinsights/out/AutoCollection/diagnostic-channel/console.sub.js",".././node_modules/applicationinsights/out/AutoCollection/diagnostic-channel/initialization.js",".././node_modules/applicationinsights/out/AutoCollection/diagnostic-channel/mongodb.sub.js",".././node_modules/applicationinsights/out/AutoCollection/diagnostic-channel/mysql.sub.js",".././node_modules/applicationinsights/out/AutoCollection/diagnostic-channel/postgres.sub.js",".././node_modules/applicationinsights/out/AutoCollection/diagnostic-channel/redis.sub.js",".././node_modules/applicationinsights/out/AutoCollection/diagnostic-channel/winston.sub.js",".././node_modules/applicationinsights/out/Declarations/Constants.js",".././node_modules/applicationinsights/out/Declarations/Contracts/Constants.js",".././node_modules/applicationinsights/out/Declarations/Contracts/Generated/AvailabilityData.js",".././node_modules/applicationinsights/out/Declarations/Contracts/Generated/Base.js",".././node_modules/applicationinsights/out/Declarations/Contracts/Generated/ContextTagKeys.js",".././node_modules/applicationinsights/out/Declarations/Contracts/Generated/Data.js",".././node_modules/applicationinsights/out/Declarations/Contracts/Generated/DataPoint.js",".././node_modules/applicationinsights/out/Declarations/Contracts/Generated/DataPointType.js",".././node_modules/applicationinsights/out/Declarations/Contracts/Generated/Domain.js",".././node_modules/applicationinsights/out/Declarations/Contracts/Generated/Envelope.js",".././node_modules/applicationinsights/out/Declarations/Contracts/Generated/EventData.js",".././node_modules/applicationinsights/out/Declarations/Contracts/Generated/ExceptionData.js",".././node_modules/applicationinsights/out/Declarations/Contracts/Generated/ExceptionDetails.js",".././node_modules/applicationinsights/out/Declarations/Contracts/Generated/MessageData.js",".././node_modules/applicationinsights/out/Declarations/Contracts/Generated/MetricData.js",".././node_modules/applicationinsights/out/Declarations/Contracts/Generated/PageViewData.js",".././node_modules/applicationinsights/out/Declarations/Contracts/Generated/RemoteDependencyData.js",".././node_modules/applicationinsights/out/Declarations/Contracts/Generated/RequestData.js",".././node_modules/applicationinsights/out/Declarations/Contracts/Generated/SeverityLevel.js",".././node_modules/applicationinsights/out/Declarations/Contracts/Generated/StackFrame.js",".././node_modules/applicationinsights/out/Declarations/Contracts/Generated/index.js",".././node_modules/applicationinsights/out/Declarations/Contracts/TelemetryTypes/TelemetryType.js",".././node_modules/applicationinsights/out/Declarations/Contracts/TelemetryTypes/index.js",".././node_modules/applicationinsights/out/Declarations/Contracts/index.js",".././node_modules/applicationinsights/out/Library/Channel.js",".././node_modules/applicationinsights/out/Library/Config.js",".././node_modules/applicationinsights/out/Library/ConnectionStringParser.js",".././node_modules/applicationinsights/out/Library/Context.js",".././node_modules/applicationinsights/out/Library/CorrelationIdManager.js",".././node_modules/applicationinsights/out/Library/EnvelopeFactory.js",".././node_modules/applicationinsights/out/Library/Logging.js",".././node_modules/applicationinsights/out/Library/NodeClient.js",".././node_modules/applicationinsights/out/Library/QuickPulseEnvelopeFactory.js",".././node_modules/applicationinsights/out/Library/QuickPulseSender.js",".././node_modules/applicationinsights/out/Library/QuickPulseStateManager.js",".././node_modules/applicationinsights/out/Library/RequestResponseHeaders.js",".././node_modules/applicationinsights/out/Library/Sender.js",".././node_modules/applicationinsights/out/Library/TelemetryClient.js",".././node_modules/applicationinsights/out/Library/Traceparent.js",".././node_modules/applicationinsights/out/Library/Tracestate.js",".././node_modules/applicationinsights/out/Library/Util.js",".././node_modules/applicationinsights/out/TelemetryProcessors/PerformanceMetricsTelemetryProcessor.js",".././node_modules/applicationinsights/out/TelemetryProcessors/SamplingTelemetryProcessor.js",".././node_modules/applicationinsights/out/TelemetryProcessors/index.js",".././node_modules/applicationinsights/out/applicationinsights.js",".././node_modules/async-hook-jl/async-hook.js",".././node_modules/async-hook-jl/index.js",".././node_modules/async-hook-jl/patches/next-tick.js",".././node_modules/async-hook-jl/patches/promise.js",".././node_modules/async-hook-jl/patches/timers.js",".././node_modules/async-listener/es6-wrapped-promise.js",".././node_modules/async-listener/glue.js",".././node_modules/async-listener/index.js",".././node_modules/cls-hooked/context-legacy.js",".././node_modules/cls-hooked/context.js",".././node_modules/cls-hooked/index.js",".././node_modules/continuation-local-storage/context.js",".././node_modules/diagnostic-channel-publishers/dist/src sync ^.*\\/lib\\/Connection$",".././node_modules/diagnostic-channel-publishers/dist/src sync ^.*\\/lib\\/Pool$",".././node_modules/diagnostic-channel-publishers/dist/src/bunyan.pub.js",".././node_modules/diagnostic-channel-publishers/dist/src/console.pub.js",".././node_modules/diagnostic-channel-publishers/dist/src/index.js",".././node_modules/diagnostic-channel-publishers/dist/src/mongodb-core.pub.js",".././node_modules/diagnostic-channel-publishers/dist/src/mongodb.pub.js",".././node_modules/diagnostic-channel-publishers/dist/src/mysql.pub.js",".././node_modules/diagnostic-channel-publishers/dist/src/pg-pool.pub.js",".././node_modules/diagnostic-channel-publishers/dist/src/pg.pub.js",".././node_modules/diagnostic-channel-publishers/dist/src/redis.pub.js",".././node_modules/diagnostic-channel-publishers/dist/src/winston.pub.js",".././node_modules/diagnostic-channel/dist/src/channel.js",".././node_modules/diagnostic-channel/dist/src/patchRequire.js",".././node_modules/emitter-listener/listener.js",".././node_modules/semver/semver.js",".././node_modules/shimmer/index.js",".././node_modules/stack-chain/format.js",".././node_modules/stack-chain/index.js",".././node_modules/stack-chain/stack-chain.js",".././node_modules/ws/index.js",".././node_modules/ws/lib/buffer-util.js",".././node_modules/ws/lib/constants.js",".././node_modules/ws/lib/event-target.js",".././node_modules/ws/lib/extension.js",".././node_modules/ws/lib/limiter.js",".././node_modules/ws/lib/permessage-deflate.js",".././node_modules/ws/lib/receiver.js",".././node_modules/ws/lib/sender.js",".././node_modules/ws/lib/stream.js",".././node_modules/ws/lib/validation.js",".././node_modules/ws/lib/websocket-server.js",".././node_modules/ws/lib/websocket.js",".././src/extension.ts",".././src/telemetry.ts",".././src/utils.ts","../external \"assert\"","../external \"async_hooks\"","../external \"child_process\"","../external \"console\"","../external \"constants\"","../external \"crypto\"","../external \"dns\"","../external \"events\"","../external \"fs\"","../external \"http\"","../external \"https\"","../external \"module\"","../external \"net\"","../external \"os\"","../external \"path\"","../external \"stream\"","../external \"timers\"","../external \"tls\"","../external \"url\"","../external \"util\"","../external \"vscode\"","../external \"zlib\""],"names":[],"mappings":";;QAAA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;;QAEA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;;;QAGA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;QACA,0CAA0C,gCAAgC;QAC1E;QACA;;QAEA;QACA;QACA;QACA,wDAAwD,kBAAkB;QAC1E;QACA,iDAAiD,cAAc;QAC/D;;QAEA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA,yCAAyC,iCAAiC;QAC1E,gHAAgH,mBAAmB,EAAE;QACrI;QACA;;QAEA;QACA;QACA;QACA,2BAA2B,0BAA0B,EAAE;QACvD,iCAAiC,eAAe;QAChD;QACA;QACA;;QAEA;QACA,sDAAsD,+DAA+D;;QAErH;QACA;;;QAGA;QACA;;;;;;;;;;;;;AClFa;AACb,kBAAkB,mBAAO,CAAC,uIAAqC;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,mBAAO,CAAC,iIAAkC;AACtD,YAAY,mBAAO,CAAC,+HAAiC;AACrD,YAAY,mBAAO,CAAC,iIAAkC;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA,mC;;;;;;;;;;;;AC5Ba;AACb,8CAA8C,cAAc;AAC5D,cAAc,mBAAO,CAAC,qFAAoB;AAC1C,kBAAkB,mBAAO,CAAC,uIAAqC;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sEAAsE;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,mBAAO,CAAC,sDAAY;AACnD;AACA;AACA,+BAA+B,mBAAO,CAAC,wFAA4B;AACnE;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8GAA8G;AAC9G;AACA;AACA;AACA;AACA,yDAAyD;AACzD;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,uBAAuB,uBAAuB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,uBAAuB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,wBAAwB;AACjD;AACA;AACA;AACA,CAAC;AACD,qD;;;;;;;;;;;;ACvMa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,4BAA4B,EAAE;AACxD;AACA;AACA,KAAK;AACL;AACA,0BAA0B,6BAA6B,EAAE;AACzD;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,kEAAkE;AAC7G,kDAAkD,mBAAmB;AACrE,yCAAyC,sBAAsB;AAC/D;AACA;AACA,qFAAqF;AACrF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA,sC;;;;;;;;;;;;AClEa;AACb,WAAW,mBAAO,CAAC,kBAAM;AACzB,YAAY,mBAAO,CAAC,oBAAO;AAC3B,cAAc,mBAAO,CAAC,qFAAoB;AAC1C,WAAW,mBAAO,CAAC,+EAAiB;AACpC,6BAA6B,mBAAO,CAAC,mHAAmC;AACxE,2BAA2B,mBAAO,CAAC,6GAAwB;AAC3D,kCAAkC,mBAAO,CAAC,uHAA6B;AACvE,2BAA2B,mBAAO,CAAC,+GAAiC;AACpE,kBAAkB,mBAAO,CAAC,6FAAwB;AAClD,kBAAkB,mBAAO,CAAC,uIAAqC;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,mBAAO,CAAC,iIAAkC;AACtD,YAAY,mBAAO,CAAC,6HAAgC;AACpD,YAAY,mBAAO,CAAC,6HAAgC;AACpD,YAAY,mBAAO,CAAC,mIAAmC;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yEAAyE,qCAAqC;AAC9G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,uBAAuB;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,uBAAuB;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,uBAAuB;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,uBAAuB;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA,4C;;;;;;;;;;;;ACzMa;AACb;AACA;AACA,UAAU,gBAAgB,sCAAsC,iBAAiB,EAAE;AACnF,yBAAyB,uDAAuD;AAChF;AACA;AACA,uBAAuB,sBAAsB;AAC7C;AACA;AACA,CAAC;AACD,UAAU,mBAAO,CAAC,gBAAK;AACvB,gBAAgB,mBAAO,CAAC,yGAA2B;AACnD,WAAW,mBAAO,CAAC,+EAAiB;AACpC,6BAA6B,mBAAO,CAAC,mHAAmC;AACxE,oBAAoB,mBAAO,CAAC,+FAAiB;AAC7C,2BAA2B,mBAAO,CAAC,+GAAiC;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA,gD;;;;;;;;;;;;AC7Ia;AACb;AACA;AACA,UAAU,gBAAgB,sCAAsC,iBAAiB,EAAE;AACnF,yBAAyB,uDAAuD;AAChF;AACA;AACA,uBAAuB,sBAAsB;AAC7C;AACA;AACA,CAAC;AACD,UAAU,mBAAO,CAAC,gBAAK;AACvB,gBAAgB,mBAAO,CAAC,yGAA2B;AACnD,WAAW,mBAAO,CAAC,+EAAiB;AACpC,6BAA6B,mBAAO,CAAC,mHAAmC;AACxE,oBAAoB,mBAAO,CAAC,+FAAiB;AAC7C,2BAA2B,mBAAO,CAAC,+GAAiC;AACpE,iBAAiB,mBAAO,CAAC,2FAAuB;AAChD,kBAAkB,mBAAO,CAAC,6FAAwB;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,6BAA6B,IAAI,QAAQ,IAAI,QAAQ,IAAI,QAAQ,IAAI;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4FAA4F;AAC5F,8FAA8F;AAC9F,0FAA0F;AAC1F,yFAAyF;AACzF,qFAAqF;AACrF;AACA;AACA;AACA,sEAAsE;AACtE,4GAA4G;AAC5G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA,CAAC;AACD;AACA,6C;;;;;;;;;;;;AC5Pa;AACb,WAAW,mBAAO,CAAC,kBAAM;AACzB,YAAY,mBAAO,CAAC,oBAAO;AAC3B,cAAc,mBAAO,CAAC,qFAAoB;AAC1C,WAAW,mBAAO,CAAC,+EAAiB;AACpC,6BAA6B,mBAAO,CAAC,mHAAmC;AACxE,wBAAwB,mBAAO,CAAC,uGAAqB;AACrD,kCAAkC,mBAAO,CAAC,uHAA6B;AACvE,6BAA6B,mBAAO,CAAC,2FAAe;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iFAAiF,uCAAuC;AACxH;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA,wC;;;;;;;;;;;;ACnOa;AACb;AACA,4CAA4C,OAAO;AACnD;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D,aAAa,mBAAO,CAAC,mFAAmB;AACxC,cAAc,mBAAO,CAAC,qFAAoB;AAC1C,cAAc,mBAAO,CAAC,qFAAoB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA,yCAAyC,sBAAsB;AAC/D,4CAA4C,4BAA4B;AACxE;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,mBAAO,CAAC,4JAAoC;AACxF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,oCAAoC,EAAE;AAC1F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,qCAAqC;AACpD,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,sCAAsC;AAC1D;AACA,yFAAyF;AACzF;AACA;AACA;AACA;AACA,2DAA2D,0BAA0B;AACrF;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,8CAA8C;AACtE;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA,oBAAoB,uDAAuD;AAC3E;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC;AACtC;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC;AAClC;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC;AAClC;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,kCAAkC;AAClC;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,kCAAkC;AAClC;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,CAAC;AACD;AACA,6C;;;;;;;;;;;;AC1Pa;AACb,SAAS,mBAAO,CAAC,cAAI;AACrB,gBAAgB,mBAAO,CAAC,mGAA2B;AACnD;AACA;AACA;AACA;AACA;AACA,4CAA4C,4BAA4B;AACxE,mDAAmD,mCAAmC;AACtF,mDAAmD;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD,iCAAiC,EAAE;AAC3F,qCAAqC;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mEAAmE;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mEAAmE;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,2BAA2B;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+HAA+H;AAC/H;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,gHAAgH;AACtJ,sCAAsC,+GAA+G;AACrJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,mEAAmE;AACrG,kCAAkC,qEAAqE;AACvG;AACA;AACA,sCAAsC,4EAA4E;AAClH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oKAAoK;AACpK,sGAAsG;AACtG;AACA;AACA;AACA,sCAAsC,yEAAyE;AAC/G;AACA;AACA,0CAA0C,0FAA0F;AACpI;AACA;AACA;AACA,0CAA0C,sFAAsF;AAChI;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gHAAgH;AAChH;AACA;AACA;AACA,0CAA0C,+EAA+E;AACzH,0CAA0C,6FAA6F;AACvI;AACA;AACA;AACA,8CAA8C,+FAA+F;AAC7I;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,4EAA4E;AACtH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA,uC;;;;;;;;;;;;ACrRa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA,yC;;;;;;;;;;;;AC3Ca;AACb,8CAA8C,cAAc;AAC5D,kBAAkB,mBAAO,CAAC,4GAA8B;AACxD,2BAA2B,mBAAO,CAAC,iFAAoB;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,uBAAuB;AAC1D;AACA;AACA,+BAA+B,sCAAsC;AACrE;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,oBAAoB,EAAE;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sC;;;;;;;;;;;;AC/Ca;AACb,8CAA8C,cAAc;AAC5D,kBAAkB,mBAAO,CAAC,4GAA8B;AACxD,2BAA2B,mBAAO,CAAC,iFAAoB;AACvD;AACA;AACA;AACA;AACA;AACA,mCAAmC,qBAAqB;AACxD;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,8HAA8H;AAC7J;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,oBAAoB,EAAE;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uC;;;;;;;;;;;;ACzCa;AACb;AACA;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA,qBAAqB,mBAAO,CAAC,qGAA+B;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,mBAAO,CAAC,iFAAoB;AAChC;AACA;AACA,0C;;;;;;;;;;;;ACjCa;AACb,8CAA8C,cAAc;AAC5D,2BAA2B,mBAAO,CAAC,iFAAoB;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,oBAAoB,EAAE;AACrE;AACA;AACA;AACA;AACA;AACA;AACA,uC;;;;;;;;;;;;ACnCa;AACb,8CAA8C,cAAc;AAC5D,2BAA2B,mBAAO,CAAC,iFAAoB;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,oBAAoB,EAAE;AACrE;AACA;AACA;AACA;AACA;AACA;AACA,qC;;;;;;;;;;;;ACxCa;AACb,8CAA8C,cAAc;AAC5D,2BAA2B,mBAAO,CAAC,iFAAoB;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,oBAAoB,EAAE;AACrE;AACA;AACA;AACA;AACA;AACA;AACA,wC;;;;;;;;;;;;ACrCa;AACb,8CAA8C,cAAc;AAC5D,2BAA2B,mBAAO,CAAC,iFAAoB;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,oBAAoB,EAAE;AACrE;AACA;AACA;AACA;AACA;AACA;AACA,qC;;;;;;;;;;;;ACtCa;AACb,8CAA8C,cAAc;AAC5D,kBAAkB,mBAAO,CAAC,4GAA8B;AACxD,2BAA2B,mBAAO,CAAC,iFAAoB;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,oBAAoB,EAAE;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uC;;;;;;;;;;;;AC1Ea;AACb,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,kFAAkF;AACnF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,qFAAqF;AACtF;AACA;AACA;AACA;AACA,iDAAiD;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qC;;;;;;;;;;;;ACvFa;AACb,8CAA8C,cAAc;AAC5D,kBAAkB,mBAAO,CAAC,qGAAa;AACvC;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qC;;;;;;;;;;;;ACtBa;AACb;AACA;AACA,UAAU,gBAAgB,sCAAsC,iBAAiB,EAAE;AACnF,yBAAyB,uDAAuD;AAChF;AACA;AACA,uBAAuB,sBAAsB;AAC7C;AACA;AACA,CAAC;AACD;AACA,aAAa,mBAAO,CAAC,mGAAU;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA,4C;;;;;;;;;;;;AC7BA;AACa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA,gC;;;;;;;;;;;;ACXA;AACa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA,0C;;;;;;;;;;;;AC/Ba;AACb;AACA;AACA,UAAU,gBAAgB,sCAAsC,iBAAiB,EAAE;AACnF,yBAAyB,uDAAuD;AAChF;AACA;AACA,uBAAuB,sBAAsB;AAC7C;AACA;AACA,CAAC;AACD;AACA,WAAW,mBAAO,CAAC,+FAAQ;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA,gC;;;;;;;;;;;;ACzBa;AACb;AACA,oBAAoB,mBAAO,CAAC,iHAAiB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA,qC;;;;;;;;;;;;ACdA;AACa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,sCAAsC;AACvC;AACA,yC;;;;;;;;;;;;ACXA;AACa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA,kC;;;;;;;;;;;;ACXa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA,oC;;;;;;;;;;;;ACba;AACb;AACA;AACA,UAAU,gBAAgB,sCAAsC,iBAAiB,EAAE;AACnF,yBAAyB,uDAAuD;AAChF;AACA;AACA,uBAAuB,sBAAsB;AAC7C;AACA;AACA,CAAC;AACD;AACA,aAAa,mBAAO,CAAC,mGAAU;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA,qC;;;;;;;;;;;;AC7Ba;AACb;AACA;AACA,UAAU,gBAAgB,sCAAsC,iBAAiB,EAAE;AACnF,yBAAyB,uDAAuD;AAChF;AACA;AACA,uBAAuB,sBAAsB;AAC7C;AACA;AACA,CAAC;AACD;AACA,aAAa,mBAAO,CAAC,mGAAU;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA,yC;;;;;;;;;;;;AC9Ba;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA,4C;;;;;;;;;;;;ACZa;AACb;AACA;AACA,UAAU,gBAAgB,sCAAsC,iBAAiB,EAAE;AACnF,yBAAyB,uDAAuD;AAChF;AACA;AACA,uBAAuB,sBAAsB;AAC7C;AACA;AACA,CAAC;AACD;AACA,aAAa,mBAAO,CAAC,mGAAU;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA,uC;;;;;;;;;;;;AC5Ba;AACb;AACA;AACA,UAAU,gBAAgB,sCAAsC,iBAAiB,EAAE;AACnF,yBAAyB,uDAAuD;AAChF;AACA;AACA,uBAAuB,sBAAsB;AAC7C;AACA;AACA,CAAC;AACD;AACA,aAAa,mBAAO,CAAC,mGAAU;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA,sC;;;;;;;;;;;;AC7Ba;AACb;AACA;AACA,UAAU,gBAAgB,sCAAsC,iBAAiB,EAAE;AACnF,yBAAyB,uDAAuD;AAChF;AACA;AACA,uBAAuB,sBAAsB;AAC7C;AACA;AACA,CAAC;AACD;AACA,gBAAgB,mBAAO,CAAC,yGAAa;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA,wC;;;;;;;;;;;;AC7Ba;AACb;AACA;AACA,UAAU,gBAAgB,sCAAsC,iBAAiB,EAAE;AACnF,yBAAyB,uDAAuD;AAChF;AACA;AACA,uBAAuB,sBAAsB;AAC7C;AACA;AACA,CAAC;AACD;AACA,aAAa,mBAAO,CAAC,mGAAU;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA,gD;;;;;;;;;;;;AC9Ba;AACb;AACA;AACA,UAAU,gBAAgB,sCAAsC,iBAAiB,EAAE;AACnF,yBAAyB,uDAAuD;AAChF;AACA;AACA,uBAAuB,sBAAsB;AAC7C;AACA;AACA,CAAC;AACD;AACA,aAAa,mBAAO,CAAC,mGAAU;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA,uC;;;;;;;;;;;;AC7BA;AACa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,sCAAsC;AACvC;AACA,yC;;;;;;;;;;;;ACdA;AACa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA,sC;;;;;;;;;;;;ACXA;AACa;AACb,8CAA8C,cAAc;AAC5D,2BAA2B,mBAAO,CAAC,uHAAoB;AACvD,eAAe,mBAAO,CAAC,+FAAQ;AAC/B,yBAAyB,mBAAO,CAAC,mHAAkB;AACnD,eAAe,mBAAO,CAAC,+FAAQ;AAC/B,oBAAoB,mBAAO,CAAC,yGAAa;AACzC,wBAAwB,mBAAO,CAAC,iHAAiB;AACjD,iBAAiB,mBAAO,CAAC,mGAAU;AACnC,mBAAmB,mBAAO,CAAC,uGAAY;AACvC,oBAAoB,mBAAO,CAAC,yGAAa;AACzC,wBAAwB,mBAAO,CAAC,iHAAiB;AACjD,2BAA2B,mBAAO,CAAC,uHAAoB;AACvD,sBAAsB,mBAAO,CAAC,6GAAe;AAC7C,qBAAqB,mBAAO,CAAC,2GAAc;AAC3C,uBAAuB,mBAAO,CAAC,+GAAgB;AAC/C,+BAA+B,mBAAO,CAAC,+HAAwB;AAC/D,sBAAsB,mBAAO,CAAC,6GAAe;AAC7C,wBAAwB,mBAAO,CAAC,iHAAiB;AACjD,qBAAqB,mBAAO,CAAC,2GAAc;AAC3C,iC;;;;;;;;;;;;ACrBa;AACb,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,sEAAsE;AACvE,yC;;;;;;;;;;;;ACxEa;AACb;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D,SAAS,mBAAO,CAAC,sHAAiB;AAClC,iC;;;;;;;;;;;;ACNa;AACb;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D,SAAS,mBAAO,CAAC,+FAAa;AAC9B,SAAS,mBAAO,CAAC,qGAAa;AAC9B,SAAS,mBAAO,CAAC,+GAAkB;AACnC,iC;;;;;;;;;;;;ACRa;AACb,cAAc,mBAAO,CAAC,4EAAW;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,cAAc;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA,mC;;;;;;;;;;;;ACjGa;AACb,2BAA2B,mBAAO,CAAC,sGAAwB;AAC3D,6BAA6B,mBAAO,CAAC,0GAA0B;AAC/D,gBAAgB,mBAAO,CAAC,mGAA2B;AACnD,UAAU,mBAAO,CAAC,gBAAK;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0DAA0D,4CAA4C;AACtG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,0EAA0E;AAC1E;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA,kC;;;;;;;;;;;;AC3Fa;AACb,gBAAgB,mBAAO,CAAC,mGAA2B;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,IAAI;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD;AACjD;AACA;AACA,CAAC;AACD;AACA,kD;;;;;;;;;;;;ACtCA,iDAAa;AACb,SAAS,mBAAO,CAAC,cAAI;AACrB,SAAS,mBAAO,CAAC,cAAI;AACrB,WAAW,mBAAO,CAAC,kBAAM;AACzB,gBAAgB,mBAAO,CAAC,yGAA2B;AACnD,cAAc,mBAAO,CAAC,4EAAW;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA,mC;;;;;;;;;;;;;AC/Da;AACb,WAAW,mBAAO,CAAC,sEAAQ;AAC3B,cAAc,mBAAO,CAAC,4EAAW;AACjC;AACA;AACA;AACA;AACA,6BAA6B,kBAAkB,gBAAgB,wBAAwB;AACvF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,uGAAuG,mBAAmB,EAAE;AAC5H;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uGAAuG,uBAAuB,EAAE;AAChI;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,kBAAkB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA,gD;;;;;;;;;;;;ACxJa;AACb,gBAAgB,mBAAO,CAAC,yGAA2B;AACnD,WAAW,mBAAO,CAAC,sEAAQ;AAC3B,kCAAkC,mBAAO,CAAC,uIAA6C;AACvF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,oBAAoB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,KAAK,yDAAyD;AAC5F;AACA,CAAC;AACD;AACA,2C;;;;;;;;;;;;AClTa;AACb;AACA;AACA;AACA;AACA;AACA,wBAAwB,uBAAuB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,uBAAuB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA,mC;;;;;;;;;;;;AC5Ba;AACb;AACA;AACA,UAAU,gBAAgB,sCAAsC,iBAAiB,EAAE;AACnF,yBAAyB,uDAAuD;AAChF;AACA;AACA,uBAAuB,sBAAsB;AAC7C;AACA;AACA,CAAC;AACD,sBAAsB,mBAAO,CAAC,4FAAmB;AACjD,4BAA4B,mBAAO,CAAC,6GAAgC;AACpE,4BAA4B,mBAAO,CAAC,qHAAoC;AACxE,cAAc,mBAAO,CAAC,4EAAW;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA,sC;;;;;;;;;;;;ACxEa;AACb;AACA,4CAA4C,OAAO;AACnD;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,mBAAO,CAAC,cAAI;AACrB,gBAAgB,mBAAO,CAAC,yGAA2B;AACnD,gBAAgB,mBAAO,CAAC,mGAA2B;AACnD,WAAW,mBAAO,CAAC,sEAAQ;AAC3B,cAAc,mBAAO,CAAC,4EAAW;AACjC,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA,2CAA2C;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,aAAa,aAAa;AACjE;AACA;AACA;AACA;AACA;AACA,uCAAuC,aAAa,iGAAiG;AACrJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,aAAa,yFAAyF;AACjJ;AACA;AACA;AACA;AACA;AACA,yCAAyC,aAAa;AACtD,UAAU;AACV;AACA;AACA;AACA;AACA;AACA,4CAA4C,aAAa,4OAA4O;AACrS;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA,qD;;;;;;;;;;;;AChKa;AACb,YAAY,mBAAO,CAAC,oBAAO;AAC3B,kCAAkC,mBAAO,CAAC,qHAAoC;AAC9E,cAAc,mBAAO,CAAC,4EAAW;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA,4C;;;;;;;;;;;;ACnEa;AACb,cAAc,mBAAO,CAAC,4EAAW;AACjC,aAAa,mBAAO,CAAC,0EAAU;AAC/B,gCAAgC,mBAAO,CAAC,gHAA6B;AACrE,uBAAuB,mBAAO,CAAC,8FAAoB;AACnD,gBAAgB,mBAAO,CAAC,mGAA2B;AACnD,cAAc,mBAAO,CAAC,4EAAW;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mEAAmE,0BAA0B,EAAE;AAC/F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA,kD;;;;;;;;;;;;AC9Ja;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kD;;;;;;;;;;;;AC5Ca;AACb,SAAS,mBAAO,CAAC,cAAI;AACrB,SAAS,mBAAO,CAAC,cAAI;AACrB,WAAW,mBAAO,CAAC,kBAAM;AACzB,WAAW,mBAAO,CAAC,kBAAM;AACzB,oBAAoB,mBAAO,CAAC,oCAAe;AAC3C,cAAc,mBAAO,CAAC,4EAAW;AACjC,kCAAkC,mBAAO,CAAC,qHAAoC;AAC9E,WAAW,mBAAO,CAAC,sEAAQ;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,qCAAqC,EAAE;AAC3F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qEAAqE,oBAAoB;AACzF,0CAA0C,oBAAoB,EAAE;AAChE;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,6EAA6E,oBAAoB;AACjG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,+CAA+C,kBAAkB,EAAE;AACnE,yCAAyC,0BAA0B,EAAE;AACrE;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gEAAgE;AAChE;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,kBAAkB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,kBAAkB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,YAAY,oBAAoB,oCAAoC,EAAE;AAC3H,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,YAAY;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D,kDAAkD,EAAE;AAC/G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA,kC;;;;;;;;;;;;AChda;AACb,UAAU,mBAAO,CAAC,gBAAK;AACvB,aAAa,mBAAO,CAAC,0EAAU;AAC/B,cAAc,mBAAO,CAAC,4EAAW;AACjC,gBAAgB,mBAAO,CAAC,yGAA2B;AACnD,cAAc,mBAAO,CAAC,4EAAW;AACjC,0BAA0B,mBAAO,CAAC,mGAAwB;AAC1D,kCAAkC,mBAAO,CAAC,uIAA6C;AACvF,aAAa,mBAAO,CAAC,0EAAU;AAC/B,WAAW,mBAAO,CAAC,sEAAQ;AAC3B,cAAc,mBAAO,CAAC,4EAAW;AACjC,sBAAsB,mBAAO,CAAC,4FAAmB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,kCAAkC,EAAE,eAAe,4BAA4B,EAAE,eAAe,kCAAkC,EAAE;AACpL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6FAA6F,gGAAgG;AAC7L;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,8BAA8B;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA,2C;;;;;;;;;;;;ACzKa;AACb,WAAW,mBAAO,CAAC,sEAAQ;AAC3B,2BAA2B,mBAAO,CAAC,sGAAwB;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,EAAE;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,EAAE;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,GAAG;AACtC;AACA;AACA,mCAAmC,GAAG;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA,uC;;;;;;;;;;;;AC3Ga;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0EAA0E,MAAM;AAChF,0EAA0E,KAAK;AAC/E;AACA;AACA;AACA;AACA,4DAA4D,MAAM;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,qBAAqB;AAC9D;AACA,sCAAsC;AACtC;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA,sC;;;;;;;;;;;;AC3Ea;AACb;AACA,4CAA4C,OAAO;AACnD;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,mBAAO,CAAC,kBAAM;AACzB,YAAY,mBAAO,CAAC,oBAAO;AAC3B,UAAU,mBAAO,CAAC,gBAAK;AACvB,gBAAgB,mBAAO,CAAC,4BAAW;AACnC,cAAc,mBAAO,CAAC,4EAAW;AACjC,6BAA6B,mBAAO,CAAC,0GAA0B;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC;AACzC,2BAA2B,oBAAoB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,OAAO;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gEAAgE,IAAI;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8DAA8D;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,4BAA4B;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,sBAAsB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,SAAS;AACxB,iBAAiB,mBAAmB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,mBAAmB,gGAAgG;AACpJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,YAAY,yGAAyG,oBAAoB,kCAAkC,GAAG;AACnN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD,+CAA+C,EAAE;AACvG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,CAAC;AACD;AACA,gC;;;;;;;;;;;;ACpVa;AACb,8CAA8C,cAAc;AAC5D,6BAA6B,mBAAO,CAAC,2GAA+B;AACpE,oBAAoB,mBAAO,CAAC,yGAA2B;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gE;;;;;;;;;;;;AC1Ba;AACb,8CAA8C,cAAc;AAC5D,gBAAgB,mBAAO,CAAC,yGAA2B;AACnD;AACA;AACA;AACA;AACA,iDAAiD;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,kBAAkB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sD;;;;;;;;;;;;AC9Ca;AACb;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D,SAAS,mBAAO,CAAC,8HAA8B;AAC/C,SAAS,mBAAO,CAAC,kJAAwC;AACzD,iC;;;;;;;;;;;;ACPa;AACb,8CAA8C,cAAc;AAC5D,gCAAgC,mBAAO,CAAC,sIAA4C,EAAE;AACtF,yBAAyB,mBAAO,CAAC,kGAA0B;AAC3D,4BAA4B,mBAAO,CAAC,wGAA6B;AACjE,6BAA6B,mBAAO,CAAC,0GAA8B;AACnE,kCAAkC,mBAAO,CAAC,oHAAmC;AAC7E,8BAA8B,mBAAO,CAAC,4GAA+B;AACrE,2BAA2B,mBAAO,CAAC,8GAAgC;AACnE,cAAc,mBAAO,CAAC,oFAAmB;AACzC,uBAAuB,mBAAO,CAAC,kHAAkC;AACjE,0BAA0B,mBAAO,CAAC,sHAAoC;AACtE;AACA;AACA,0BAA0B,mBAAO,CAAC,0FAAsB;AACxD,oBAAoB,mBAAO,CAAC,wGAA0B;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,oGAAoG;AACrG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,cAAc;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,oBAAoB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,cAAc;AAC/B;AACA;AACA,2CAA2C,2BAA2B;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,cAAc;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,cAAc;AAC/B;AACA;AACA,gDAAgD,+BAA+B;AAC/E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,cAAc;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,cAAc;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,cAAc;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,cAAc;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,cAAc;AAC/B;AACA;AACA,4CAA4C,4BAA4B;AACxE,8CAA8C,6BAA6B;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,gBAAgB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+EAA+E;AAC/E;AACA;AACA;AACA,yCAAyC;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+C;;;;;;;;;;;;ACrUa;;AAEb;AACA;;AAEA;AACA,cAAc,mBAAO,CAAC,iFAAwB;AAC9C,aAAa,mBAAO,CAAC,6EAAsB;AAC3C,YAAY,mBAAO,CAAC,2EAAqB;AACzC;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,iBAAiB,mBAAO,CAAC,iEAAgB;;AAEzC;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,E;;;;;;;;;;;;ACrIA,iDAAa;;AAEb,kBAAkB,mBAAO,CAAC,mEAAiB;;AAE3C;AACA;AACA;AACA;AACA,oCAAoC,mBAAO,CAAC,iEAAgB;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,qBAAqB,mBAAO,CAAC,wDAAa;;AAE1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;;AAEH;AACA,C;;;;;;;;;;;;;;;;;;;;;;;;AC9Ba;;AAEb;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,mBAAmB,sBAAsB;AACzC;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;;;;;;ACxDa;;AAEb;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC/Da;;AAEb,eAAe,mBAAO,CAAC,sBAAQ;;AAE/B;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,mBAAmB,sBAAsB;AACzC;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;;;;;;ACpHa;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACpCA,WAAW,mBAAO,CAAC,gDAAS;;AAE5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,kBAAkB,gBAAgB;;AAElC;;AAEA,iBAAiB,iBAAiB;AAClC;AACA,eAAe,gBAAgB;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,mBAAmB,YAAY;AAC/B;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,mBAAmB,YAAY;AAC/B;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,qBAAqB,YAAY;AACjC;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,iBAAiB,YAAY;AAC7B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,mBAAmB,YAAY;AAC/B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,mBAAmB,YAAY;AAC/B;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,qBAAqB,YAAY;AACjC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,YAAY;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW;;AAEX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,YAAY;AACjC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB,YAAY;AAC7B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,iBAAiB,YAAY;AAC7B;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB,sBAAsB;AACvC;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA,iBAAiB,sBAAsB;AACvC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;;;;;;;;;;;;ACvea;;AAEb;;AAEA,mBAAmB,mBAAO,CAAC,gDAAS;AACpC,mBAAmB,mBAAO,CAAC,+CAAQ;AACnC;AACA;AACA,mBAAmB,mBAAO,CAAC,wDAAW;AACtC,mBAAmB,mBAAO,CAAC,kBAAM;AACjC;;AAEA;AACA;AACA;AACA;;AAEA,UAAU,mBAAO,CAAC,gBAAK;;AAEvB;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;;AAEA,0BAA0B,yCAAyC;;AAEnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED,WAAW,mBAAO,CAAC,kBAAM;;AAEzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,CAAC;;AAED,mBAAmB,mBAAO,CAAC,oCAAe;;AAE1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,aAAa,mBAAO,CAAC,sBAAQ;AAC7B;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,UAAU,mBAAO,CAAC,gBAAK;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,SAAS,mBAAO,CAAC,cAAI;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,KAAK,QAAQ,mBAAO,CAAC,kBAAM,EAAE,EAAE,cAAc;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK,UAAU,mBAAO,CAAC,sBAAQ,EAAE,EAAE,cAAc;AACjD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,gDAAgD,gBAAgB;AAChE,0DAA0D,gBAAgB;;AAE1E;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,qBAAqB,mBAAO,CAAC,sFAA0B;AACvD,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAc;AACd,KAAK;AACL,cAAc;AACd,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,mDAAmD;AACnD;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,0BAA0B;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,sBAAsB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;;;;;;;ACjqBa;;AAEb,aAAa,mBAAO,CAAC,kBAAM;AAC3B,eAAe,mBAAO,CAAC,sBAAQ;AAC/B,oBAAoB,mBAAO,CAAC,qEAAkB;AAC9C,kBAAkB,mBAAO,CAAC,4DAAe;;AAEzC;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA,WAAW,SAAS;AACpB,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,yDAAyD;AACzD;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,MAAM;AACjB;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,4CAA4C;AAC5C;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;;AAEA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;;AAEH;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF,EAAE;;;AAGF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;;AAGA;AACA;AACA,mBAAmB,mBAAO,CAAC,wDAAa;AACxC;AACA;AACA;AACA;;;;;;;;;;;;;ACnaA;AACa;;AAEb,aAAa,mBAAO,CAAC,kBAAM;AAC3B,eAAe,mBAAO,CAAC,sBAAQ;AAC/B,oBAAoB,mBAAO,CAAC,qEAAkB;AAC9C,oBAAoB,mBAAO,CAAC,gCAAa;;AAEzC;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,8JAA8J,sCAAsC;AACpM;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,gLAAgL,sCAAsC;AACtN,gBAAgB,UAAU,qCAAqC,UAAU,IAAI,IAAI,wBAAwB,WAAW,uBAAuB,oBAAoB,aAAa,UAAU,OAAO,iBAAiB;AAC9M;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yKAAyK,sCAAsC;AAC/M,cAAc,UAAU,wBAAwB,UAAU,IAAI,IAAI,GAAG,iBAAiB,cAAc,WAAW,uBAAuB,oBAAoB,aAAa,UAAU,OAAO,iBAAiB,UAAU,0BAA0B;AAC7O;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAc,UAAU,4BAA4B,UAAU,eAAe,WAAW,uBAAuB,oBAAoB,aAAa,UAAU,OAAO,iBAAiB,WAAW,uBAAuB,sCAAsC,EAAE;AAC5P;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,gBAAgB,UAAU,sBAAsB,UAAU,eAAe,WAAW,aAAa,UAAU,uBAAuB,oBAAoB,OAAO,iBAAiB,WAAW,sBAAsB;AAC/M;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,gBAAgB,UAAU,oBAAoB,UAAU,eAAe,WAAW,aAAa,UAAU,uBAAuB,oBAAoB,OAAO,iBAAiB,GAAG,sBAAsB;AACrM;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA,WAAW,SAAS;AACpB,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,UAAU,kBAAkB,UAAU,eAAe,WAAW,aAAa,UAAU,uBAAuB,oBAAoB,OAAO,iBAAiB,GAAG,sBAAsB;AACjM;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,UAAU,iBAAiB,UAAU,eAAe,WAAW,aAAa,UAAU,uBAAuB,oBAAoB,OAAO,iBAAiB,GAAG,sBAAsB;AAChM;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,yDAAyD;AACzD,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,MAAM;AACjB;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,qCAAqC,KAAK;AAC1C;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,UAAU,QAAQ,KAAK,KAAK,KAAK,gCAAgC,QAAQ,cAAc,WAAW,aAAa,UAAU,UAAU,qCAAqC,YAAY,SAAS;AACtN;AACA,YAAY;AACZ;AACA,yBAAyB,UAAU,QAAQ,KAAK,KAAK,KAAK,4BAA4B,QAAQ,cAAc,WAAW,aAAa,UAAU,UAAU,qCAAqC,YAAY,SAAS;AAClN;AACA,UAAU;AACV;AACA;AACA;AACA,uBAAuB,UAAU,QAAQ,KAAK,KAAK,KAAK,YAAY,QAAQ,cAAc,WAAW,aAAa,UAAU,UAAU,qCAAqC,YAAY,SAAS;AAChM;AACA;AACA;AACA;;AAEA;AACA;AACA,oBAAoB,UAAU,QAAQ,KAAK,KAAK,KAAK,YAAY,QAAQ,cAAc,WAAW,aAAa,UAAU,UAAU,gCAAgC,sCAAsC,EAAE,YAAY,SAAS;AAChO;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,UAAU,qCAAqC,KAAK,KAAK,KAAK,YAAY,QAAQ,cAAc,WAAW,aAAa,UAAU,UAAU,gCAAgC,2CAA2C,EAAE,YAAY,SAAS;AACpQ;AACA,SAAS;AACT;AACA,oBAAoB,UAAU,wBAAwB,KAAK,KAAK,KAAK,YAAY,QAAQ,cAAc,WAAW,aAAa,UAAU,UAAU,gCAAgC,2CAA2C,EAAE,YAAY,SAAS;AACrP;AACA;;;AAGA;AACA,uCAAuC,iBAAiB;AACxD;AACA;AACA,kBAAkB,UAAU,yBAAyB,KAAK,KAAK,KAAK,aAAa,SAAS,WAAW,QAAQ,cAAc,WAAW,aAAa,UAAU,UAAU,gCAAgC,sCAAsC,EAAE,YAAY,SAAS;AACpQ;;AAEA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,mDAAmD;AACnD,OAAO;AACP;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,oBAAoB,UAAU,UAAU,KAAK,YAAY,QAAQ,cAAc,WAAW,aAAa,UAAU,UAAU,gCAAgC,sCAAsC,EAAE,WAAW,sBAAsB;AACpO;AACA;;AAEA;;AAEA,OAAO;AACP;AACA;AACA,kBAAkB,UAAU,0BAA0B,KAAK,YAAY,QAAQ,cAAc,WAAW,aAAa,UAAU,UAAU,gCAAgC,sCAAsC,EAAE,uBAAuB,mCAAmC,sCAAsC,EAAE;AACnT;AACA;AACA,KAAK;AACL;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA,mDAAmD;AACnD,OAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,oBAAoB,UAAU,SAAS,KAAK,YAAY,QAAQ,cAAc,WAAW,aAAa,UAAU,UAAU,gCAAgC,sCAAsC,EAAE,WAAW,sBAAsB;AACnO;;AAEA;;AAEA,OAAO;AACP;AACA;AACA;AACA,kBAAkB,UAAU,yBAAyB,KAAK,YAAY,QAAQ,cAAc,WAAW,aAAa,UAAU,UAAU,gCAAgC,sCAAsC,EAAE,WAAW,sBAAsB;AACjP;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,kBAAkB,UAAU,WAAW,KAAK,eAAe,WAAW,WAAW,QAAQ,aAAa,UAAU,UAAU,gCAAgC,sCAAsC,EAAE,WAAW,kDAAkD;AAC/P;;AAEA;AACA;AACA,GAAG;;AAEH;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,yBAAyB,qBAAqB;AAC9C,yBAAyB,qBAAqB;AAC9C;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,CAAC;;;;;;;;;;;;;;;AC1dY;;AAEb,eAAe,mBAAO,CAAC,+CAAQ;;AAE/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,mBAAO,CAAC,uDAAW;AACtC,CAAC;AACD,mBAAmB,mBAAO,CAAC,qEAAkB;AAC7C;;;;;;;;;;;;;ACda;;AAEb,kBAAkB,mBAAO,CAAC,sBAAQ;AAClC,kBAAkB,mBAAO,CAAC,qEAAkB;;AAE5C;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,+BAA+B,mBAAO,CAAC,8DAAgB;;AAEvD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,uDAAuD;AACvD;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,MAAM;AACjB;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,0BAA0B,yBAAyB,EAAE;AACrD,0CAA0C,uCAAuC,EAAE;AACnF,0CAA0C,sCAAsC,EAAE;AAClF,iCAAiC,sCAAsC;AACvE,GAAG;;AAEH;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,iCAAiC;;AAEjC;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACnNA;AACA;AACA;AACA;AACA;AACA,uCAAuC,WAAW;AAClD;AACA;AACA,wH;;;;;;;;;;;ACRA;AACA;AACA;AACA;AACA;AACA,uCAAuC,WAAW;AAClD;AACA;AACA,kH;;;;;;;;;;;;ACRa;AACb,8CAA8C,cAAc;AAC5D;AACA;AACA,2BAA2B,mBAAO,CAAC,iFAAoB;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D,gCAAgC;AAC5F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sC;;;;;;;;;;;;AC5Ba;AACb,8CAA8C,cAAc;AAC5D;AACA;AACA,2BAA2B,mBAAO,CAAC,iFAAoB;AACvD,eAAe,mBAAO,CAAC,sBAAQ;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD,mBAAmB;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD,iCAAiC;AAC1F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC;AACzC;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD,8BAA8B;AACrF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,mBAAO,CAAC,wBAAS;AACrB;AACA;AACA,uC;;;;;;;;;;;;AC9Da;AACb;AACA;AACA,8CAA8C,cAAc;AAC5D,aAAa,mBAAO,CAAC,yFAAc;AACnC;AACA,iBAAiB,mBAAO,CAAC,2FAAe;AACxC;AACA,kBAAkB,mBAAO,CAAC,qGAAoB;AAC9C;AACA,cAAc,mBAAO,CAAC,2FAAe;AACrC;AACA,YAAY,mBAAO,CAAC,uFAAa;AACjC;AACA,aAAa,mBAAO,CAAC,2FAAe;AACpC;AACA,SAAS,mBAAO,CAAC,iFAAU;AAC3B;AACA,YAAY,mBAAO,CAAC,uFAAa;AACjC;AACA,cAAc,mBAAO,CAAC,2FAAe;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iC;;;;;;;;;;;;AClCa;AACb,8CAA8C,cAAc;AAC5D;AACA;AACA,2BAA2B,mBAAO,CAAC,iFAAoB;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4C;;;;;;;;;;;;ACzCa;AACb,8CAA8C,cAAc;AAC5D;AACA;AACA,2BAA2B,mBAAO,CAAC,iFAAoB;AACvD;AACA;AACA;AACA;AACA,iFAAiF,aAAa,EAAE;AAChG,aAAa;AACb,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,uCAAuC,yDAAyD,0DAA0D,EAAE,EAAE;AAC9J,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,uCAAuC,yDAAyD,2DAA2D,EAAE,EAAE;AAC/J,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gGAAgG,aAAa,EAAE;AAC/G;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,yDAAyD,0DAA0D,EAAE,EAAE;AAC5K;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,yDAAyD,2DAA2D,EAAE,EAAE;AAC7K;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gGAAgG,aAAa,EAAE;AAC/G;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,yDAAyD,0DAA0D,EAAE,EAAE;AAC5K;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,yDAAyD,2DAA2D,EAAE,EAAE;AAC7K;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uC;;;;;;;;;;;;AChKa;AACb,8CAA8C,cAAc;AAC5D;AACA;AACA,2BAA2B,mBAAO,CAAC,iFAAoB;AACvD,WAAW,mBAAO,CAAC,kBAAM;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD,QAAQ;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,oHAAQ,kCAAkC,iBAAiB,CAAC;AACtF,0DAA0D,uEAAuE,EAAE;AACnI;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D,uFAAuF;AAClJ;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,oBAAoB,8GAAQ,kCAAkC,WAAW,CAAC;AAC1E,oDAAoD,2DAA2D,EAAE;AACjH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qC;;;;;;;;;;;;AChFa;AACb,8CAA8C,cAAc;AAC5D;AACA;AACA,2BAA2B,mBAAO,CAAC,iFAAoB;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uC;;;;;;;;;;;;ACvBa;AACb,8CAA8C,cAAc;AAC5D;AACA;AACA,2BAA2B,mBAAO,CAAC,iFAAoB;AACvD,eAAe,mBAAO,CAAC,sBAAQ;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,iFAAiF,YAAY;AAC7F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6DAA6D,IAAI;AACjE;AACA,kDAAkD,IAAI;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C;AAC1C;AACA,qBAAqB;AACrB;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,iFAAiF,YAAY;AAC7F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kC;;;;;;;;;;;;ACjRa;AACb,8CAA8C,cAAc;AAC5D;AACA;AACA,2BAA2B,mBAAO,CAAC,iFAAoB;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mEAAmE,2FAA2F;AAC9J;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qC;;;;;;;;;;;;AC1Ca;AACb;AACA;AACA,UAAU,gBAAgB,sCAAsC,iBAAiB,EAAE;AACnF,yBAAyB,uDAAuD;AAChF;AACA;AACA,uBAAuB,sBAAsB;AAC7C;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA,4DAA4D,cAAc;AAC1E;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA,2BAA2B,mBAAO,CAAC,iFAAoB;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD,mEAAmE;AAC5H;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6DAA6D,4BAA4B,EAAE;AAC3F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+FAA+F;AAC/F;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA,6DAA6D,mEAAmE;AAChI;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D,mBAAmB;AAC/E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8DAA8D,mBAAmB;AACjF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uC;;;;;;;;;;;;ACvJa;AACb;AACA;AACA,8CAA8C,cAAc;AAC5D,qBAAqB,mBAAO,CAAC,kFAAgB;AAC7C,qBAAqB,mBAAO,CAAC,kFAAgB;AAC7C;AACA,wCAAwC,aAAa;AACrD;AACA;AACA,uBAAuB,mBAAO,CAAC,4EAAsB,UAAU;AAC/D;AACA,0DAA0D,WAAW;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,gCAAgC,qBAAqB;AACrD;AACA;AACA;AACA,qCAAqC,qCAAqC;AAC1E;AACA;AACA,gCAAgC,qBAAqB;AACrD;AACA;AACA,+BAA+B,0BAA0B;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0DAA0D,WAAW;AACrE;AACA,+EAA+E,wCAAwC,EAAE;AACzH;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D,iDAAiD,EAAE;AAC9G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA,uBAAuB,mBAAO,CAAC,sBAAQ;AACvC;AACA;AACA;AACA;AACA;AACA,mC;;;;;;;;;;;;AC5Ga;AACb;AACA;AACA,8CAA8C,cAAc;AAC5D,WAAW,mBAAO,CAAC,kBAAM;AACzB,aAAa,mBAAO,CAAC,+CAAQ;AAC7B;AACA,mBAAmB,mBAAO,CAAC,sBAAQ;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD,gBAAgB;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wC;;;;;;;;;;;;;;;;;;;;;;;ACzDa;;AAEb,cAAc,mBAAO,CAAC,gDAAS;AAC/B;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,YAAY;AACjC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,+CAA+C,kCAAkC,EAAE;AACnF;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,sBAAsB;AACzC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;;;;;;;;;;;AC3KA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,oBAAoB,oCAAoC;AACxD,0BAA0B,oCAAoC;AAC9D,0BAA0B,oCAAoC;AAC9D;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;;AAEH;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP,KAAK;AACL,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA,OAAO;AACP;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;;AAEA;;AAEA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,iBAAiB,qBAAqB;AACtC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,iBAAiB,gBAAgB;AACjC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,gBAAgB;AAC/B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,iBAAiB,sBAAsB;AACvC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,iBAAiB,sBAAsB;AACvC;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;;;;;;;AC18CY;;AAEZ;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;;AAEA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;ACxHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D;AAC3D,oBAAoB;AACpB;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB,mBAAmB;AACpC;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC1DA;AACA;AACA;AACA;AACA,qCAAqC,mBAAO,CAAC,+DAAgB;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,mBAAO,CAAC,gEAAe;AAC/D;;;;;;;;;;;;;;;;;;;;;;;;ACdA;AACA,sBAAsB,mBAAO,CAAC,yDAAa;;AAE3C;AACA;AACA;AACA;AACA;AACA,iBAAiB,mBAAO,CAAC,+DAAgB;AACzC;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA,6CAA6C,OAAO;AACpD;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;;AAEH;AACA,CAAC;;AAED;;;;;;;;;;;;;ACrMa;;AAEb,kBAAkB,mBAAO,CAAC,2DAAiB;;AAE3C,kCAAkC,mBAAO,CAAC,qDAAc;AACxD,mBAAmB,mBAAO,CAAC,yEAAwB;AACnD,qBAAqB,mBAAO,CAAC,yDAAgB;AAC7C,mBAAmB,mBAAO,CAAC,qDAAc;;AAEzC;;;;;;;;;;;;;ACTa;;AAEb,OAAO,eAAe,GAAG,mBAAO,CAAC,uDAAa;;AAE9C;AACA;AACA;AACA,WAAW,SAAS;AACpB,WAAW,OAAO;AAClB,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,iBAAiB,iBAAiB;AAClC;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA;AACA;AACA,iBAAiB,YAAY;AAC7B;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA,iBAAiB,YAAY;AAC7B;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY,YAAY;AACxB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,WAAW,EAAE;AACb,YAAY,OAAO;AACnB,YAAY;AACZ;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,WAAW,sBAAsB;AACjC,YAAY,OAAO;AACnB;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,qBAAqB,mBAAO,CAAC,oIAAY;AACzC;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACjJa;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACTa;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,qCAAqC;AAClD,aAAa,UAAU;AACvB;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,UAAU;AACvB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,UAAU;AACvB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,UAAU;AACvB;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,SAAS;AACtB;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,SAAS;AACtB;AACA;AACA;AACA;;AAEA,mBAAmB,sBAAsB;AACzC;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;;ACzKa;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,wBAAwB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY,OAAO;AACnB;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,QAAQ,mBAAmB;AAC3B;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA,OAAO,6BAA6B;AACpC;AACA,iEAAiE,EAAE;AACnE;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA,OAAO;AACP,+DAA+D,EAAE;AACjE;AACA,KAAK;AACL;AACA;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA,iEAAiE,EAAE;AACnE;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP,+DAA+D,EAAE;AACjE;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAiE,EAAE;AACnE;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA,SAAS;AACT,iEAAiE,EAAE;AACnE;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA,iEAAiE,EAAE;AACnE;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP,+DAA+D,EAAE;AACjE;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,EAAE,GAAG,EAAE;AAC1D,0BAA0B;AAC1B,eAAe;AACf;AACA,oBAAoB;AACpB,SAAS;AACT;AACA,KAAK;AACL;AACA;;AAEA,kBAAkB;;;;;;;;;;;;;AC9NL;;AAEb;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;;ACrDa;;AAEb,aAAa,mBAAO,CAAC,kBAAM;;AAE3B,mBAAmB,mBAAO,CAAC,2DAAe;AAC1C,gBAAgB,mBAAO,CAAC,mDAAW;AACnC,OAAO,oBAAoB,GAAG,mBAAO,CAAC,uDAAa;;AAEnD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,QAAQ;AACrB;AACA,aAAa,QAAQ;AACrB;AACA,aAAa,iBAAiB;AAC9B;AACA,aAAa,iBAAiB;AAC9B;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB;AACA,aAAa,OAAO;AACpB;AACA,aAAa,QAAQ;AACrB;AACA,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,YAAY;AACZ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAc,OAAO;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,aAAa,MAAM;AACnB,cAAc,OAAO;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,MAAM;AACnB,cAAc,OAAO;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,aAAa,MAAM;AACnB,cAAc,OAAO;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,aAAa,MAAM;AACnB,cAAc,MAAM;AACpB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,wCAAwC,IAAI;AAC5C;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,gDAAgD,IAAI,KAAK,MAAM;AAC/D;AACA;AACA;AACA,WAAW;AACX;AACA,8CAA8C,IAAI,KAAK,MAAM;AAC7D;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,8CAA8C,IAAI,KAAK,MAAM;AAC7D;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,8CAA8C,IAAI,KAAK,MAAM;AAC7D;AACA;AACA,SAAS;AACT,gDAAgD,IAAI;AACpD;;AAEA;AACA,OAAO;AACP,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,QAAQ;AACrB,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;;AAEA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,QAAQ;AACrB,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;;AAEA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,QAAQ;AACrB,aAAa,SAAS;AACtB;AACA;AACA;AACA;;AAEA;AACA,qBAAqB,SAAS;AAC9B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,gCAAgC,SAAS;AACzC;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,QAAQ;AACrB,aAAa,SAAS;AACtB;AACA;AACA;AACA;;AAEA;AACA,qBAAqB,SAAS;AAC9B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;;AAEP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,gCAAgC,SAAS;AACzC;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;;AAEA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,MAAM;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC9fa;;AAEb,OAAO,WAAW,GAAG,mBAAO,CAAC,sBAAQ;;AAErC,0BAA0B,mBAAO,CAAC,yEAAsB;AACxD;AACA;AACA;AACA;AACA;AACA,CAAC,GAAG,mBAAO,CAAC,uDAAa;AACzB,OAAO,gCAAgC,GAAG,mBAAO,CAAC,2DAAe;AACjE,OAAO,iCAAiC,GAAG,mBAAO,CAAC,yDAAc;;AAEjE;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,SAAS;AACtB;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,OAAO;AACpB,cAAc,OAAO;AACrB;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;AACA,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;AACA,cAAc,uBAAuB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA,mDAAmD,aAAa;AAChE;;AAEA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,oCAAoC,oBAAoB;AACxD;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,iDAAiD,aAAa;AAC9D;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAc,uBAAuB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAc,uBAAuB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAc,uBAAuB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,SAAS;AACtB,cAAc,6BAA6B;AAC3C;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,SAAS;AACtB;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA,cAAc,kBAAkB;AAChC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA;;AAEA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,aAAa,OAAO;AACpB,cAAc,6BAA6B;AAC3C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA,OAAO;AACP;;AAEA;AACA,0DAA0D,KAAK;AAC/D;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,WAAW,mBAAmB;AAC9B,WAAW,OAAO;AAClB,WAAW,QAAQ;AACnB;AACA,WAAW,OAAO;AAClB,YAAY,mBAAmB;AAC/B;AACA;AACA;AACA;AACA,yCAAyC,QAAQ;AACjD;;AAEA;AACA;AACA;AACA;;;;;;;;;;;;;AC5ea;;AAEb,OAAO,iBAAiB,GAAG,mBAAO,CAAC,sBAAQ;;AAE3C,0BAA0B,mBAAO,CAAC,yEAAsB;AACxD,OAAO,eAAe,GAAG,mBAAO,CAAC,uDAAa;AAC9C,OAAO,oBAAoB,GAAG,mBAAO,CAAC,yDAAc;AACpD,OAAO,4BAA4B,GAAG,mBAAO,CAAC,2DAAe;;AAE7D;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,WAAW;AACxB,aAAa,OAAO;AACpB;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,QAAQ;AACrB,aAAa,QAAQ;AACrB,aAAa,QAAQ;AACrB,aAAa,QAAQ;AACrB,cAAc,SAAS;AACvB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,mBAAmB;AAChC,aAAa,OAAO;AACpB,aAAa,QAAQ;AACrB,aAAa,SAAS;AACtB;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,QAAQ;AACrB,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,EAAE;AACf,aAAa,QAAQ;AACrB,aAAa,SAAS;AACtB;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,EAAE;AACf,aAAa,QAAQ;AACrB,aAAa,QAAQ;AACrB,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,EAAE;AACf,aAAa,QAAQ;AACrB,aAAa,SAAS;AACtB;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,EAAE;AACf,aAAa,QAAQ;AACrB,aAAa,QAAQ;AACrB,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,EAAE;AACf,aAAa,OAAO;AACpB,aAAa,QAAQ;AACrB,aAAa,QAAQ;AACrB,aAAa,QAAQ;AACrB,aAAa,QAAQ;AACrB,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,QAAQ;AACrB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,QAAQ;AACrB,aAAa,QAAQ;AACrB,aAAa,QAAQ;AACrB,aAAa,QAAQ;AACrB,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,MAAM;AACnB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,SAAS;AACtB,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;;ACvWa;;AAEb,OAAO,SAAS,GAAG,mBAAO,CAAC,sBAAQ;;AAEnC;AACA;AACA;AACA,WAAW,cAAc;AACzB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,UAAU;AACrB,WAAW,OAAO;AAClB,YAAY,cAAc;AAC1B;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA;;AAEA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;;ACpJa;;AAEb;AACA,sBAAsB,mBAAO,CAAC,wIAAgB;;AAE9C;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY,QAAQ;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC7Ba;;AAEb,qBAAqB,mBAAO,CAAC,sBAAQ;AACrC,OAAO,aAAa,GAAG,mBAAO,CAAC,sBAAQ;AACvC,OAAO,6BAA6B,GAAG,mBAAO,CAAC,kBAAM;;AAErD,0BAA0B,mBAAO,CAAC,yEAAsB;AACxD,kBAAkB,mBAAO,CAAC,uDAAa;AACvC,OAAO,gBAAgB,GAAG,mBAAO,CAAC,uDAAa;AAC/C,OAAO,OAAO,GAAG,mBAAO,CAAC,uDAAa;;AAEtC,iCAAiC,GAAG;AACpC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB;AACA,aAAa,QAAQ;AACrB;AACA,aAAa,SAAS;AACtB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,QAAQ;AACrB,aAAa,OAAO;AACpB,aAAa,iBAAiB;AAC9B;AACA,aAAa,OAAO;AACpB,aAAa,YAAY;AACzB,aAAa,SAAS;AACtB,aAAa,SAAS;AACtB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,qBAAqB;AACnC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,SAAS;AACtB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,aAAa,qBAAqB;AAClC,cAAc,QAAQ;AACtB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,aAAa,qBAAqB;AAClC,aAAa,WAAW;AACxB,aAAa,OAAO;AACpB,aAAa,SAAS;AACtB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,kDAAkD;AAC3E;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,SAAS;AACT;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,qBAAqB;AAClC,aAAa,WAAW;AACxB,aAAa,OAAO;AACpB,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,+BAA+B,OAAO;AACtC;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA,gDAAgD,SAAS;AACzD;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP,gDAAgD,MAAM;AACtD;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,WAAW,aAAa;AACxB,WAAW,0BAA0B;AACrC,YAAY,SAAS;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,aAAa;AACxB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,WAAW;AACtB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,kBAAkB,KAAK,GAAG,mBAAmB;AAC7C;AACA,yBAAyB,EAAE,IAAI,WAAW;AAC1C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;;;;;;ACrZa;;AAEb,qBAAqB,mBAAO,CAAC,sBAAQ;AACrC,cAAc,mBAAO,CAAC,oBAAO;AAC7B,aAAa,mBAAO,CAAC,kBAAM;AAC3B,YAAY,mBAAO,CAAC,gBAAK;AACzB,YAAY,mBAAO,CAAC,gBAAK;AACzB,OAAO,0BAA0B,GAAG,mBAAO,CAAC,sBAAQ;AACpD,OAAO,MAAM,GAAG,mBAAO,CAAC,gBAAK;;AAE7B,0BAA0B,mBAAO,CAAC,yEAAsB;AACxD,iBAAiB,mBAAO,CAAC,qDAAY;AACrC,eAAe,mBAAO,CAAC,iDAAU;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,GAAG,mBAAO,CAAC,uDAAa;AACzB,OAAO,wCAAwC,GAAG,mBAAO,CAAC,6DAAgB;AAC1E,OAAO,gBAAgB,GAAG,mBAAO,CAAC,uDAAa;AAC/C,OAAO,WAAW,GAAG,mBAAO,CAAC,2DAAe;;AAE5C;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,iBAAiB;AAC9B,aAAa,kBAAkB;AAC/B,aAAa,OAAO;AACpB;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,YAAY;AACZ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,YAAY;AACZ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,WAAW;AACxB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,EAAE;AACf,aAAa,QAAQ;AACrB,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,EAAE;AACf,aAAa,QAAQ;AACrB,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,EAAE;AACf,aAAa,OAAO;AACpB,aAAa,QAAQ;AACrB;AACA,aAAa,QAAQ;AACrB,aAAa,QAAQ;AACrB,aAAa,QAAQ;AACrB,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA,kDAAkD,OAAO;AACzD;AACA;AACA;AACA,gBAAgB,qBAAqB;AACrC;AACA;AACA;AACA;AACA,qBAAqB,sBAAsB;AAC3C;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA;AACA,eAAe,SAAS;AACxB;AACA;AACA;AACA;AACA,qBAAqB,sBAAsB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,CAAC;;AAED;AACA;;AAEA;;AAEA;AACA;AACA;AACA,WAAW,UAAU;AACrB,WAAW,iBAAiB;AAC5B,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,iBAAiB;AAC5B;AACA,WAAW,OAAO;AAClB;AACA,WAAW,OAAO;AAClB;AACA,WAAW,OAAO;AAClB;AACA,WAAW,OAAO;AAClB,WAAW,QAAQ;AACnB,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,uCAAuC,qBAAqB;AAC5D,gCAAgC,4BAA4B;AAC5D;AACA;;AAEA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;;AAEA;AACA,oCAAoC,cAAc;AAClD;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,mEAAmE;AACnE;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,mBAAmB,mBAAmB,GAAG,mBAAmB;AAC5D;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA,KAAK;AACL;AACA;AACA;AACA,uCAAuC,eAAe;AACtD;AACA;AACA,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY,WAAW;AACvB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY,cAAc;AAC1B;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,WAAW,UAAU;AACrB,WAAW,gCAAgC;AAC3C;AACA,WAAW,OAAO;AAClB;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,UAAU;AACrB,WAAW,EAAE;AACb,WAAW,SAAS;AACpB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,2CAA2C,qBAAqB;AAChE,YAAY,kCAAkC;AAC9C;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,mBAAmB;AAC9B;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,qCAAqC;AAChD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC34BA,mEAA6B;AAC7B,yEAAiC;AACjC,0FAA2B;AAC3B,kGAA4C;AAE5C,iFAAiC;AACjC,qGAA0C;AAQ1C,MAAM,YAAY,GAAW,qBAAqB,CAAC;AACnD,MAAM,UAAU,GAAW,aAAa,CAAC;AACzC,IAAI,iBAAoC,CAAC;AAEzC,SAAgB,QAAQ,CAAC,OAAgC;IAErD,MAAM,WAAW,GAAG,cAAc,CAAC,OAAO,CAAC,CAAC;IAC5C,IAAI,WAAW,IAAI,MAAM,CAAC,GAAG,CAAC,SAAS,KAAK,qBAAqB,EAAE;QAC/D,kCAAkC;QAClC,iBAAiB,GAAG,IAAI,mBAAiB,CAAC,WAAW,CAAC,IAAI,EAAE,WAAW,CAAC,OAAO,EAAE,WAAW,CAAC,KAAK,CAAC,CAAC;KACvG;SAAM;QACH,wCAAwC;QACxC,iBAAiB,GAAG,IAAI,sBAAsB,EAAE,CAAC;KACpD;IACD,OAAO,CAAC,aAAa,CAAC,IAAI,CAAC,iBAAiB,CAAC,CAAC;IAE9C,OAAO,CAAC,aAAa,CAAC,IAAI,CAAC,MAAM,CAAC,QAAQ,CAAC,eAAe,CAAC,4BAA4B,EAAE,KAAK,IAAI,EAAE;QAChG,MAAM,CAAC,OAAO,CAAC,CAAC;IACpB,CAAC,CAAC,CAAC,CAAC;IAEJ,OAAO,CAAC,aAAa,CAAC,IAAI,CAAC,MAAM,CAAC,QAAQ,CAAC,eAAe,CAAC,4BAA4B,EAAE,KAAK,IAAI,EAAE;QAChG,MAAM,CAAC,OAAO,EAAE,gBAAgB,CAAC,KAAK,EAAE,UAAU,CAAC,CAAC;IACxD,CAAC,CAAC,CAAC,CAAC;IAEJ,MAAM,CAAC,KAAK,CAAC,kCAAkC,CAAC,YAAY,EAAE;QAC1D,0BAA0B,CAAC,MAA0C,EAAE,KAAgC;YACnG,OAAO,OAAO,CAAC,OAAO,CAAC,CAAC;oBACpB,IAAI,EAAE,YAAY;oBAClB,IAAI,EAAE,iCAAiC;oBACvC,OAAO,EAAE,QAAQ;oBACjB,GAAG,EAAE,uBAAuB;iBAC/B,CAAC,CAAC,CAAC;QACR,CAAC;QAED,yBAAyB,CAAC,MAA0C,EAAE,MAAiC,EAAE,KAAgC;YACrI,IAAI,MAAM,IAAI,MAAM,CAAC,IAAI,KAAK,YAAY,EAAE;gBACxC,MAAM,SAAS,GAAW,KAAK,CAAC,gBAAgB,CAAC,MAAM,EAAE,MAAM,CAAC,CAAC;gBACjE,IAAI,MAAM,CAAC,OAAO,IAAI,MAAM,CAAC,OAAO,CAAC,aAAa,CAAC,QAAQ,EAAE,IAAI,EAAE,EAAE,WAAW,EAAE,MAAM,EAAE,CAAC,KAAK,CAAC,EAAE;oBAC/F,MAAM,CAAC,OAAO,EAAE,gBAAgB,CAAC,IAAI,EAAE,SAAS,CAAC,CAAC;oBAClD,iBAAiB,CAAC,kBAAkB,CAAC,uBAAuB,CAAC,CAAC;iBACjE;qBAAM,IAAI,MAAM,CAAC,OAAO,IAAI,MAAM,CAAC,OAAO,CAAC,aAAa,CAAC,QAAQ,EAAE,IAAI,EAAE,EAAE,WAAW,EAAE,MAAM,EAAE,CAAC,KAAK,CAAC,EAAE;oBACtG,MAAM,CAAC,OAAO,EAAE,SAAS,EAAE,MAAM,CAAC,UAAU,CAAC,CAAC;oBAC9C,iBAAiB,CAAC,kBAAkB,CAAC,uBAAuB,CAAC,CAAC;iBACjE;aACJ;iBAAM;gBACH,MAAM,CAAC,MAAM,CAAC,gBAAgB,CAAC,uCAAuC,CAAC,CAAC;gBACxE,iBAAiB,CAAC,kBAAkB,CAAC,+BAA+B,CAAC,CAAC;aACzE;YACD,OAAO;QACX,CAAC;KACJ,CAAC,CAAC;AACP,CAAC;AA/CD,4BA+CC;AAED,KAAK,UAAU,MAAM,CAAC,OAAgC,EAAE,SAAkB,EAAE,0BAAmC;IAC3G,MAAM,SAAS,GAAG,CAAC,CAAC,CAAC,SAAS,IAAI,0BAA0B,CAAC,CAAC;IAC9D,MAAM,cAAc,GAAG,EAAE,SAAS,EAAE,GAAG,SAAS,EAAE,EAAE,CAAC;IACrD,iBAAiB,CAAC,kBAAkB,CAAC,QAAQ,EAAE,cAAc,CAAC,CAAC;IAE/D,MAAM,EAAE,QAAQ,EAAE,IAAI,EAAE,GAAG,WAAW,EAAE,CAAC;IACzC,MAAM,QAAQ,GAAG,MAAM,KAAK,CAAC,UAAU,CAAC,QAAQ,EAAE,IAAI,CAAC,CAAC;IACxD,IAAI,QAAQ,EAAE;QACV,MAAM,QAAQ,GAAG,MAAM,CAAC,SAAS,CAAC,gBAAgB,CAAC,4BAA4B,CAAC,CAAC;QACjF,MAAM,YAAY,GAAG,QAAQ,CAAC,GAAG,CAAC,YAAY,CAAW,IAAI,0BAA0B,IAAI,KAAK,CAAC,eAAe,EAAE,CAAC;QAEnH,IAAI,CAAC,YAAY,IAAI,CAAC,KAAK,CAAC,UAAU,CAAC,YAAY,CAAC,EAAE;YAClD,MAAM,CAAC,MAAM,CAAC,gBAAgB,CAAC,oLAAoL,CAAC,CAAC;YACrN,iBAAiB,CAAC,kBAAkB,CAAC,+BAA+B,EAAE,cAAc,CAAC,CAAC;YACtF,OAAO;SACV;QAED,KAAK,CAAC,iBAAiB,CAAC,YAAY,EAAE,IAAI,EAAE,UAAU,CAAC,CAAC;KAC3D;IAED,MAAM,MAAM,GAAG,IAAI,CAAC,KAAK,CAAC,MAAM,KAAK,CAAC,MAAM,CAAC,UAAU,QAAQ,IAAI,IAAI,aAAa,SAAS,EAAE,CAAC,CAAC,CAAC;IAElG,IAAI,CAAC,MAAM,IAAI,CAAC,MAAM,CAAC,oBAAoB,IAAI,MAAM,CAAC,oBAAoB,KAAK,EAAE,EAAE;QAC/E,MAAM,CAAC,MAAM,CAAC,gBAAgB,CAAC,4CAA4C,SAAS,IAAI,CAAC,CAAC;QAC1F,iBAAiB,CAAC,kBAAkB,CAAC,4BAA4B,EAAE,cAAc,CAAC,CAAC;QACnF,MAAM,CAAC,OAAO,EAAE,SAAS,EAAE,UAAU,CAAC,CAAC;KAC1C;SAAM;QACH,aAAa,CAAC,YAAY,CAAC,OAAO,EAAE,MAAM,CAAC,oBAAoB,CAAC,CAAC;KACpE;AACL,CAAC;AAED,KAAK,UAAU,MAAM,CAAC,OAAgC,EAAE,SAAkB,EAAE,SAAiB;IACzF,MAAM,cAAc,GAAG,EAAE,SAAS,EAAE,GAAG,SAAS,EAAE,EAAE,CAAC;IACrD,iBAAiB,CAAC,kBAAkB,CAAC,QAAQ,EAAE,cAAc,CAAC,CAAC;IAE/D,MAAM,EAAE,QAAQ,EAAE,IAAI,EAAE,GAAG,WAAW,EAAE,CAAC;IACzC,MAAM,aAAa,GAAG,MAAM,gBAAgB,CAAC,QAAQ,EAAE,IAAI,CAAC,CAAC;IAC7D,IAAI,KAAK,CAAC,OAAO,CAAC,aAAa,CAAC,EAAE;QAC9B,iBAAiB,CAAC,kBAAkB,CAAC,aAAa,EAAE,cAAc,EAAE,EAAE,WAAW,EAAE,aAAa,CAAC,MAAM,EAAE,CAAC,CAAC;QAE3G,IAAI,aAAa,CAAC,MAAM,KAAK,CAAC,EAAE;YAC5B,MAAM,CAAC,MAAM,CAAC,gBAAgB,CAAC,gHAAgH,CAAC,CAAC;YACjJ,OAAO;SACV;QAED,MAAM,KAAK,GAAoB,EAAE,CAAC;QAElC,aAAa,CAAC,OAAO,CAAC,CAAC,CAAC,EAAE;YACtB,CAAC,GAAG,KAAK,CAAC,YAAY,CAAC,QAAQ,EAAE,IAAI,EAAE,CAAC,CAAC,CAAC;YAC1C,KAAK,CAAC,IAAI,CAAC;gBACP,KAAK,EAAE,CAAC,CAAC,KAAK;gBACd,WAAW,EAAE,CAAC,CAAC,GAAG;gBAClB,MAAM,EAAE,CAAC,CAAC,oBAAoB;aACjC,CAAC,CAAC;QACP,CAAC,CAAC,CAAC;QAEH,IAAI,kBAAkB,GAAG,EAAE,CAAC;QAC5B,IAAI,OAAO,SAAS,KAAK,QAAQ,IAAI,SAAS,CAAC,MAAM,GAAG,CAAC,IAAI,SAAS,KAAK,UAAU,EAAE;YACnF,MAAM,OAAO,GAAG,KAAK,CAAC,MAAM,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,WAAW,IAAI,SAAS,CAAC,aAAa,CAAC,CAAC,CAAC,WAAW,EAAE,IAAI,EAAE,EAAE,WAAW,EAAE,MAAM,EAAE,CAAC,KAAK,CAAC,CAAC,CAAC;YAChI,IAAI,OAAO,IAAI,OAAO,CAAC,MAAM,GAAG,CAAC,EAAG;gBAChC,kBAAkB,GAAG,OAAO,CAAC,CAAC,CAAC,CAAC,MAAM,IAAI,EAAE,CAAC;aAChD;iBAAM;gBACH,MAAM,CAAC,MAAM,CAAC,gBAAgB,CAAC,sBAAsB,SAAS,GAAG,CAAC,CAAC;aACtE;SACJ;QAED,IAAI,kBAAkB,IAAI,kBAAkB,CAAC,MAAM,GAAG,CAAC,EAAE;YACrD,aAAa,CAAC,YAAY,CAAC,OAAO,EAAE,kBAA4B,CAAC,CAAC;SACrE;aAAM;YACH,MAAM,CAAC,MAAM,CAAC,aAAa,CAAC,KAAK,CAAC,CAAC,IAAI,CAAC,CAAC,SAAS,EAAE,EAAE;gBAClD,IAAI,SAAS,EAAE;oBACX,aAAa,CAAC,YAAY,CAAC,OAAO,EAAE,SAAS,CAAC,MAAgB,CAAC,CAAC;iBACnE;YACL,CAAC,CAAC,CAAC;SACN;KACJ;SAAM;QACH,iBAAiB,CAAC,kBAAkB,CAAC,4BAA4B,EAAE,cAAc,CAAC,CAAC;KACtF;AACL,CAAC;AAED,SAAS,WAAW;IAChB,MAAM,QAAQ,GAAG,MAAM,CAAC,SAAS,CAAC,gBAAgB,CAAC,4BAA4B,CAAC,CAAC;IACjF,MAAM,QAAQ,GAAG,QAAQ,CAAC,GAAG,CAAC,UAAU,CAAW,IAAI,WAAW,CAAC;IACnE,MAAM,IAAI,GAAG,QAAQ,CAAC,GAAG,CAAC,MAAM,CAAW,IAAI,IAAI,CAAC;IAEpD,OAAO,EAAE,QAAQ,EAAE,IAAI,EAAE,CAAC;AAC9B,CAAC;AAED,SAAS,cAAc,CAAC,OAAgC;IACpD,IAAI,sBAAW,EAAE;QACb,OAAO;YACH,IAAI,EAAE,sBAAW,CAAC,IAAI;YACtB,OAAO,EAAE,sBAAW,CAAC,OAAO;YAC5B,KAAK,EAAE,sBAAW,CAAC,KAAK;SAC3B,CAAC;KACL;IACD,OAAO,SAAgC,CAAC;AAC5C,CAAC;AAED,KAAK,UAAU,gBAAgB,CAAC,QAAgB,EAAE,IAAY,EAAE,WAAoB,KAAK;IACrF,MAAM,sBAAsB,GAAG,CAAC,GAAW,EAAE,EAAE;QAC3C,OAAO,KAAK,CAAC,MAAM,CAAC,GAAG,EAAE,EAAE,OAAO,EAAE,EAAE,IAAI,EAAE,WAAW,EAAE,EAAE,CAAC,CAAC;IACjE,CAAC,CAAC;IAEF,MAAM,QAAQ,GAAG,CAAC,QAAQ,CAAC,CAAC,CAAC,OAAO,CAAC,CAAC,CAAC,MAAM,CAAC,CAAC;IAE/C,IAAI,YAAY,GAAG,EAAE,CAAC;IACtB,KAAK,MAAM,QAAQ,IAAI,CAAC,YAAY,EAAE,OAAO,CAAC,EAAE;QAC5C,IAAI;YACA,YAAY,GAAG,MAAM,sBAAsB,CAAC,GAAG,QAAQ,MAAM,QAAQ,IAAI,IAAI,GAAG,QAAQ,EAAE,CAAC,CAAC;YAC5F,IAAI,YAAY,EAAE;gBACd,MAAM;aACT;SACJ;QAAC,WAAM;YACJ,aAAa;SAChB;KACJ;IAED,IAAI,MAAa,CAAC;IAClB,IAAI;QACA,MAAM,GAAG,IAAI,CAAC,KAAK,CAAC,YAAY,CAAC,CAAC;KACrC;IAAC,WAAM;QACJ,MAAM,GAAG,EAAE,CAAC;KACf;IACD,OAAO,MAAM,CAAC;AAClB,CAAC;AAED,MAAM,aAAa;IA+Bf,YAAoB,KAA0B,EAAE,OAAgC,EAAE,SAAiB;QAzB3F,YAAO,GAA0B,SAAS,CAAC;QAC3C,iBAAY,GAAY,KAAK,CAAC;QAC9B,cAAS,GAAU,EAAE,CAAC;QACtB,iBAAY,GAAwB,EAAE,CAAC;QAuB3C,IAAI,CAAC,MAAM,GAAG,KAAK,CAAC;QACpB,IAAI,CAAC,QAAQ,GAAG,OAAO,CAAC;QACxB,IAAI,CAAC,cAAc,GAAG,OAAO,CAAC,aAAa,CAAC;QAC5C,IAAI,CAAC,UAAU,GAAG,SAAS,CAAC;QAE5B,IAAI,CAAC,OAAO,EAAE,CAAC;QAEf,iBAAiB;QACjB,IAAI,CAAC,MAAM,CAAC,YAAY,CAAC,GAAG,EAAE;YAC1B,IAAI,CAAC,OAAO,EAAE,CAAC;QACnB,CAAC,EAAE,SAAS,EAAE,IAAI,CAAC,YAAY,CAAC,CAAC;QAEjC,qBAAqB;QACrB,IAAI,CAAC,MAAM,CAAC,oBAAoB,CAAC,CAAC,CAAC,EAAE;YACjC,IAAI,IAAI,CAAC,MAAM,CAAC,OAAO,EAAE;gBACrB,IAAI,CAAC,OAAO,EAAE,CAAC;aAClB;QACL,CAAC,EAAE,SAAS,EAAE,IAAI,CAAC,YAAY,CAAC,CAAC;QAEjC,mCAAmC;QACnC,IAAI,CAAC,MAAM,CAAC,OAAO,CAAC,mBAAmB,CAAC,OAAO,CAAC,EAAE;YAC9C,IAAI,CAAC,qBAAqB,CAAC,OAAO,CAAC,CAAC;QACxC,CAAC,EAAE,SAAS,EAAE,IAAI,CAAC,YAAY,CAAC,CAAC;IACrC,CAAC;IA5CM,MAAM,CAAC,YAAY,CAAC,OAAgC,EAAE,SAAiB;QAC1E,MAAM,MAAM,GAAG,MAAM,CAAC,UAAU,CAAC,MAAM,CAAC;QAExC,IAAI,aAAa,CAAC,YAAY,EAAE;YAC5B,aAAa,CAAC,YAAY,CAAC,MAAM,CAAC,MAAM,CAAC,MAAM,CAAC,CAAC;SACpD;aAAM;YACH,MAAM,KAAK,GAAG,MAAM,CAAC,MAAM,CAAC,kBAAkB,CAAC,qBAAqB,EAAE,UAAU,EAAE,MAAM,EAAE;gBACtF,aAAa,EAAE,IAAI;gBACnB,iBAAiB,EAAE,IAAI;gBACvB,uBAAuB,EAAE,IAAI;aAChC,CAAC,CAAC;YAEH,aAAa,CAAC,YAAY,GAAG,IAAI,aAAa,CAAC,KAAK,EAAE,OAAO,EAAE,SAAS,CAAC,CAAC;SAC7E;IACL,CAAC;IAEM,MAAM,CAAC,MAAM,CAAC,KAA0B,EAAE,OAAgC,EAAE,SAAiB;QAChG,aAAa,CAAC,YAAY,GAAG,IAAI,aAAa,CAAC,KAAK,EAAE,OAAO,EAAE,SAAS,CAAC,CAAC;IAC9E,CAAC;IA4BM,OAAO;QACV,aAAa,CAAC,YAAY,GAAG,SAAS,CAAC;QAEvC,IAAI,CAAC,MAAM,CAAC,OAAO,EAAE,CAAC;QACtB,IAAI,CAAC,cAAc,EAAE,CAAC;QAEtB,OAAO,IAAI,CAAC,YAAY,CAAC,MAAM,EAAE;YAC7B,MAAM,CAAC,GAAG,IAAI,CAAC,YAAY,CAAC,GAAG,EAAE,CAAC;YAClC,IAAI,CAAC,EAAE;gBACH,CAAC,CAAC,OAAO,EAAE,CAAC;aACf;SACJ;IACL,CAAC;IAEO,cAAc;QAClB,IAAI,IAAI,CAAC,OAAO,EAAE;YACd,yDAAyD;YACzD,iBAAiB,CAAC,kBAAkB,CAAC,mBAAmB,CAAC,CAAC;YAC1D,MAAM,CAAC,GAAG,IAAI,CAAC,OAAc,CAAC;YAC9B,CAAC,CAAC,MAAM,GAAG,SAAS,CAAC;YACrB,CAAC,CAAC,SAAS,GAAG,SAAS,CAAC;YACxB,CAAC,CAAC,OAAO,GAAG,SAAS,CAAC;YACtB,CAAC,CAAC,OAAO,GAAG,SAAS,CAAC;YACtB,IAAI,CAAC,OAAO,CAAC,KAAK,EAAE,CAAC;YACrB,IAAI,CAAC,OAAO,GAAG,SAAS,CAAC;SAC5B;IACL,CAAC;IAEO,qBAAqB,CAAC,OAAe;QACzC,IAAI,OAAO,KAAK,OAAO,EAAE;YACrB,IAAI,IAAI,CAAC,OAAO,EAAE;gBACd,iBAAiB,CAAC,kBAAkB,CAAC,qBAAqB,CAAC,CAAC;aAC/D;YACD,IAAI,CAAC,cAAc,EAAE,CAAC;SACzB;aAAM,IAAI,OAAO,CAAC,MAAM,CAAC,CAAC,EAAE,EAAE,CAAC,KAAK,YAAY,EAAE;YAC/C,OAAO,IAAI,CAAC,qBAAqB,CAAC,OAAO,CAAC,MAAM,CAAC,EAAE,CAAC,CAAC,CAAC;SACzD;aAAM,IAAI,OAAO,CAAC,MAAM,CAAC,CAAC,EAAE,CAAC,CAAC,KAAK,WAAW,EAAE;YAC7C,OAAO,IAAI,CAAC,iBAAiB,EAAE,CAAC;SACnC;aAAM,IAAI,OAAO,CAAC,MAAM,CAAC,CAAC,EAAE,CAAC,CAAC,KAAK,WAAW,EAAE;YAC7C,OAAO,IAAI,CAAC,iBAAiB,CAAC,OAAO,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC;SACpD;aAAM,IAAI,OAAO,CAAC,MAAM,CAAC,CAAC,EAAE,CAAC,CAAC,KAAK,SAAS,EAAE;YAC3C,OAAO,IAAI,CAAC,eAAe,CAAC,OAAO,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC;SAClD;aAAM,IAAI,OAAO,CAAC,MAAM,CAAC,CAAC,EAAE,CAAC,CAAC,KAAK,WAAW,EAAE;YAC7C,OAAO,IAAI,CAAC,SAAS,CAAC,OAAO,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC;SAC5C;QAED,IAAI,CAAC,IAAI,CAAC,OAAO,EAAE;YACf,2DAA2D;YAC3D,IAAI,CAAC,gBAAgB,EAAE,CAAC;SAC3B;aAAM,IAAI,CAAC,IAAI,CAAC,YAAY,EAAE;YAC3B,4FAA4F;YAC5F,IAAI,CAAC,SAAS,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC;SAChC;aAAM;YACH,+CAA+C;YAC/C,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC;SAC9B;IACL,CAAC;IAEO,gBAAgB;QACpB,MAAM,GAAG,GAAG,IAAI,CAAC,UAAU,CAAC;QAE5B,uBAAuB;QACvB,IAAI,CAAC,OAAO,GAAG,IAAI,YAAS,CAAC,GAAG,CAAC,CAAC;QAClC,IAAI,CAAC,OAAO,CAAC,MAAM,GAAG,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;QAC9C,IAAI,CAAC,OAAO,CAAC,SAAS,GAAG,IAAI,CAAC,UAAU,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;QACpD,IAAI,CAAC,OAAO,CAAC,OAAO,GAAG,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;QAChD,IAAI,CAAC,OAAO,CAAC,OAAO,GAAG,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;IACpD,CAAC;IAEO,OAAO;QACX,IAAI,CAAC,YAAY,GAAG,IAAI,CAAC;QACzB,uDAAuD;QACvD,iBAAiB,CAAC,kBAAkB,CAAC,gBAAgB,CAAC,CAAC;QACvD,IAAI,CAAC,MAAM,CAAC,OAAO,CAAC,WAAW,CAAC,MAAM,CAAC,CAAC;QAExC,IAAI,IAAI,CAAC,OAAO,EAAE;YACd,sDAAsD;YACtD,KAAK,MAAM,OAAO,IAAI,IAAI,CAAC,SAAS,EAAE;gBAClC,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC;aAC9B;YACD,IAAI,CAAC,SAAS,GAAG,EAAE,CAAC;SACvB;IACL,CAAC;IAEO,UAAU,CAAC,OAAY;QAC3B,IAAI,IAAI,CAAC,YAAY,EAAE;YACnB,wCAAwC;YACxC,IAAI,CAAC,MAAM,CAAC,OAAO,CAAC,WAAW,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC;SACjD;IACL,CAAC;IAEO,QAAQ;QACZ,IAAI,IAAI,CAAC,YAAY,EAAE;YACnB,sDAAsD;YACtD,iBAAiB,CAAC,kBAAkB,CAAC,iBAAiB,CAAC,CAAC;YACxD,IAAI,CAAC,MAAM,CAAC,OAAO,CAAC,WAAW,CAAC,OAAO,CAAC,CAAC;SAC5C;IACL,CAAC;IAEO,QAAQ;QACZ,IAAI,IAAI,CAAC,YAAY,EAAE;YACnB,uDAAuD;YACvD,iBAAiB,CAAC,kBAAkB,CAAC,iBAAiB,CAAC,CAAC;YACxD,IAAI,CAAC,MAAM,CAAC,OAAO,CAAC,WAAW,CAAC,OAAO,CAAC,CAAC;SAC5C;QACD,IAAI,CAAC,YAAY,GAAG,KAAK,CAAC;IAC9B,CAAC;IAEO,qBAAqB,CAAC,OAAe;QACzC,MAAM,SAAS,GAAG,IAAI,CAAC,KAAK,CAAC,OAAO,CAAC,CAAC;QACtC,iBAAiB,CAAC,kBAAkB,CAAC,SAAS,CAAC,IAAI,EAAE,SAAS,CAAC,UAAU,EAAE,SAAS,CAAC,OAAO,CAAC,CAAC;IAClG,CAAC;IAEO,iBAAiB;QACrB,MAAM,WAAW,GAAG,sBAAsB,CAAC;QAC3C,MAAM,QAAQ,GAAQ,IAAI,CAAC,QAAQ,CAAC,cAAc,CAAC,GAAG,CAAC,WAAW,CAAC;YAC/D;gBACI,OAAO,EAAE,QAAQ;gBACjB,iBAAiB,EAAE,KAAK;aAC3B,CAAC;QACN,IAAI,CAAC,MAAM,CAAC,OAAO,CAAC,WAAW,CAAC,eAAe,IAAI,CAAC,SAAS,CAAC,QAAQ,CAAC,EAAE,CAAC,CAAC;IAC/E,CAAC;IAEO,iBAAiB,CAAC,OAAe;QACrC,qDAAqD;QACrD,MAAM,IAAI,GAAG,IAAI,CAAC,KAAK,CAAC,OAAO,CAAoC,CAAC;QAEpE,MAAM,WAAW,GAAG,sBAAsB,CAAC;QAC3C,MAAM,QAAQ,GAAQ,IAAI,CAAC,QAAQ,CAAC,cAAc,CAAC,GAAG,CAAC,WAAW,CAAC,IAAI,EAAE,CAAC;QAC1E,QAAQ,CAAC,IAAI,CAAC,IAAI,CAAC,GAAG,IAAI,CAAC,KAAK,CAAC;QACjC,IAAI,CAAC,QAAQ,CAAC,cAAc,CAAC,MAAM,CAAC,WAAW,EAAE,QAAQ,CAAC,CAAC;IAC/D,CAAC;IAEO,KAAK,CAAC,eAAe,CAAC,OAAe;QACzC,kDAAkD;QAClD,MAAM,OAAO,GAAG,IAAI,CAAC,KAAK,CAAC,OAAO,CAAgC,CAAC;QAEnE,IAAI,OAAO,GAAG,EAAE,CAAC;QACjB,IAAI;YACA,OAAO,GAAG,MAAM,KAAK,CAAC,MAAM,CAAC,OAAO,CAAC,GAAG,CAAC,CAAC;SAC7C;QAAC,OAAO,EAAE,EAAE;YACT,OAAO,GAAG,EAAE,CAAC;SAChB;QAED,IAAI,CAAC,MAAM,CAAC,OAAO,CAAC,WAAW,CAAC,UAAU,IAAI,CAAC,SAAS,CAAC,EAAE,EAAE,EAAE,OAAO,CAAC,EAAE,EAAE,OAAO,EAAE,CAAC,EAAE,CAAC,CAAC;IAC7F,CAAC;IAEO,KAAK,CAAC,SAAS,CAAC,OAAe;QACnC,kDAAkD;QAClD,MAAM,OAAO,GAAG,IAAI,CAAC,KAAK,CAAC,OAAO,CAAqB,CAAC;QACxD,MAAM,CAAC,GAAG,CAAC,SAAS,CAAC,SAAS,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC;IACjD,CAAC;IAEO,OAAO;QACX,IAAI,CAAC,MAAM,CAAC,OAAO,CAAC,IAAI,GAAG,IAAI,CAAC,kBAAkB,EAAE,CAAC;IACzD,CAAC;IAEO,kBAAkB;QACtB,MAAM,QAAQ,GAAG,MAAM,CAAC,GAAG,CAAC,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,cAAc,EAAE,qBAAqB,EAAE,gBAAgB,CAAC,CAAC,CAAC;QAC1G,MAAM,OAAO,GAAG,QAAQ,CAAC,IAAI,CAAC,EAAE,MAAM,EAAE,iBAAiB,EAAE,CAAC,CAAC;QAE7D,MAAM,UAAU,GAAG,MAAM,CAAC,GAAG,CAAC,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,cAAc,EAAE,KAAK,EAAE,MAAM,EAAE,qBAAqB,CAAC,CAAC,CAAC;QACzG,MAAM,SAAS,GAAG,UAAU,CAAC,IAAI,CAAC,EAAE,MAAM,EAAE,iBAAiB,EAAE,CAAC,CAAC;QAEjE,MAAM,UAAU,GAAG,MAAM,CAAC,GAAG,CAAC,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,cAAc,EAAE,KAAK,EAAE,QAAQ,EAAE,YAAY,CAAC,CAAC,CAAC;QAClG,MAAM,SAAS,GAAG,UAAU,CAAC,IAAI,CAAC,EAAE,MAAM,EAAE,iBAAiB,EAAE,CAAC,CAAC;QAEjE,OAAO;;;;;;;;;;8BAUe,SAAS;+BACR,SAAS;;;yDAGiB,OAAO;;;aAGnD,CAAC;IACV,CAAC;CACJ;AAED,MAAM,sBAAuB,SAAQ,mBAAiB;IAClD;QACI,KAAK,CAAC,aAAa,EAAE,kBAAkB,EAAE,KAAK,CAAC,CAAC;IACpD,CAAC;IAEM,kBAAkB,CAAC,IAAY,EAAE,UAAgB,EAAE,YAAkB;QACxE,OAAO,CAAC,GAAG,CAAC,GAAG,IAAI,KAAK,IAAI,CAAC,SAAS,CAAC,UAAU,CAAC,KAAK,IAAI,CAAC,SAAS,CAAC,UAAU,CAAC,EAAE,CAAC,CAAC;IACzF,CAAC;IAEM,OAAO;QACV,OAAO,OAAO,CAAC,OAAO,EAAE,CAAC;IAC7B,CAAC;CACJ;;;;;;;;;;;;;ACncD;;4DAE4D;AAC5D,sCAAsC;AAEzB;;;;;;;;;AAEb,OAAO,CAAC,GAAG,CAAC,4CAA4C,CAAC,GAAG,MAAM,CAAC;AAEnE,kJAAmD;AACnD,6DAAyB;AACzB,6DAAyB;AACzB,mEAA6B;AAC7B,yEAAiC;AAEjC,MAAqB,iBAAkB,SAAQ,MAAM,CAAC,UAAU;IAU5D,YAAoB,WAAmB,EAAU,gBAAwB,EAAE,GAAW;QAClF,KAAK,CAAC,GAAG,EAAE,CAAC,IAAI,CAAC,SAAS,CAAC,OAAO,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC,IAAI,CAAC,CAAC,OAAO,EAAE,CAAC,CAAC,CAAC;QAD7C,gBAAW,GAAX,WAAW,CAAQ;QAAU,qBAAgB,GAAhB,gBAAgB,CAAQ;QARjE,cAAS,GAAY,KAAK,CAAC;QAC3B,cAAS,GAAwB,EAAE,CAAC;QASxC,IAAI,WAAW,GAAG,OAAO,CAAC,GAAG,CAAC,aAAa,CAAC,IAAI,EAAE,CAAC;QACnD,IAAI,WAAW,IAAI,WAAW,IAAI,OAAO,CAAC,GAAG,CAAC,kBAAkB,CAAC,KAAK,OAAO,EAAE;YAC3E,WAAW,GAAG,IAAI,CAAC,IAAI,CAAC,WAAW,EAAE,GAAG,WAAW,MAAM,CAAC,CAAC;YAC3D,IAAI,CAAC,SAAS,GAAG,EAAE,CAAC,iBAAiB,CAAC,WAAW,EAAE,EAAE,KAAK,EAAE,GAAG,EAAE,QAAQ,EAAE,MAAM,EAAE,SAAS,EAAE,IAAI,EAAE,CAAC,CAAC;SACzG;QACD,IAAI,CAAC,eAAe,CAAC,GAAG,CAAC,CAAC;QAC1B,IAAI,CAAC,SAAS,CAAC,IAAI,CAAC,MAAM,CAAC,SAAS,CAAC,wBAAwB,CAAC,GAAG,EAAE,CAAC,IAAI,CAAC,eAAe,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC;IACpG,CAAC;IAEO,eAAe,CAAC,GAAW;QAC/B,MAAM,MAAM,GAAG,MAAM,CAAC,SAAS,CAAC,gBAAgB,CAAC,iBAAiB,CAAC,mBAAmB,CAAC,CAAC;QACxF,IAAI,IAAI,CAAC,SAAS,KAAK,MAAM,CAAC,GAAG,CAAU,iBAAiB,CAAC,2BAA2B,EAAE,IAAI,CAAC,EAAE;YAC7F,IAAI,CAAC,SAAS,GAAG,MAAM,CAAC,GAAG,CAAU,iBAAiB,CAAC,2BAA2B,EAAE,IAAI,CAAC,CAAC;YAC1F,IAAI,IAAI,CAAC,SAAS,EAAE;gBAChB,IAAI,CAAC,uBAAuB,CAAC,GAAG,CAAC,CAAC;aACrC;iBAAM;gBACH,IAAI,CAAC,OAAO,EAAE,CAAC;aAClB;SACJ;IACL,CAAC;IAEO,uBAAuB,CAAC,GAAW;QACvC,mDAAmD;QACnD,IAAI,WAAW,CAAC,aAAa,EAAE;YAC3B,IAAI,CAAC,iBAAiB,GAAG,IAAI,WAAW,CAAC,eAAe,CAAC,GAAG,CAAC,CAAC;YAC9D,sCAAsC;YACtC,IAAI,CAAC,iBAAiB,CAAC,OAAO,CAAC,sBAAsB,CAAC,IAAI,CAAC,CAAC;SAC/D;aAAM;YACH,WAAW,CAAC,KAAK,CAAC,GAAG,CAAC;iBACjB,sBAAsB,CAAC,KAAK,CAAC;iBAC7B,yBAAyB,CAAC,KAAK,CAAC;iBAChC,wBAAwB,CAAC,KAAK,CAAC;iBAC/B,0BAA0B,CAAC,KAAK,CAAC;iBACjC,4BAA4B,CAAC,KAAK,CAAC;iBACnC,qBAAqB,CAAC,KAAK,CAAC;iBAC5B,sBAAsB,CAAC,IAAI,CAAC;iBAC5B,KAAK,EAAE,CAAC;YACb,IAAI,CAAC,iBAAiB,GAAG,WAAW,CAAC,aAAa,CAAC;SACtD;QAED,IAAI,CAAC,iBAAiB,CAAC,gBAAgB,GAAG,IAAI,CAAC,mBAAmB,EAAE,CAAC;QAErE,iGAAiG;QACjG,IAAI,MAAM,IAAI,MAAM,CAAC,GAAG,EAAE;YACtB,IAAI,CAAC,iBAAiB,CAAC,OAAO,CAAC,IAAI,CAAC,IAAI,CAAC,iBAAiB,CAAC,OAAO,CAAC,IAAI,CAAC,MAAM,CAAC,GAAG,MAAM,CAAC,GAAG,CAAC,SAAS,CAAC;YACvG,IAAI,CAAC,iBAAiB,CAAC,OAAO,CAAC,IAAI,CAAC,IAAI,CAAC,iBAAiB,CAAC,OAAO,CAAC,IAAI,CAAC,SAAS,CAAC,GAAG,MAAM,CAAC,GAAG,CAAC,SAAS,CAAC;SAC7G;QAED,qDAAqD;QACrD,IAAI,GAAG,IAAI,GAAG,CAAC,OAAO,CAAC,MAAM,CAAC,KAAK,CAAC,EAAE;YAClC,IAAI,CAAC,iBAAiB,CAAC,MAAM,CAAC,WAAW,GAAG,8CAA8C,CAAC;SAC9F;IACL,CAAC;IAED,qGAAqG;IACrG,kHAAkH;IAClH,iHAAiH;IACjH,oHAAoH;IACpH,iKAAiK;IACjK,kHAAkH;IAClH,gHAAgH;IACxG,mBAAmB;QACvB,2CAA2C;QAC3C,MAAM,gBAAgB,GAAG,MAAM,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC;QAC7C,gBAAgB,CAAC,WAAW,CAAC,GAAG,EAAE,CAAC,QAAQ,EAAE,CAAC;QAC9C,gBAAgB,CAAC,wBAAwB,CAAC,GAAG,CAAC,EAAE,CAAC,OAAO,EAAE,IAAI,EAAE,CAAC,CAAC,OAAO,CAAC,4BAA4B,EAAE,QAAQ,CAAC,CAAC;QAClH,gBAAgB,CAAC,gBAAgB,CAAC,GAAG,IAAI,CAAC,WAAW,CAAC;QACtD,gBAAgB,CAAC,mBAAmB,CAAC,GAAG,IAAI,CAAC,gBAAgB,CAAC;QAC9D,IAAI,MAAM,IAAI,MAAM,CAAC,GAAG,EAAE;YACtB,gBAAgB,CAAC,wBAAwB,CAAC,GAAG,MAAM,CAAC,GAAG,CAAC,SAAS,CAAC;YAClE,gBAAgB,CAAC,wBAAwB,CAAC,GAAG,MAAM,CAAC,GAAG,CAAC,SAAS,CAAC;YAClE,gBAAgB,CAAC,sBAAsB,CAAC,GAAG,MAAM,CAAC,OAAO,CAAC;SAC7D;QACD,OAAO,gBAAgB,CAAC;IAC5B,CAAC;IAEM,kBAAkB,CAAC,SAAiB,EAAE,UAAsC,EAAE,YAAwC;QACzH,IAAI,IAAI,CAAC,SAAS,IAAI,SAAS,IAAI,IAAI,CAAC,iBAAiB,EAAE;YACvD,IAAI,CAAC,iBAAiB,CAAC,UAAU,CAAC;gBAC9B,IAAI,EAAE,GAAG,IAAI,CAAC,WAAW,IAAI,SAAS,EAAE;gBACxC,UAAU,EAAE,UAAU;gBACtB,YAAY,EAAE,YAAY;aAC7B,CAAC,CAAC;YAEH,IAAI,IAAI,CAAC,SAAS,EAAE;gBAChB,IAAI,CAAC,SAAS,CAAC,KAAK,CAAC,aAAa,SAAS,IAAI,IAAI,CAAC,SAAS,CAAC,EAAE,UAAU,EAAE,YAAY,EAAE,CAAC,IAAI,CAAC,CAAC;aACpG;SACJ;IACL,CAAC;IAEM,OAAO;QACV,MAAM,mBAAmB,GAAG,IAAI,OAAO,CAAM,OAAO,CAAC,EAAE;YACnD,IAAI,CAAC,IAAI,CAAC,SAAS,EAAE;gBACjB,OAAO,OAAO,CAAC,KAAK,CAAC,CAAC,CAAC;aAC1B;YACD,IAAI,CAAC,SAAS,CAAC,EAAE,CAAC,QAAQ,EAAE,OAAO,CAAC,CAAC;YACrC,IAAI,CAAC,SAAS,CAAC,GAAG,EAAE,CAAC;QACzB,CAAC,CAAC,CAAC;QAEH,MAAM,eAAe,GAAG,IAAI,OAAO,CAAM,OAAO,CAAC,EAAE;YAC/C,IAAI,IAAI,CAAC,iBAAiB,EAAE;gBACxB,IAAI,CAAC,iBAAiB,CAAC,KAAK,CAAC;oBACzB,QAAQ,EAAE,GAAG,EAAE;wBACX,mBAAmB;wBACnB,IAAI,CAAC,iBAAiB,GAAG,SAAS,CAAC;wBACnC,OAAO,CAAC,KAAK,CAAC,CAAC,CAAC;oBACpB,CAAC;iBACJ,CAAC,CAAC;aACN;iBAAM;gBACH,OAAO,CAAC,KAAK,CAAC,CAAC,CAAC;aACnB;QACL,CAAC,CAAC,CAAC;QACH,OAAO,OAAO,CAAC,GAAG,CAAC,CAAC,eAAe,EAAE,mBAAmB,CAAC,CAAC,CAAC;IAC/D,CAAC;;AA7HL,oCA8HC;AAzHkB,qCAAmB,GAAG,WAAW,CAAC;AAClC,6CAA2B,GAAG,iBAAiB,CAAC;;;;;;;;;;;;;;;;;;;;;;ACrBnE,mFAAoC;AACpC,6DAAyB;AACzB,mEAA6B;AAC7B,sEAA+B;AAC/B,gEAA2B;AAC3B,6DAAyB;AACzB,mEAA6B;AAC7B,gEAA2B;AAG3B,SAAgB,MAAM,CAAC,IAAY,EAAE,UAAgC,EAAE;IACnE,OAAO,IAAI,OAAO,CAAC,CAAC,OAAO,EAAE,MAAM,EAAE,EAAE;QACnC,MAAM,SAAS,GAAG,GAAG,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC;QAClC,MAAM,GAAG,GAAG,SAAS,CAAC,QAAQ,KAAK,QAAQ,CAAC,CAAC,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC,CAAC,IAAI,CAAC,GAAG,CAAC;QACnE,OAAO,GAAG,8BACN,kBAAkB,EAAE,KAAK,IACtB,SAAS,GACT,OAAO,CACb,CAAC;QAEF,GAAG,CAAC,OAAO,EAAE,CAAC,QAAQ,EAAE,EAAE;YACtB,IAAI,YAAY,GAAG,EAAE,CAAC;YACtB,QAAQ,CAAC,EAAE,CAAC,MAAM,EAAE,KAAK,CAAC,EAAE;gBACxB,YAAY,IAAI,KAAK,CAAC,QAAQ,EAAE,CAAC;YACrC,CAAC,CAAC,CAAC;YACH,QAAQ,CAAC,EAAE,CAAC,KAAK,EAAE,GAAG,EAAE;gBACpB,+DAA+D;gBAC/D,IAAI,QAAQ,CAAC,UAAU,KAAK,GAAG,EAAE;oBAC7B,OAAO,CAAC,YAAY,CAAC,CAAC;iBACzB;qBAAM;oBACH,MAAM,CAAC,IAAI,KAAK,CAAC,YAAY,CAAC,IAAI,EAAE,CAAC,CAAC,CAAC;iBAC1C;YACL,CAAC,CAAC,CAAC;QACP,CAAC,CAAC,CAAC,EAAE,CAAC,OAAO,EAAE,CAAC,CAAC,EAAE;YACf,MAAM,CAAC,CAAC,CAAC,CAAC;QACd,CAAC,CAAC,CAAC;IACP,CAAC,CAAC,CAAC;AACP,CAAC;AA3BD,wBA2BC;AAED,SAAgB,YAAY,CAAC,aAAqB,EAAE,UAAkB,EAAE,MAAW;IAC/E,IAAI,MAAM,CAAC,oBAAoB,EAAE;QAC7B,MAAM,YAAY,GAAG,MAAM,CAAC,oBAAoB,CAAC,KAAK,CAAC,mBAAmB,CAAC,CAAC;QAC5E,IAAI,YAAY,EAAE;YACd,MAAM,cAAc,GAAG,GAAG,aAAa,IAAI,UAAU,EAAE,CAAC;YACxD,MAAM,CAAC,oBAAoB,GAAG,MAAM,CAAC,oBAAoB,CAAC,OAAO,CAAC,YAAY,CAAC,CAAC,CAAC,EAAE,cAAc,CAAC,CAAC;SACtG;KACJ;IACD,OAAO,MAAM,CAAC;AAClB,CAAC;AATD,oCASC;AAOD,SAAgB,WAAW;IACvB,MAAM,QAAQ,GAAG,EAAE,CAAC,QAAQ,EAAE,CAAC;IAC/B,OAAO,QAAQ,KAAK,QAAQ,CAAC,CAAC,aAAc,CAAC;QACzC,QAAQ,KAAK,OAAO,CAAC,CAAC,iBAAkB,CAAC;yBACvB,CAAC;AAC3B,CAAC;AALD,kCAKC;AAED,SAAgB,UAAU,CAAC,IAAY;IACnC,IAAI;QACA,EAAE,CAAC,QAAQ,CAAC,IAAI,CAAC,CAAC;QAClB,OAAO,IAAI,CAAC;KACf;IAAC,OAAO,CAAC,EAAE;QACR,OAAO,KAAK,CAAC;KAChB;AACL,CAAC;AAPD,gCAOC;AAED,SAAgB,iBAAiB,CAAC,UAAkB,EAAE,UAAkB,EAAE,SAAiB;IACvF,MAAM,UAAU,GAAG;QACf,sBAAsB;QACtB,2BAA2B,UAAU,EAAE;KAC1C,CAAC;IAEF,MAAM,UAAU,GAAG,EAAE,CAAC,KAAK,CAAC,UAAU,EAAE,UAAU,EAAE;QAChD,KAAK,EAAE,QAAQ;QACf,QAAQ,EAAE,IAAI;KACjB,CAAC,CAAC;IAEH,UAAU,CAAC,KAAK,EAAE,CAAC;AACvB,CAAC;AAZD,8CAYC;AAEM,KAAK,UAAU,UAAU,CAAC,IAAY,EAAE,IAAY;IACvD,OAAO,IAAI,OAAO,CAAU,CAAC,OAAO,EAAE,EAAE;QACpC,MAAM,MAAM,GAAG,GAAG,CAAC,YAAY,EAAE,CAAC;QAElC,MAAM,CAAC,EAAE,CAAC,OAAO,EAAE,GAAG,EAAE,CAAC,OAAO,CAAC,KAAK,CAAC,CAAC,CAAC;QACzC,MAAM,CAAC,MAAM,CAAC,IAAI,EAAE,IAAI,CAAC,CAAC;QAE1B,MAAM,CAAC,EAAE,CAAC,WAAW,EAAE,GAAG,EAAE;YACxB,MAAM,CAAC,KAAK,EAAE,CAAC;YACf,MAAM,CAAC,KAAK,EAAE,CAAC;QACnB,CAAC,CAAC,CAAC;QAEH,MAAM,CAAC,EAAE,CAAC,OAAO,EAAE,GAAG,EAAE,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC,CAAC;IAC5C,CAAC,CAAC,CAAC;AACP,CAAC;AAdD,gCAcC;AAED,MAAM,WAAW,GAAG,OAAO,CAAC,GAAG,CAAC,YAAY,IAAI,GAAG,CAAC;AACpD,MAAM,mBAAmB,GAAG;IACxB,KAAK,EAAE,wBAAwB;IAC/B,GAAG,EAAE,8DAA8D;IACnE,GAAG,EAAE,4DAA4D;IACjE,gBAAgB,EAAE,IAAI,CAAC,IAAI,CAAC,WAAW,EAAE,yCAAyC,CAAC;IACnF,MAAM,EAAE,kEAAkE;CAC7E,CAAC;AAEF,SAAgB,eAAe;IAC3B,MAAM,QAAQ,GAAG,WAAW,EAAE,CAAC;IAC/B,IAAI,QAAQ,gBAAiB,EAAE;QAC3B,OAAO,UAAU,CAAC,mBAAmB,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,mBAAmB,CAAC,GAAG,CAAC,CAAC,CAAC,EAAE,CAAC;KAC7E;SAAM,IAAI,QAAQ,oBAAqB,EAAE;QACtC,IAAI,UAAU,CAAC,mBAAmB,CAAC,MAAM,CAAC,EAAE;YACxC,OAAO,mBAAmB,CAAC,MAAM,CAAC;SACrC;aAAM,IAAI,UAAU,CAAC,mBAAmB,CAAC,GAAG,CAAC,EAAE;YAC5C,OAAO,mBAAmB,CAAC,GAAG,CAAC;SAClC;aAAM,IAAI,UAAU,CAAC,mBAAmB,CAAC,gBAAgB,CAAC,EAAE;YACzD,OAAO,mBAAmB,CAAC,gBAAgB,CAAC;SAC/C;aAAM;YACH,OAAO,EAAE,CAAC;SACb;KACJ;SAAM;QACH,OAAO,UAAU,CAAC,mBAAmB,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,mBAAmB,CAAC,KAAK,CAAC,CAAC,CAAC,EAAE,CAAC;KACjF;AACL,CAAC;AAjBD,0CAiBC;AAED,SAAgB,aAAa,CAAC,OAAe,EAAE,SAAmB;IAC9D,IAAI,SAAS,EAAE;QACX,OAAO,GAAG,IAAI,CAAC,SAAS,CAAC,OAAO,CAAC,CAAC;QAClC,OAAO,GAAG,mBAAmB,CAAC,OAAO,CAAC,CAAC;KAC1C;IAED,OAAO,GAAG,CAAC,OAAO,CAAC,UAAU,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,SAAS,CAAC,CAAC,CAAC,UAAU,CAAC,GAAI,OAAO,CAAC;IACxE,OAAO,SAAS,CAAC,OAAO,CAAC,CAAC;AAC9B,CAAC;AARD,sCAQC;AAED,SAAgB,mBAAmB,CAAC,IAAY;IAC5C,OAAO,IAAI;SACN,OAAO,CAAC,OAAO,EAAE,GAAG,CAAC,CAAC,mDAAmD;SACzE,OAAO,CAAC,KAAK,EAAE,GAAG,CAAC,CAAC;AAC7B,CAAC;AAJD,kDAIC;AAED,SAAgB,gBAAgB,CAAC,MAA0C,EAAE,MAAiC;IAC1G,IAAI,YAAY,GAAG,EAAE,CAAC;IAEtB,IAAI,MAAM,CAAC,IAAI,IAAI,MAAM,EAAE;QACvB,YAAY,GAAG,MAAM,CAAC,IAAI,CAAC;QAC3B,YAAY,GAAG,YAAY,CAAC,OAAO,CAAC,oBAAoB,EAAE,MAAM,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC;QAC3E,YAAY,GAAG,aAAa,CAAC,YAAY,CAAC,CAAC;KAC9C;SAAM,IAAI,MAAM,CAAC,GAAG,EAAE;QACnB,YAAY,GAAG,MAAM,CAAC,GAAG,CAAC;KAC7B;IAED,OAAO,YAAY,CAAC;AACxB,CAAC;AAZD,4CAYC;;;;;;;;;;;;AC7JD,mC;;;;;;;;;;;ACAA,wC;;;;;;;;;;;ACAA,0C;;;;;;;;;;;ACAA,oC;;;;;;;;;;;ACAA,sC;;;;;;;;;;;ACAA,mC;;;;;;;;;;;ACAA,gC;;;;;;;;;;;ACAA,mC;;;;;;;;;;;ACAA,+B;;;;;;;;;;;ACAA,iC;;;;;;;;;;;ACAA,kC;;;;;;;;;;;ACAA,mC;;;;;;;;;;;ACAA,gC;;;;;;;;;;;ACAA,+B;;;;;;;;;;;ACAA,iC;;;;;;;;;;;ACAA,mC;;;;;;;;;;;ACAA,mC;;;;;;;;;;;ACAA,gC;;;;;;;;;;;ACAA,gC;;;;;;;;;;;ACAA,iC;;;;;;;;;;;ACAA,mC;;;;;;;;;;;ACAA,iC","file":"extension.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./src/extension.ts\");\n","\"use strict\";\r\nvar DiagChannel = require(\"./diagnostic-channel/initialization\");\r\nvar AutoCollectConsole = (function () {\r\n    function AutoCollectConsole(client) {\r\n        if (!!AutoCollectConsole.INSTANCE) {\r\n            throw new Error(\"Console logging adapter tracking should be configured from the applicationInsights object\");\r\n        }\r\n        this._client = client;\r\n        AutoCollectConsole.INSTANCE = this;\r\n    }\r\n    AutoCollectConsole.prototype.enable = function (isEnabled, collectConsoleLog) {\r\n        if (DiagChannel.IsInitialized) {\r\n            require(\"./diagnostic-channel/console.sub\").enable(isEnabled && collectConsoleLog, this._client);\r\n            require(\"./diagnostic-channel/bunyan.sub\").enable(isEnabled, this._client);\r\n            require(\"./diagnostic-channel/winston.sub\").enable(isEnabled, this._client);\r\n        }\r\n    };\r\n    AutoCollectConsole.prototype.isInitialized = function () {\r\n        return this._isInitialized;\r\n    };\r\n    AutoCollectConsole.prototype.dispose = function () {\r\n        AutoCollectConsole.INSTANCE = null;\r\n        this.enable(false, false);\r\n    };\r\n    AutoCollectConsole._methodNames = [\"debug\", \"info\", \"log\", \"warn\", \"error\"];\r\n    return AutoCollectConsole;\r\n}());\r\nmodule.exports = AutoCollectConsole;\r\n//# sourceMappingURL=Console.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar Logging = require(\"../Library/Logging\");\r\nvar DiagChannel = require(\"./diagnostic-channel/initialization\");\r\nvar CorrelationContextManager = (function () {\r\n    function CorrelationContextManager() {\r\n    }\r\n    /**\r\n     *  Provides the current Context.\r\n     *  The context is the most recent one entered into for the current\r\n     *  logical chain of execution, including across asynchronous calls.\r\n     */\r\n    CorrelationContextManager.getCurrentContext = function () {\r\n        if (!CorrelationContextManager.enabled) {\r\n            return null;\r\n        }\r\n        var context = CorrelationContextManager.session.get(CorrelationContextManager.CONTEXT_NAME);\r\n        if (context === undefined) {\r\n            return null;\r\n        }\r\n        return context;\r\n    };\r\n    /**\r\n     *  A helper to generate objects conforming to the CorrelationContext interface\r\n     */\r\n    CorrelationContextManager.generateContextObject = function (operationId, parentId, operationName, correlationContextHeader, traceparent, tracestate) {\r\n        parentId = parentId || operationId;\r\n        if (this.enabled) {\r\n            return {\r\n                operation: {\r\n                    name: operationName,\r\n                    id: operationId,\r\n                    parentId: parentId,\r\n                    traceparent: traceparent,\r\n                    tracestate: tracestate\r\n                },\r\n                customProperties: new CustomPropertiesImpl(correlationContextHeader)\r\n            };\r\n        }\r\n        return null;\r\n    };\r\n    /**\r\n     *  Runs a function inside a given Context.\r\n     *  All logical children of the execution path that entered this Context\r\n     *  will receive this Context object on calls to GetCurrentContext.\r\n     */\r\n    CorrelationContextManager.runWithContext = function (context, fn) {\r\n        if (CorrelationContextManager.enabled) {\r\n            return CorrelationContextManager.session.bind(fn, (_a = {}, _a[CorrelationContextManager.CONTEXT_NAME] = context, _a))();\r\n        }\r\n        else {\r\n            return fn();\r\n        }\r\n        var _a;\r\n    };\r\n    /**\r\n     * Wrapper for cls-hooked bindEmitter method\r\n     */\r\n    CorrelationContextManager.wrapEmitter = function (emitter) {\r\n        if (CorrelationContextManager.enabled) {\r\n            CorrelationContextManager.session.bindEmitter(emitter);\r\n        }\r\n    };\r\n    /**\r\n     *  Patches a callback to restore the correct Context when getCurrentContext\r\n     *  is run within it. This is necessary if automatic correlation fails to work\r\n     *  with user-included libraries.\r\n     *\r\n     *  The supplied callback will be given the same context that was present for\r\n     *  the call to wrapCallback.  */\r\n    CorrelationContextManager.wrapCallback = function (fn) {\r\n        if (CorrelationContextManager.enabled) {\r\n            return CorrelationContextManager.session.bind(fn);\r\n        }\r\n        return fn;\r\n    };\r\n    /**\r\n     *  Enables the CorrelationContextManager.\r\n     */\r\n    CorrelationContextManager.enable = function (forceClsHooked) {\r\n        if (this.enabled) {\r\n            return;\r\n        }\r\n        if (!this.isNodeVersionCompatible()) {\r\n            this.enabled = false;\r\n            return;\r\n        }\r\n        if (!CorrelationContextManager.hasEverEnabled) {\r\n            this.forceClsHooked = forceClsHooked;\r\n            this.hasEverEnabled = true;\r\n            if (typeof this.cls === \"undefined\") {\r\n                if ((CorrelationContextManager.forceClsHooked === true) || (CorrelationContextManager.forceClsHooked === undefined && CorrelationContextManager.shouldUseClsHooked())) {\r\n                    this.cls = require('cls-hooked');\r\n                }\r\n                else {\r\n                    this.cls = require('continuation-local-storage');\r\n                }\r\n            }\r\n            CorrelationContextManager.session = this.cls.createNamespace(\"AI-CLS-Session\");\r\n            DiagChannel.registerContextPreservation(function (cb) {\r\n                return CorrelationContextManager.session.bind(cb);\r\n            });\r\n        }\r\n        this.enabled = true;\r\n    };\r\n    /**\r\n     *  Disables the CorrelationContextManager.\r\n     */\r\n    CorrelationContextManager.disable = function () {\r\n        this.enabled = false;\r\n    };\r\n    /**\r\n     * Reset the namespace\r\n     */\r\n    CorrelationContextManager.reset = function () {\r\n        if (CorrelationContextManager.hasEverEnabled) {\r\n            CorrelationContextManager.session = null;\r\n            CorrelationContextManager.session = this.cls.createNamespace('AI-CLS-Session');\r\n        }\r\n    };\r\n    /**\r\n     *  Reports if CorrelationContextManager is able to run in this environment\r\n     */\r\n    CorrelationContextManager.isNodeVersionCompatible = function () {\r\n        var nodeVer = process.versions.node.split(\".\");\r\n        return parseInt(nodeVer[0]) > 3 || (parseInt(nodeVer[0]) > 2 && parseInt(nodeVer[1]) > 2);\r\n    };\r\n    /**\r\n     * We only want to use cls-hooked when it uses async_hooks api (8.2+), else\r\n     * use async-listener (plain -cls)\r\n     */\r\n    CorrelationContextManager.shouldUseClsHooked = function () {\r\n        var nodeVer = process.versions.node.split(\".\");\r\n        return (parseInt(nodeVer[0]) > 8) || (parseInt(nodeVer[0]) >= 8 && parseInt(nodeVer[1]) >= 2);\r\n    };\r\n    /**\r\n     * A TypeError is triggered by cls-hooked for node [8.0, 8.2)\r\n     * @internal Used in tests only\r\n     */\r\n    CorrelationContextManager.canUseClsHooked = function () {\r\n        var nodeVer = process.versions.node.split(\".\");\r\n        var greater800 = (parseInt(nodeVer[0]) > 8) || (parseInt(nodeVer[0]) >= 8 && parseInt(nodeVer[1]) >= 0);\r\n        var less820 = (parseInt(nodeVer[0]) < 8) || (parseInt(nodeVer[0]) <= 8 && parseInt(nodeVer[1]) < 2);\r\n        var greater470 = parseInt(nodeVer[0]) > 4 || (parseInt(nodeVer[0]) >= 4 && parseInt(nodeVer[1]) >= 7); // cls-hooked requires node 4.7+\r\n        return !(greater800 && less820) && greater470;\r\n    };\r\n    CorrelationContextManager.enabled = false;\r\n    CorrelationContextManager.hasEverEnabled = false;\r\n    CorrelationContextManager.forceClsHooked = undefined; // true: use cls-hooked, false: use cls, undefined: choose based on node version\r\n    CorrelationContextManager.CONTEXT_NAME = \"ApplicationInsights-Context\";\r\n    return CorrelationContextManager;\r\n}());\r\nexports.CorrelationContextManager = CorrelationContextManager;\r\nvar CustomPropertiesImpl = (function () {\r\n    function CustomPropertiesImpl(header) {\r\n        this.props = [];\r\n        this.addHeaderData(header);\r\n    }\r\n    CustomPropertiesImpl.prototype.addHeaderData = function (header) {\r\n        var keyvals = header ? header.split(\", \") : [];\r\n        this.props = keyvals.map(function (keyval) {\r\n            var parts = keyval.split(\"=\");\r\n            return { key: parts[0], value: parts[1] };\r\n        }).concat(this.props);\r\n    };\r\n    CustomPropertiesImpl.prototype.serializeToHeader = function () {\r\n        return this.props.map(function (keyval) {\r\n            return keyval.key + \"=\" + keyval.value;\r\n        }).join(\", \");\r\n    };\r\n    CustomPropertiesImpl.prototype.getProperty = function (prop) {\r\n        for (var i = 0; i < this.props.length; ++i) {\r\n            var keyval = this.props[i];\r\n            if (keyval.key === prop) {\r\n                return keyval.value;\r\n            }\r\n        }\r\n        return;\r\n    };\r\n    // TODO: Strictly according to the spec, properties which are recieved from\r\n    // an incoming request should be left untouched, while we may add our own new\r\n    // properties. The logic here will need to change to track that.\r\n    CustomPropertiesImpl.prototype.setProperty = function (prop, val) {\r\n        if (CustomPropertiesImpl.bannedCharacters.test(prop) || CustomPropertiesImpl.bannedCharacters.test(val)) {\r\n            Logging.warn(\"Correlation context property keys and values must not contain ',' or '='. setProperty was called with key: \" + prop + \" and value: \" + val);\r\n            return;\r\n        }\r\n        for (var i = 0; i < this.props.length; ++i) {\r\n            var keyval = this.props[i];\r\n            if (keyval.key === prop) {\r\n                keyval.value = val;\r\n                return;\r\n            }\r\n        }\r\n        this.props.push({ key: prop, value: val });\r\n    };\r\n    CustomPropertiesImpl.bannedCharacters = /[,=]/;\r\n    return CustomPropertiesImpl;\r\n}());\r\n//# sourceMappingURL=CorrelationContextManager.js.map","\"use strict\";\r\nvar AutoCollectExceptions = (function () {\r\n    function AutoCollectExceptions(client) {\r\n        if (!!AutoCollectExceptions.INSTANCE) {\r\n            throw new Error(\"Exception tracking should be configured from the applicationInsights object\");\r\n        }\r\n        AutoCollectExceptions.INSTANCE = this;\r\n        this._client = client;\r\n    }\r\n    Object.defineProperty(AutoCollectExceptions, \"UNCAUGHT_EXCEPTION_HANDLER_NAME\", {\r\n        get: function () { return \"uncaughtException\"; },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(AutoCollectExceptions, \"UNHANDLED_REJECTION_HANDLER_NAME\", {\r\n        get: function () { return \"unhandledRejection\"; },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    AutoCollectExceptions.prototype.isInitialized = function () {\r\n        return this._isInitialized;\r\n    };\r\n    AutoCollectExceptions.prototype.enable = function (isEnabled) {\r\n        var _this = this;\r\n        if (isEnabled) {\r\n            this._isInitialized = true;\r\n            var self = this;\r\n            if (!this._exceptionListenerHandle) {\r\n                // For scenarios like Promise.reject(), an error won't be passed to the handle. Create a placeholder\r\n                // error for these scenarios.\r\n                var handle = function (reThrow, error) {\r\n                    if (error === void 0) { error = new Error(AutoCollectExceptions._FALLBACK_ERROR_MESSAGE); }\r\n                    _this._client.trackException({ exception: error });\r\n                    _this._client.flush({ isAppCrashing: true });\r\n                    if (reThrow) {\r\n                        var THIS_IS_APPLICATION_INSIGHTS_RETHROWING_YOUR_EXCEPTION = error;\r\n                        throw THIS_IS_APPLICATION_INSIGHTS_RETHROWING_YOUR_EXCEPTION; // Error originated somewhere else in your app\r\n                    }\r\n                };\r\n                this._exceptionListenerHandle = handle.bind(this, true);\r\n                this._rejectionListenerHandle = handle.bind(this, false);\r\n                process.on(AutoCollectExceptions.UNCAUGHT_EXCEPTION_HANDLER_NAME, this._exceptionListenerHandle);\r\n                process.on(AutoCollectExceptions.UNHANDLED_REJECTION_HANDLER_NAME, this._rejectionListenerHandle);\r\n            }\r\n        }\r\n        else {\r\n            if (this._exceptionListenerHandle) {\r\n                process.removeListener(AutoCollectExceptions.UNCAUGHT_EXCEPTION_HANDLER_NAME, this._exceptionListenerHandle);\r\n                process.removeListener(AutoCollectExceptions.UNHANDLED_REJECTION_HANDLER_NAME, this._rejectionListenerHandle);\r\n                this._exceptionListenerHandle = undefined;\r\n                this._rejectionListenerHandle = undefined;\r\n                delete this._exceptionListenerHandle;\r\n                delete this._rejectionListenerHandle;\r\n            }\r\n        }\r\n    };\r\n    AutoCollectExceptions.prototype.dispose = function () {\r\n        AutoCollectExceptions.INSTANCE = null;\r\n        this.enable(false);\r\n        this._isInitialized = false;\r\n    };\r\n    AutoCollectExceptions.INSTANCE = null;\r\n    AutoCollectExceptions._FALLBACK_ERROR_MESSAGE = \"A promise was rejected without providing an error. Application Insights generated this error stack for you.\";\r\n    return AutoCollectExceptions;\r\n}());\r\nmodule.exports = AutoCollectExceptions;\r\n//# sourceMappingURL=Exceptions.js.map","\"use strict\";\r\nvar http = require(\"http\");\r\nvar https = require(\"https\");\r\nvar Logging = require(\"../Library/Logging\");\r\nvar Util = require(\"../Library/Util\");\r\nvar RequestResponseHeaders = require(\"../Library/RequestResponseHeaders\");\r\nvar HttpDependencyParser = require(\"./HttpDependencyParser\");\r\nvar CorrelationContextManager_1 = require(\"./CorrelationContextManager\");\r\nvar CorrelationIdManager = require(\"../Library/CorrelationIdManager\");\r\nvar Traceparent = require(\"../Library/Traceparent\");\r\nvar DiagChannel = require(\"./diagnostic-channel/initialization\");\r\nvar AutoCollectHttpDependencies = (function () {\r\n    function AutoCollectHttpDependencies(client) {\r\n        if (!!AutoCollectHttpDependencies.INSTANCE) {\r\n            throw new Error(\"Client request tracking should be configured from the applicationInsights object\");\r\n        }\r\n        AutoCollectHttpDependencies.INSTANCE = this;\r\n        this._client = client;\r\n    }\r\n    AutoCollectHttpDependencies.prototype.enable = function (isEnabled) {\r\n        this._isEnabled = isEnabled;\r\n        if (this._isEnabled && !this._isInitialized) {\r\n            this._initialize();\r\n        }\r\n        if (DiagChannel.IsInitialized) {\r\n            require(\"./diagnostic-channel/mongodb.sub\").enable(isEnabled, this._client);\r\n            require(\"./diagnostic-channel/mysql.sub\").enable(isEnabled, this._client);\r\n            require(\"./diagnostic-channel/redis.sub\").enable(isEnabled, this._client);\r\n            require(\"./diagnostic-channel/postgres.sub\").enable(isEnabled, this._client);\r\n        }\r\n    };\r\n    AutoCollectHttpDependencies.prototype.isInitialized = function () {\r\n        return this._isInitialized;\r\n    };\r\n    AutoCollectHttpDependencies.prototype._initialize = function () {\r\n        var _this = this;\r\n        this._isInitialized = true;\r\n        var originalGet = http.get;\r\n        var originalRequest = http.request;\r\n        var originalHttpsRequest = https.request;\r\n        var clientRequestPatch = function (request, options) {\r\n            var shouldCollect = !options[AutoCollectHttpDependencies.disableCollectionRequestOption] &&\r\n                !request[AutoCollectHttpDependencies.alreadyAutoCollectedFlag];\r\n            request[AutoCollectHttpDependencies.alreadyAutoCollectedFlag] = true;\r\n            if (request && options && shouldCollect) {\r\n                CorrelationContextManager_1.CorrelationContextManager.wrapEmitter(request);\r\n                AutoCollectHttpDependencies.trackRequest(_this._client, { options: options, request: request });\r\n            }\r\n        };\r\n        // On node >= v0.11.12 and < 9.0 (excluding 8.9.0) https.request just calls http.request (with additional options).\r\n        // On node < 0.11.12, 8.9.0, and 9.0 > https.request is handled separately\r\n        // Patch both and leave a flag to not double-count on versions that just call through\r\n        // We add the flag to both http and https to protect against strange double collection in other scenarios\r\n        http.request = function (options) {\r\n            var requestArgs = [];\r\n            for (var _i = 1; _i < arguments.length; _i++) {\r\n                requestArgs[_i - 1] = arguments[_i];\r\n            }\r\n            var request = originalRequest.call.apply(originalRequest, [http, options].concat(requestArgs));\r\n            clientRequestPatch(request, options);\r\n            return request;\r\n        };\r\n        https.request = function (options) {\r\n            var requestArgs = [];\r\n            for (var _i = 1; _i < arguments.length; _i++) {\r\n                requestArgs[_i - 1] = arguments[_i];\r\n            }\r\n            var request = originalHttpsRequest.call.apply(originalHttpsRequest, [https, options].concat(requestArgs));\r\n            clientRequestPatch(request, options);\r\n            return request;\r\n        };\r\n        // Node 8 calls http.request from http.get using a local reference!\r\n        // We have to patch .get manually in this case and can't just assume request is enough\r\n        // We have to replace the entire method in this case. We can't call the original.\r\n        // This is because calling the original will give us no chance to set headers as it internally does .end().\r\n        http.get = function (options) {\r\n            var requestArgs = [];\r\n            for (var _i = 1; _i < arguments.length; _i++) {\r\n                requestArgs[_i - 1] = arguments[_i];\r\n            }\r\n            var request = (_a = http.request).call.apply(_a, [http, options].concat(requestArgs));\r\n            request.end();\r\n            return request;\r\n            var _a;\r\n        };\r\n        https.get = function (options) {\r\n            var requestArgs = [];\r\n            for (var _i = 1; _i < arguments.length; _i++) {\r\n                requestArgs[_i - 1] = arguments[_i];\r\n            }\r\n            var request = (_a = https.request).call.apply(_a, [https, options].concat(requestArgs));\r\n            request.end();\r\n            return request;\r\n            var _a;\r\n        };\r\n    };\r\n    /**\r\n     * Tracks an outgoing request. Because it may set headers this method must be called before\r\n     * writing content to or ending the request.\r\n     */\r\n    AutoCollectHttpDependencies.trackRequest = function (client, telemetry) {\r\n        if (!telemetry.options || !telemetry.request || !client) {\r\n            Logging.info(\"AutoCollectHttpDependencies.trackRequest was called with invalid parameters: \", !telemetry.options, !telemetry.request, !client);\r\n            return;\r\n        }\r\n        var requestParser = new HttpDependencyParser(telemetry.options, telemetry.request);\r\n        var currentContext = CorrelationContextManager_1.CorrelationContextManager.getCurrentContext();\r\n        var uniqueRequestId;\r\n        var uniqueTraceparent;\r\n        if (currentContext && currentContext.operation && currentContext.operation.traceparent && Traceparent.isValidTraceId(currentContext.operation.traceparent.traceId)) {\r\n            currentContext.operation.traceparent.updateSpanId();\r\n            uniqueRequestId = currentContext.operation.traceparent.getBackCompatRequestId();\r\n        }\r\n        else if (CorrelationIdManager.w3cEnabled) {\r\n            // Start an operation now so that we can include the w3c headers in the outgoing request\r\n            var traceparent = new Traceparent();\r\n            uniqueTraceparent = traceparent.toString();\r\n            uniqueRequestId = traceparent.getBackCompatRequestId();\r\n        }\r\n        else {\r\n            uniqueRequestId = currentContext && currentContext.operation && (currentContext.operation.parentId + AutoCollectHttpDependencies.requestNumber++ + '.');\r\n        }\r\n        // Add the source correlationId to the request headers, if a value was not already provided.\r\n        // The getHeader/setHeader methods aren't available on very old Node versions, and\r\n        // are not included in the v0.10 type declarations currently used. So check if the\r\n        // methods exist before invoking them.\r\n        if (Util.canIncludeCorrelationHeader(client, requestParser.getUrl()) && telemetry.request.getHeader && telemetry.request.setHeader) {\r\n            if (client.config && client.config.correlationId) {\r\n                // getHeader returns \"any\" type in newer versions of node. In basic scenarios, this will be <string | string[] | number>, but could be modified to anything else via middleware\r\n                var correlationHeader = telemetry.request.getHeader(RequestResponseHeaders.requestContextHeader);\r\n                try {\r\n                    Util.safeIncludeCorrelationHeader(client, telemetry.request, correlationHeader);\r\n                }\r\n                catch (err) {\r\n                    Logging.warn(\"Request-Context header could not be set. Correlation of requests may be lost\", err);\r\n                }\r\n                if (currentContext && currentContext.operation) {\r\n                    try {\r\n                        telemetry.request.setHeader(RequestResponseHeaders.requestIdHeader, uniqueRequestId);\r\n                        // Also set legacy headers\r\n                        telemetry.request.setHeader(RequestResponseHeaders.parentIdHeader, currentContext.operation.id);\r\n                        telemetry.request.setHeader(RequestResponseHeaders.rootIdHeader, uniqueRequestId);\r\n                        // Set W3C headers, if available\r\n                        if (uniqueTraceparent || currentContext.operation.traceparent) {\r\n                            telemetry.request.setHeader(RequestResponseHeaders.traceparentHeader, uniqueTraceparent || currentContext.operation.traceparent.toString());\r\n                        }\r\n                        else if (CorrelationIdManager.w3cEnabled) {\r\n                            // should never get here since we set uniqueTraceparent above for the w3cEnabled scenario\r\n                            var traceparent = new Traceparent().toString();\r\n                            telemetry.request.setHeader(RequestResponseHeaders.traceparentHeader, traceparent);\r\n                        }\r\n                        if (currentContext.operation.tracestate) {\r\n                            var tracestate = currentContext.operation.tracestate.toString();\r\n                            if (tracestate) {\r\n                                telemetry.request.setHeader(RequestResponseHeaders.traceStateHeader, tracestate);\r\n                            }\r\n                        }\r\n                        var correlationContextHeader = currentContext.customProperties.serializeToHeader();\r\n                        if (correlationContextHeader) {\r\n                            telemetry.request.setHeader(RequestResponseHeaders.correlationContextHeader, correlationContextHeader);\r\n                        }\r\n                    }\r\n                    catch (err) {\r\n                        Logging.warn(\"Correlation headers could not be set. Correlation of requests may be lost.\", err);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        // Collect dependency telemetry about the request when it finishes.\r\n        if (telemetry.request.on) {\r\n            telemetry.request.on('response', function (response) {\r\n                requestParser.onResponse(response);\r\n                var dependencyTelemetry = requestParser.getDependencyTelemetry(telemetry, uniqueRequestId);\r\n                dependencyTelemetry.contextObjects = dependencyTelemetry.contextObjects || {};\r\n                dependencyTelemetry.contextObjects[\"http.RequestOptions\"] = telemetry.options;\r\n                dependencyTelemetry.contextObjects[\"http.ClientRequest\"] = telemetry.request;\r\n                dependencyTelemetry.contextObjects[\"http.ClientResponse\"] = response;\r\n                client.trackDependency(dependencyTelemetry);\r\n            });\r\n            telemetry.request.on('error', function (e) {\r\n                requestParser.onError(e);\r\n                var dependencyTelemetry = requestParser.getDependencyTelemetry(telemetry, uniqueRequestId);\r\n                dependencyTelemetry.contextObjects = dependencyTelemetry.contextObjects || {};\r\n                dependencyTelemetry.contextObjects[\"http.RequestOptions\"] = telemetry.options;\r\n                dependencyTelemetry.contextObjects[\"http.ClientRequest\"] = telemetry.request;\r\n                dependencyTelemetry.contextObjects[\"Error\"] = e;\r\n                client.trackDependency(dependencyTelemetry);\r\n            });\r\n        }\r\n    };\r\n    AutoCollectHttpDependencies.prototype.dispose = function () {\r\n        AutoCollectHttpDependencies.INSTANCE = null;\r\n        this.enable(false);\r\n        this._isInitialized = false;\r\n    };\r\n    AutoCollectHttpDependencies.disableCollectionRequestOption = 'disableAppInsightsAutoCollection';\r\n    AutoCollectHttpDependencies.requestNumber = 1;\r\n    AutoCollectHttpDependencies.alreadyAutoCollectedFlag = '_appInsightsAutoCollected';\r\n    return AutoCollectHttpDependencies;\r\n}());\r\nmodule.exports = AutoCollectHttpDependencies;\r\n//# sourceMappingURL=HttpDependencies.js.map","\"use strict\";\r\nvar __extends = (this && this.__extends) || (function () {\r\n    var extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\nvar url = require(\"url\");\r\nvar Contracts = require(\"../Declarations/Contracts\");\r\nvar Util = require(\"../Library/Util\");\r\nvar RequestResponseHeaders = require(\"../Library/RequestResponseHeaders\");\r\nvar RequestParser = require(\"./RequestParser\");\r\nvar CorrelationIdManager = require(\"../Library/CorrelationIdManager\");\r\n/**\r\n * Helper class to read data from the requst/response objects and convert them into the telemetry contract\r\n */\r\nvar HttpDependencyParser = (function (_super) {\r\n    __extends(HttpDependencyParser, _super);\r\n    function HttpDependencyParser(requestOptions, request) {\r\n        var _this = _super.call(this) || this;\r\n        if (request && request.method && requestOptions) {\r\n            // The ClientRequest.method property isn't documented, but is always there.\r\n            _this.method = request.method;\r\n            _this.url = HttpDependencyParser._getUrlFromRequestOptions(requestOptions, request);\r\n            _this.startTime = +new Date();\r\n        }\r\n        return _this;\r\n    }\r\n    /**\r\n     * Called when the ClientRequest emits an error event.\r\n     */\r\n    HttpDependencyParser.prototype.onError = function (error) {\r\n        this._setStatus(undefined, error);\r\n    };\r\n    /**\r\n     * Called when the ClientRequest emits a response event.\r\n     */\r\n    HttpDependencyParser.prototype.onResponse = function (response) {\r\n        this._setStatus(response.statusCode, undefined);\r\n        this.correlationId = Util.getCorrelationContextTarget(response, RequestResponseHeaders.requestContextTargetKey);\r\n    };\r\n    /**\r\n     * Gets a dependency data contract object for a completed ClientRequest.\r\n     */\r\n    HttpDependencyParser.prototype.getDependencyTelemetry = function (baseTelemetry, dependencyId) {\r\n        var urlObject = url.parse(this.url);\r\n        urlObject.search = undefined;\r\n        urlObject.hash = undefined;\r\n        var dependencyName = this.method.toUpperCase() + \" \" + urlObject.pathname;\r\n        var remoteDependencyType = Contracts.RemoteDependencyDataConstants.TYPE_HTTP;\r\n        var remoteDependencyTarget = urlObject.hostname;\r\n        if (this.correlationId) {\r\n            remoteDependencyType = Contracts.RemoteDependencyDataConstants.TYPE_AI;\r\n            if (this.correlationId !== CorrelationIdManager.correlationIdPrefix) {\r\n                remoteDependencyTarget = urlObject.hostname + \" | \" + this.correlationId;\r\n            }\r\n        }\r\n        else {\r\n            remoteDependencyType = Contracts.RemoteDependencyDataConstants.TYPE_HTTP;\r\n        }\r\n        var dependencyTelemetry = {\r\n            id: dependencyId,\r\n            name: dependencyName,\r\n            data: this.url,\r\n            duration: this.duration,\r\n            success: this._isSuccess(),\r\n            resultCode: this.statusCode ? this.statusCode.toString() : null,\r\n            properties: this.properties || {},\r\n            dependencyTypeName: remoteDependencyType,\r\n            target: remoteDependencyTarget\r\n        };\r\n        // We should keep any parameters the user passed in\r\n        // Except the fields defined above in requestTelemetry, which take priority\r\n        // Except the properties field, where they're merged instead, with baseTelemetry taking priority\r\n        if (baseTelemetry) {\r\n            // Copy missing fields\r\n            for (var key in baseTelemetry) {\r\n                if (!dependencyTelemetry[key]) {\r\n                    dependencyTelemetry[key] = baseTelemetry[key];\r\n                }\r\n            }\r\n            // Merge properties\r\n            if (baseTelemetry.properties) {\r\n                for (var key in baseTelemetry.properties) {\r\n                    dependencyTelemetry.properties[key] = baseTelemetry.properties[key];\r\n                }\r\n            }\r\n        }\r\n        return dependencyTelemetry;\r\n    };\r\n    /**\r\n     * Builds a URL from request options, using the same logic as http.request(). This is\r\n     * necessary because a ClientRequest object does not expose a url property.\r\n     */\r\n    HttpDependencyParser._getUrlFromRequestOptions = function (options, request) {\r\n        if (typeof options === 'string') {\r\n            options = url.parse(options);\r\n        }\r\n        else {\r\n            // Avoid modifying the original options object.\r\n            var originalOptions_1 = options;\r\n            options = {};\r\n            if (originalOptions_1) {\r\n                Object.keys(originalOptions_1).forEach(function (key) {\r\n                    options[key] = originalOptions_1[key];\r\n                });\r\n            }\r\n        }\r\n        // Oddly, url.format ignores path and only uses pathname and search,\r\n        // so create them from the path, if path was specified\r\n        if (options.path) {\r\n            var parsedQuery = url.parse(options.path);\r\n            options.pathname = parsedQuery.pathname;\r\n            options.search = parsedQuery.search;\r\n        }\r\n        // Simiarly, url.format ignores hostname and port if host is specified,\r\n        // even if host doesn't have the port, but http.request does not work\r\n        // this way. It will use the port if one is not specified in host,\r\n        // effectively treating host as hostname, but will use the port specified\r\n        // in host if it exists.\r\n        if (options.host && options.port) {\r\n            // Force a protocol so it will parse the host as the host, not path.\r\n            // It is discarded and not used, so it doesn't matter if it doesn't match\r\n            var parsedHost = url.parse(\"http://\" + options.host);\r\n            if (!parsedHost.port && options.port) {\r\n                options.hostname = options.host;\r\n                delete options.host;\r\n            }\r\n        }\r\n        // Mix in default values used by http.request and others\r\n        options.protocol = options.protocol || (request.agent && request.agent.protocol) || undefined;\r\n        options.hostname = options.hostname || 'localhost';\r\n        return url.format(options);\r\n    };\r\n    return HttpDependencyParser;\r\n}(RequestParser));\r\nmodule.exports = HttpDependencyParser;\r\n//# sourceMappingURL=HttpDependencyParser.js.map","\"use strict\";\r\nvar __extends = (this && this.__extends) || (function () {\r\n    var extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\nvar url = require(\"url\");\r\nvar Contracts = require(\"../Declarations/Contracts\");\r\nvar Util = require(\"../Library/Util\");\r\nvar RequestResponseHeaders = require(\"../Library/RequestResponseHeaders\");\r\nvar RequestParser = require(\"./RequestParser\");\r\nvar CorrelationIdManager = require(\"../Library/CorrelationIdManager\");\r\nvar Tracestate = require(\"../Library/Tracestate\");\r\nvar Traceparent = require(\"../Library/Traceparent\");\r\n/**\r\n * Helper class to read data from the requst/response objects and convert them into the telemetry contract\r\n */\r\nvar HttpRequestParser = (function (_super) {\r\n    __extends(HttpRequestParser, _super);\r\n    function HttpRequestParser(request, requestId) {\r\n        var _this = _super.call(this) || this;\r\n        if (request) {\r\n            _this.method = request.method;\r\n            _this.url = _this._getAbsoluteUrl(request);\r\n            _this.startTime = +new Date();\r\n            _this.socketRemoteAddress = request.socket && request.socket.remoteAddress;\r\n            _this.parseHeaders(request, requestId);\r\n            if (request.connection) {\r\n                _this.connectionRemoteAddress = request.connection.remoteAddress;\r\n                _this.legacySocketRemoteAddress = request.connection[\"socket\"] && request.connection[\"socket\"].remoteAddress;\r\n            }\r\n        }\r\n        return _this;\r\n    }\r\n    HttpRequestParser.prototype.onError = function (error, ellapsedMilliseconds) {\r\n        this._setStatus(undefined, error);\r\n        // This parameter is only for overrides. setStatus handles this internally for the autocollected case\r\n        if (ellapsedMilliseconds) {\r\n            this.duration = ellapsedMilliseconds;\r\n        }\r\n    };\r\n    HttpRequestParser.prototype.onResponse = function (response, ellapsedMilliseconds) {\r\n        this._setStatus(response.statusCode, undefined);\r\n        // This parameter is only for overrides. setStatus handles this internally for the autocollected case\r\n        if (ellapsedMilliseconds) {\r\n            this.duration = ellapsedMilliseconds;\r\n        }\r\n    };\r\n    HttpRequestParser.prototype.getRequestTelemetry = function (baseTelemetry) {\r\n        var requestTelemetry = {\r\n            id: this.requestId,\r\n            name: this.method + \" \" + url.parse(this.url).pathname,\r\n            url: this.url,\r\n            /*\r\n            See https://github.com/Microsoft/ApplicationInsights-dotnet-server/blob/25d695e6a906fbe977f67be3966d25dbf1c50a79/Src/Web/Web.Shared.Net/RequestTrackingTelemetryModule.cs#L250\r\n            for reference\r\n            */\r\n            source: this.sourceCorrelationId,\r\n            duration: this.duration,\r\n            resultCode: this.statusCode ? this.statusCode.toString() : null,\r\n            success: this._isSuccess(),\r\n            properties: this.properties\r\n        };\r\n        // We should keep any parameters the user passed in\r\n        // Except the fields defined above in requestTelemetry, which take priority\r\n        // Except the properties field, where they're merged instead, with baseTelemetry taking priority\r\n        if (baseTelemetry) {\r\n            // Copy missing fields\r\n            for (var key in baseTelemetry) {\r\n                if (!requestTelemetry[key]) {\r\n                    requestTelemetry[key] = baseTelemetry[key];\r\n                }\r\n            }\r\n            // Merge properties\r\n            if (baseTelemetry.properties) {\r\n                for (var key in baseTelemetry.properties) {\r\n                    requestTelemetry.properties[key] = baseTelemetry.properties[key];\r\n                }\r\n            }\r\n        }\r\n        return requestTelemetry;\r\n    };\r\n    HttpRequestParser.prototype.getRequestTags = function (tags) {\r\n        // create a copy of the context for requests since client info will be used here\r\n        var newTags = {};\r\n        for (var key in tags) {\r\n            newTags[key] = tags[key];\r\n        }\r\n        // don't override tags if they are already set\r\n        newTags[HttpRequestParser.keys.locationIp] = tags[HttpRequestParser.keys.locationIp] || this._getIp();\r\n        newTags[HttpRequestParser.keys.sessionId] = tags[HttpRequestParser.keys.sessionId] || this._getId(\"ai_session\");\r\n        newTags[HttpRequestParser.keys.userId] = tags[HttpRequestParser.keys.userId] || this._getId(\"ai_user\");\r\n        newTags[HttpRequestParser.keys.userAuthUserId] = tags[HttpRequestParser.keys.userAuthUserId] || this._getId(\"ai_authUser\");\r\n        newTags[HttpRequestParser.keys.operationName] = this.getOperationName(tags);\r\n        newTags[HttpRequestParser.keys.operationParentId] = this.getOperationParentId(tags);\r\n        newTags[HttpRequestParser.keys.operationId] = this.getOperationId(tags);\r\n        return newTags;\r\n    };\r\n    HttpRequestParser.prototype.getOperationId = function (tags) {\r\n        return tags[HttpRequestParser.keys.operationId] || this.operationId;\r\n    };\r\n    HttpRequestParser.prototype.getOperationParentId = function (tags) {\r\n        return tags[HttpRequestParser.keys.operationParentId] || this.parentId || this.getOperationId(tags);\r\n    };\r\n    HttpRequestParser.prototype.getOperationName = function (tags) {\r\n        return tags[HttpRequestParser.keys.operationName] || this.method + \" \" + url.parse(this.url).pathname;\r\n    };\r\n    HttpRequestParser.prototype.getRequestId = function () {\r\n        return this.requestId;\r\n    };\r\n    HttpRequestParser.prototype.getCorrelationContextHeader = function () {\r\n        return this.correlationContextHeader;\r\n    };\r\n    HttpRequestParser.prototype.getTraceparent = function () {\r\n        return this.traceparent;\r\n    };\r\n    HttpRequestParser.prototype.getTracestate = function () {\r\n        return this.tracestate;\r\n    };\r\n    HttpRequestParser.prototype.getLegacyRootId = function () {\r\n        return this.legacyRootId;\r\n    };\r\n    HttpRequestParser.prototype._getAbsoluteUrl = function (request) {\r\n        if (!request.headers) {\r\n            return request.url;\r\n        }\r\n        var encrypted = request.connection ? request.connection.encrypted : null;\r\n        var requestUrl = url.parse(request.url);\r\n        var pathName = requestUrl.pathname;\r\n        var search = requestUrl.search;\r\n        var absoluteUrl = url.format({\r\n            protocol: encrypted ? \"https\" : \"http\",\r\n            host: request.headers.host,\r\n            pathname: pathName,\r\n            search: search\r\n        });\r\n        return absoluteUrl;\r\n    };\r\n    HttpRequestParser.prototype._getIp = function () {\r\n        // regex to match ipv4 without port\r\n        // Note: including the port would cause the payload to be rejected by the data collector\r\n        var ipMatch = /[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}/;\r\n        var check = function (str) {\r\n            var results = ipMatch.exec(str);\r\n            if (results) {\r\n                return results[0];\r\n            }\r\n        };\r\n        var ip = check(this.rawHeaders[\"x-forwarded-for\"])\r\n            || check(this.rawHeaders[\"x-client-ip\"])\r\n            || check(this.rawHeaders[\"x-real-ip\"])\r\n            || check(this.connectionRemoteAddress)\r\n            || check(this.socketRemoteAddress)\r\n            || check(this.legacySocketRemoteAddress);\r\n        // node v12 returns this if the address is \"localhost\"\r\n        if (!ip\r\n            && this.connectionRemoteAddress\r\n            && this.connectionRemoteAddress.substr\r\n            && this.connectionRemoteAddress.substr(0, 2) === \"::\") {\r\n            ip = \"127.0.0.1\";\r\n        }\r\n        return ip;\r\n    };\r\n    HttpRequestParser.prototype._getId = function (name) {\r\n        var cookie = (this.rawHeaders && this.rawHeaders[\"cookie\"] &&\r\n            typeof this.rawHeaders[\"cookie\"] === 'string' && this.rawHeaders[\"cookie\"]) || \"\";\r\n        var value = HttpRequestParser.parseId(Util.getCookie(name, cookie));\r\n        return value;\r\n    };\r\n    /**\r\n     * Sets this operation's operationId, parentId, requestId (and legacyRootId, if necessary) based on this operation's traceparent\r\n     */\r\n    HttpRequestParser.prototype.setBackCompatFromThisTraceContext = function () {\r\n        // Set operationId\r\n        this.operationId = this.traceparent.traceId;\r\n        if (this.traceparent.legacyRootId) {\r\n            this.legacyRootId = this.traceparent.legacyRootId;\r\n        }\r\n        // Set parentId with existing spanId\r\n        this.parentId = this.traceparent.parentId;\r\n        // Update the spanId and set the current requestId\r\n        this.traceparent.updateSpanId();\r\n        this.requestId = this.traceparent.getBackCompatRequestId();\r\n    };\r\n    HttpRequestParser.prototype.parseHeaders = function (request, requestId) {\r\n        this.rawHeaders = request.headers || request.rawHeaders;\r\n        this.userAgent = request.headers && request.headers[\"user-agent\"];\r\n        this.sourceCorrelationId = Util.getCorrelationContextTarget(request, RequestResponseHeaders.requestContextSourceKey);\r\n        if (request.headers) {\r\n            var tracestateHeader = request.headers[RequestResponseHeaders.traceStateHeader]; // w3c header\r\n            var traceparentHeader = request.headers[RequestResponseHeaders.traceparentHeader]; // w3c header\r\n            var requestIdHeader = request.headers[RequestResponseHeaders.requestIdHeader]; // default AI header\r\n            var legacy_parentId = request.headers[RequestResponseHeaders.parentIdHeader]; // legacy AI header\r\n            var legacy_rootId = request.headers[RequestResponseHeaders.rootIdHeader]; // legacy AI header\r\n            this.correlationContextHeader = request.headers[RequestResponseHeaders.correlationContextHeader];\r\n            if (CorrelationIdManager.w3cEnabled && (traceparentHeader || tracestateHeader)) {\r\n                // Parse W3C Trace Context headers\r\n                this.traceparent = new Traceparent(traceparentHeader); // new traceparent is always created from this\r\n                this.tracestate = traceparentHeader && tracestateHeader && new Tracestate(tracestateHeader); // discard tracestate if no traceparent is present\r\n                this.setBackCompatFromThisTraceContext();\r\n            }\r\n            else if (requestIdHeader) {\r\n                // Parse AI headers\r\n                if (CorrelationIdManager.w3cEnabled) {\r\n                    this.traceparent = new Traceparent(null, requestIdHeader);\r\n                    this.setBackCompatFromThisTraceContext();\r\n                }\r\n                else {\r\n                    this.parentId = requestIdHeader;\r\n                    this.requestId = CorrelationIdManager.generateRequestId(this.parentId);\r\n                    this.operationId = CorrelationIdManager.getRootId(this.requestId);\r\n                }\r\n            }\r\n            else {\r\n                // Legacy fallback\r\n                if (CorrelationIdManager.w3cEnabled) {\r\n                    this.traceparent = new Traceparent();\r\n                    this.traceparent.parentId = legacy_parentId;\r\n                    this.traceparent.legacyRootId = legacy_rootId || legacy_parentId;\r\n                    this.setBackCompatFromThisTraceContext();\r\n                }\r\n                else {\r\n                    this.parentId = legacy_parentId;\r\n                    this.requestId = CorrelationIdManager.generateRequestId(legacy_rootId || this.parentId);\r\n                    this.correlationContextHeader = null;\r\n                    this.operationId = CorrelationIdManager.getRootId(this.requestId);\r\n                }\r\n            }\r\n            if (requestId) {\r\n                // For the scenarios that don't guarantee an AI-created context,\r\n                // override the requestId with the provided one.\r\n                this.requestId = requestId;\r\n                this.operationId = CorrelationIdManager.getRootId(this.requestId);\r\n            }\r\n        }\r\n    };\r\n    HttpRequestParser.parseId = function (cookieValue) {\r\n        var cookieParts = cookieValue.split(\"|\");\r\n        if (cookieParts.length > 0) {\r\n            return cookieParts[0];\r\n        }\r\n        return \"\"; // old behavior was to return \"\" for incorrect parsing\r\n    };\r\n    HttpRequestParser.keys = new Contracts.ContextTagKeys();\r\n    return HttpRequestParser;\r\n}(RequestParser));\r\nmodule.exports = HttpRequestParser;\r\n//# sourceMappingURL=HttpRequestParser.js.map","\"use strict\";\r\nvar http = require(\"http\");\r\nvar https = require(\"https\");\r\nvar Logging = require(\"../Library/Logging\");\r\nvar Util = require(\"../Library/Util\");\r\nvar RequestResponseHeaders = require(\"../Library/RequestResponseHeaders\");\r\nvar HttpRequestParser = require(\"./HttpRequestParser\");\r\nvar CorrelationContextManager_1 = require(\"./CorrelationContextManager\");\r\nvar AutoCollectPerformance = require(\"./Performance\");\r\nvar AutoCollectHttpRequests = (function () {\r\n    function AutoCollectHttpRequests(client) {\r\n        if (!!AutoCollectHttpRequests.INSTANCE) {\r\n            throw new Error(\"Server request tracking should be configured from the applicationInsights object\");\r\n        }\r\n        AutoCollectHttpRequests.INSTANCE = this;\r\n        this._client = client;\r\n    }\r\n    AutoCollectHttpRequests.prototype.enable = function (isEnabled) {\r\n        this._isEnabled = isEnabled;\r\n        // Autocorrelation requires automatic monitoring of incoming server requests\r\n        // Disabling autocollection but enabling autocorrelation will still enable\r\n        // request monitoring but will not produce request events\r\n        if ((this._isAutoCorrelating || this._isEnabled || AutoCollectPerformance.isEnabled()) && !this._isInitialized) {\r\n            this.useAutoCorrelation(this._isAutoCorrelating);\r\n            this._initialize();\r\n        }\r\n    };\r\n    AutoCollectHttpRequests.prototype.useAutoCorrelation = function (isEnabled, forceClsHooked) {\r\n        if (isEnabled && !this._isAutoCorrelating) {\r\n            CorrelationContextManager_1.CorrelationContextManager.enable(forceClsHooked);\r\n        }\r\n        else if (!isEnabled && this._isAutoCorrelating) {\r\n            CorrelationContextManager_1.CorrelationContextManager.disable();\r\n        }\r\n        this._isAutoCorrelating = isEnabled;\r\n    };\r\n    AutoCollectHttpRequests.prototype.isInitialized = function () {\r\n        return this._isInitialized;\r\n    };\r\n    AutoCollectHttpRequests.prototype.isAutoCorrelating = function () {\r\n        return this._isAutoCorrelating;\r\n    };\r\n    AutoCollectHttpRequests.prototype._generateCorrelationContext = function (requestParser) {\r\n        if (!this._isAutoCorrelating) {\r\n            return;\r\n        }\r\n        return CorrelationContextManager_1.CorrelationContextManager.generateContextObject(requestParser.getOperationId(this._client.context.tags), requestParser.getRequestId(), requestParser.getOperationName(this._client.context.tags), requestParser.getCorrelationContextHeader(), requestParser.getTraceparent(), requestParser.getTracestate());\r\n    };\r\n    AutoCollectHttpRequests.prototype._initialize = function () {\r\n        var _this = this;\r\n        this._isInitialized = true;\r\n        var wrapOnRequestHandler = function (onRequest) {\r\n            if (!onRequest) {\r\n                return undefined;\r\n            }\r\n            if (typeof onRequest !== 'function') {\r\n                throw new Error('onRequest handler must be a function');\r\n            }\r\n            return function (request, response) {\r\n                CorrelationContextManager_1.CorrelationContextManager.wrapEmitter(request);\r\n                CorrelationContextManager_1.CorrelationContextManager.wrapEmitter(response);\r\n                var shouldCollect = request && !request[AutoCollectHttpRequests.alreadyAutoCollectedFlag];\r\n                if (request && shouldCollect) {\r\n                    // Set up correlation context\r\n                    var requestParser_1 = new HttpRequestParser(request);\r\n                    var correlationContext = _this._generateCorrelationContext(requestParser_1);\r\n                    // Note: Check for if correlation is enabled happens within this method.\r\n                    // If not enabled, function will directly call the callback.\r\n                    CorrelationContextManager_1.CorrelationContextManager.runWithContext(correlationContext, function () {\r\n                        if (_this._isEnabled) {\r\n                            // Mark as auto collected\r\n                            request[AutoCollectHttpRequests.alreadyAutoCollectedFlag] = true;\r\n                            // Auto collect request\r\n                            AutoCollectHttpRequests.trackRequest(_this._client, { request: request, response: response }, requestParser_1);\r\n                        }\r\n                        if (typeof onRequest === \"function\") {\r\n                            onRequest(request, response);\r\n                        }\r\n                    });\r\n                }\r\n                else {\r\n                    if (typeof onRequest === \"function\") {\r\n                        onRequest(request, response);\r\n                    }\r\n                }\r\n            };\r\n        };\r\n        // The `http.createServer` function will instantiate a new http.Server object.\r\n        // Inside the Server's constructor, it is using addListener to register the\r\n        // onRequest handler. So there are two ways to inject the wrapped onRequest handler:\r\n        // 1) Overwrite Server.prototype.addListener (and .on()) globally and not patching\r\n        //    the http.createServer call. Or\r\n        // 2) Overwrite the http.createServer method and add a patched addListener to the\r\n        //    fresh server instance. This seems more stable for possible future changes as\r\n        //    it also covers the case where the Server might not use addListener to manage\r\n        //    the callback internally.\r\n        //    And also as long as the constructor uses addListener to add the handle, it is\r\n        //    ok to patch the addListener after construction only. Because if we would patch\r\n        //    the prototype one and the createServer method, we would wrap the handler twice\r\n        //    in case of the constructor call.\r\n        var wrapServerEventHandler = function (server) {\r\n            var originalAddListener = server.addListener.bind(server);\r\n            server.addListener = function (eventType, eventHandler) {\r\n                switch (eventType) {\r\n                    case 'request':\r\n                    case 'checkContinue':\r\n                        return originalAddListener(eventType, wrapOnRequestHandler(eventHandler));\r\n                    default:\r\n                        return originalAddListener(eventType, eventHandler);\r\n                }\r\n            };\r\n            // on is an alias to addListener only\r\n            server.on = server.addListener;\r\n        };\r\n        var originalHttpServer = http.createServer;\r\n        http.createServer = function (onRequest) {\r\n            // todo: get a pointer to the server so the IP address can be read from server.address\r\n            var server = originalHttpServer(wrapOnRequestHandler(onRequest));\r\n            wrapServerEventHandler(server);\r\n            return server;\r\n        };\r\n        var originalHttpsServer = https.createServer;\r\n        https.createServer = function (options, onRequest) {\r\n            var server = originalHttpsServer(options, wrapOnRequestHandler(onRequest));\r\n            wrapServerEventHandler(server);\r\n            return server;\r\n        };\r\n    };\r\n    /**\r\n     * Tracks a request synchronously (doesn't wait for response 'finish' event)\r\n     */\r\n    AutoCollectHttpRequests.trackRequestSync = function (client, telemetry) {\r\n        if (!telemetry.request || !telemetry.response || !client) {\r\n            Logging.info(\"AutoCollectHttpRequests.trackRequestSync was called with invalid parameters: \", !telemetry.request, !telemetry.response, !client);\r\n            return;\r\n        }\r\n        AutoCollectHttpRequests.addResponseCorrelationIdHeader(client, telemetry.response);\r\n        // store data about the request\r\n        var correlationContext = CorrelationContextManager_1.CorrelationContextManager.getCurrentContext();\r\n        var requestParser = new HttpRequestParser(telemetry.request, (correlationContext && correlationContext.operation.parentId));\r\n        // Overwrite correlation context with request parser results\r\n        if (correlationContext) {\r\n            correlationContext.operation.id = requestParser.getOperationId(client.context.tags) || correlationContext.operation.id;\r\n            correlationContext.operation.name = requestParser.getOperationName(client.context.tags) || correlationContext.operation.name;\r\n            correlationContext.operation.parentId = requestParser.getRequestId() || correlationContext.operation.parentId;\r\n            correlationContext.customProperties.addHeaderData(requestParser.getCorrelationContextHeader());\r\n        }\r\n        AutoCollectHttpRequests.endRequest(client, requestParser, telemetry, telemetry.duration, telemetry.error);\r\n    };\r\n    /**\r\n     * Tracks a request by listening to the response 'finish' event\r\n     */\r\n    AutoCollectHttpRequests.trackRequest = function (client, telemetry, _requestParser) {\r\n        if (!telemetry.request || !telemetry.response || !client) {\r\n            Logging.info(\"AutoCollectHttpRequests.trackRequest was called with invalid parameters: \", !telemetry.request, !telemetry.response, !client);\r\n            return;\r\n        }\r\n        // store data about the request\r\n        var correlationContext = CorrelationContextManager_1.CorrelationContextManager.getCurrentContext();\r\n        var requestParser = _requestParser || new HttpRequestParser(telemetry.request, correlationContext && correlationContext.operation.parentId);\r\n        if (Util.canIncludeCorrelationHeader(client, requestParser.getUrl())) {\r\n            AutoCollectHttpRequests.addResponseCorrelationIdHeader(client, telemetry.response);\r\n        }\r\n        // Overwrite correlation context with request parser results (if not an automatic track. we've already precalculated the correlation context in that case)\r\n        if (correlationContext && !_requestParser) {\r\n            correlationContext.operation.id = requestParser.getOperationId(client.context.tags) || correlationContext.operation.id;\r\n            correlationContext.operation.name = requestParser.getOperationName(client.context.tags) || correlationContext.operation.name;\r\n            correlationContext.operation.parentId = requestParser.getOperationParentId(client.context.tags) || correlationContext.operation.parentId;\r\n            correlationContext.customProperties.addHeaderData(requestParser.getCorrelationContextHeader());\r\n        }\r\n        // response listeners\r\n        if (telemetry.response.once) {\r\n            telemetry.response.once(\"finish\", function () {\r\n                AutoCollectHttpRequests.endRequest(client, requestParser, telemetry, null, null);\r\n            });\r\n        }\r\n        // track a failed request if an error is emitted\r\n        if (telemetry.request.on) {\r\n            telemetry.request.on(\"error\", function (error) {\r\n                AutoCollectHttpRequests.endRequest(client, requestParser, telemetry, null, error);\r\n            });\r\n        }\r\n    };\r\n    /**\r\n     * Add the target correlationId to the response headers, if not already provided.\r\n     */\r\n    AutoCollectHttpRequests.addResponseCorrelationIdHeader = function (client, response) {\r\n        if (client.config && client.config.correlationId &&\r\n            response.getHeader && response.setHeader && !response.headersSent) {\r\n            var correlationHeader = response.getHeader(RequestResponseHeaders.requestContextHeader);\r\n            Util.safeIncludeCorrelationHeader(client, response, correlationHeader);\r\n        }\r\n    };\r\n    AutoCollectHttpRequests.endRequest = function (client, requestParser, telemetry, ellapsedMilliseconds, error) {\r\n        if (error) {\r\n            requestParser.onError(error, ellapsedMilliseconds);\r\n        }\r\n        else {\r\n            requestParser.onResponse(telemetry.response, ellapsedMilliseconds);\r\n        }\r\n        var requestTelemetry = requestParser.getRequestTelemetry(telemetry);\r\n        requestTelemetry.tagOverrides = requestParser.getRequestTags(client.context.tags);\r\n        if (telemetry.tagOverrides) {\r\n            for (var key in telemetry.tagOverrides) {\r\n                requestTelemetry.tagOverrides[key] = telemetry.tagOverrides[key];\r\n            }\r\n        }\r\n        var legacyRootId = requestParser.getLegacyRootId();\r\n        if (legacyRootId) {\r\n            requestTelemetry.properties[\"ai_legacyRootId\"] = legacyRootId;\r\n        }\r\n        requestTelemetry.contextObjects = requestTelemetry.contextObjects || {};\r\n        requestTelemetry.contextObjects[\"http.ServerRequest\"] = telemetry.request;\r\n        requestTelemetry.contextObjects[\"http.ServerResponse\"] = telemetry.response;\r\n        client.trackRequest(requestTelemetry);\r\n    };\r\n    AutoCollectHttpRequests.prototype.dispose = function () {\r\n        AutoCollectHttpRequests.INSTANCE = null;\r\n        this.enable(false);\r\n        this._isInitialized = false;\r\n        CorrelationContextManager_1.CorrelationContextManager.disable();\r\n        this._isAutoCorrelating = false;\r\n    };\r\n    AutoCollectHttpRequests.alreadyAutoCollectedFlag = '_appInsightsAutoCollected';\r\n    return AutoCollectHttpRequests;\r\n}());\r\nmodule.exports = AutoCollectHttpRequests;\r\n//# sourceMappingURL=HttpRequests.js.map","\"use strict\";\r\nvar __assign = (this && this.__assign) || Object.assign || function(t) {\r\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n        s = arguments[i];\r\n        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\r\n            t[p] = s[p];\r\n    }\r\n    return t;\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar Config = require(\"../Library/Config\");\r\nvar Context = require(\"../Library/Context\");\r\nvar Logging = require(\"../Library/Logging\");\r\nvar AutoCollectNativePerformance = (function () {\r\n    function AutoCollectNativePerformance(client) {\r\n        this._disabledMetrics = {};\r\n        // Note: Only 1 instance of this can exist. So when we reconstruct this object,\r\n        // just disable old native instance and reset JS member variables\r\n        if (AutoCollectNativePerformance.INSTANCE) {\r\n            AutoCollectNativePerformance.INSTANCE.dispose();\r\n        }\r\n        AutoCollectNativePerformance.INSTANCE = this;\r\n        this._client = client;\r\n    }\r\n    /**\r\n     *  Reports if NativePerformance is able to run in this environment\r\n     */\r\n    AutoCollectNativePerformance.isNodeVersionCompatible = function () {\r\n        var nodeVer = process.versions.node.split(\".\");\r\n        return parseInt(nodeVer[0]) >= 6;\r\n    };\r\n    /**\r\n     * Start instance of native metrics agent.\r\n     *\r\n     * @param {boolean} isEnabled\r\n     * @param {number} [collectionInterval=60000]\r\n     * @memberof AutoCollectNativePerformance\r\n     */\r\n    AutoCollectNativePerformance.prototype.enable = function (isEnabled, disabledMetrics, collectionInterval) {\r\n        var _this = this;\r\n        if (disabledMetrics === void 0) { disabledMetrics = {}; }\r\n        if (collectionInterval === void 0) { collectionInterval = 60000; }\r\n        if (!AutoCollectNativePerformance.isNodeVersionCompatible()) {\r\n            return;\r\n        }\r\n        if (AutoCollectNativePerformance._metricsAvailable == undefined && isEnabled && !this._isInitialized) {\r\n            // Try to require in the native-metrics library. If it's found initialize it, else do nothing and never try again.\r\n            try {\r\n                var NativeMetricsEmitters = require(\"applicationinsights-native-metrics\");\r\n                AutoCollectNativePerformance._emitter = new NativeMetricsEmitters();\r\n                AutoCollectNativePerformance._metricsAvailable = true;\r\n                Logging.info(\"Native metrics module successfully loaded!\");\r\n            }\r\n            catch (err) {\r\n                // Package not available. Never try again\r\n                AutoCollectNativePerformance._metricsAvailable = false;\r\n                return;\r\n            }\r\n        }\r\n        this._isEnabled = isEnabled;\r\n        this._disabledMetrics = disabledMetrics;\r\n        if (this._isEnabled && !this._isInitialized) {\r\n            this._isInitialized = true;\r\n        }\r\n        // Enable the emitter if we were able to construct one\r\n        if (this._isEnabled && AutoCollectNativePerformance._emitter) {\r\n            // enable self\r\n            AutoCollectNativePerformance._emitter.enable(true, collectionInterval);\r\n            this._handle = setInterval(function () { return _this._trackNativeMetrics(); }, collectionInterval);\r\n            this._handle.unref();\r\n        }\r\n        else if (AutoCollectNativePerformance._emitter) {\r\n            // disable self\r\n            AutoCollectNativePerformance._emitter.enable(false);\r\n            if (this._handle) {\r\n                clearInterval(this._handle);\r\n                this._handle = undefined;\r\n            }\r\n        }\r\n    };\r\n    /**\r\n     * Cleanup this instance of AutoCollectNativePerformance\r\n     *\r\n     * @memberof AutoCollectNativePerformance\r\n     */\r\n    AutoCollectNativePerformance.prototype.dispose = function () {\r\n        this.enable(false);\r\n    };\r\n    /**\r\n     * Parse environment variable and overwrite isEnabled based on respective fields being set\r\n     *\r\n     * @private\r\n     * @static\r\n     * @param {(boolean | IDisabledExtendedMetrics)} collectExtendedMetrics\r\n     * @returns {(boolean | IDisabledExtendedMetrics)}\r\n     * @memberof AutoCollectNativePerformance\r\n     */\r\n    AutoCollectNativePerformance.parseEnabled = function (collectExtendedMetrics) {\r\n        var disableAll = process.env[Config.ENV_nativeMetricsDisableAll];\r\n        var individualOptOuts = process.env[Config.ENV_nativeMetricsDisablers];\r\n        // case 1: disable all env var set, RETURN with isEnabled=false\r\n        if (disableAll) {\r\n            return { isEnabled: false, disabledMetrics: {} };\r\n        }\r\n        // case 2: individual env vars set, RETURN with isEnabled=true, disabledMetrics={...}\r\n        if (individualOptOuts) {\r\n            var optOutsArr = individualOptOuts.split(\",\");\r\n            var disabledMetrics = {};\r\n            if (optOutsArr.length > 0) {\r\n                for (var _i = 0, optOutsArr_1 = optOutsArr; _i < optOutsArr_1.length; _i++) {\r\n                    var opt = optOutsArr_1[_i];\r\n                    disabledMetrics[opt] = true;\r\n                }\r\n            }\r\n            // case 2a: collectExtendedMetrics is an object, overwrite existing ones if they exist\r\n            if (typeof collectExtendedMetrics === \"object\") {\r\n                return { isEnabled: true, disabledMetrics: __assign({}, collectExtendedMetrics, disabledMetrics) };\r\n            }\r\n            // case 2b: collectExtendedMetrics is a boolean, set disabledMetrics as is\r\n            return { isEnabled: collectExtendedMetrics, disabledMetrics: disabledMetrics };\r\n        }\r\n        // case 4: no env vars set, input arg is a boolean, RETURN with isEnabled=collectExtendedMetrics, disabledMetrics={}\r\n        if (typeof collectExtendedMetrics === \"boolean\") {\r\n            return { isEnabled: collectExtendedMetrics, disabledMetrics: {} };\r\n        }\r\n        else {\r\n            // case 5: no env vars set, input arg is object, RETURN with isEnabled=true, disabledMetrics=collectExtendedMetrics\r\n            return { isEnabled: true, disabledMetrics: collectExtendedMetrics };\r\n        }\r\n    };\r\n    /**\r\n     * Trigger an iteration of native metrics collection\r\n     *\r\n     * @private\r\n     * @memberof AutoCollectNativePerformance\r\n     */\r\n    AutoCollectNativePerformance.prototype._trackNativeMetrics = function () {\r\n        var shouldSendAll = true;\r\n        if (typeof this._isEnabled !== \"object\") {\r\n            shouldSendAll = this._isEnabled;\r\n        }\r\n        if (shouldSendAll) {\r\n            this._trackGarbageCollection();\r\n            this._trackEventLoop();\r\n            this._trackHeapUsage();\r\n        }\r\n    };\r\n    /**\r\n     * Tracks garbage collection stats for this interval. One custom metric is sent per type of garbage\r\n     * collection that occurred during this collection interval.\r\n     *\r\n     * @private\r\n     * @memberof AutoCollectNativePerformance\r\n     */\r\n    AutoCollectNativePerformance.prototype._trackGarbageCollection = function () {\r\n        if (this._disabledMetrics.gc) {\r\n            return;\r\n        }\r\n        var gcData = AutoCollectNativePerformance._emitter.getGCData();\r\n        for (var gc in gcData) {\r\n            var metrics = gcData[gc].metrics;\r\n            var name_1 = gc + \" Garbage Collection Duration\";\r\n            var stdDev = Math.sqrt(metrics.sumSquares / metrics.count - Math.pow(metrics.total / metrics.count, 2)) || 0;\r\n            this._client.trackMetric({\r\n                name: name_1,\r\n                value: metrics.total,\r\n                count: metrics.count,\r\n                max: metrics.max,\r\n                min: metrics.min,\r\n                stdDev: stdDev,\r\n                tagOverrides: (_a = {},\r\n                    _a[this._client.context.keys.internalSdkVersion] = \"node-nativeperf:\" + Context.sdkVersion,\r\n                    _a)\r\n            });\r\n        }\r\n        var _a;\r\n    };\r\n    /**\r\n     * Tracks event loop ticks per interval as a custom metric. Also included in the metric is min/max/avg\r\n     * time spent in event loop for this interval.\r\n     *\r\n     * @private\r\n     * @returns {void}\r\n     * @memberof AutoCollectNativePerformance\r\n     */\r\n    AutoCollectNativePerformance.prototype._trackEventLoop = function () {\r\n        if (this._disabledMetrics.loop) {\r\n            return;\r\n        }\r\n        var loopData = AutoCollectNativePerformance._emitter.getLoopData();\r\n        var metrics = loopData.loopUsage;\r\n        if (metrics.count == 0) {\r\n            return;\r\n        }\r\n        var name = \"Event Loop CPU Time\";\r\n        var stdDev = Math.sqrt(metrics.sumSquares / metrics.count - Math.pow(metrics.total / metrics.count, 2)) || 0;\r\n        this._client.trackMetric({\r\n            name: name,\r\n            value: metrics.total,\r\n            count: metrics.count,\r\n            min: metrics.min,\r\n            max: metrics.max,\r\n            stdDev: stdDev,\r\n            tagOverrides: (_a = {},\r\n                _a[this._client.context.keys.internalSdkVersion] = \"node-nativeperf:\" + Context.sdkVersion,\r\n                _a)\r\n        });\r\n        var _a;\r\n    };\r\n    /**\r\n     * Track heap memory usage metrics as a custom metric.\r\n     *\r\n     * @private\r\n     * @memberof AutoCollectNativePerformance\r\n     */\r\n    AutoCollectNativePerformance.prototype._trackHeapUsage = function () {\r\n        if (this._disabledMetrics.heap) {\r\n            return;\r\n        }\r\n        var memoryUsage = process.memoryUsage();\r\n        var heapUsed = memoryUsage.heapUsed, heapTotal = memoryUsage.heapTotal, rss = memoryUsage.rss;\r\n        this._client.trackMetric({\r\n            name: \"Memory Usage (Heap)\",\r\n            value: heapUsed,\r\n            count: 1,\r\n            tagOverrides: (_a = {},\r\n                _a[this._client.context.keys.internalSdkVersion] = \"node-nativeperf:\" + Context.sdkVersion,\r\n                _a)\r\n        });\r\n        this._client.trackMetric({\r\n            name: \"Memory Total (Heap)\",\r\n            value: heapTotal,\r\n            count: 1,\r\n            tagOverrides: (_b = {},\r\n                _b[this._client.context.keys.internalSdkVersion] = \"node-nativeperf:\" + Context.sdkVersion,\r\n                _b)\r\n        });\r\n        this._client.trackMetric({\r\n            name: \"Memory Usage (Non-Heap)\",\r\n            value: rss - heapTotal,\r\n            count: 1,\r\n            tagOverrides: (_c = {},\r\n                _c[this._client.context.keys.internalSdkVersion] = \"node-nativeperf:\" + Context.sdkVersion,\r\n                _c)\r\n        });\r\n        var _a, _b, _c;\r\n    };\r\n    return AutoCollectNativePerformance;\r\n}());\r\nexports.AutoCollectNativePerformance = AutoCollectNativePerformance;\r\n//# sourceMappingURL=NativePerformance.js.map","\"use strict\";\r\nvar os = require(\"os\");\r\nvar Constants = require(\"../Declarations/Constants\");\r\nvar AutoCollectPerformance = (function () {\r\n    /**\r\n     * @param enableLiveMetricsCounters - enable sending additional live metrics information (dependency metrics, exception metrics, committed memory)\r\n     */\r\n    function AutoCollectPerformance(client, collectionInterval, enableLiveMetricsCounters) {\r\n        if (collectionInterval === void 0) { collectionInterval = 60000; }\r\n        if (enableLiveMetricsCounters === void 0) { enableLiveMetricsCounters = false; }\r\n        this._lastIntervalRequestExecutionTime = 0; // the sum of durations which took place during from app start until last interval\r\n        this._lastIntervalDependencyExecutionTime = 0;\r\n        if (!AutoCollectPerformance.INSTANCE) {\r\n            AutoCollectPerformance.INSTANCE = this;\r\n        }\r\n        this._isInitialized = false;\r\n        this._client = client;\r\n        this._collectionInterval = collectionInterval;\r\n        this._enableLiveMetricsCounters = enableLiveMetricsCounters;\r\n    }\r\n    AutoCollectPerformance.prototype.enable = function (isEnabled, collectionInterval) {\r\n        var _this = this;\r\n        this._isEnabled = isEnabled;\r\n        if (this._isEnabled && !this._isInitialized) {\r\n            this._isInitialized = true;\r\n        }\r\n        if (isEnabled) {\r\n            if (!this._handle) {\r\n                this._lastCpus = os.cpus();\r\n                this._lastRequests = {\r\n                    totalRequestCount: AutoCollectPerformance._totalRequestCount,\r\n                    totalFailedRequestCount: AutoCollectPerformance._totalFailedRequestCount,\r\n                    time: +new Date\r\n                };\r\n                this._lastDependencies = {\r\n                    totalDependencyCount: AutoCollectPerformance._totalDependencyCount,\r\n                    totalFailedDependencyCount: AutoCollectPerformance._totalFailedDependencyCount,\r\n                    time: +new Date\r\n                };\r\n                this._lastExceptions = {\r\n                    totalExceptionCount: AutoCollectPerformance._totalExceptionCount,\r\n                    time: +new Date\r\n                };\r\n                if (typeof process.cpuUsage === 'function') {\r\n                    this._lastAppCpuUsage = process.cpuUsage();\r\n                }\r\n                this._lastHrtime = process.hrtime();\r\n                this._collectionInterval = collectionInterval || this._collectionInterval;\r\n                this._handle = setInterval(function () { return _this.trackPerformance(); }, this._collectionInterval);\r\n                this._handle.unref(); // Allow the app to terminate even while this loop is going on\r\n            }\r\n        }\r\n        else {\r\n            if (this._handle) {\r\n                clearInterval(this._handle);\r\n                this._handle = undefined;\r\n            }\r\n        }\r\n    };\r\n    AutoCollectPerformance.countRequest = function (duration, success) {\r\n        var durationMs;\r\n        if (!AutoCollectPerformance.isEnabled()) {\r\n            return;\r\n        }\r\n        if (typeof duration === 'string') {\r\n            // dependency duration is passed in as \"00:00:00.123\" by autocollectors\r\n            durationMs = +new Date('1970-01-01T' + duration + 'Z'); // convert to num ms, returns NaN if wrong\r\n        }\r\n        else if (typeof duration === 'number') {\r\n            durationMs = duration;\r\n        }\r\n        else {\r\n            return;\r\n        }\r\n        AutoCollectPerformance._intervalRequestExecutionTime += durationMs;\r\n        if (success === false) {\r\n            AutoCollectPerformance._totalFailedRequestCount++;\r\n        }\r\n        AutoCollectPerformance._totalRequestCount++;\r\n    };\r\n    AutoCollectPerformance.countException = function () {\r\n        AutoCollectPerformance._totalExceptionCount++;\r\n    };\r\n    AutoCollectPerformance.countDependency = function (duration, success) {\r\n        var durationMs;\r\n        if (!AutoCollectPerformance.isEnabled()) {\r\n            return;\r\n        }\r\n        if (typeof duration === 'string') {\r\n            // dependency duration is passed in as \"00:00:00.123\" by autocollectors\r\n            durationMs = +new Date('1970-01-01T' + duration + 'Z'); // convert to num ms, returns NaN if wrong\r\n        }\r\n        else if (typeof duration === 'number') {\r\n            durationMs = duration;\r\n        }\r\n        else {\r\n            return;\r\n        }\r\n        AutoCollectPerformance._intervalDependencyExecutionTime += durationMs;\r\n        if (success === false) {\r\n            AutoCollectPerformance._totalFailedDependencyCount++;\r\n        }\r\n        AutoCollectPerformance._totalDependencyCount++;\r\n    };\r\n    AutoCollectPerformance.prototype.isInitialized = function () {\r\n        return this._isInitialized;\r\n    };\r\n    AutoCollectPerformance.isEnabled = function () {\r\n        return AutoCollectPerformance.INSTANCE && AutoCollectPerformance.INSTANCE._isEnabled;\r\n    };\r\n    AutoCollectPerformance.prototype.trackPerformance = function () {\r\n        this._trackCpu();\r\n        this._trackMemory();\r\n        this._trackNetwork();\r\n        this._trackDependencyRate();\r\n        this._trackExceptionRate();\r\n    };\r\n    AutoCollectPerformance.prototype._trackCpu = function () {\r\n        // this reports total ms spent in each category since the OS was booted, to calculate percent it is necessary\r\n        // to find the delta since the last measurement\r\n        var cpus = os.cpus();\r\n        if (cpus && cpus.length && this._lastCpus && cpus.length === this._lastCpus.length) {\r\n            var totalUser = 0;\r\n            var totalSys = 0;\r\n            var totalNice = 0;\r\n            var totalIdle = 0;\r\n            var totalIrq = 0;\r\n            for (var i = 0; !!cpus && i < cpus.length; i++) {\r\n                var cpu = cpus[i];\r\n                var lastCpu = this._lastCpus[i];\r\n                var name = \"% cpu(\" + i + \") \";\r\n                var model = cpu.model;\r\n                var speed = cpu.speed;\r\n                var times = cpu.times;\r\n                var lastTimes = lastCpu.times;\r\n                // user cpu time (or) % CPU time spent in user space\r\n                var user = (times.user - lastTimes.user) || 0;\r\n                totalUser += user;\r\n                // system cpu time (or) % CPU time spent in kernel space\r\n                var sys = (times.sys - lastTimes.sys) || 0;\r\n                totalSys += sys;\r\n                // user nice cpu time (or) % CPU time spent on low priority processes\r\n                var nice = (times.nice - lastTimes.nice) || 0;\r\n                totalNice += nice;\r\n                // idle cpu time (or) % CPU time spent idle\r\n                var idle = (times.idle - lastTimes.idle) || 0;\r\n                totalIdle += idle;\r\n                // irq (or) % CPU time spent servicing/handling hardware interrupts\r\n                var irq = (times.irq - lastTimes.irq) || 0;\r\n                totalIrq += irq;\r\n            }\r\n            // Calculate % of total cpu time (user + system) this App Process used (Only supported by node v6.1.0+)\r\n            var appCpuPercent = undefined;\r\n            if (typeof process.cpuUsage === 'function') {\r\n                var appCpuUsage = process.cpuUsage();\r\n                var hrtime = process.hrtime();\r\n                var totalApp = ((appCpuUsage.user - this._lastAppCpuUsage.user) + (appCpuUsage.system - this._lastAppCpuUsage.system)) || 0;\r\n                if (typeof this._lastHrtime !== 'undefined' && this._lastHrtime.length === 2) {\r\n                    var elapsedTime = ((hrtime[0] - this._lastHrtime[0]) * 1e6 + (hrtime[1] - this._lastHrtime[1]) / 1e3) || 0; // convert to microseconds\r\n                    appCpuPercent = 100 * totalApp / (elapsedTime * cpus.length);\r\n                }\r\n                // Set previous\r\n                this._lastAppCpuUsage = appCpuUsage;\r\n                this._lastHrtime = hrtime;\r\n            }\r\n            var combinedTotal = (totalUser + totalSys + totalNice + totalIdle + totalIrq) || 1;\r\n            this._client.trackMetric({ name: Constants.PerformanceCounter.PROCESSOR_TIME, value: ((combinedTotal - totalIdle) / combinedTotal) * 100 });\r\n            this._client.trackMetric({ name: Constants.PerformanceCounter.PROCESS_TIME, value: appCpuPercent || ((totalUser / combinedTotal) * 100) });\r\n        }\r\n        this._lastCpus = cpus;\r\n    };\r\n    AutoCollectPerformance.prototype._trackMemory = function () {\r\n        var freeMem = os.freemem();\r\n        var usedMem = process.memoryUsage().rss;\r\n        var committedMemory = os.totalmem() - freeMem;\r\n        this._client.trackMetric({ name: Constants.PerformanceCounter.PRIVATE_BYTES, value: usedMem });\r\n        this._client.trackMetric({ name: Constants.PerformanceCounter.AVAILABLE_BYTES, value: freeMem });\r\n        // Only supported by quickpulse service\r\n        if (this._enableLiveMetricsCounters) {\r\n            this._client.trackMetric({ name: Constants.QuickPulseCounter.COMMITTED_BYTES, value: committedMemory });\r\n        }\r\n    };\r\n    AutoCollectPerformance.prototype._trackNetwork = function () {\r\n        // track total request counters\r\n        var lastRequests = this._lastRequests;\r\n        var requests = {\r\n            totalRequestCount: AutoCollectPerformance._totalRequestCount,\r\n            totalFailedRequestCount: AutoCollectPerformance._totalFailedRequestCount,\r\n            time: +new Date\r\n        };\r\n        var intervalRequests = (requests.totalRequestCount - lastRequests.totalRequestCount) || 0;\r\n        var intervalFailedRequests = (requests.totalFailedRequestCount - lastRequests.totalFailedRequestCount) || 0;\r\n        var elapsedMs = requests.time - lastRequests.time;\r\n        var elapsedSeconds = elapsedMs / 1000;\r\n        var averageRequestExecutionTime = ((AutoCollectPerformance._intervalRequestExecutionTime - this._lastIntervalRequestExecutionTime) / intervalRequests) || 0; // default to 0 in case no requests in this interval\r\n        this._lastIntervalRequestExecutionTime = AutoCollectPerformance._intervalRequestExecutionTime; // reset\r\n        if (elapsedMs > 0) {\r\n            var requestsPerSec = intervalRequests / elapsedSeconds;\r\n            var failedRequestsPerSec = intervalFailedRequests / elapsedSeconds;\r\n            this._client.trackMetric({ name: Constants.PerformanceCounter.REQUEST_RATE, value: requestsPerSec });\r\n            // Only send duration to live metrics if it has been updated!\r\n            if (!this._enableLiveMetricsCounters || intervalRequests > 0) {\r\n                this._client.trackMetric({ name: Constants.PerformanceCounter.REQUEST_DURATION, value: averageRequestExecutionTime });\r\n            }\r\n            // Only supported by quickpulse service\r\n            if (this._enableLiveMetricsCounters) {\r\n                this._client.trackMetric({ name: Constants.QuickPulseCounter.REQUEST_FAILURE_RATE, value: failedRequestsPerSec });\r\n            }\r\n        }\r\n        this._lastRequests = requests;\r\n    };\r\n    // Static counter is accumulated externally. Report the rate to client here\r\n    // Note: This is currently only used with QuickPulse client\r\n    AutoCollectPerformance.prototype._trackDependencyRate = function () {\r\n        if (this._enableLiveMetricsCounters) {\r\n            var lastDependencies = this._lastDependencies;\r\n            var dependencies = {\r\n                totalDependencyCount: AutoCollectPerformance._totalDependencyCount,\r\n                totalFailedDependencyCount: AutoCollectPerformance._totalFailedDependencyCount,\r\n                time: +new Date\r\n            };\r\n            var intervalDependencies = (dependencies.totalDependencyCount - lastDependencies.totalDependencyCount) || 0;\r\n            var intervalFailedDependencies = (dependencies.totalFailedDependencyCount - lastDependencies.totalFailedDependencyCount) || 0;\r\n            var elapsedMs = dependencies.time - lastDependencies.time;\r\n            var elapsedSeconds = elapsedMs / 1000;\r\n            var averageDependencyExecutionTime = ((AutoCollectPerformance._intervalDependencyExecutionTime - this._lastIntervalDependencyExecutionTime) / intervalDependencies) || 0;\r\n            this._lastIntervalDependencyExecutionTime = AutoCollectPerformance._intervalDependencyExecutionTime; // reset\r\n            if (elapsedMs > 0) {\r\n                var dependenciesPerSec = intervalDependencies / elapsedSeconds;\r\n                var failedDependenciesPerSec = intervalFailedDependencies / elapsedSeconds;\r\n                this._client.trackMetric({ name: Constants.QuickPulseCounter.DEPENDENCY_RATE, value: dependenciesPerSec });\r\n                this._client.trackMetric({ name: Constants.QuickPulseCounter.DEPENDENCY_FAILURE_RATE, value: failedDependenciesPerSec });\r\n                // redundant check for livemetrics, but kept for consistency w/ requests\r\n                // Only send duration to live metrics if it has been updated!\r\n                if (!this._enableLiveMetricsCounters || intervalDependencies > 0) {\r\n                    this._client.trackMetric({ name: Constants.QuickPulseCounter.DEPENDENCY_DURATION, value: averageDependencyExecutionTime });\r\n                }\r\n            }\r\n            this._lastDependencies = dependencies;\r\n        }\r\n    };\r\n    // Static counter is accumulated externally. Report the rate to client here\r\n    // Note: This is currently only used with QuickPulse client\r\n    AutoCollectPerformance.prototype._trackExceptionRate = function () {\r\n        if (this._enableLiveMetricsCounters) {\r\n            var lastExceptions = this._lastExceptions;\r\n            var exceptions = {\r\n                totalExceptionCount: AutoCollectPerformance._totalExceptionCount,\r\n                time: +new Date\r\n            };\r\n            var intervalExceptions = (exceptions.totalExceptionCount - lastExceptions.totalExceptionCount) || 0;\r\n            var elapsedMs = exceptions.time - lastExceptions.time;\r\n            var elapsedSeconds = elapsedMs / 1000;\r\n            if (elapsedMs > 0) {\r\n                var exceptionsPerSec = intervalExceptions / elapsedSeconds;\r\n                this._client.trackMetric({ name: Constants.QuickPulseCounter.EXCEPTION_RATE, value: exceptionsPerSec });\r\n            }\r\n            this._lastExceptions = exceptions;\r\n        }\r\n    };\r\n    AutoCollectPerformance.prototype.dispose = function () {\r\n        AutoCollectPerformance.INSTANCE = null;\r\n        this.enable(false);\r\n        this._isInitialized = false;\r\n    };\r\n    AutoCollectPerformance._totalRequestCount = 0;\r\n    AutoCollectPerformance._totalFailedRequestCount = 0;\r\n    AutoCollectPerformance._lastRequestExecutionTime = 0;\r\n    AutoCollectPerformance._totalDependencyCount = 0;\r\n    AutoCollectPerformance._totalFailedDependencyCount = 0;\r\n    AutoCollectPerformance._lastDependencyExecutionTime = 0;\r\n    AutoCollectPerformance._totalExceptionCount = 0;\r\n    AutoCollectPerformance._intervalDependencyExecutionTime = 0;\r\n    AutoCollectPerformance._intervalRequestExecutionTime = 0;\r\n    return AutoCollectPerformance;\r\n}());\r\nmodule.exports = AutoCollectPerformance;\r\n//# sourceMappingURL=Performance.js.map","\"use strict\";\r\n/**\r\n * Base class for helpers that read data from HTTP requst/response objects and convert them\r\n * into the telemetry contract objects.\r\n */\r\nvar RequestParser = (function () {\r\n    function RequestParser() {\r\n    }\r\n    /**\r\n     * Gets a url parsed out from request options\r\n     */\r\n    RequestParser.prototype.getUrl = function () {\r\n        return this.url;\r\n    };\r\n    RequestParser.prototype.RequestParser = function () {\r\n        this.startTime = +new Date();\r\n    };\r\n    RequestParser.prototype._setStatus = function (status, error) {\r\n        var endTime = +new Date();\r\n        this.duration = endTime - this.startTime;\r\n        this.statusCode = status;\r\n        var properties = this.properties || {};\r\n        if (error) {\r\n            if (typeof error === \"string\") {\r\n                properties[\"error\"] = error;\r\n            }\r\n            else if (error instanceof Error) {\r\n                properties[\"error\"] = error.message;\r\n            }\r\n            else if (typeof error === \"object\") {\r\n                for (var key in error) {\r\n                    properties[key] = error[key] && error[key].toString && error[key].toString();\r\n                }\r\n            }\r\n        }\r\n        this.properties = properties;\r\n    };\r\n    RequestParser.prototype._isSuccess = function () {\r\n        return (0 < this.statusCode) && (this.statusCode < 400);\r\n    };\r\n    return RequestParser;\r\n}());\r\nmodule.exports = RequestParser;\r\n//# sourceMappingURL=RequestParser.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar Contracts_1 = require(\"../../Declarations/Contracts\");\r\nvar diagnostic_channel_1 = require(\"diagnostic-channel\");\r\nvar clients = [];\r\n// Mapping from bunyan levels defined at https://github.com/trentm/node-bunyan/blob/master/lib/bunyan.js#L256\r\nvar bunyanToAILevelMap = {\r\n    10: Contracts_1.SeverityLevel.Verbose,\r\n    20: Contracts_1.SeverityLevel.Verbose,\r\n    30: Contracts_1.SeverityLevel.Information,\r\n    40: Contracts_1.SeverityLevel.Warning,\r\n    50: Contracts_1.SeverityLevel.Error,\r\n    60: Contracts_1.SeverityLevel.Critical,\r\n};\r\nvar subscriber = function (event) {\r\n    var message = event.data.result;\r\n    clients.forEach(function (client) {\r\n        var AIlevel = bunyanToAILevelMap[event.data.level];\r\n        if (message instanceof Error) {\r\n            client.trackException({ exception: (message) });\r\n        }\r\n        else {\r\n            client.trackTrace({ message: message, severity: AIlevel });\r\n        }\r\n    });\r\n};\r\nfunction enable(enabled, client) {\r\n    if (enabled) {\r\n        if (clients.length === 0) {\r\n            diagnostic_channel_1.channel.subscribe(\"bunyan\", subscriber);\r\n        }\r\n        ;\r\n        clients.push(client);\r\n    }\r\n    else {\r\n        clients = clients.filter(function (c) { return c != client; });\r\n        if (clients.length === 0) {\r\n            diagnostic_channel_1.channel.unsubscribe(\"bunyan\", subscriber);\r\n        }\r\n    }\r\n}\r\nexports.enable = enable;\r\nfunction dispose() {\r\n    diagnostic_channel_1.channel.unsubscribe(\"bunyan\", subscriber);\r\n    clients = [];\r\n}\r\nexports.dispose = dispose;\r\n//# sourceMappingURL=bunyan.sub.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar Contracts_1 = require(\"../../Declarations/Contracts\");\r\nvar diagnostic_channel_1 = require(\"diagnostic-channel\");\r\nvar clients = [];\r\nvar subscriber = function (event) {\r\n    var message = event.data.message;\r\n    clients.forEach(function (client) {\r\n        if (message instanceof Error) {\r\n            client.trackException({ exception: message });\r\n        }\r\n        else {\r\n            // Message can have a trailing newline\r\n            if (message.lastIndexOf(\"\\n\") == message.length - 1) {\r\n                message = message.substring(0, message.length - 1);\r\n            }\r\n            client.trackTrace({ message: message, severity: (event.data.stderr ? Contracts_1.SeverityLevel.Warning : Contracts_1.SeverityLevel.Information) });\r\n        }\r\n    });\r\n};\r\nfunction enable(enabled, client) {\r\n    if (enabled) {\r\n        if (clients.length === 0) {\r\n            diagnostic_channel_1.channel.subscribe(\"console\", subscriber);\r\n        }\r\n        ;\r\n        clients.push(client);\r\n    }\r\n    else {\r\n        clients = clients.filter(function (c) { return c != client; });\r\n        if (clients.length === 0) {\r\n            diagnostic_channel_1.channel.unsubscribe(\"console\", subscriber);\r\n        }\r\n    }\r\n}\r\nexports.enable = enable;\r\nfunction dispose() {\r\n    diagnostic_channel_1.channel.unsubscribe(\"console\", subscriber);\r\n    clients = [];\r\n}\r\nexports.dispose = dispose;\r\n//# sourceMappingURL=console.sub.js.map","\"use strict\";\r\n// Copyright (c) Microsoft Corporation. All rights reserved.\r\n// Licensed under the MIT license. See LICENSE file in the project root for details.\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.IsInitialized = !process.env[\"APPLICATION_INSIGHTS_NO_DIAGNOSTIC_CHANNEL\"];\r\nif (exports.IsInitialized) {\r\n    var publishers = require(\"diagnostic-channel-publishers\");\r\n    var individualOptOuts = process.env[\"APPLICATION_INSIGHTS_NO_PATCH_MODULES\"] || \"\";\r\n    var unpatchedModules = individualOptOuts.split(\",\");\r\n    var modules = {\r\n        bunyan: publishers.bunyan,\r\n        console: publishers.console,\r\n        mongodb: publishers.mongodb,\r\n        mongodbCore: publishers.mongodbCore,\r\n        mysql: publishers.mysql,\r\n        redis: publishers.redis,\r\n        pg: publishers.pg,\r\n        pgPool: publishers.pgPool,\r\n        winston: publishers.winston\r\n    };\r\n    for (var mod in modules) {\r\n        if (unpatchedModules.indexOf(mod) === -1) {\r\n            modules[mod].enable();\r\n        }\r\n    }\r\n}\r\nfunction registerContextPreservation(cb) {\r\n    if (!exports.IsInitialized) {\r\n        return;\r\n    }\r\n    require(\"diagnostic-channel\").channel.addContextPreservation(cb);\r\n}\r\nexports.registerContextPreservation = registerContextPreservation;\r\n//# sourceMappingURL=initialization.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar diagnostic_channel_1 = require(\"diagnostic-channel\");\r\nvar clients = [];\r\nexports.subscriber = function (event) {\r\n    clients.forEach(function (client) {\r\n        var dbName = (event.data.startedData && event.data.startedData.databaseName) || \"Unknown database\";\r\n        client.trackDependency({\r\n            target: dbName,\r\n            data: event.data.event.commandName,\r\n            name: event.data.event.commandName,\r\n            duration: event.data.event.duration,\r\n            success: event.data.succeeded,\r\n            /* TODO: transmit result code from mongo */\r\n            resultCode: event.data.succeeded ? \"0\" : \"1\",\r\n            dependencyTypeName: 'mongodb'\r\n        });\r\n    });\r\n};\r\nfunction enable(enabled, client) {\r\n    if (enabled) {\r\n        if (clients.length === 0) {\r\n            diagnostic_channel_1.channel.subscribe(\"mongodb\", exports.subscriber);\r\n        }\r\n        ;\r\n        clients.push(client);\r\n    }\r\n    else {\r\n        clients = clients.filter(function (c) { return c != client; });\r\n        if (clients.length === 0) {\r\n            diagnostic_channel_1.channel.unsubscribe(\"mongodb\", exports.subscriber);\r\n        }\r\n    }\r\n}\r\nexports.enable = enable;\r\n//# sourceMappingURL=mongodb.sub.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar diagnostic_channel_1 = require(\"diagnostic-channel\");\r\nvar clients = [];\r\nexports.subscriber = function (event) {\r\n    clients.forEach(function (client) {\r\n        var queryObj = event.data.query || {};\r\n        var sqlString = queryObj.sql || \"Unknown query\";\r\n        var success = !event.data.err;\r\n        var connection = queryObj._connection || {};\r\n        var connectionConfig = connection.config || {};\r\n        var dbName = connectionConfig.socketPath ? connectionConfig.socketPath : (connectionConfig.host || \"localhost\") + \":\" + connectionConfig.port;\r\n        client.trackDependency({\r\n            target: dbName,\r\n            data: sqlString,\r\n            name: sqlString,\r\n            duration: event.data.duration,\r\n            success: success,\r\n            /* TODO: transmit result code from mysql */\r\n            resultCode: success ? \"0\" : \"1\",\r\n            dependencyTypeName: \"mysql\"\r\n        });\r\n    });\r\n};\r\nfunction enable(enabled, client) {\r\n    if (enabled) {\r\n        if (clients.length === 0) {\r\n            diagnostic_channel_1.channel.subscribe(\"mysql\", exports.subscriber);\r\n        }\r\n        ;\r\n        clients.push(client);\r\n    }\r\n    else {\r\n        clients = clients.filter(function (c) { return c != client; });\r\n        if (clients.length === 0) {\r\n            diagnostic_channel_1.channel.unsubscribe(\"mysql\", exports.subscriber);\r\n        }\r\n    }\r\n}\r\nexports.enable = enable;\r\n//# sourceMappingURL=mysql.sub.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar diagnostic_channel_1 = require(\"diagnostic-channel\");\r\nvar clients = [];\r\nexports.subscriber = function (event) {\r\n    clients.forEach(function (client) {\r\n        var q = event.data.query;\r\n        var sql = (q.preparable && q.preparable.text) || q.plan || q.text || \"unknown query\";\r\n        var success = !event.data.error;\r\n        var conn = event.data.database.host + \":\" + event.data.database.port;\r\n        client.trackDependency({\r\n            target: conn,\r\n            data: sql,\r\n            name: sql,\r\n            duration: event.data.duration,\r\n            success: success,\r\n            resultCode: success ? \"0\" : \"1\",\r\n            dependencyTypeName: \"postgres\"\r\n        });\r\n    });\r\n};\r\nfunction enable(enabled, client) {\r\n    if (enabled) {\r\n        if (clients.length === 0) {\r\n            diagnostic_channel_1.channel.subscribe(\"postgres\", exports.subscriber);\r\n        }\r\n        ;\r\n        clients.push(client);\r\n    }\r\n    else {\r\n        clients = clients.filter(function (c) { return c != client; });\r\n        if (clients.length === 0) {\r\n            diagnostic_channel_1.channel.unsubscribe(\"postgres\", exports.subscriber);\r\n        }\r\n    }\r\n}\r\nexports.enable = enable;\r\n//# sourceMappingURL=postgres.sub.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar diagnostic_channel_1 = require(\"diagnostic-channel\");\r\nvar clients = [];\r\nexports.subscriber = function (event) {\r\n    clients.forEach(function (client) {\r\n        if (event.data.commandObj.command === \"info\") {\r\n            // We don't want to report 'info', it's irrelevant\r\n            return;\r\n        }\r\n        client.trackDependency({\r\n            target: event.data.address,\r\n            name: event.data.commandObj.command,\r\n            data: event.data.commandObj.command,\r\n            duration: event.data.duration,\r\n            success: !event.data.err,\r\n            /* TODO: transmit result code from redis */\r\n            resultCode: event.data.err ? \"1\" : \"0\",\r\n            dependencyTypeName: \"redis\"\r\n        });\r\n    });\r\n};\r\nfunction enable(enabled, client) {\r\n    if (enabled) {\r\n        if (clients.length === 0) {\r\n            diagnostic_channel_1.channel.subscribe(\"redis\", exports.subscriber);\r\n        }\r\n        ;\r\n        clients.push(client);\r\n    }\r\n    else {\r\n        clients = clients.filter(function (c) { return c != client; });\r\n        if (clients.length === 0) {\r\n            diagnostic_channel_1.channel.unsubscribe(\"redis\", exports.subscriber);\r\n        }\r\n    }\r\n}\r\nexports.enable = enable;\r\n//# sourceMappingURL=redis.sub.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar Contracts_1 = require(\"../../Declarations/Contracts\");\r\nvar diagnostic_channel_1 = require(\"diagnostic-channel\");\r\nvar clients = [];\r\nvar winstonToAILevelMap = {\r\n    syslog: function (og) {\r\n        var map = {\r\n            emerg: Contracts_1.SeverityLevel.Critical,\r\n            alert: Contracts_1.SeverityLevel.Critical,\r\n            crit: Contracts_1.SeverityLevel.Critical,\r\n            error: Contracts_1.SeverityLevel.Error,\r\n            warning: Contracts_1.SeverityLevel.Warning,\r\n            notice: Contracts_1.SeverityLevel.Information,\r\n            info: Contracts_1.SeverityLevel.Information,\r\n            debug: Contracts_1.SeverityLevel.Verbose\r\n        };\r\n        return map[og] === undefined ? Contracts_1.SeverityLevel.Information : map[og];\r\n    },\r\n    npm: function (og) {\r\n        var map = {\r\n            error: Contracts_1.SeverityLevel.Error,\r\n            warn: Contracts_1.SeverityLevel.Warning,\r\n            info: Contracts_1.SeverityLevel.Information,\r\n            verbose: Contracts_1.SeverityLevel.Verbose,\r\n            debug: Contracts_1.SeverityLevel.Verbose,\r\n            silly: Contracts_1.SeverityLevel.Verbose\r\n        };\r\n        return map[og] === undefined ? Contracts_1.SeverityLevel.Information : map[og];\r\n    },\r\n    unknown: function (og) {\r\n        return Contracts_1.SeverityLevel.Information;\r\n    }\r\n};\r\nvar subscriber = function (event) {\r\n    var message = event.data.message;\r\n    clients.forEach(function (client) {\r\n        if (message instanceof Error) {\r\n            client.trackException({\r\n                exception: message,\r\n                properties: event.data.meta\r\n            });\r\n        }\r\n        else {\r\n            var AIlevel = winstonToAILevelMap[event.data.levelKind](event.data.level);\r\n            client.trackTrace({\r\n                message: message,\r\n                severity: AIlevel,\r\n                properties: event.data.meta\r\n            });\r\n        }\r\n    });\r\n};\r\nfunction enable(enabled, client) {\r\n    if (enabled) {\r\n        if (clients.length === 0) {\r\n            diagnostic_channel_1.channel.subscribe(\"winston\", subscriber);\r\n        }\r\n        ;\r\n        clients.push(client);\r\n    }\r\n    else {\r\n        clients = clients.filter(function (c) { return c != client; });\r\n        if (clients.length === 0) {\r\n            diagnostic_channel_1.channel.unsubscribe(\"winston\", subscriber);\r\n        }\r\n    }\r\n}\r\nexports.enable = enable;\r\nfunction dispose() {\r\n    diagnostic_channel_1.channel.unsubscribe(\"winston\", subscriber);\r\n    clients = [];\r\n}\r\nexports.dispose = dispose;\r\n//# sourceMappingURL=winston.sub.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.DEFAULT_BREEZE_ENDPOINT = \"https://dc.services.visualstudio.com\";\r\nexports.DEFAULT_LIVEMETRICS_ENDPOINT = \"https://rt.services.visualstudio.com\";\r\nexports.DEFAULT_LIVEMETRICS_HOST = \"rt.services.visualstudio.com\";\r\nvar QuickPulseCounter;\r\n(function (QuickPulseCounter) {\r\n    // Memory\r\n    QuickPulseCounter[\"COMMITTED_BYTES\"] = \"\\\\Memory\\\\Committed Bytes\";\r\n    // CPU\r\n    QuickPulseCounter[\"PROCESSOR_TIME\"] = \"\\\\Processor(_Total)\\\\% Processor Time\";\r\n    // Request\r\n    QuickPulseCounter[\"REQUEST_RATE\"] = \"\\\\ApplicationInsights\\\\Requests/Sec\";\r\n    QuickPulseCounter[\"REQUEST_FAILURE_RATE\"] = \"\\\\ApplicationInsights\\\\Requests Failed/Sec\";\r\n    QuickPulseCounter[\"REQUEST_DURATION\"] = \"\\\\ApplicationInsights\\\\Request Duration\";\r\n    // Dependency\r\n    QuickPulseCounter[\"DEPENDENCY_RATE\"] = \"\\\\ApplicationInsights\\\\Dependency Calls/Sec\";\r\n    QuickPulseCounter[\"DEPENDENCY_FAILURE_RATE\"] = \"\\\\ApplicationInsights\\\\Dependency Calls Failed/Sec\";\r\n    QuickPulseCounter[\"DEPENDENCY_DURATION\"] = \"\\\\ApplicationInsights\\\\Dependency Call Duration\";\r\n    // Exception\r\n    QuickPulseCounter[\"EXCEPTION_RATE\"] = \"\\\\ApplicationInsights\\\\Exceptions/Sec\";\r\n})(QuickPulseCounter = exports.QuickPulseCounter || (exports.QuickPulseCounter = {}));\r\nvar PerformanceCounter;\r\n(function (PerformanceCounter) {\r\n    // Memory\r\n    PerformanceCounter[\"PRIVATE_BYTES\"] = \"\\\\Process(??APP_WIN32_PROC??)\\\\Private Bytes\";\r\n    PerformanceCounter[\"AVAILABLE_BYTES\"] = \"\\\\Memory\\\\Available Bytes\";\r\n    // CPU\r\n    PerformanceCounter[\"PROCESSOR_TIME\"] = \"\\\\Processor(_Total)\\\\% Processor Time\";\r\n    PerformanceCounter[\"PROCESS_TIME\"] = \"\\\\Process(??APP_WIN32_PROC??)\\\\% Processor Time\";\r\n    // Requests\r\n    PerformanceCounter[\"REQUEST_RATE\"] = \"\\\\ASP.NET Applications(??APP_W3SVC_PROC??)\\\\Requests/Sec\";\r\n    PerformanceCounter[\"REQUEST_DURATION\"] = \"\\\\ASP.NET Applications(??APP_W3SVC_PROC??)\\\\Request Execution Time\";\r\n})(PerformanceCounter = exports.PerformanceCounter || (exports.PerformanceCounter = {}));\r\n;\r\n/**\r\n * Map a PerformanceCounter/QuickPulseCounter to a QuickPulseCounter. If no mapping exists, mapping is *undefined*\r\n */\r\nexports.PerformanceToQuickPulseCounter = (_a = {},\r\n    _a[PerformanceCounter.PROCESSOR_TIME] = QuickPulseCounter.PROCESSOR_TIME,\r\n    _a[PerformanceCounter.REQUEST_RATE] = QuickPulseCounter.REQUEST_RATE,\r\n    _a[PerformanceCounter.REQUEST_DURATION] = QuickPulseCounter.REQUEST_DURATION,\r\n    // Remap quick pulse only counters\r\n    _a[QuickPulseCounter.COMMITTED_BYTES] = QuickPulseCounter.COMMITTED_BYTES,\r\n    _a[QuickPulseCounter.REQUEST_FAILURE_RATE] = QuickPulseCounter.REQUEST_FAILURE_RATE,\r\n    _a[QuickPulseCounter.DEPENDENCY_RATE] = QuickPulseCounter.DEPENDENCY_RATE,\r\n    _a[QuickPulseCounter.DEPENDENCY_FAILURE_RATE] = QuickPulseCounter.DEPENDENCY_FAILURE_RATE,\r\n    _a[QuickPulseCounter.DEPENDENCY_DURATION] = QuickPulseCounter.DEPENDENCY_DURATION,\r\n    _a[QuickPulseCounter.EXCEPTION_RATE] = QuickPulseCounter.EXCEPTION_RATE,\r\n    _a);\r\nexports.QuickPulseDocumentType = {\r\n    Event: \"Event\",\r\n    Exception: \"Exception\",\r\n    Trace: \"Trace\",\r\n    Metric: \"Metric\",\r\n    Request: \"Request\",\r\n    Dependency: \"RemoteDependency\",\r\n    Availability: \"Availability\"\r\n};\r\nexports.QuickPulseType = {\r\n    Event: \"EventTelemetryDocument\",\r\n    Exception: \"ExceptionTelemetryDocument\",\r\n    Trace: \"TraceTelemetryDocument\",\r\n    Metric: \"MetricTelemetryDocument\",\r\n    Request: \"RequestTelemetryDocument\",\r\n    Dependency: \"DependencyTelemetryDocument\",\r\n    Availability: \"AvailabilityTelemetryDocument\"\r\n};\r\nexports.TelemetryTypeStringToQuickPulseType = {\r\n    EventData: exports.QuickPulseType.Event,\r\n    ExceptionData: exports.QuickPulseType.Exception,\r\n    MessageData: exports.QuickPulseType.Trace,\r\n    MetricData: exports.QuickPulseType.Metric,\r\n    RequestData: exports.QuickPulseType.Request,\r\n    RemoteDependencyData: exports.QuickPulseType.Dependency,\r\n    AvailabilityData: exports.QuickPulseType.Availability\r\n};\r\nexports.TelemetryTypeStringToQuickPulseDocumentType = {\r\n    EventData: exports.QuickPulseDocumentType.Event,\r\n    ExceptionData: exports.QuickPulseDocumentType.Exception,\r\n    MessageData: exports.QuickPulseDocumentType.Trace,\r\n    MetricData: exports.QuickPulseDocumentType.Metric,\r\n    RequestData: exports.QuickPulseDocumentType.Request,\r\n    RemoteDependencyData: exports.QuickPulseDocumentType.Dependency,\r\n    AvailabilityData: exports.QuickPulseDocumentType.Availability\r\n};\r\nvar _a;\r\n//# sourceMappingURL=Constants.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar Generated_1 = require(\"./Generated\");\r\nvar RemoteDependencyDataConstants = (function () {\r\n    function RemoteDependencyDataConstants() {\r\n    }\r\n    RemoteDependencyDataConstants.TYPE_HTTP = \"Http\";\r\n    RemoteDependencyDataConstants.TYPE_AI = \"Http (tracked component)\";\r\n    return RemoteDependencyDataConstants;\r\n}());\r\nexports.RemoteDependencyDataConstants = RemoteDependencyDataConstants;\r\nfunction domainSupportsProperties(domain) {\r\n    return \"properties\" in domain ||\r\n        domain instanceof Generated_1.EventData ||\r\n        domain instanceof Generated_1.ExceptionData ||\r\n        domain instanceof Generated_1.MessageData ||\r\n        domain instanceof Generated_1.MetricData ||\r\n        domain instanceof Generated_1.PageViewData ||\r\n        domain instanceof Generated_1.RemoteDependencyData ||\r\n        domain instanceof Generated_1.RequestData;\r\n}\r\nexports.domainSupportsProperties = domainSupportsProperties;\r\n//# sourceMappingURL=Constants.js.map","\"use strict\";\r\nvar __extends = (this && this.__extends) || (function () {\r\n    var extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\n// THIS FILE WAS AUTOGENERATED\r\nvar Domain = require(\"./Domain\");\r\n\"use strict\";\r\n/**\r\n * Instances of AvailabilityData represent the result of executing an availability test.\r\n */\r\nvar AvailabilityData = (function (_super) {\r\n    __extends(AvailabilityData, _super);\r\n    function AvailabilityData() {\r\n        var _this = _super.call(this) || this;\r\n        _this.ver = 2;\r\n        _this.properties = {};\r\n        _this.measurements = {};\r\n        return _this;\r\n    }\r\n    return AvailabilityData;\r\n}(Domain));\r\nmodule.exports = AvailabilityData;\r\n//# sourceMappingURL=AvailabilityData.js.map","// THIS FILE WAS AUTOGENERATED\r\n\"use strict\";\r\n/**\r\n * Data struct to contain only C section with custom fields.\r\n */\r\nvar Base = (function () {\r\n    function Base() {\r\n    }\r\n    return Base;\r\n}());\r\nmodule.exports = Base;\r\n//# sourceMappingURL=Base.js.map","// THIS FILE WAS AUTOGENERATED\r\n\"use strict\";\r\nvar ContextTagKeys = (function () {\r\n    function ContextTagKeys() {\r\n        this.applicationVersion = \"ai.application.ver\";\r\n        this.deviceId = \"ai.device.id\";\r\n        this.deviceLocale = \"ai.device.locale\";\r\n        this.deviceModel = \"ai.device.model\";\r\n        this.deviceOEMName = \"ai.device.oemName\";\r\n        this.deviceOSVersion = \"ai.device.osVersion\";\r\n        this.deviceType = \"ai.device.type\";\r\n        this.locationIp = \"ai.location.ip\";\r\n        this.operationId = \"ai.operation.id\";\r\n        this.operationName = \"ai.operation.name\";\r\n        this.operationParentId = \"ai.operation.parentId\";\r\n        this.operationSyntheticSource = \"ai.operation.syntheticSource\";\r\n        this.operationCorrelationVector = \"ai.operation.correlationVector\";\r\n        this.sessionId = \"ai.session.id\";\r\n        this.sessionIsFirst = \"ai.session.isFirst\";\r\n        this.userAccountId = \"ai.user.accountId\";\r\n        this.userId = \"ai.user.id\";\r\n        this.userAuthUserId = \"ai.user.authUserId\";\r\n        this.cloudRole = \"ai.cloud.role\";\r\n        this.cloudRoleInstance = \"ai.cloud.roleInstance\";\r\n        this.internalSdkVersion = \"ai.internal.sdkVersion\";\r\n        this.internalAgentVersion = \"ai.internal.agentVersion\";\r\n        this.internalNodeName = \"ai.internal.nodeName\";\r\n    }\r\n    return ContextTagKeys;\r\n}());\r\nmodule.exports = ContextTagKeys;\r\n//# sourceMappingURL=ContextTagKeys.js.map","\"use strict\";\r\nvar __extends = (this && this.__extends) || (function () {\r\n    var extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\n// THIS FILE WAS AUTOGENERATED\r\nvar Base = require(\"./Base\");\r\n\"use strict\";\r\n/**\r\n * Data struct to contain both B and C sections.\r\n */\r\nvar Data = (function (_super) {\r\n    __extends(Data, _super);\r\n    function Data() {\r\n        return _super.call(this) || this;\r\n    }\r\n    return Data;\r\n}(Base));\r\nmodule.exports = Data;\r\n//# sourceMappingURL=Data.js.map","\"use strict\";\r\n// THIS FILE WAS AUTOGENERATED\r\nvar DataPointType = require(\"./DataPointType\");\r\n\"use strict\";\r\n/**\r\n * Metric data single measurement.\r\n */\r\nvar DataPoint = (function () {\r\n    function DataPoint() {\r\n        this.kind = DataPointType.Measurement;\r\n    }\r\n    return DataPoint;\r\n}());\r\nmodule.exports = DataPoint;\r\n//# sourceMappingURL=DataPoint.js.map","// THIS FILE WAS AUTOGENERATED\r\n\"use strict\";\r\n/**\r\n * Type of the metric data measurement.\r\n */\r\nvar DataPointType;\r\n(function (DataPointType) {\r\n    DataPointType[DataPointType[\"Measurement\"] = 0] = \"Measurement\";\r\n    DataPointType[DataPointType[\"Aggregation\"] = 1] = \"Aggregation\";\r\n})(DataPointType || (DataPointType = {}));\r\nmodule.exports = DataPointType;\r\n//# sourceMappingURL=DataPointType.js.map","// THIS FILE WAS AUTOGENERATED\r\n\"use strict\";\r\n/**\r\n * The abstract common base of all domains.\r\n */\r\nvar Domain = (function () {\r\n    function Domain() {\r\n    }\r\n    return Domain;\r\n}());\r\nmodule.exports = Domain;\r\n//# sourceMappingURL=Domain.js.map","\"use strict\";\r\n/**\r\n * System variables for a telemetry item.\r\n */\r\nvar Envelope = (function () {\r\n    function Envelope() {\r\n        this.ver = 1;\r\n        this.sampleRate = 100.0;\r\n        this.tags = {};\r\n    }\r\n    return Envelope;\r\n}());\r\nmodule.exports = Envelope;\r\n//# sourceMappingURL=Envelope.js.map","\"use strict\";\r\nvar __extends = (this && this.__extends) || (function () {\r\n    var extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\n// THIS FILE WAS AUTOGENERATED\r\nvar Domain = require(\"./Domain\");\r\n\"use strict\";\r\n/**\r\n * Instances of Event represent structured event records that can be grouped and searched by their properties. Event data item also creates a metric of event count by name.\r\n */\r\nvar EventData = (function (_super) {\r\n    __extends(EventData, _super);\r\n    function EventData() {\r\n        var _this = _super.call(this) || this;\r\n        _this.ver = 2;\r\n        _this.properties = {};\r\n        _this.measurements = {};\r\n        return _this;\r\n    }\r\n    return EventData;\r\n}(Domain));\r\nmodule.exports = EventData;\r\n//# sourceMappingURL=EventData.js.map","\"use strict\";\r\nvar __extends = (this && this.__extends) || (function () {\r\n    var extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\n// THIS FILE WAS AUTOGENERATED\r\nvar Domain = require(\"./Domain\");\r\n\"use strict\";\r\n/**\r\n * An instance of Exception represents a handled or unhandled exception that occurred during execution of the monitored application.\r\n */\r\nvar ExceptionData = (function (_super) {\r\n    __extends(ExceptionData, _super);\r\n    function ExceptionData() {\r\n        var _this = _super.call(this) || this;\r\n        _this.ver = 2;\r\n        _this.exceptions = [];\r\n        _this.properties = {};\r\n        _this.measurements = {};\r\n        return _this;\r\n    }\r\n    return ExceptionData;\r\n}(Domain));\r\nmodule.exports = ExceptionData;\r\n//# sourceMappingURL=ExceptionData.js.map","\"use strict\";\r\n/**\r\n * Exception details of the exception in a chain.\r\n */\r\nvar ExceptionDetails = (function () {\r\n    function ExceptionDetails() {\r\n        this.hasFullStack = true;\r\n        this.parsedStack = [];\r\n    }\r\n    return ExceptionDetails;\r\n}());\r\nmodule.exports = ExceptionDetails;\r\n//# sourceMappingURL=ExceptionDetails.js.map","\"use strict\";\r\nvar __extends = (this && this.__extends) || (function () {\r\n    var extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\n// THIS FILE WAS AUTOGENERATED\r\nvar Domain = require(\"./Domain\");\r\n\"use strict\";\r\n/**\r\n * Instances of Message represent printf-like trace statements that are text-searched. Log4Net, NLog and other text-based log file entries are translated into intances of this type. The message does not have measurements.\r\n */\r\nvar MessageData = (function (_super) {\r\n    __extends(MessageData, _super);\r\n    function MessageData() {\r\n        var _this = _super.call(this) || this;\r\n        _this.ver = 2;\r\n        _this.properties = {};\r\n        return _this;\r\n    }\r\n    return MessageData;\r\n}(Domain));\r\nmodule.exports = MessageData;\r\n//# sourceMappingURL=MessageData.js.map","\"use strict\";\r\nvar __extends = (this && this.__extends) || (function () {\r\n    var extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\n// THIS FILE WAS AUTOGENERATED\r\nvar Domain = require(\"./Domain\");\r\n\"use strict\";\r\n/**\r\n * An instance of the Metric item is a list of measurements (single data points) and/or aggregations.\r\n */\r\nvar MetricData = (function (_super) {\r\n    __extends(MetricData, _super);\r\n    function MetricData() {\r\n        var _this = _super.call(this) || this;\r\n        _this.ver = 2;\r\n        _this.metrics = [];\r\n        _this.properties = {};\r\n        return _this;\r\n    }\r\n    return MetricData;\r\n}(Domain));\r\nmodule.exports = MetricData;\r\n//# sourceMappingURL=MetricData.js.map","\"use strict\";\r\nvar __extends = (this && this.__extends) || (function () {\r\n    var extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\n// THIS FILE WAS AUTOGENERATED\r\nvar EventData = require(\"./EventData\");\r\n\"use strict\";\r\n/**\r\n * An instance of PageView represents a generic action on a page like a button click. It is also the base type for PageView.\r\n */\r\nvar PageViewData = (function (_super) {\r\n    __extends(PageViewData, _super);\r\n    function PageViewData() {\r\n        var _this = _super.call(this) || this;\r\n        _this.ver = 2;\r\n        _this.properties = {};\r\n        _this.measurements = {};\r\n        return _this;\r\n    }\r\n    return PageViewData;\r\n}(EventData));\r\nmodule.exports = PageViewData;\r\n//# sourceMappingURL=PageViewData.js.map","\"use strict\";\r\nvar __extends = (this && this.__extends) || (function () {\r\n    var extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\n// THIS FILE WAS AUTOGENERATED\r\nvar Domain = require(\"./Domain\");\r\n\"use strict\";\r\n/**\r\n * An instance of Remote Dependency represents an interaction of the monitored component with a remote component/service like SQL or an HTTP endpoint.\r\n */\r\nvar RemoteDependencyData = (function (_super) {\r\n    __extends(RemoteDependencyData, _super);\r\n    function RemoteDependencyData() {\r\n        var _this = _super.call(this) || this;\r\n        _this.ver = 2;\r\n        _this.success = true;\r\n        _this.properties = {};\r\n        _this.measurements = {};\r\n        return _this;\r\n    }\r\n    return RemoteDependencyData;\r\n}(Domain));\r\nmodule.exports = RemoteDependencyData;\r\n//# sourceMappingURL=RemoteDependencyData.js.map","\"use strict\";\r\nvar __extends = (this && this.__extends) || (function () {\r\n    var extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\n// THIS FILE WAS AUTOGENERATED\r\nvar Domain = require(\"./Domain\");\r\n\"use strict\";\r\n/**\r\n * An instance of Request represents completion of an external request to the application to do work and contains a summary of that request execution and the results.\r\n */\r\nvar RequestData = (function (_super) {\r\n    __extends(RequestData, _super);\r\n    function RequestData() {\r\n        var _this = _super.call(this) || this;\r\n        _this.ver = 2;\r\n        _this.properties = {};\r\n        _this.measurements = {};\r\n        return _this;\r\n    }\r\n    return RequestData;\r\n}(Domain));\r\nmodule.exports = RequestData;\r\n//# sourceMappingURL=RequestData.js.map","// THIS FILE WAS AUTOGENERATED\r\n\"use strict\";\r\n/**\r\n * Defines the level of severity for the event.\r\n */\r\nvar SeverityLevel;\r\n(function (SeverityLevel) {\r\n    SeverityLevel[SeverityLevel[\"Verbose\"] = 0] = \"Verbose\";\r\n    SeverityLevel[SeverityLevel[\"Information\"] = 1] = \"Information\";\r\n    SeverityLevel[SeverityLevel[\"Warning\"] = 2] = \"Warning\";\r\n    SeverityLevel[SeverityLevel[\"Error\"] = 3] = \"Error\";\r\n    SeverityLevel[SeverityLevel[\"Critical\"] = 4] = \"Critical\";\r\n})(SeverityLevel || (SeverityLevel = {}));\r\nmodule.exports = SeverityLevel;\r\n//# sourceMappingURL=SeverityLevel.js.map","// THIS FILE WAS AUTOGENERATED\r\n\"use strict\";\r\n/**\r\n * Stack frame information.\r\n */\r\nvar StackFrame = (function () {\r\n    function StackFrame() {\r\n    }\r\n    return StackFrame;\r\n}());\r\nmodule.exports = StackFrame;\r\n//# sourceMappingURL=StackFrame.js.map","// THIS FILE WAS AUTOGENERATED\r\n\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.AvailabilityData = require(\"./AvailabilityData\");\r\nexports.Base = require(\"./Base\");\r\nexports.ContextTagKeys = require(\"./ContextTagKeys\");\r\nexports.Data = require(\"./Data\");\r\nexports.DataPoint = require(\"./DataPoint\");\r\nexports.DataPointType = require(\"./DataPointType\");\r\nexports.Domain = require(\"./Domain\");\r\nexports.Envelope = require(\"./Envelope\");\r\nexports.EventData = require(\"./EventData\");\r\nexports.ExceptionData = require(\"./ExceptionData\");\r\nexports.ExceptionDetails = require(\"./ExceptionDetails\");\r\nexports.MessageData = require(\"./MessageData\");\r\nexports.MetricData = require(\"./MetricData\");\r\nexports.PageViewData = require(\"./PageViewData\");\r\nexports.RemoteDependencyData = require(\"./RemoteDependencyData\");\r\nexports.RequestData = require(\"./RequestData\");\r\nexports.SeverityLevel = require(\"./SeverityLevel\");\r\nexports.StackFrame = require(\"./StackFrame\");\r\n//# sourceMappingURL=index.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/**\r\n * Converts the user-friendly enumeration TelemetryType to the underlying schema baseType value\r\n * @param type Type to convert to BaseData string\r\n */\r\nfunction telemetryTypeToBaseType(type) {\r\n    switch (type) {\r\n        case TelemetryType.Event:\r\n            return \"EventData\";\r\n        case TelemetryType.Exception:\r\n            return \"ExceptionData\";\r\n        case TelemetryType.Trace:\r\n            return \"MessageData\";\r\n        case TelemetryType.Metric:\r\n            return \"MetricData\";\r\n        case TelemetryType.Request:\r\n            return \"RequestData\";\r\n        case TelemetryType.Dependency:\r\n            return \"RemoteDependencyData\";\r\n        case TelemetryType.Availability:\r\n            return \"AvailabilityData\";\r\n    }\r\n    return undefined;\r\n}\r\nexports.telemetryTypeToBaseType = telemetryTypeToBaseType;\r\n/**\r\n * Converts the schema baseType value to the user-friendly enumeration TelemetryType\r\n * @param baseType BaseData string to convert to TelemetryType\r\n */\r\nfunction baseTypeToTelemetryType(baseType) {\r\n    switch (baseType) {\r\n        case \"EventData\":\r\n            return TelemetryType.Event;\r\n        case \"ExceptionData\":\r\n            return TelemetryType.Exception;\r\n        case \"MessageData\":\r\n            return TelemetryType.Trace;\r\n        case \"MetricData\":\r\n            return TelemetryType.Metric;\r\n        case \"RequestData\":\r\n            return TelemetryType.Request;\r\n        case \"RemoteDependencyData\":\r\n            return TelemetryType.Dependency;\r\n        case \"AvailabilityData\":\r\n            return TelemetryType.Availability;\r\n    }\r\n    return undefined;\r\n}\r\nexports.baseTypeToTelemetryType = baseTypeToTelemetryType;\r\nexports.TelemetryTypeString = {\r\n    Event: \"EventData\",\r\n    Exception: \"ExceptionData\",\r\n    Trace: \"MessageData\",\r\n    Metric: \"MetricData\",\r\n    Request: \"RequestData\",\r\n    Dependency: \"RemoteDependencyData\",\r\n    Availability: \"AvailabilityData\"\r\n};\r\n/**\r\n * Telemetry types supported by this SDK\r\n */\r\nvar TelemetryType;\r\n(function (TelemetryType) {\r\n    TelemetryType[TelemetryType[\"Event\"] = 0] = \"Event\";\r\n    TelemetryType[TelemetryType[\"Exception\"] = 1] = \"Exception\";\r\n    TelemetryType[TelemetryType[\"Trace\"] = 2] = \"Trace\";\r\n    TelemetryType[TelemetryType[\"Metric\"] = 3] = \"Metric\";\r\n    TelemetryType[TelemetryType[\"Request\"] = 4] = \"Request\";\r\n    TelemetryType[TelemetryType[\"Dependency\"] = 5] = \"Dependency\";\r\n    TelemetryType[TelemetryType[\"Availability\"] = 6] = \"Availability\";\r\n})(TelemetryType = exports.TelemetryType || (exports.TelemetryType = {}));\r\n//# sourceMappingURL=TelemetryType.js.map","\"use strict\";\r\nfunction __export(m) {\r\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n__export(require(\"./TelemetryType\"));\r\n//# sourceMappingURL=index.js.map","\"use strict\";\r\nfunction __export(m) {\r\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n__export(require(\"./Constants\"));\r\n__export(require(\"./Generated\"));\r\n__export(require(\"./TelemetryTypes\"));\r\n//# sourceMappingURL=index.js.map","\"use strict\";\r\nvar Logging = require(\"./Logging\");\r\nvar Channel = (function () {\r\n    function Channel(isDisabled, getBatchSize, getBatchIntervalMs, sender) {\r\n        this._buffer = [];\r\n        this._lastSend = 0;\r\n        this._isDisabled = isDisabled;\r\n        this._getBatchSize = getBatchSize;\r\n        this._getBatchIntervalMs = getBatchIntervalMs;\r\n        this._sender = sender;\r\n    }\r\n    /**\r\n     * Enable or disable disk-backed retry caching to cache events when client is offline (enabled by default)\r\n     * These cached events are stored in your system or user's temporary directory and access restricted to your user when possible.\r\n     * @param value if true events that occured while client is offline will be cached on disk\r\n     * @param resendInterval The wait interval for resending cached events.\r\n     * @param maxBytesOnDisk The maximum size (in bytes) that the created temporary directory for cache events can grow to, before caching is disabled.\r\n     * @returns {Configuration} this class\r\n     */\r\n    Channel.prototype.setUseDiskRetryCaching = function (value, resendInterval, maxBytesOnDisk) {\r\n        this._sender.setDiskRetryMode(value, resendInterval, maxBytesOnDisk);\r\n    };\r\n    /**\r\n     * Add a telemetry item to the send buffer\r\n     */\r\n    Channel.prototype.send = function (envelope) {\r\n        var _this = this;\r\n        // if master off switch is set, don't send any data\r\n        if (this._isDisabled()) {\r\n            // Do not send/save data\r\n            return;\r\n        }\r\n        // validate input\r\n        if (!envelope) {\r\n            Logging.warn(\"Cannot send null/undefined telemetry\");\r\n            return;\r\n        }\r\n        // check if the incoming payload is too large, truncate if necessary\r\n        var payload = this._stringify(envelope);\r\n        if (typeof payload !== \"string\") {\r\n            return;\r\n        }\r\n        // enqueue the payload\r\n        this._buffer.push(payload);\r\n        // flush if we would exceed the max-size limit by adding this item\r\n        if (this._buffer.length >= this._getBatchSize()) {\r\n            this.triggerSend(false);\r\n            return;\r\n        }\r\n        // ensure an invocation timeout is set if anything is in the buffer\r\n        if (!this._timeoutHandle && this._buffer.length > 0) {\r\n            this._timeoutHandle = setTimeout(function () {\r\n                _this._timeoutHandle = null;\r\n                _this.triggerSend(false);\r\n            }, this._getBatchIntervalMs());\r\n        }\r\n    };\r\n    /**\r\n     * Immediately send buffered data\r\n     */\r\n    Channel.prototype.triggerSend = function (isNodeCrashing, callback) {\r\n        var bufferIsEmpty = this._buffer.length < 1;\r\n        if (!bufferIsEmpty) {\r\n            // compose an array of payloads\r\n            var batch = this._buffer.join(\"\\n\");\r\n            // invoke send\r\n            if (isNodeCrashing) {\r\n                this._sender.saveOnCrash(batch);\r\n                if (typeof callback === \"function\") {\r\n                    callback(\"data saved on crash\");\r\n                }\r\n            }\r\n            else {\r\n                this._sender.send(Buffer.from ? Buffer.from(batch) : new Buffer(batch), callback);\r\n            }\r\n        }\r\n        // update lastSend time to enable throttling\r\n        this._lastSend = +new Date;\r\n        // clear buffer\r\n        this._buffer.length = 0;\r\n        clearTimeout(this._timeoutHandle);\r\n        this._timeoutHandle = null;\r\n        if (bufferIsEmpty && typeof callback === \"function\") {\r\n            callback(\"no data to send\");\r\n        }\r\n    };\r\n    Channel.prototype._stringify = function (envelope) {\r\n        try {\r\n            return JSON.stringify(envelope);\r\n        }\r\n        catch (error) {\r\n            Logging.warn(\"Failed to serialize payload\", error, envelope);\r\n        }\r\n    };\r\n    return Channel;\r\n}());\r\nmodule.exports = Channel;\r\n//# sourceMappingURL=Channel.js.map","\"use strict\";\r\nvar CorrelationIdManager = require(\"./CorrelationIdManager\");\r\nvar ConnectionStringParser = require(\"./ConnectionStringParser\");\r\nvar Constants = require(\"../Declarations/Constants\");\r\nvar url = require(\"url\");\r\nvar Config = (function () {\r\n    function Config(setupString) {\r\n        var _this = this;\r\n        this.endpointBase = Constants.DEFAULT_BREEZE_ENDPOINT;\r\n        var connectionStringEnv = process.env[Config.ENV_connectionString];\r\n        var csCode = ConnectionStringParser.parse(setupString);\r\n        var csEnv = ConnectionStringParser.parse(connectionStringEnv);\r\n        var iKeyCode = !csCode.instrumentationkey && Object.keys(csCode).length > 0\r\n            ? null // CS was valid but instrumentation key was not provided, null and grab from env var\r\n            : setupString; // CS was invalid, so it must be an ikey\r\n        this.instrumentationKey = csCode.instrumentationkey || iKeyCode /* === instrumentationKey */ || csEnv.instrumentationkey || Config._getInstrumentationKey();\r\n        this.endpointUrl = (csCode.ingestionendpoint || csEnv.ingestionendpoint || this.endpointBase) + \"/v2/track\";\r\n        this.maxBatchSize = 250;\r\n        this.maxBatchIntervalMs = 15000;\r\n        this.disableAppInsights = false;\r\n        this.samplingPercentage = 100;\r\n        this.correlationIdRetryIntervalMs = 30 * 1000;\r\n        this.correlationHeaderExcludedDomains = [\r\n            \"*.core.windows.net\",\r\n            \"*.core.chinacloudapi.cn\",\r\n            \"*.core.cloudapi.de\",\r\n            \"*.core.usgovcloudapi.net\"\r\n        ];\r\n        this.setCorrelationId = function (correlationId) { return _this.correlationId = correlationId; };\r\n        this.profileQueryEndpoint = csCode.ingestionendpoint || csEnv.ingestionendpoint || process.env[Config.ENV_profileQueryEndpoint] || this.endpointBase;\r\n        this.proxyHttpUrl = process.env[Config.ENV_http_proxy] || undefined;\r\n        this.proxyHttpsUrl = process.env[Config.ENV_https_proxy] || undefined;\r\n        this.httpAgent = undefined;\r\n        this.httpsAgent = undefined;\r\n        this._quickPulseHost = csCode.liveendpoint || csEnv.liveendpoint || process.env[Config.ENV_quickPulseHost] || Constants.DEFAULT_LIVEMETRICS_HOST;\r\n        // Parse quickPulseHost if it startswith http(s)://\r\n        if (this._quickPulseHost.match(/^https?:\\/\\//)) {\r\n            this._quickPulseHost = url.parse(this._quickPulseHost).host;\r\n        }\r\n    }\r\n    Object.defineProperty(Config.prototype, \"profileQueryEndpoint\", {\r\n        get: function () {\r\n            return this._profileQueryEndpoint;\r\n        },\r\n        set: function (endpoint) {\r\n            CorrelationIdManager.cancelCorrelationIdQuery(this, this.setCorrelationId);\r\n            this._profileQueryEndpoint = endpoint;\r\n            this.correlationId = CorrelationIdManager.correlationIdPrefix; // Reset the correlationId while we wait for the new query\r\n            CorrelationIdManager.queryCorrelationId(this, this.setCorrelationId);\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(Config.prototype, \"quickPulseHost\", {\r\n        get: function () {\r\n            return this._quickPulseHost;\r\n        },\r\n        set: function (host) {\r\n            this._quickPulseHost = host;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Config._getInstrumentationKey = function () {\r\n        // check for both the documented env variable and the azure-prefixed variable\r\n        var iKey = process.env[Config.ENV_iKey]\r\n            || process.env[Config.ENV_azurePrefix + Config.ENV_iKey]\r\n            || process.env[Config.legacy_ENV_iKey]\r\n            || process.env[Config.ENV_azurePrefix + Config.legacy_ENV_iKey];\r\n        if (!iKey || iKey == \"\") {\r\n            throw new Error(\"Instrumentation key not found, pass the key in the config to this method or set the key in the environment variable APPINSIGHTS_INSTRUMENTATIONKEY before starting the server\");\r\n        }\r\n        return iKey;\r\n    };\r\n    // Azure adds this prefix to all environment variables\r\n    Config.ENV_azurePrefix = \"APPSETTING_\";\r\n    // This key is provided in the readme\r\n    Config.ENV_iKey = \"APPINSIGHTS_INSTRUMENTATIONKEY\";\r\n    Config.legacy_ENV_iKey = \"APPINSIGHTS_INSTRUMENTATION_KEY\";\r\n    Config.ENV_profileQueryEndpoint = \"APPINSIGHTS_PROFILE_QUERY_ENDPOINT\";\r\n    Config.ENV_quickPulseHost = \"APPINSIGHTS_QUICKPULSE_HOST\";\r\n    // Azure Connection String\r\n    Config.ENV_connectionString = \"APPLICATIONINSIGHTS_CONNECTION_STRING\";\r\n    // Native Metrics Opt Outs\r\n    Config.ENV_nativeMetricsDisablers = \"APPLICATION_INSIGHTS_DISABLE_EXTENDED_METRIC\";\r\n    Config.ENV_nativeMetricsDisableAll = \"APPLICATION_INSIGHTS_DISABLE_ALL_EXTENDED_METRICS\";\r\n    Config.ENV_http_proxy = \"http_proxy\";\r\n    Config.ENV_https_proxy = \"https_proxy\";\r\n    return Config;\r\n}());\r\nmodule.exports = Config;\r\n//# sourceMappingURL=Config.js.map","\"use strict\";\r\nvar Constants = require(\"../Declarations/Constants\");\r\nvar ConnectionStringParser = (function () {\r\n    function ConnectionStringParser() {\r\n    }\r\n    ConnectionStringParser.parse = function (connectionString) {\r\n        if (!connectionString) {\r\n            return {};\r\n        }\r\n        var kvPairs = connectionString.split(ConnectionStringParser._FIELDS_SEPARATOR);\r\n        var result = kvPairs.reduce(function (fields, kv) {\r\n            var kvParts = kv.split(ConnectionStringParser._FIELD_KEY_VALUE_SEPARATOR);\r\n            if (kvParts.length === 2) {\r\n                var key = kvParts[0].toLowerCase();\r\n                var value = kvParts[1];\r\n                fields[key] = value;\r\n            }\r\n            return fields;\r\n        }, {});\r\n        if (Object.keys(result).length > 0) {\r\n            // this is a valid connection string, so parse the results\r\n            if (result.endpointsuffix) {\r\n                // use endpoint suffix where overrides are not provided\r\n                var locationPrefix = result.location ? result.location + \".\" : \"\";\r\n                result.ingestionendpoint = result.ingestionendpoint || (\"https://\" + locationPrefix + \"dc.\" + result.endpointsuffix);\r\n                result.liveendpoint = result.liveendpoint || (\"https://\" + locationPrefix + \"live.\" + result.endpointsuffix);\r\n            }\r\n            // apply the default endpoints\r\n            result.ingestionendpoint = result.ingestionendpoint || Constants.DEFAULT_BREEZE_ENDPOINT;\r\n            result.liveendpoint = result.liveendpoint || Constants.DEFAULT_LIVEMETRICS_ENDPOINT;\r\n        }\r\n        return result;\r\n    };\r\n    ConnectionStringParser._FIELDS_SEPARATOR = \";\";\r\n    ConnectionStringParser._FIELD_KEY_VALUE_SEPARATOR = \"=\";\r\n    return ConnectionStringParser;\r\n}());\r\nmodule.exports = ConnectionStringParser;\r\n//# sourceMappingURL=ConnectionStringParser.js.map","\"use strict\";\r\nvar os = require(\"os\");\r\nvar fs = require(\"fs\");\r\nvar path = require(\"path\");\r\nvar Contracts = require(\"../Declarations/Contracts\");\r\nvar Logging = require(\"./Logging\");\r\nvar Context = (function () {\r\n    function Context(packageJsonPath) {\r\n        this.keys = new Contracts.ContextTagKeys();\r\n        this.tags = {};\r\n        this._loadApplicationContext();\r\n        this._loadDeviceContext();\r\n        this._loadInternalContext();\r\n    }\r\n    Context.prototype._loadApplicationContext = function (packageJsonPath) {\r\n        // note: this should return the host package.json\r\n        packageJsonPath = packageJsonPath || path.resolve(__dirname, \"../../../../package.json\");\r\n        if (!Context.appVersion[packageJsonPath]) {\r\n            Context.appVersion[packageJsonPath] = \"unknown\";\r\n            try {\r\n                var packageJson = JSON.parse(fs.readFileSync(packageJsonPath, \"utf8\"));\r\n                if (packageJson && typeof packageJson.version === \"string\") {\r\n                    Context.appVersion[packageJsonPath] = packageJson.version;\r\n                }\r\n            }\r\n            catch (exception) {\r\n                Logging.info(\"unable to read app version: \", exception);\r\n            }\r\n        }\r\n        this.tags[this.keys.applicationVersion] = Context.appVersion[packageJsonPath];\r\n    };\r\n    Context.prototype._loadDeviceContext = function () {\r\n        this.tags[this.keys.deviceId] = \"\";\r\n        this.tags[this.keys.cloudRoleInstance] = os && os.hostname();\r\n        this.tags[this.keys.deviceOSVersion] = os && (os.type() + \" \" + os.release());\r\n        this.tags[this.keys.cloudRole] = Context.DefaultRoleName;\r\n        // not yet supported tags\r\n        this.tags[\"ai.device.osArchitecture\"] = os && os.arch();\r\n        this.tags[\"ai.device.osPlatform\"] = os && os.platform();\r\n    };\r\n    Context.prototype._loadInternalContext = function () {\r\n        // note: this should return the sdk package.json\r\n        var packageJsonPath = path.resolve(__dirname, \"../../package.json\");\r\n        if (!Context.sdkVersion) {\r\n            Context.sdkVersion = \"unknown\";\r\n            try {\r\n                var packageJson = JSON.parse(fs.readFileSync(packageJsonPath, \"utf8\"));\r\n                if (packageJson && typeof packageJson.version === \"string\") {\r\n                    Context.sdkVersion = packageJson.version;\r\n                }\r\n            }\r\n            catch (exception) {\r\n                Logging.info(\"unable to read app version: \", exception);\r\n            }\r\n        }\r\n        this.tags[this.keys.internalSdkVersion] = \"node:\" + Context.sdkVersion;\r\n    };\r\n    Context.DefaultRoleName = \"Web\";\r\n    Context.appVersion = {};\r\n    Context.sdkVersion = null;\r\n    return Context;\r\n}());\r\nmodule.exports = Context;\r\n//# sourceMappingURL=Context.js.map","\"use strict\";\r\nvar Util = require(\"./Util\");\r\nvar Logging = require(\"./Logging\");\r\nvar CorrelationIdManager = (function () {\r\n    function CorrelationIdManager() {\r\n    }\r\n    CorrelationIdManager.queryCorrelationId = function (config, callback) {\r\n        // GET request to `${this.endpointBase}/api/profiles/${this.instrumentationKey}/appId`\r\n        // If it 404s, the iKey is bad and we should give up\r\n        // If it fails otherwise, try again later\r\n        var appIdUrlString = config.profileQueryEndpoint + \"/api/profiles/\" + config.instrumentationKey + \"/appId\";\r\n        if (CorrelationIdManager.completedLookups.hasOwnProperty(appIdUrlString)) {\r\n            callback(CorrelationIdManager.completedLookups[appIdUrlString]);\r\n            return;\r\n        }\r\n        else if (CorrelationIdManager.pendingLookups[appIdUrlString]) {\r\n            CorrelationIdManager.pendingLookups[appIdUrlString].push(callback);\r\n            return;\r\n        }\r\n        CorrelationIdManager.pendingLookups[appIdUrlString] = [callback];\r\n        var fetchAppId = function () {\r\n            if (!CorrelationIdManager.pendingLookups[appIdUrlString]) {\r\n                // This query has been cancelled.\r\n                return;\r\n            }\r\n            var requestOptions = {\r\n                method: 'GET',\r\n                // Ensure this request is not captured by auto-collection.\r\n                // Note: we don't refer to the property in HttpDependencyParser because that would cause a cyclical dependency\r\n                disableAppInsightsAutoCollection: true\r\n            };\r\n            Logging.info(CorrelationIdManager.TAG, requestOptions);\r\n            var req = Util.makeRequest(config, appIdUrlString, requestOptions, function (res) {\r\n                if (res.statusCode === 200) {\r\n                    // Success; extract the appId from the body\r\n                    var appId_1 = \"\";\r\n                    res.setEncoding(\"utf-8\");\r\n                    res.on('data', function (data) {\r\n                        appId_1 += data;\r\n                    });\r\n                    res.on('end', function () {\r\n                        Logging.info(CorrelationIdManager.TAG, appId_1);\r\n                        var result = CorrelationIdManager.correlationIdPrefix + appId_1;\r\n                        CorrelationIdManager.completedLookups[appIdUrlString] = result;\r\n                        if (CorrelationIdManager.pendingLookups[appIdUrlString]) {\r\n                            CorrelationIdManager.pendingLookups[appIdUrlString].forEach(function (cb) { return cb(result); });\r\n                        }\r\n                        delete CorrelationIdManager.pendingLookups[appIdUrlString];\r\n                    });\r\n                }\r\n                else if (res.statusCode >= 400 && res.statusCode < 500) {\r\n                    // Not found, probably a bad key. Do not try again.\r\n                    CorrelationIdManager.completedLookups[appIdUrlString] = undefined;\r\n                    delete CorrelationIdManager.pendingLookups[appIdUrlString];\r\n                }\r\n                else {\r\n                    // Retry after timeout.\r\n                    setTimeout(fetchAppId, config.correlationIdRetryIntervalMs);\r\n                }\r\n            });\r\n            if (req) {\r\n                req.on('error', function (error) {\r\n                    // Unable to contact endpoint.\r\n                    // Do nothing for now.\r\n                    Logging.warn(CorrelationIdManager.TAG, error);\r\n                });\r\n                req.end();\r\n            }\r\n        };\r\n        setTimeout(fetchAppId, 0);\r\n    };\r\n    CorrelationIdManager.cancelCorrelationIdQuery = function (config, callback) {\r\n        var appIdUrlString = config.profileQueryEndpoint + \"/api/profiles/\" + config.instrumentationKey + \"/appId\";\r\n        var pendingLookups = CorrelationIdManager.pendingLookups[appIdUrlString];\r\n        if (pendingLookups) {\r\n            CorrelationIdManager.pendingLookups[appIdUrlString] = pendingLookups.filter(function (cb) { return cb != callback; });\r\n            if (CorrelationIdManager.pendingLookups[appIdUrlString].length == 0) {\r\n                delete CorrelationIdManager.pendingLookups[appIdUrlString];\r\n            }\r\n        }\r\n    };\r\n    /**\r\n     * Generate a request Id according to https://github.com/lmolkova/correlation/blob/master/hierarchical_request_id.md\r\n     * @param parentId\r\n     */\r\n    CorrelationIdManager.generateRequestId = function (parentId) {\r\n        if (parentId) {\r\n            parentId = parentId[0] == '|' ? parentId : '|' + parentId;\r\n            if (parentId[parentId.length - 1] !== '.') {\r\n                parentId += '.';\r\n            }\r\n            var suffix = (CorrelationIdManager.currentRootId++).toString(16);\r\n            return CorrelationIdManager.appendSuffix(parentId, suffix, '_');\r\n        }\r\n        else {\r\n            return CorrelationIdManager.generateRootId();\r\n        }\r\n    };\r\n    /**\r\n     * Given a hierarchical identifier of the form |X.*\r\n     * return the root identifier X\r\n     * @param id\r\n     */\r\n    CorrelationIdManager.getRootId = function (id) {\r\n        var endIndex = id.indexOf('.');\r\n        if (endIndex < 0) {\r\n            endIndex = id.length;\r\n        }\r\n        var startIndex = id[0] === '|' ? 1 : 0;\r\n        return id.substring(startIndex, endIndex);\r\n    };\r\n    CorrelationIdManager.generateRootId = function () {\r\n        return '|' + Util.w3cTraceId() + '.';\r\n    };\r\n    CorrelationIdManager.appendSuffix = function (parentId, suffix, delimiter) {\r\n        if (parentId.length + suffix.length < CorrelationIdManager.requestIdMaxLength) {\r\n            return parentId + suffix + delimiter;\r\n        }\r\n        // Combined identifier would be too long, so we must truncate it.\r\n        // We need 9 characters of space: 8 for the overflow ID, 1 for the\r\n        // overflow delimiter '#'\r\n        var trimPosition = CorrelationIdManager.requestIdMaxLength - 9;\r\n        if (parentId.length > trimPosition) {\r\n            for (; trimPosition > 1; --trimPosition) {\r\n                var c = parentId[trimPosition - 1];\r\n                if (c === '.' || c === '_') {\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        if (trimPosition <= 1) {\r\n            // parentId is not a valid ID\r\n            return CorrelationIdManager.generateRootId();\r\n        }\r\n        suffix = Util.randomu32().toString(16);\r\n        while (suffix.length < 8) {\r\n            suffix = '0' + suffix;\r\n        }\r\n        return parentId.substring(0, trimPosition) + suffix + '#';\r\n    };\r\n    CorrelationIdManager.TAG = \"CorrelationIdManager\";\r\n    CorrelationIdManager.correlationIdPrefix = \"cid-v1:\";\r\n    CorrelationIdManager.w3cEnabled = false;\r\n    // To avoid extraneous HTTP requests, we maintain a queue of callbacks waiting on a particular appId lookup,\r\n    // as well as a cache of completed lookups so future requests can be resolved immediately.\r\n    CorrelationIdManager.pendingLookups = {};\r\n    CorrelationIdManager.completedLookups = {};\r\n    CorrelationIdManager.requestIdMaxLength = 1024;\r\n    CorrelationIdManager.currentRootId = Util.randomu32();\r\n    return CorrelationIdManager;\r\n}());\r\nmodule.exports = CorrelationIdManager;\r\n//# sourceMappingURL=CorrelationIdManager.js.map","\"use strict\";\r\nvar Contracts = require(\"../Declarations/Contracts\");\r\nvar Util = require(\"./Util\");\r\nvar CorrelationContextManager_1 = require(\"../AutoCollection/CorrelationContextManager\");\r\n/**\r\n * Manages the logic of creating envelopes from Telemetry objects\r\n */\r\nvar EnvelopeFactory = (function () {\r\n    function EnvelopeFactory() {\r\n    }\r\n    /**\r\n     * Creates envelope ready to be sent by Channel\r\n     * @param telemetry Telemetry data\r\n     * @param telemetryType Type of telemetry\r\n     * @param commonProperties Bag of custom common properties to be added to the envelope\r\n     * @param context Client context\r\n     * @param config Client configuration\r\n     */\r\n    EnvelopeFactory.createEnvelope = function (telemetry, telemetryType, commonProperties, context, config) {\r\n        var data = null;\r\n        switch (telemetryType) {\r\n            case Contracts.TelemetryType.Trace:\r\n                data = EnvelopeFactory.createTraceData(telemetry);\r\n                break;\r\n            case Contracts.TelemetryType.Dependency:\r\n                data = EnvelopeFactory.createDependencyData(telemetry);\r\n                break;\r\n            case Contracts.TelemetryType.Event:\r\n                data = EnvelopeFactory.createEventData(telemetry);\r\n                break;\r\n            case Contracts.TelemetryType.Exception:\r\n                data = EnvelopeFactory.createExceptionData(telemetry);\r\n                break;\r\n            case Contracts.TelemetryType.Request:\r\n                data = EnvelopeFactory.createRequestData(telemetry);\r\n                break;\r\n            case Contracts.TelemetryType.Metric:\r\n                data = EnvelopeFactory.createMetricData(telemetry);\r\n                break;\r\n            case Contracts.TelemetryType.Availability:\r\n                data = EnvelopeFactory.createAvailabilityData(telemetry);\r\n                break;\r\n        }\r\n        if (commonProperties && Contracts.domainSupportsProperties(data.baseData)) {\r\n            if (data && data.baseData) {\r\n                // if no properties are specified just add the common ones\r\n                if (!data.baseData.properties) {\r\n                    data.baseData.properties = commonProperties;\r\n                }\r\n                else {\r\n                    // otherwise, check each of the common ones\r\n                    for (var name in commonProperties) {\r\n                        // only override if the property `name` has not been set on this item\r\n                        if (!data.baseData.properties[name]) {\r\n                            data.baseData.properties[name] = commonProperties[name];\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            // sanitize properties\r\n            data.baseData.properties = Util.validateStringMap(data.baseData.properties);\r\n        }\r\n        var iKey = config ? config.instrumentationKey || \"\" : \"\";\r\n        var envelope = new Contracts.Envelope();\r\n        envelope.data = data;\r\n        envelope.iKey = iKey;\r\n        // this is kind of a hack, but the envelope name is always the same as the data name sans the chars \"data\"\r\n        envelope.name =\r\n            \"Microsoft.ApplicationInsights.\" +\r\n                iKey.replace(/-/g, \"\") +\r\n                \".\" +\r\n                data.baseType.substr(0, data.baseType.length - 4);\r\n        envelope.tags = this.getTags(context, telemetry.tagOverrides);\r\n        envelope.time = (new Date()).toISOString();\r\n        envelope.ver = 1;\r\n        envelope.sampleRate = config ? config.samplingPercentage : 100;\r\n        // Exclude metrics from sampling by default\r\n        if (telemetryType === Contracts.TelemetryType.Metric) {\r\n            envelope.sampleRate = 100;\r\n        }\r\n        return envelope;\r\n    };\r\n    EnvelopeFactory.createTraceData = function (telemetry) {\r\n        var trace = new Contracts.MessageData();\r\n        trace.message = telemetry.message;\r\n        trace.properties = telemetry.properties;\r\n        if (!isNaN(telemetry.severity)) {\r\n            trace.severityLevel = telemetry.severity;\r\n        }\r\n        else {\r\n            trace.severityLevel = Contracts.SeverityLevel.Information;\r\n        }\r\n        var data = new Contracts.Data();\r\n        data.baseType = Contracts.telemetryTypeToBaseType(Contracts.TelemetryType.Trace);\r\n        data.baseData = trace;\r\n        return data;\r\n    };\r\n    EnvelopeFactory.createDependencyData = function (telemetry) {\r\n        var remoteDependency = new Contracts.RemoteDependencyData();\r\n        remoteDependency.name = telemetry.name;\r\n        remoteDependency.data = telemetry.data;\r\n        remoteDependency.target = telemetry.target;\r\n        remoteDependency.duration = Util.msToTimeSpan(telemetry.duration);\r\n        remoteDependency.success = telemetry.success;\r\n        remoteDependency.type = telemetry.dependencyTypeName;\r\n        remoteDependency.properties = telemetry.properties;\r\n        remoteDependency.resultCode = (telemetry.resultCode ? telemetry.resultCode + '' : '');\r\n        if (telemetry.id) {\r\n            remoteDependency.id = telemetry.id;\r\n        }\r\n        else {\r\n            remoteDependency.id = Util.w3cTraceId();\r\n        }\r\n        var data = new Contracts.Data();\r\n        data.baseType = Contracts.telemetryTypeToBaseType(Contracts.TelemetryType.Dependency);\r\n        data.baseData = remoteDependency;\r\n        return data;\r\n    };\r\n    EnvelopeFactory.createEventData = function (telemetry) {\r\n        var event = new Contracts.EventData();\r\n        event.name = telemetry.name;\r\n        event.properties = telemetry.properties;\r\n        event.measurements = telemetry.measurements;\r\n        var data = new Contracts.Data();\r\n        data.baseType = Contracts.telemetryTypeToBaseType(Contracts.TelemetryType.Event);\r\n        data.baseData = event;\r\n        return data;\r\n    };\r\n    EnvelopeFactory.createExceptionData = function (telemetry) {\r\n        var exception = new Contracts.ExceptionData();\r\n        exception.properties = telemetry.properties;\r\n        if (!isNaN(telemetry.severity)) {\r\n            exception.severityLevel = telemetry.severity;\r\n        }\r\n        else {\r\n            exception.severityLevel = Contracts.SeverityLevel.Error;\r\n        }\r\n        exception.measurements = telemetry.measurements;\r\n        exception.exceptions = [];\r\n        var stack = telemetry.exception[\"stack\"];\r\n        var exceptionDetails = new Contracts.ExceptionDetails();\r\n        exceptionDetails.message = telemetry.exception.message;\r\n        exceptionDetails.typeName = telemetry.exception.name;\r\n        exceptionDetails.parsedStack = this.parseStack(stack);\r\n        exceptionDetails.hasFullStack = Util.isArray(exceptionDetails.parsedStack) && exceptionDetails.parsedStack.length > 0;\r\n        exception.exceptions.push(exceptionDetails);\r\n        var data = new Contracts.Data();\r\n        data.baseType = Contracts.telemetryTypeToBaseType(Contracts.TelemetryType.Exception);\r\n        data.baseData = exception;\r\n        return data;\r\n    };\r\n    EnvelopeFactory.createRequestData = function (telemetry) {\r\n        var requestData = new Contracts.RequestData();\r\n        if (telemetry.id) {\r\n            requestData.id = telemetry.id;\r\n        }\r\n        else {\r\n            requestData.id = Util.w3cTraceId();\r\n        }\r\n        requestData.name = telemetry.name;\r\n        requestData.url = telemetry.url;\r\n        requestData.source = telemetry.source;\r\n        requestData.duration = Util.msToTimeSpan(telemetry.duration);\r\n        requestData.responseCode = (telemetry.resultCode ? telemetry.resultCode + '' : '');\r\n        requestData.success = telemetry.success;\r\n        requestData.properties = telemetry.properties;\r\n        var data = new Contracts.Data();\r\n        data.baseType = Contracts.telemetryTypeToBaseType(Contracts.TelemetryType.Request);\r\n        data.baseData = requestData;\r\n        return data;\r\n    };\r\n    EnvelopeFactory.createMetricData = function (telemetry) {\r\n        var metrics = new Contracts.MetricData(); // todo: enable client-batching of these\r\n        metrics.metrics = [];\r\n        var metric = new Contracts.DataPoint();\r\n        metric.count = !isNaN(telemetry.count) ? telemetry.count : 1;\r\n        metric.kind = Contracts.DataPointType.Aggregation;\r\n        metric.max = !isNaN(telemetry.max) ? telemetry.max : telemetry.value;\r\n        metric.min = !isNaN(telemetry.min) ? telemetry.min : telemetry.value;\r\n        metric.name = telemetry.name;\r\n        metric.stdDev = !isNaN(telemetry.stdDev) ? telemetry.stdDev : 0;\r\n        metric.value = telemetry.value;\r\n        metrics.metrics.push(metric);\r\n        metrics.properties = telemetry.properties;\r\n        var data = new Contracts.Data();\r\n        data.baseType = Contracts.telemetryTypeToBaseType(Contracts.TelemetryType.Metric);\r\n        data.baseData = metrics;\r\n        return data;\r\n    };\r\n    EnvelopeFactory.createAvailabilityData = function (telemetry) {\r\n        var availabilityData = new Contracts.AvailabilityData();\r\n        if (telemetry.id) {\r\n            availabilityData.id = telemetry.id;\r\n        }\r\n        else {\r\n            availabilityData.id = Util.w3cTraceId();\r\n        }\r\n        availabilityData.name = telemetry.name;\r\n        availabilityData.duration = Util.msToTimeSpan(telemetry.duration);\r\n        availabilityData.success = telemetry.success;\r\n        availabilityData.runLocation = telemetry.runLocation;\r\n        availabilityData.message = telemetry.message;\r\n        availabilityData.measurements = telemetry.measurements;\r\n        availabilityData.properties = telemetry.properties;\r\n        var data = new Contracts.Data();\r\n        data.baseType = Contracts.telemetryTypeToBaseType(Contracts.TelemetryType.Availability);\r\n        data.baseData = availabilityData;\r\n        return data;\r\n    };\r\n    EnvelopeFactory.getTags = function (context, tagOverrides) {\r\n        var correlationContext = CorrelationContextManager_1.CorrelationContextManager.getCurrentContext();\r\n        // Make a copy of context tags so we don't alter the actual object\r\n        // Also perform tag overriding\r\n        var newTags = {};\r\n        if (context && context.tags) {\r\n            for (var key in context.tags) {\r\n                newTags[key] = context.tags[key];\r\n            }\r\n        }\r\n        if (tagOverrides) {\r\n            for (var key in tagOverrides) {\r\n                newTags[key] = tagOverrides[key];\r\n            }\r\n        }\r\n        // Fill in internally-populated values if not already set\r\n        if (correlationContext) {\r\n            newTags[context.keys.operationId] = newTags[context.keys.operationId] || correlationContext.operation.id;\r\n            newTags[context.keys.operationName] = newTags[context.keys.operationName] || correlationContext.operation.name;\r\n            newTags[context.keys.operationParentId] = newTags[context.keys.operationParentId] || correlationContext.operation.parentId;\r\n        }\r\n        return newTags;\r\n    };\r\n    EnvelopeFactory.parseStack = function (stack) {\r\n        var parsedStack = undefined;\r\n        if (typeof stack === \"string\") {\r\n            var frames = stack.split(\"\\n\");\r\n            parsedStack = [];\r\n            var level = 0;\r\n            var totalSizeInBytes = 0;\r\n            for (var i = 0; i <= frames.length; i++) {\r\n                var frame = frames[i];\r\n                if (_StackFrame.regex.test(frame)) {\r\n                    var parsedFrame = new _StackFrame(frames[i], level++);\r\n                    totalSizeInBytes += parsedFrame.sizeInBytes;\r\n                    parsedStack.push(parsedFrame);\r\n                }\r\n            }\r\n            // DP Constraint - exception parsed stack must be < 32KB\r\n            // remove frames from the middle to meet the threshold\r\n            var exceptionParsedStackThreshold = 32 * 1024;\r\n            if (totalSizeInBytes > exceptionParsedStackThreshold) {\r\n                var left = 0;\r\n                var right = parsedStack.length - 1;\r\n                var size = 0;\r\n                var acceptedLeft = left;\r\n                var acceptedRight = right;\r\n                while (left < right) {\r\n                    // check size\r\n                    var lSize = parsedStack[left].sizeInBytes;\r\n                    var rSize = parsedStack[right].sizeInBytes;\r\n                    size += lSize + rSize;\r\n                    if (size > exceptionParsedStackThreshold) {\r\n                        // remove extra frames from the middle\r\n                        var howMany = acceptedRight - acceptedLeft + 1;\r\n                        parsedStack.splice(acceptedLeft, howMany);\r\n                        break;\r\n                    }\r\n                    // update pointers\r\n                    acceptedLeft = left;\r\n                    acceptedRight = right;\r\n                    left++;\r\n                    right--;\r\n                }\r\n            }\r\n        }\r\n        return parsedStack;\r\n    };\r\n    return EnvelopeFactory;\r\n}());\r\nvar _StackFrame = (function () {\r\n    function _StackFrame(frame, level) {\r\n        this.sizeInBytes = 0;\r\n        this.level = level;\r\n        this.method = \"<no_method>\";\r\n        this.assembly = Util.trim(frame);\r\n        var matches = frame.match(_StackFrame.regex);\r\n        if (matches && matches.length >= 5) {\r\n            this.method = Util.trim(matches[2]) || this.method;\r\n            this.fileName = Util.trim(matches[4]) || \"<no_filename>\";\r\n            this.line = parseInt(matches[5]) || 0;\r\n        }\r\n        this.sizeInBytes += this.method.length;\r\n        this.sizeInBytes += this.fileName.length;\r\n        this.sizeInBytes += this.assembly.length;\r\n        // todo: these might need to be removed depending on how the back-end settles on their size calculation\r\n        this.sizeInBytes += _StackFrame.baseSize;\r\n        this.sizeInBytes += this.level.toString().length;\r\n        this.sizeInBytes += this.line.toString().length;\r\n    }\r\n    // regex to match stack frames from ie/chrome/ff\r\n    // methodName=$2, fileName=$4, lineNo=$5, column=$6\r\n    _StackFrame.regex = /^([\\s]+at)?(.*?)(\\@|\\s\\(|\\s)([^\\(\\@\\n]+):([0-9]+):([0-9]+)(\\)?)$/;\r\n    _StackFrame.baseSize = 58; //'{\"method\":\"\",\"level\":,\"assembly\":\"\",\"fileName\":\"\",\"line\":}'.length\r\n    return _StackFrame;\r\n}());\r\nmodule.exports = EnvelopeFactory;\r\n//# sourceMappingURL=EnvelopeFactory.js.map","\"use strict\";\r\nvar Logging = (function () {\r\n    function Logging() {\r\n    }\r\n    Logging.info = function (message) {\r\n        var optionalParams = [];\r\n        for (var _i = 1; _i < arguments.length; _i++) {\r\n            optionalParams[_i - 1] = arguments[_i];\r\n        }\r\n        if (Logging.enableDebug) {\r\n            console.info(Logging.TAG + message, optionalParams);\r\n        }\r\n    };\r\n    Logging.warn = function (message) {\r\n        var optionalParams = [];\r\n        for (var _i = 1; _i < arguments.length; _i++) {\r\n            optionalParams[_i - 1] = arguments[_i];\r\n        }\r\n        if (!Logging.disableWarnings) {\r\n            console.warn(Logging.TAG + message, optionalParams);\r\n        }\r\n    };\r\n    Logging.enableDebug = false;\r\n    Logging.disableWarnings = false;\r\n    Logging.TAG = \"ApplicationInsights:\";\r\n    return Logging;\r\n}());\r\nmodule.exports = Logging;\r\n//# sourceMappingURL=Logging.js.map","\"use strict\";\r\nvar __extends = (this && this.__extends) || (function () {\r\n    var extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\nvar TelemetryClient = require(\"./TelemetryClient\");\r\nvar ServerRequestTracking = require(\"../AutoCollection/HttpRequests\");\r\nvar ClientRequestTracking = require(\"../AutoCollection/HttpDependencies\");\r\nvar Logging = require(\"./Logging\");\r\n/**\r\n * Application Insights Telemetry Client for Node.JS. Provides the Application Insights TelemetryClient API\r\n * in addition to Node-specific helper functions.\r\n * Construct a new TelemetryClient to have an instance with a different configuration than the default client.\r\n * In most cases, `appInsights.defaultClient` should be used instead.\r\n */\r\nvar NodeClient = (function (_super) {\r\n    __extends(NodeClient, _super);\r\n    function NodeClient() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    /**\r\n     * Log RequestTelemetry from HTTP request and response. This method will log immediately without waitng for request completion\r\n     * and it requires duration parameter to be specified on NodeHttpRequestTelemetry object.\r\n     * Use trackNodeHttpRequest function to log the telemetry after request completion\r\n     * @param telemetry Object encapsulating incoming request, response and duration information\r\n     */\r\n    NodeClient.prototype.trackNodeHttpRequestSync = function (telemetry) {\r\n        if (telemetry && telemetry.request && telemetry.response && telemetry.duration) {\r\n            ServerRequestTracking.trackRequestSync(this, telemetry);\r\n        }\r\n        else {\r\n            Logging.warn(\"trackNodeHttpRequestSync requires NodeHttpRequestTelemetry object with request, response and duration specified.\");\r\n        }\r\n    };\r\n    /**\r\n     * Log RequestTelemetry from HTTP request and response. This method will `follow` the request to completion.\r\n     * Use trackNodeHttpRequestSync function to log telemetry immediately without waiting for request completion\r\n     * @param telemetry Object encapsulating incoming request and response information\r\n     */\r\n    NodeClient.prototype.trackNodeHttpRequest = function (telemetry) {\r\n        if (telemetry.duration || telemetry.error) {\r\n            Logging.warn(\"trackNodeHttpRequest will ignore supplied duration and error parameters. These values are collected from the request and response objects.\");\r\n        }\r\n        if (telemetry && telemetry.request && telemetry.response) {\r\n            ServerRequestTracking.trackRequest(this, telemetry);\r\n        }\r\n        else {\r\n            Logging.warn(\"trackNodeHttpRequest requires NodeHttpRequestTelemetry object with request and response specified.\");\r\n        }\r\n    };\r\n    /**\r\n     * Log DependencyTelemetry from outgoing HTTP request. This method will instrument the outgoing request and append\r\n     * the specified headers and will log the telemetry when outgoing request is complete\r\n     * @param telemetry Object encapsulating outgoing request information\r\n     */\r\n    NodeClient.prototype.trackNodeHttpDependency = function (telemetry) {\r\n        if (telemetry && telemetry.request) {\r\n            ClientRequestTracking.trackRequest(this, telemetry);\r\n        }\r\n        else {\r\n            Logging.warn(\"trackNodeHttpDependency requires NodeHttpDependencyTelemetry object with request specified.\");\r\n        }\r\n    };\r\n    return NodeClient;\r\n}(TelemetryClient));\r\nmodule.exports = NodeClient;\r\n//# sourceMappingURL=NodeClient.js.map","\"use strict\";\r\nvar __assign = (this && this.__assign) || Object.assign || function(t) {\r\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n        s = arguments[i];\r\n        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\r\n            t[p] = s[p];\r\n    }\r\n    return t;\r\n};\r\nvar os = require(\"os\");\r\nvar Contracts = require(\"../Declarations/Contracts\");\r\nvar Constants = require(\"../Declarations/Constants\");\r\nvar Util = require(\"./Util\");\r\nvar Logging = require(\"./Logging\");\r\nvar StreamId = Util.w3cTraceId(); // Create a guid\r\nvar QuickPulseEnvelopeFactory = (function () {\r\n    function QuickPulseEnvelopeFactory() {\r\n    }\r\n    QuickPulseEnvelopeFactory.createQuickPulseEnvelope = function (metrics, documents, config, context) {\r\n        var machineName = (os && typeof os.hostname === \"function\"\r\n            && os.hostname()) || \"Unknown\"; // Note: os.hostname() was added in node v0.3.3\r\n        var instance = (context.tags\r\n            && context.keys\r\n            && context.keys.cloudRoleInstance\r\n            && context.tags[context.keys.cloudRoleInstance]) || machineName;\r\n        var envelope = {\r\n            Documents: documents.length > 0 ? documents : null,\r\n            InstrumentationKey: config.instrumentationKey || \"\",\r\n            Metrics: metrics.length > 0 ? metrics : null,\r\n            InvariantVersion: 1,\r\n            Timestamp: \"/Date(\" + Date.now() + \")/\",\r\n            Version: context.tags[context.keys.internalSdkVersion],\r\n            StreamId: StreamId,\r\n            MachineName: machineName,\r\n            Instance: instance\r\n        };\r\n        return envelope;\r\n    };\r\n    QuickPulseEnvelopeFactory.createQuickPulseMetric = function (telemetry) {\r\n        var data;\r\n        data = {\r\n            Name: telemetry.name,\r\n            Value: telemetry.value,\r\n            Weight: telemetry.count || 1\r\n        };\r\n        return data;\r\n    };\r\n    QuickPulseEnvelopeFactory.telemetryEnvelopeToQuickPulseDocument = function (envelope) {\r\n        switch (envelope.data.baseType) {\r\n            case Contracts.TelemetryTypeString.Event:\r\n                return QuickPulseEnvelopeFactory.createQuickPulseEventDocument(envelope);\r\n            case Contracts.TelemetryTypeString.Exception:\r\n                return QuickPulseEnvelopeFactory.createQuickPulseExceptionDocument(envelope);\r\n            case Contracts.TelemetryTypeString.Trace:\r\n                return QuickPulseEnvelopeFactory.createQuickPulseTraceDocument(envelope);\r\n            case Contracts.TelemetryTypeString.Dependency:\r\n                return QuickPulseEnvelopeFactory.createQuickPulseDependencyDocument(envelope);\r\n            case Contracts.TelemetryTypeString.Request:\r\n                return QuickPulseEnvelopeFactory.createQuickPulseRequestDocument(envelope);\r\n        }\r\n        return null;\r\n    };\r\n    QuickPulseEnvelopeFactory.createQuickPulseEventDocument = function (envelope) {\r\n        var document = QuickPulseEnvelopeFactory.createQuickPulseDocument(envelope);\r\n        var name = envelope.data.baseData.name;\r\n        var eventDocument = __assign({}, document, { Name: name });\r\n        return eventDocument;\r\n    };\r\n    QuickPulseEnvelopeFactory.createQuickPulseTraceDocument = function (envelope) {\r\n        var document = QuickPulseEnvelopeFactory.createQuickPulseDocument(envelope);\r\n        var severityLevel = envelope.data.baseData.severityLevel || 0;\r\n        var traceDocument = __assign({}, document, { Message: envelope.data.baseData.message, SeverityLevel: Contracts.SeverityLevel[severityLevel] });\r\n        return traceDocument;\r\n    };\r\n    QuickPulseEnvelopeFactory.createQuickPulseExceptionDocument = function (envelope) {\r\n        var document = QuickPulseEnvelopeFactory.createQuickPulseDocument(envelope);\r\n        var exceptionDetails = envelope.data.baseData.exceptions;\r\n        var exception = '';\r\n        var exceptionMessage = '';\r\n        var exceptionType = '';\r\n        // Try to fill exception information from first error only\r\n        if (exceptionDetails && exceptionDetails.length > 0) {\r\n            // Try to grab the stack from parsedStack or stack\r\n            if (exceptionDetails[0].parsedStack && exceptionDetails[0].parsedStack.length > 0) {\r\n                exceptionDetails[0].parsedStack.forEach(function (err) {\r\n                    exception += err.assembly + \"\\n\";\r\n                });\r\n            }\r\n            else if (exceptionDetails[0].stack && exceptionDetails[0].stack.length > 0) {\r\n                exception = exceptionDetails[0].stack;\r\n            }\r\n            exceptionMessage = exceptionDetails[0].message;\r\n            exceptionType = exceptionDetails[0].typeName;\r\n        }\r\n        var exceptionDocument = __assign({}, document, { Exception: exception, ExceptionMessage: exceptionMessage, ExceptionType: exceptionType });\r\n        return exceptionDocument;\r\n    };\r\n    QuickPulseEnvelopeFactory.createQuickPulseRequestDocument = function (envelope) {\r\n        var document = QuickPulseEnvelopeFactory.createQuickPulseDocument(envelope);\r\n        var baseData = envelope.data.baseData;\r\n        var requestDocument = __assign({}, document, { Name: baseData.name, Success: baseData.success, Duration: baseData.duration, ResponseCode: baseData.responseCode, OperationName: baseData.name // TODO: is this correct?\r\n         });\r\n        return requestDocument;\r\n    };\r\n    QuickPulseEnvelopeFactory.createQuickPulseDependencyDocument = function (envelope) {\r\n        var document = QuickPulseEnvelopeFactory.createQuickPulseDocument(envelope);\r\n        var baseData = envelope.data.baseData;\r\n        var dependencyDocument = __assign({}, document, { Name: baseData.name, Target: baseData.target, Success: baseData.success, Duration: baseData.duration, ResultCode: baseData.resultCode, CommandName: baseData.data, OperationName: document.OperationId, DependencyTypeName: baseData.type });\r\n        return dependencyDocument;\r\n    };\r\n    QuickPulseEnvelopeFactory.createQuickPulseDocument = function (envelope) {\r\n        var documentType;\r\n        var __type;\r\n        var operationId, properties;\r\n        if (envelope.data.baseType) {\r\n            __type = Constants.TelemetryTypeStringToQuickPulseType[envelope.data.baseType];\r\n            documentType = Constants.TelemetryTypeStringToQuickPulseDocumentType[envelope.data.baseType];\r\n        }\r\n        else {\r\n            // Remark: This should never be hit because createQuickPulseDocument is only called within\r\n            // valid baseType values\r\n            Logging.warn(\"Document type invalid; not sending live metric document\", envelope.data.baseType);\r\n        }\r\n        operationId = envelope.tags[QuickPulseEnvelopeFactory.keys.operationId];\r\n        properties = QuickPulseEnvelopeFactory.aggregateProperties(envelope);\r\n        var document = {\r\n            DocumentType: documentType,\r\n            __type: __type,\r\n            OperationId: operationId,\r\n            Version: \"1.0\",\r\n            Properties: properties\r\n        };\r\n        return document;\r\n    };\r\n    QuickPulseEnvelopeFactory.aggregateProperties = function (envelope) {\r\n        var properties = [];\r\n        // Collect measurements\r\n        var meas = (envelope.data.baseData).measurements || {};\r\n        for (var key in meas) {\r\n            if (meas.hasOwnProperty(key)) {\r\n                var value = meas[key];\r\n                var property = { key: key, value: value };\r\n                properties.push(property);\r\n            }\r\n        }\r\n        // Collect properties\r\n        var props = (envelope.data.baseData).properties || {};\r\n        for (var key in props) {\r\n            if (props.hasOwnProperty(key)) {\r\n                var value = props[key];\r\n                var property = { key: key, value: value };\r\n                properties.push(property);\r\n            }\r\n        }\r\n        return properties;\r\n    };\r\n    QuickPulseEnvelopeFactory.keys = new Contracts.ContextTagKeys();\r\n    return QuickPulseEnvelopeFactory;\r\n}());\r\nmodule.exports = QuickPulseEnvelopeFactory;\r\n//# sourceMappingURL=QuickPulseEnvelopeFactory.js.map","\"use strict\";\r\nvar https = require(\"https\");\r\nvar AutoCollectHttpDependencies = require(\"../AutoCollection/HttpDependencies\");\r\nvar Logging = require(\"./Logging\");\r\nvar QuickPulseConfig = {\r\n    method: \"POST\",\r\n    time: \"x-ms-qps-transmission-time\",\r\n    subscribed: \"x-ms-qps-subscribed\"\r\n};\r\nvar QuickPulseSender = (function () {\r\n    function QuickPulseSender(config) {\r\n        this._config = config;\r\n        this._consecutiveErrors = 0;\r\n    }\r\n    QuickPulseSender.prototype.ping = function (envelope, done) {\r\n        this._submitData(envelope, done, \"ping\");\r\n    };\r\n    QuickPulseSender.prototype.post = function (envelope, done) {\r\n        // Important: When POSTing data, envelope must be an array\r\n        this._submitData([envelope], done, \"post\");\r\n    };\r\n    QuickPulseSender.prototype._submitData = function (envelope, done, postOrPing) {\r\n        var _this = this;\r\n        var payload = JSON.stringify(envelope);\r\n        var options = (_a = {},\r\n            _a[AutoCollectHttpDependencies.disableCollectionRequestOption] = true,\r\n            _a.host = this._config.quickPulseHost,\r\n            _a.method = QuickPulseConfig.method,\r\n            _a.path = \"/QuickPulseService.svc/\" + postOrPing + \"?ikey=\" + this._config.instrumentationKey,\r\n            _a.headers = (_b = {\r\n                    'Expect': '100-continue'\r\n                },\r\n                _b[QuickPulseConfig.time] = 10000 * Date.now(),\r\n                _b['Content-Type'] = 'application\\/json',\r\n                _b['Content-Length'] = Buffer.byteLength(payload),\r\n                _b),\r\n            _a);\r\n        var req = https.request(options, function (res) {\r\n            var shouldPOSTData = res.headers[QuickPulseConfig.subscribed] === \"true\";\r\n            _this._consecutiveErrors = 0;\r\n            done(shouldPOSTData, res);\r\n        });\r\n        req.on(\"error\", function (error) {\r\n            // Unable to contact qps endpoint.\r\n            // Do nothing for now.\r\n            _this._consecutiveErrors++;\r\n            // LOG every error, but WARN instead when X number of consecutive errors occur\r\n            var notice = \"Transient error connecting to the Live Metrics endpoint. This packet will not appear in your Live Metrics Stream. Error:\";\r\n            if (_this._consecutiveErrors % QuickPulseSender.MAX_QPS_FAILURES_BEFORE_WARN === 0) {\r\n                notice = \"Live Metrics endpoint could not be reached \" + _this._consecutiveErrors + \" consecutive times. Most recent error:\";\r\n                Logging.warn(QuickPulseSender.TAG, notice, error);\r\n            }\r\n            else {\r\n                // Potentially transient error, do not change the ping/post state yet.\r\n                Logging.info(QuickPulseSender.TAG, notice, error);\r\n            }\r\n            done();\r\n        });\r\n        req.write(payload);\r\n        req.end();\r\n        var _a, _b;\r\n    };\r\n    QuickPulseSender.TAG = \"QuickPulseSender\";\r\n    QuickPulseSender.MAX_QPS_FAILURES_BEFORE_WARN = 25;\r\n    return QuickPulseSender;\r\n}());\r\nmodule.exports = QuickPulseSender;\r\n//# sourceMappingURL=QuickPulseSender.js.map","\"use strict\";\r\nvar Logging = require(\"./Logging\");\r\nvar Config = require(\"./Config\");\r\nvar QuickPulseEnvelopeFactory = require(\"./QuickPulseEnvelopeFactory\");\r\nvar QuickPulseSender = require(\"./QuickPulseSender\");\r\nvar Constants = require(\"../Declarations/Constants\");\r\nvar Context = require(\"./Context\");\r\n/** State Container for sending to the QuickPulse Service */\r\nvar QuickPulseStateManager = (function () {\r\n    function QuickPulseStateManager(iKey, context) {\r\n        this._isCollectingData = false;\r\n        this._lastSuccessTime = Date.now();\r\n        this._lastSendSucceeded = true;\r\n        this._metrics = {};\r\n        this._documents = [];\r\n        this._collectors = [];\r\n        this.config = new Config(iKey);\r\n        this.context = context || new Context();\r\n        this._sender = new QuickPulseSender(this.config);\r\n        this._isEnabled = false;\r\n    }\r\n    /**\r\n     *\r\n     * @param collector\r\n     */\r\n    QuickPulseStateManager.prototype.addCollector = function (collector) {\r\n        this._collectors.push(collector);\r\n    };\r\n    /**\r\n     * Override of TelemetryClient.trackMetric\r\n     */\r\n    QuickPulseStateManager.prototype.trackMetric = function (telemetry) {\r\n        this._addMetric(telemetry);\r\n    };\r\n    /**\r\n     * Add a document to the current buffer\r\n     * @param envelope\r\n     */\r\n    QuickPulseStateManager.prototype.addDocument = function (envelope) {\r\n        var document = QuickPulseEnvelopeFactory.telemetryEnvelopeToQuickPulseDocument(envelope);\r\n        if (document) {\r\n            this._documents.push(document);\r\n        }\r\n    };\r\n    /**\r\n     * Enable or disable communication with QuickPulseService\r\n     * @param isEnabled\r\n     */\r\n    QuickPulseStateManager.prototype.enable = function (isEnabled) {\r\n        if (isEnabled && !this._isEnabled) {\r\n            this._isEnabled = true;\r\n            this._goQuickPulse();\r\n        }\r\n        else if (!isEnabled && this._isEnabled) {\r\n            this._isEnabled = false;\r\n            clearTimeout(this._handle);\r\n            this._handle = undefined;\r\n        }\r\n    };\r\n    /**\r\n     * Enable or disable all collectors in this instance\r\n     * @param enable\r\n     */\r\n    QuickPulseStateManager.prototype.enableCollectors = function (enable) {\r\n        this._collectors.forEach(function (collector) {\r\n            collector.enable(enable);\r\n        });\r\n    };\r\n    /**\r\n     * Add the metric to this buffer. If same metric already exists in this buffer, add weight to it\r\n     * @param telemetry\r\n     */\r\n    QuickPulseStateManager.prototype._addMetric = function (telemetry) {\r\n        var value = telemetry.value;\r\n        var count = telemetry.count || 1;\r\n        var name = Constants.PerformanceToQuickPulseCounter[telemetry.name];\r\n        if (name) {\r\n            if (this._metrics[name]) {\r\n                this._metrics[name].Value = (this._metrics[name].Value * this._metrics[name].Weight + value * count) / (this._metrics[name].Weight + count);\r\n                this._metrics[name].Weight += count;\r\n            }\r\n            else {\r\n                this._metrics[name] = QuickPulseEnvelopeFactory.createQuickPulseMetric(telemetry);\r\n                this._metrics[name].Name = name;\r\n                this._metrics[name].Weight = 1;\r\n            }\r\n        }\r\n    };\r\n    QuickPulseStateManager.prototype._resetQuickPulseBuffer = function () {\r\n        delete this._metrics;\r\n        this._metrics = {};\r\n        this._documents.length = 0;\r\n    };\r\n    QuickPulseStateManager.prototype._goQuickPulse = function () {\r\n        var _this = this;\r\n        // Create envelope from Documents and Metrics\r\n        var metrics = Object.keys(this._metrics).map(function (k) { return _this._metrics[k]; });\r\n        var envelope = QuickPulseEnvelopeFactory.createQuickPulseEnvelope(metrics, this._documents.slice(), this.config, this.context);\r\n        // Clear this document, metric buffer\r\n        this._resetQuickPulseBuffer();\r\n        // Send it to QuickPulseService, if collecting\r\n        if (this._isCollectingData) {\r\n            this._post(envelope);\r\n        }\r\n        else {\r\n            this._ping(envelope);\r\n        }\r\n        var currentTimeout = this._isCollectingData ? QuickPulseStateManager.POST_INTERVAL : QuickPulseStateManager.PING_INTERVAL;\r\n        if (this._isCollectingData && Date.now() - this._lastSuccessTime >= QuickPulseStateManager.MAX_POST_WAIT_TIME && !this._lastSendSucceeded) {\r\n            // Haven't posted successfully in 20 seconds, so wait 60 seconds and ping\r\n            this._isCollectingData = false;\r\n            currentTimeout = QuickPulseStateManager.FALLBACK_INTERVAL;\r\n        }\r\n        else if (!this._isCollectingData && Date.now() - this._lastSuccessTime >= QuickPulseStateManager.MAX_PING_WAIT_TIME && !this._lastSendSucceeded) {\r\n            // Haven't pinged successfully in 60 seconds, so wait another 60 seconds\r\n            currentTimeout = QuickPulseStateManager.FALLBACK_INTERVAL;\r\n        }\r\n        this._lastSendSucceeded = null;\r\n        this._handle = setTimeout(this._goQuickPulse.bind(this), currentTimeout);\r\n        this._handle.unref(); // Don't block apps from terminating\r\n    };\r\n    QuickPulseStateManager.prototype._ping = function (envelope) {\r\n        this._sender.ping(envelope, this._quickPulseDone.bind(this));\r\n    };\r\n    QuickPulseStateManager.prototype._post = function (envelope) {\r\n        this._sender.post(envelope, this._quickPulseDone.bind(this));\r\n    };\r\n    /**\r\n     * Change the current QPS send state. (shouldPOST == undefined) --> error, but do not change the state yet.\r\n     */\r\n    QuickPulseStateManager.prototype._quickPulseDone = function (shouldPOST, res) {\r\n        if (shouldPOST != undefined) {\r\n            if (this._isCollectingData !== shouldPOST) {\r\n                Logging.info(\"Live Metrics sending data\", shouldPOST);\r\n                this.enableCollectors(shouldPOST);\r\n            }\r\n            this._isCollectingData = shouldPOST;\r\n            if (res && res.statusCode < 300 && res.statusCode >= 200) {\r\n                this._lastSuccessTime = Date.now();\r\n                this._lastSendSucceeded = true;\r\n            }\r\n            else {\r\n                this._lastSendSucceeded = false;\r\n            }\r\n        }\r\n        else {\r\n            // Received an error, keep the state as is\r\n            this._lastSendSucceeded = false;\r\n        }\r\n    };\r\n    QuickPulseStateManager.MAX_POST_WAIT_TIME = 20000;\r\n    QuickPulseStateManager.MAX_PING_WAIT_TIME = 60000;\r\n    QuickPulseStateManager.FALLBACK_INTERVAL = 60000;\r\n    QuickPulseStateManager.PING_INTERVAL = 5000;\r\n    QuickPulseStateManager.POST_INTERVAL = 1000;\r\n    return QuickPulseStateManager;\r\n}());\r\nmodule.exports = QuickPulseStateManager;\r\n//# sourceMappingURL=QuickPulseStateManager.js.map","\"use strict\";\r\nmodule.exports = {\r\n    /**\r\n     * Request-Context header\r\n     */\r\n    requestContextHeader: \"request-context\",\r\n    /**\r\n     * Source instrumentation header that is added by an application while making http\r\n     * requests and retrieved by the other application when processing incoming requests.\r\n     */\r\n    requestContextSourceKey: \"appId\",\r\n    /**\r\n     * Target instrumentation header that is added to the response and retrieved by the\r\n     * calling application when processing incoming responses.\r\n     */\r\n    requestContextTargetKey: \"appId\",\r\n    /**\r\n     * Request-Id header\r\n     */\r\n    requestIdHeader: \"request-id\",\r\n    /**\r\n     * Legacy Header containing the id of the immidiate caller\r\n     */\r\n    parentIdHeader: \"x-ms-request-id\",\r\n    /**\r\n     * Legacy Header containing the correlation id that kept the same for every telemetry item\r\n     * accross transactions\r\n     */\r\n    rootIdHeader: \"x-ms-request-root-id\",\r\n    /**\r\n     * Correlation-Context header\r\n     *\r\n     * Not currently actively used, but the contents should be passed from incoming to outgoing requests\r\n     */\r\n    correlationContextHeader: \"correlation-context\",\r\n    /**\r\n     * W3C distributed tracing protocol header\r\n     */\r\n    traceparentHeader: \"traceparent\",\r\n    /**\r\n     * W3C distributed tracing protocol state header\r\n     */\r\n    traceStateHeader: \"tracestate\"\r\n};\r\n//# sourceMappingURL=RequestResponseHeaders.js.map","\"use strict\";\r\nvar fs = require(\"fs\");\r\nvar os = require(\"os\");\r\nvar path = require(\"path\");\r\nvar zlib = require(\"zlib\");\r\nvar child_process = require(\"child_process\");\r\nvar Logging = require(\"./Logging\");\r\nvar AutoCollectHttpDependencies = require(\"../AutoCollection/HttpDependencies\");\r\nvar Util = require(\"./Util\");\r\nvar Sender = (function () {\r\n    function Sender(config, onSuccess, onError) {\r\n        this._config = config;\r\n        this._onSuccess = onSuccess;\r\n        this._onError = onError;\r\n        this._enableDiskRetryMode = false;\r\n        this._resendInterval = Sender.WAIT_BETWEEN_RESEND;\r\n        this._maxBytesOnDisk = Sender.MAX_BYTES_ON_DISK;\r\n        this._numConsecutiveFailures = 0;\r\n        if (!Sender.OS_PROVIDES_FILE_PROTECTION) {\r\n            // Node's chmod levels do not appropriately restrict file access on Windows\r\n            // Use the built-in command line tool ICACLS on Windows to properly restrict\r\n            // access to the temporary directory used for disk retry mode.\r\n            if (Sender.USE_ICACLS) {\r\n                // This should be async - but it's currently safer to have this synchronous\r\n                // This guarantees we can immediately fail setDiskRetryMode if we need to\r\n                try {\r\n                    Sender.OS_PROVIDES_FILE_PROTECTION = fs.existsSync(Sender.ICACLS_PATH);\r\n                }\r\n                catch (e) { }\r\n                if (!Sender.OS_PROVIDES_FILE_PROTECTION) {\r\n                    Logging.warn(Sender.TAG, \"Could not find ICACLS in expected location! This is necessary to use disk retry mode on Windows.\");\r\n                }\r\n            }\r\n            else {\r\n                // chmod works everywhere else\r\n                Sender.OS_PROVIDES_FILE_PROTECTION = true;\r\n            }\r\n        }\r\n    }\r\n    /**\r\n    * Enable or disable offline mode\r\n    */\r\n    Sender.prototype.setDiskRetryMode = function (value, resendInterval, maxBytesOnDisk) {\r\n        this._enableDiskRetryMode = Sender.OS_PROVIDES_FILE_PROTECTION && value;\r\n        if (typeof resendInterval === 'number' && resendInterval >= 0) {\r\n            this._resendInterval = Math.floor(resendInterval);\r\n        }\r\n        if (typeof maxBytesOnDisk === 'number' && maxBytesOnDisk >= 0) {\r\n            this._maxBytesOnDisk = Math.floor(maxBytesOnDisk);\r\n        }\r\n        if (value && !Sender.OS_PROVIDES_FILE_PROTECTION) {\r\n            this._enableDiskRetryMode = false;\r\n            Logging.warn(Sender.TAG, \"Ignoring request to enable disk retry mode. Sufficient file protection capabilities were not detected.\");\r\n        }\r\n    };\r\n    Sender.prototype.send = function (payload, callback) {\r\n        var _this = this;\r\n        var endpointUrl = this._config.endpointUrl;\r\n        // todo: investigate specifying an agent here: https://nodejs.org/api/http.html#http_class_http_agent\r\n        var options = {\r\n            method: \"POST\",\r\n            withCredentials: false,\r\n            headers: {\r\n                \"Content-Type\": \"application/x-json-stream\"\r\n            }\r\n        };\r\n        zlib.gzip(payload, function (err, buffer) {\r\n            var dataToSend = buffer;\r\n            if (err) {\r\n                Logging.warn(err);\r\n                dataToSend = payload; // something went wrong so send without gzip\r\n                options.headers[\"Content-Length\"] = payload.length.toString();\r\n            }\r\n            else {\r\n                options.headers[\"Content-Encoding\"] = \"gzip\";\r\n                options.headers[\"Content-Length\"] = buffer.length;\r\n            }\r\n            Logging.info(Sender.TAG, options);\r\n            // Ensure this request is not captured by auto-collection.\r\n            options[AutoCollectHttpDependencies.disableCollectionRequestOption] = true;\r\n            var requestCallback = function (res) {\r\n                res.setEncoding(\"utf-8\");\r\n                //returns empty if the data is accepted\r\n                var responseString = \"\";\r\n                res.on(\"data\", function (data) {\r\n                    responseString += data;\r\n                });\r\n                res.on(\"end\", function () {\r\n                    _this._numConsecutiveFailures = 0;\r\n                    Logging.info(Sender.TAG, responseString);\r\n                    if (typeof _this._onSuccess === \"function\") {\r\n                        _this._onSuccess(responseString);\r\n                    }\r\n                    if (typeof callback === \"function\") {\r\n                        callback(responseString);\r\n                    }\r\n                    if (_this._enableDiskRetryMode) {\r\n                        // try to send any cached events if the user is back online\r\n                        if (res.statusCode === 200) {\r\n                            setTimeout(function () { return _this._sendFirstFileOnDisk(); }, _this._resendInterval).unref();\r\n                            // store to disk in case of burst throttling\r\n                        }\r\n                        else if (res.statusCode === 408 ||\r\n                            res.statusCode === 429 ||\r\n                            res.statusCode === 439 ||\r\n                            res.statusCode === 500 ||\r\n                            res.statusCode === 503) {\r\n                            // TODO: Do not support partial success (206) until _sendFirstFileOnDisk checks payload age\r\n                            _this._storeToDisk(payload);\r\n                        }\r\n                    }\r\n                });\r\n            };\r\n            var req = Util.makeRequest(_this._config, endpointUrl, options, requestCallback);\r\n            req.on(\"error\", function (error) {\r\n                // todo: handle error codes better (group to recoverable/non-recoverable and persist)\r\n                _this._numConsecutiveFailures++;\r\n                // Only use warn level if retries are disabled or we've had some number of consecutive failures sending data\r\n                // This is because warn level is printed in the console by default, and we don't want to be noisy for transient and self-recovering errors\r\n                // Continue informing on each failure if verbose logging is being used\r\n                if (!_this._enableDiskRetryMode || _this._numConsecutiveFailures > 0 && _this._numConsecutiveFailures % Sender.MAX_CONNECTION_FAILURES_BEFORE_WARN === 0) {\r\n                    var notice = \"Ingestion endpoint could not be reached. This batch of telemetry items has been lost. Use Disk Retry Caching to enable resending of failed telemetry. Error:\";\r\n                    if (_this._enableDiskRetryMode) {\r\n                        notice = \"Ingestion endpoint could not be reached \" + _this._numConsecutiveFailures + \" consecutive times. There may be resulting telemetry loss. Most recent error:\";\r\n                    }\r\n                    Logging.warn(Sender.TAG, notice, error);\r\n                }\r\n                else {\r\n                    var notice = \"Transient failure to reach ingestion endpoint. This batch of telemetry items will be retried. Error:\";\r\n                    Logging.info(Sender.TAG, notice, error);\r\n                }\r\n                _this._onErrorHelper(error);\r\n                if (typeof callback === \"function\") {\r\n                    var errorMessage = \"error sending telemetry\";\r\n                    if (error && (typeof error.toString === \"function\")) {\r\n                        errorMessage = error.toString();\r\n                    }\r\n                    callback(errorMessage);\r\n                }\r\n                if (_this._enableDiskRetryMode) {\r\n                    _this._storeToDisk(payload);\r\n                }\r\n            });\r\n            req.write(dataToSend);\r\n            req.end();\r\n        });\r\n    };\r\n    Sender.prototype.saveOnCrash = function (payload) {\r\n        if (this._enableDiskRetryMode) {\r\n            this._storeToDiskSync(payload);\r\n        }\r\n    };\r\n    Sender.prototype._runICACLS = function (args, callback) {\r\n        var aclProc = child_process.spawn(Sender.ICACLS_PATH, args, { windowsHide: true });\r\n        aclProc.on(\"error\", function (e) { return callback(e); });\r\n        aclProc.on(\"close\", function (code, signal) {\r\n            return callback(code === 0 ? null : new Error(\"Setting ACL restrictions did not succeed (ICACLS returned code \" + code + \")\"));\r\n        });\r\n    };\r\n    Sender.prototype._runICACLSSync = function (args) {\r\n        // Some very old versions of Node (< 0.11) don't have this\r\n        if (child_process.spawnSync) {\r\n            var aclProc = child_process.spawnSync(Sender.ICACLS_PATH, args, { windowsHide: true });\r\n            if (aclProc.error) {\r\n                throw aclProc.error;\r\n            }\r\n            else if (aclProc.status !== 0) {\r\n                throw new Error(\"Setting ACL restrictions did not succeed (ICACLS returned code \" + aclProc.status + \")\");\r\n            }\r\n        }\r\n        else {\r\n            throw new Error(\"Could not synchronously call ICACLS under current version of Node.js\");\r\n        }\r\n    };\r\n    Sender.prototype._getACLIdentity = function (callback) {\r\n        if (Sender.ACL_IDENTITY) {\r\n            return callback(null, Sender.ACL_IDENTITY);\r\n        }\r\n        var psProc = child_process.spawn(Sender.POWERSHELL_PATH, [\"-Command\", \"[System.Security.Principal.WindowsIdentity]::GetCurrent().Name\"], {\r\n            windowsHide: true,\r\n            stdio: ['ignore', 'pipe', 'pipe'] // Needed to prevent hanging on Win 7\r\n        });\r\n        var data = \"\";\r\n        psProc.stdout.on(\"data\", function (d) { return data += d; });\r\n        psProc.on(\"error\", function (e) { return callback(e, null); });\r\n        psProc.on(\"close\", function (code, signal) {\r\n            Sender.ACL_IDENTITY = data && data.trim();\r\n            return callback(code === 0 ? null : new Error(\"Getting ACL identity did not succeed (PS returned code \" + code + \")\"), Sender.ACL_IDENTITY);\r\n        });\r\n    };\r\n    Sender.prototype._getACLIdentitySync = function () {\r\n        if (Sender.ACL_IDENTITY) {\r\n            return Sender.ACL_IDENTITY;\r\n        }\r\n        // Some very old versions of Node (< 0.11) don't have this\r\n        if (child_process.spawnSync) {\r\n            var psProc = child_process.spawnSync(Sender.POWERSHELL_PATH, [\"-Command\", \"[System.Security.Principal.WindowsIdentity]::GetCurrent().Name\"], {\r\n                windowsHide: true,\r\n                stdio: ['ignore', 'pipe', 'pipe'] // Needed to prevent hanging on Win 7\r\n            });\r\n            if (psProc.error) {\r\n                throw psProc.error;\r\n            }\r\n            else if (psProc.status !== 0) {\r\n                throw new Error(\"Getting ACL identity did not succeed (PS returned code \" + psProc.status + \")\");\r\n            }\r\n            Sender.ACL_IDENTITY = psProc.stdout && psProc.stdout.toString().trim();\r\n            return Sender.ACL_IDENTITY;\r\n        }\r\n        else {\r\n            throw new Error(\"Could not synchronously get ACL identity under current version of Node.js\");\r\n        }\r\n    };\r\n    Sender.prototype._getACLArguments = function (directory, identity) {\r\n        return [directory,\r\n            \"/grant\", \"*S-1-5-32-544:(OI)(CI)F\",\r\n            \"/grant\", identity + \":(OI)(CI)F\",\r\n            \"/inheritance:r\"]; // Remove all inherited permissions\r\n    };\r\n    Sender.prototype._applyACLRules = function (directory, callback) {\r\n        var _this = this;\r\n        if (!Sender.USE_ICACLS) {\r\n            return callback(null);\r\n        }\r\n        // For performance, only run ACL rules if we haven't already during this session\r\n        if (Sender.ACLED_DIRECTORIES[directory] === undefined) {\r\n            // Avoid multiple calls race condition by setting ACLED_DIRECTORIES to false for this directory immediately\r\n            // If batches are being failed faster than the processes spawned below return, some data won't be stored to disk\r\n            // This is better than the alternative of potentially infinitely spawned processes\r\n            Sender.ACLED_DIRECTORIES[directory] = false;\r\n            // Restrict this directory to only current user and administrator access\r\n            this._getACLIdentity(function (err, identity) {\r\n                if (err) {\r\n                    Sender.ACLED_DIRECTORIES[directory] = false; // false is used to cache failed (vs undefined which is \"not yet tried\")\r\n                    return callback(err);\r\n                }\r\n                else {\r\n                    _this._runICACLS(_this._getACLArguments(directory, identity), function (err) {\r\n                        Sender.ACLED_DIRECTORIES[directory] = !err;\r\n                        return callback(err);\r\n                    });\r\n                }\r\n            });\r\n        }\r\n        else {\r\n            return callback(Sender.ACLED_DIRECTORIES[directory] ? null :\r\n                new Error(\"Setting ACL restrictions did not succeed (cached result)\"));\r\n        }\r\n    };\r\n    Sender.prototype._applyACLRulesSync = function (directory) {\r\n        if (Sender.USE_ICACLS) {\r\n            // For performance, only run ACL rules if we haven't already during this session\r\n            if (Sender.ACLED_DIRECTORIES[directory] === undefined) {\r\n                this._runICACLSSync(this._getACLArguments(directory, this._getACLIdentitySync()));\r\n                Sender.ACLED_DIRECTORIES[directory] = true; // If we get here, it succeeded. _runIACLSSync will throw on failures\r\n                return;\r\n            }\r\n            else if (!Sender.ACLED_DIRECTORIES[directory]) {\r\n                throw new Error(\"Setting ACL restrictions did not succeed (cached result)\");\r\n            }\r\n        }\r\n    };\r\n    Sender.prototype._confirmDirExists = function (directory, callback) {\r\n        var _this = this;\r\n        fs.lstat(directory, function (err, stats) {\r\n            if (err && err.code === 'ENOENT') {\r\n                fs.mkdir(directory, function (err) {\r\n                    if (err && err.code !== 'EEXIST') {\r\n                        callback(err);\r\n                    }\r\n                    else {\r\n                        _this._applyACLRules(directory, callback);\r\n                    }\r\n                });\r\n            }\r\n            else if (!err && stats.isDirectory()) {\r\n                _this._applyACLRules(directory, callback);\r\n            }\r\n            else {\r\n                callback(err || new Error(\"Path existed but was not a directory\"));\r\n            }\r\n        });\r\n    };\r\n    /**\r\n     * Computes the size (in bytes) of all files in a directory at the root level. Asynchronously.\r\n     */\r\n    Sender.prototype._getShallowDirectorySize = function (directory, callback) {\r\n        // Get the directory listing\r\n        fs.readdir(directory, function (err, files) {\r\n            if (err) {\r\n                return callback(err, -1);\r\n            }\r\n            var error = null;\r\n            var totalSize = 0;\r\n            var count = 0;\r\n            if (files.length === 0) {\r\n                callback(null, 0);\r\n                return;\r\n            }\r\n            // Query all file sizes\r\n            for (var i = 0; i < files.length; i++) {\r\n                fs.stat(path.join(directory, files[i]), function (err, fileStats) {\r\n                    count++;\r\n                    if (err) {\r\n                        error = err;\r\n                    }\r\n                    else {\r\n                        if (fileStats.isFile()) {\r\n                            totalSize += fileStats.size;\r\n                        }\r\n                    }\r\n                    if (count === files.length) {\r\n                        // Did we get an error?\r\n                        if (error) {\r\n                            callback(error, -1);\r\n                        }\r\n                        else {\r\n                            callback(error, totalSize);\r\n                        }\r\n                    }\r\n                });\r\n            }\r\n        });\r\n    };\r\n    /**\r\n     * Computes the size (in bytes) of all files in a directory at the root level. Synchronously.\r\n     */\r\n    Sender.prototype._getShallowDirectorySizeSync = function (directory) {\r\n        var files = fs.readdirSync(directory);\r\n        var totalSize = 0;\r\n        for (var i = 0; i < files.length; i++) {\r\n            totalSize += fs.statSync(path.join(directory, files[i])).size;\r\n        }\r\n        return totalSize;\r\n    };\r\n    /**\r\n     * Stores the payload as a json file on disk in the temp directory\r\n     */\r\n    Sender.prototype._storeToDisk = function (payload) {\r\n        var _this = this;\r\n        // tmpdir is /tmp for *nix and USERDIR/AppData/Local/Temp for Windows\r\n        var directory = path.join(os.tmpdir(), Sender.TEMPDIR_PREFIX + this._config.instrumentationKey);\r\n        // This will create the dir if it does not exist\r\n        // Default permissions on *nix are directory listing from other users but no file creations\r\n        Logging.info(Sender.TAG, \"Checking existance of data storage directory: \" + directory);\r\n        this._confirmDirExists(directory, function (error) {\r\n            if (error) {\r\n                Logging.warn(Sender.TAG, \"Error while checking/creating directory: \" + (error && error.message));\r\n                _this._onErrorHelper(error);\r\n                return;\r\n            }\r\n            _this._getShallowDirectorySize(directory, function (err, size) {\r\n                if (err || size < 0) {\r\n                    Logging.warn(Sender.TAG, \"Error while checking directory size: \" + (err && err.message));\r\n                    _this._onErrorHelper(err);\r\n                    return;\r\n                }\r\n                else if (size > _this._maxBytesOnDisk) {\r\n                    Logging.warn(Sender.TAG, \"Not saving data due to max size limit being met. Directory size in bytes is: \" + size);\r\n                    return;\r\n                }\r\n                //create file - file name for now is the timestamp, a better approach would be a UUID but that\r\n                //would require an external dependency\r\n                var fileName = new Date().getTime() + \".ai.json\";\r\n                var fileFullPath = path.join(directory, fileName);\r\n                // Mode 600 is w/r for creator and no read access for others (only applies on *nix)\r\n                // For Windows, ACL rules are applied to the entire directory (see logic in _confirmDirExists and _applyACLRules)\r\n                Logging.info(Sender.TAG, \"saving data to disk at: \" + fileFullPath);\r\n                fs.writeFile(fileFullPath, payload, { mode: 384 }, function (error) { return _this._onErrorHelper(error); });\r\n            });\r\n        });\r\n    };\r\n    /**\r\n     * Stores the payload as a json file on disk using sync file operations\r\n     * this is used when storing data before crashes\r\n     */\r\n    Sender.prototype._storeToDiskSync = function (payload) {\r\n        // tmpdir is /tmp for *nix and USERDIR/AppData/Local/Temp for Windows\r\n        var directory = path.join(os.tmpdir(), Sender.TEMPDIR_PREFIX + this._config.instrumentationKey);\r\n        try {\r\n            Logging.info(Sender.TAG, \"Checking existance of data storage directory: \" + directory);\r\n            if (!fs.existsSync(directory)) {\r\n                fs.mkdirSync(directory);\r\n            }\r\n            // Make sure permissions are valid\r\n            this._applyACLRulesSync(directory);\r\n            var dirSize = this._getShallowDirectorySizeSync(directory);\r\n            if (dirSize > this._maxBytesOnDisk) {\r\n                Logging.info(Sender.TAG, \"Not saving data due to max size limit being met. Directory size in bytes is: \" + dirSize);\r\n                return;\r\n            }\r\n            //create file - file name for now is the timestamp, a better approach would be a UUID but that\r\n            //would require an external dependency\r\n            var fileName = new Date().getTime() + \".ai.json\";\r\n            var fileFullPath = path.join(directory, fileName);\r\n            // Mode 600 is w/r for creator and no access for anyone else (only applies on *nix)\r\n            Logging.info(Sender.TAG, \"saving data before crash to disk at: \" + fileFullPath);\r\n            fs.writeFileSync(fileFullPath, payload, { mode: 384 });\r\n        }\r\n        catch (error) {\r\n            Logging.warn(Sender.TAG, \"Error while saving data to disk: \" + (error && error.message));\r\n            this._onErrorHelper(error);\r\n        }\r\n    };\r\n    /**\r\n     * Check for temp telemetry files\r\n     * reads the first file if exist, deletes it and tries to send its load\r\n     */\r\n    Sender.prototype._sendFirstFileOnDisk = function () {\r\n        var _this = this;\r\n        var tempDir = path.join(os.tmpdir(), Sender.TEMPDIR_PREFIX + this._config.instrumentationKey);\r\n        fs.exists(tempDir, function (exists) {\r\n            if (exists) {\r\n                fs.readdir(tempDir, function (error, files) {\r\n                    if (!error) {\r\n                        files = files.filter(function (f) { return path.basename(f).indexOf(\".ai.json\") > -1; });\r\n                        if (files.length > 0) {\r\n                            var firstFile = files[0];\r\n                            var filePath = path.join(tempDir, firstFile);\r\n                            fs.readFile(filePath, function (error, payload) {\r\n                                if (!error) {\r\n                                    // delete the file first to prevent double sending\r\n                                    fs.unlink(filePath, function (error) {\r\n                                        if (!error) {\r\n                                            _this.send(payload);\r\n                                        }\r\n                                        else {\r\n                                            _this._onErrorHelper(error);\r\n                                        }\r\n                                    });\r\n                                }\r\n                                else {\r\n                                    _this._onErrorHelper(error);\r\n                                }\r\n                            });\r\n                        }\r\n                    }\r\n                    else {\r\n                        _this._onErrorHelper(error);\r\n                    }\r\n                });\r\n            }\r\n        });\r\n    };\r\n    Sender.prototype._onErrorHelper = function (error) {\r\n        if (typeof this._onError === \"function\") {\r\n            this._onError(error);\r\n        }\r\n    };\r\n    Sender.TAG = \"Sender\";\r\n    Sender.ICACLS_PATH = process.env.systemdrive + \"/windows/system32/icacls.exe\";\r\n    Sender.POWERSHELL_PATH = process.env.systemdrive + \"/windows/system32/windowspowershell/v1.0/powershell.exe\";\r\n    Sender.ACLED_DIRECTORIES = {};\r\n    Sender.ACL_IDENTITY = null;\r\n    // the amount of time the SDK will wait between resending cached data, this buffer is to avoid any throtelling from the service side\r\n    Sender.WAIT_BETWEEN_RESEND = 60 * 1000;\r\n    Sender.MAX_BYTES_ON_DISK = 50 * 1000 * 1000;\r\n    Sender.MAX_CONNECTION_FAILURES_BEFORE_WARN = 5;\r\n    Sender.TEMPDIR_PREFIX = \"appInsights-node\";\r\n    Sender.OS_PROVIDES_FILE_PROTECTION = false;\r\n    Sender.USE_ICACLS = os.type() === \"Windows_NT\";\r\n    return Sender;\r\n}());\r\nmodule.exports = Sender;\r\n//# sourceMappingURL=Sender.js.map","\"use strict\";\r\nvar url = require(\"url\");\r\nvar Config = require(\"./Config\");\r\nvar Context = require(\"./Context\");\r\nvar Contracts = require(\"../Declarations/Contracts\");\r\nvar Channel = require(\"./Channel\");\r\nvar TelemetryProcessors = require(\"../TelemetryProcessors\");\r\nvar CorrelationContextManager_1 = require(\"../AutoCollection/CorrelationContextManager\");\r\nvar Sender = require(\"./Sender\");\r\nvar Util = require(\"./Util\");\r\nvar Logging = require(\"./Logging\");\r\nvar EnvelopeFactory = require(\"./EnvelopeFactory\");\r\n/**\r\n * Application Insights telemetry client provides interface to track telemetry items, register telemetry initializers and\r\n * and manually trigger immediate sending (flushing)\r\n */\r\nvar TelemetryClient = (function () {\r\n    /**\r\n     * Constructs a new client of the client\r\n     * @param setupString the Connection String or Instrumentation Key to use (read from environment variable if not specified)\r\n     */\r\n    function TelemetryClient(setupString) {\r\n        this._telemetryProcessors = [];\r\n        var config = new Config(setupString);\r\n        this.config = config;\r\n        this.context = new Context();\r\n        this.commonProperties = {};\r\n        var sender = new Sender(this.config);\r\n        this.channel = new Channel(function () { return config.disableAppInsights; }, function () { return config.maxBatchSize; }, function () { return config.maxBatchIntervalMs; }, sender);\r\n    }\r\n    /**\r\n     * Log information about availability of an application\r\n     * @param telemetry      Object encapsulating tracking options\r\n     */\r\n    TelemetryClient.prototype.trackAvailability = function (telemetry) {\r\n        this.track(telemetry, Contracts.TelemetryType.Availability);\r\n    };\r\n    /**\r\n     * Log a trace message\r\n     * @param telemetry      Object encapsulating tracking options\r\n     */\r\n    TelemetryClient.prototype.trackTrace = function (telemetry) {\r\n        this.track(telemetry, Contracts.TelemetryType.Trace);\r\n    };\r\n    /**\r\n     * Log a numeric value that is not associated with a specific event. Typically used to send regular reports of performance indicators.\r\n     * To send a single measurement, use just the first two parameters. If you take measurements very frequently, you can reduce the\r\n     * telemetry bandwidth by aggregating multiple measurements and sending the resulting average at intervals.\r\n     * @param telemetry      Object encapsulating tracking options\r\n     */\r\n    TelemetryClient.prototype.trackMetric = function (telemetry) {\r\n        this.track(telemetry, Contracts.TelemetryType.Metric);\r\n    };\r\n    /**\r\n     * Log an exception\r\n     * @param telemetry      Object encapsulating tracking options\r\n     */\r\n    TelemetryClient.prototype.trackException = function (telemetry) {\r\n        if (telemetry && telemetry.exception && !Util.isError(telemetry.exception)) {\r\n            telemetry.exception = new Error(telemetry.exception.toString());\r\n        }\r\n        this.track(telemetry, Contracts.TelemetryType.Exception);\r\n    };\r\n    /**\r\n     * Log a user action or other occurrence.\r\n     * @param telemetry      Object encapsulating tracking options\r\n     */\r\n    TelemetryClient.prototype.trackEvent = function (telemetry) {\r\n        this.track(telemetry, Contracts.TelemetryType.Event);\r\n    };\r\n    /**\r\n     * Log a request. Note that the default client will attempt to collect HTTP requests automatically so only use this for requests\r\n     * that aren't automatically captured or if you've disabled automatic request collection.\r\n     *\r\n     * @param telemetry      Object encapsulating tracking options\r\n     */\r\n    TelemetryClient.prototype.trackRequest = function (telemetry) {\r\n        this.track(telemetry, Contracts.TelemetryType.Request);\r\n    };\r\n    /**\r\n     * Log a dependency. Note that the default client will attempt to collect dependencies automatically so only use this for dependencies\r\n     * that aren't automatically captured or if you've disabled automatic dependency collection.\r\n     *\r\n     * @param telemetry      Object encapsulating tracking option\r\n     * */\r\n    TelemetryClient.prototype.trackDependency = function (telemetry) {\r\n        if (telemetry && !telemetry.target && telemetry.data) {\r\n            // url.parse().host returns null for non-urls,\r\n            // making this essentially a no-op in those cases\r\n            // If this logic is moved, update jsdoc in DependencyTelemetry.target\r\n            telemetry.target = url.parse(telemetry.data).host;\r\n        }\r\n        this.track(telemetry, Contracts.TelemetryType.Dependency);\r\n    };\r\n    /**\r\n     * Immediately send all queued telemetry.\r\n     * @param options Flush options, including indicator whether app is crashing and callback\r\n     */\r\n    TelemetryClient.prototype.flush = function (options) {\r\n        this.channel.triggerSend(options ? !!options.isAppCrashing : false, options ? options.callback : undefined);\r\n    };\r\n    /**\r\n     * Generic track method for all telemetry types\r\n     * @param data the telemetry to send\r\n     * @param telemetryType specify the type of telemetry you are tracking from the list of Contracts.DataTypes\r\n     */\r\n    TelemetryClient.prototype.track = function (telemetry, telemetryType) {\r\n        if (telemetry && Contracts.telemetryTypeToBaseType(telemetryType)) {\r\n            var envelope = EnvelopeFactory.createEnvelope(telemetry, telemetryType, this.commonProperties, this.context, this.config);\r\n            // Set time on the envelope if it was set on the telemetry item\r\n            if (telemetry.time) {\r\n                envelope.time = telemetry.time.toISOString();\r\n            }\r\n            var accepted = this.runTelemetryProcessors(envelope, telemetry.contextObjects);\r\n            // Ideally we would have a central place for \"internal\" telemetry processors and users can configure which ones are in use.\r\n            // This will do for now. Otherwise clearTelemetryProcessors() would be problematic.\r\n            accepted = accepted && TelemetryProcessors.samplingTelemetryProcessor(envelope, { correlationContext: CorrelationContextManager_1.CorrelationContextManager.getCurrentContext() });\r\n            TelemetryProcessors.performanceMetricsTelemetryProcessor(envelope, this.quickPulseClient);\r\n            if (accepted) {\r\n                this.channel.send(envelope);\r\n            }\r\n        }\r\n        else {\r\n            Logging.warn(\"track() requires telemetry object and telemetryType to be specified.\");\r\n        }\r\n    };\r\n    /**\r\n     * Adds telemetry processor to the collection. Telemetry processors will be called one by one\r\n     * before telemetry item is pushed for sending and in the order they were added.\r\n     *\r\n     * @param telemetryProcessor function, takes Envelope, and optional context object and returns boolean\r\n     */\r\n    TelemetryClient.prototype.addTelemetryProcessor = function (telemetryProcessor) {\r\n        this._telemetryProcessors.push(telemetryProcessor);\r\n    };\r\n    /*\r\n     * Removes all telemetry processors\r\n     */\r\n    TelemetryClient.prototype.clearTelemetryProcessors = function () {\r\n        this._telemetryProcessors = [];\r\n    };\r\n    TelemetryClient.prototype.runTelemetryProcessors = function (envelope, contextObjects) {\r\n        var accepted = true;\r\n        var telemetryProcessorsCount = this._telemetryProcessors.length;\r\n        if (telemetryProcessorsCount === 0) {\r\n            return accepted;\r\n        }\r\n        contextObjects = contextObjects || {};\r\n        contextObjects['correlationContext'] = CorrelationContextManager_1.CorrelationContextManager.getCurrentContext();\r\n        for (var i = 0; i < telemetryProcessorsCount; ++i) {\r\n            try {\r\n                var processor = this._telemetryProcessors[i];\r\n                if (processor) {\r\n                    if (processor.apply(null, [envelope, contextObjects]) === false) {\r\n                        accepted = false;\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n            catch (error) {\r\n                accepted = true;\r\n                Logging.warn(\"One of telemetry processors failed, telemetry item will be sent.\", error, envelope);\r\n            }\r\n        }\r\n        return accepted;\r\n    };\r\n    return TelemetryClient;\r\n}());\r\nmodule.exports = TelemetryClient;\r\n//# sourceMappingURL=TelemetryClient.js.map","\"use strict\";\r\nvar Util = require(\"./Util\");\r\nvar CorrelationIdManager = require(\"./CorrelationIdManager\");\r\n/**\r\n * Helper class to manage parsing and validation of traceparent header. Also handles hierarchical\r\n * back-compatibility headers generated from traceparent. W3C traceparent spec is documented at\r\n * https://www.w3.org/TR/trace-context/#traceparent-field\r\n */\r\nvar Traceparent = (function () {\r\n    function Traceparent(traceparent, parentId) {\r\n        this.traceFlag = Traceparent.DEFAULT_TRACE_FLAG;\r\n        this.version = Traceparent.DEFAULT_VERSION;\r\n        if (traceparent && typeof traceparent === \"string\") {\r\n            // If incoming request contains traceparent: parse it, set operation, parent and telemetry id accordingly. traceparent should be injected into outgoing requests. request-id should be injected in back-compat format |traceId.spanId. so that older SDKs could understand it.\r\n            if (traceparent.split(\",\").length > 1) {\r\n                this.traceId = Util.w3cTraceId();\r\n                this.spanId = Util.w3cTraceId().substr(0, 16);\r\n            }\r\n            else {\r\n                var traceparentArr = traceparent.trim().split(\"-\");\r\n                var len = traceparentArr.length;\r\n                if (len >= 4) {\r\n                    this.version = traceparentArr[0];\r\n                    this.traceId = traceparentArr[1];\r\n                    this.spanId = traceparentArr[2];\r\n                    this.traceFlag = traceparentArr[3];\r\n                }\r\n                else {\r\n                    this.traceId = Util.w3cTraceId();\r\n                    this.spanId = Util.w3cTraceId().substr(0, 16);\r\n                }\r\n                // Version validation\r\n                if (!this.version.match(/^[0-9a-f]{2}$/g)) {\r\n                    this.version = Traceparent.DEFAULT_VERSION;\r\n                    this.traceId = Util.w3cTraceId();\r\n                }\r\n                if (this.version === \"00\" && len !== 4) {\r\n                    this.traceId = Util.w3cTraceId();\r\n                    this.spanId = Util.w3cTraceId().substr(0, 16);\r\n                }\r\n                if (this.version === \"ff\") {\r\n                    this.version = Traceparent.DEFAULT_VERSION;\r\n                    this.traceId = Util.w3cTraceId();\r\n                    this.spanId = Util.w3cTraceId().substr(0, 16);\r\n                }\r\n                if (!this.version.match(/^0[0-9a-f]$/g)) {\r\n                    this.version = Traceparent.DEFAULT_VERSION;\r\n                }\r\n                // TraceFlag validation\r\n                if (!this.traceFlag.match(/^[0-9a-f]{2}$/g)) {\r\n                    this.traceFlag = Traceparent.DEFAULT_TRACE_FLAG;\r\n                    this.traceId = Util.w3cTraceId();\r\n                }\r\n                // Validate TraceId, regenerate new traceid if invalid\r\n                if (!Traceparent.isValidTraceId(this.traceId)) {\r\n                    this.traceId = Util.w3cTraceId();\r\n                }\r\n                // Validate Span Id, discard entire traceparent if invalid\r\n                if (!Traceparent.isValidSpanId(this.spanId)) {\r\n                    this.spanId = Util.w3cTraceId().substr(0, 16);\r\n                    this.traceId = Util.w3cTraceId();\r\n                }\r\n                // Save backCompat parentId\r\n                this.parentId = this.getBackCompatRequestId();\r\n            }\r\n        }\r\n        else if (parentId) {\r\n            // If incoming request contains only request-id, new traceid and spanid should be started, request-id value should be used as a parent. Root part of request-id should be stored in custom dimension on the request telemetry if root part is different from traceid. On the outgoing request side, request-id should be emitted in the |traceId.spanId. format.\r\n            this.parentId = parentId.slice(); // copy\r\n            var operationId = CorrelationIdManager.getRootId(parentId);\r\n            if (!Traceparent.isValidTraceId(operationId)) {\r\n                this.legacyRootId = operationId;\r\n                operationId = Util.w3cTraceId();\r\n            }\r\n            if (parentId.indexOf(\"|\") !== -1) {\r\n                parentId = parentId.substring(1 + parentId.substring(0, parentId.length - 1).lastIndexOf(\".\"), parentId.length - 1);\r\n            }\r\n            this.traceId = operationId;\r\n            this.spanId = parentId;\r\n        }\r\n        else {\r\n            // Fallback default constructor\r\n            // if request does not contain any correlation headers, see case p2\r\n            this.traceId = Util.w3cTraceId();\r\n            this.spanId = Util.w3cTraceId().substr(0, 16);\r\n        }\r\n    }\r\n    Traceparent.isValidTraceId = function (id) {\r\n        return id.match(/^[0-9a-f]{32}$/) && id !== \"00000000000000000000000000000000\";\r\n    };\r\n    Traceparent.isValidSpanId = function (id) {\r\n        return id.match(/^[0-9a-f]{16}$/) && id !== \"0000000000000000\";\r\n    };\r\n    Traceparent.prototype.getBackCompatRequestId = function () {\r\n        return \"|\" + this.traceId + \".\" + this.spanId + \".\";\r\n    };\r\n    Traceparent.prototype.toString = function () {\r\n        return this.version + \"-\" + this.traceId + \"-\" + this.spanId + \"-\" + this.traceFlag;\r\n    };\r\n    Traceparent.prototype.updateSpanId = function () {\r\n        this.spanId = Util.w3cTraceId().substr(0, 16);\r\n    };\r\n    Traceparent.DEFAULT_TRACE_FLAG = \"01\";\r\n    Traceparent.DEFAULT_VERSION = \"00\";\r\n    return Traceparent;\r\n}());\r\nmodule.exports = Traceparent;\r\n//# sourceMappingURL=Traceparent.js.map","\"use strict\";\r\n/**\r\n * Helper class to manage parsing and strict-validation of tracestate header. W3C tracestate spec\r\n * is documented at https://www.w3.org/TR/trace-context/#header-value\r\n * @class Tracestate\r\n */\r\nvar Tracestate = (function () {\r\n    // if true, performs strict tracestate header checking, else just passes it along\r\n    function Tracestate(id) {\r\n        this.fieldmap = [];\r\n        if (!id) {\r\n            return;\r\n        }\r\n        this.fieldmap = this.parseHeader(id);\r\n    }\r\n    Tracestate.prototype.toString = function () {\r\n        var fieldarr = this.fieldmap;\r\n        if (!fieldarr || fieldarr.length == 0) {\r\n            return null;\r\n        }\r\n        return fieldarr.join(\", \");\r\n    };\r\n    Tracestate.validateKeyChars = function (key) {\r\n        var keyParts = key.split(\"@\");\r\n        if (keyParts.length == 2) {\r\n            // Parse for tenant@vendor format\r\n            var tenant = keyParts[0].trim();\r\n            var vendor = keyParts[1].trim();\r\n            var tenantValid = Boolean(tenant.match(/^[\\ ]?[a-z0-9\\*\\-\\_/]{1,241}$/));\r\n            var vendorValid = Boolean(vendor.match(/^[\\ ]?[a-z0-9\\*\\-\\_/]{1,14}$/));\r\n            return tenantValid && vendorValid;\r\n        }\r\n        else if (keyParts.length == 1) {\r\n            // Parse for standard key format\r\n            return Boolean(key.match(/^[\\ ]?[a-z0-9\\*\\-\\_/]{1,256}$/));\r\n        }\r\n        return false;\r\n    };\r\n    Tracestate.prototype.parseHeader = function (id) {\r\n        var res = [];\r\n        var keydeduper = {};\r\n        var parts = id.split(\",\");\r\n        if (parts.length > 32)\r\n            return null;\r\n        for (var _i = 0, parts_1 = parts; _i < parts_1.length; _i++) {\r\n            var rawPart = parts_1[_i];\r\n            var part = rawPart.trim(); // trim out whitespace\r\n            if (part.length === 0) {\r\n                continue; // Discard empty pairs, but keep the rest of this tracestate\r\n            }\r\n            var pair = part.split(\"=\");\r\n            // pair should contain exactly one \"=\"\r\n            if (pair.length !== 2) {\r\n                return null; // invalid pair: discard entire tracestate\r\n            }\r\n            // Validate length and charset of this key\r\n            if (!Tracestate.validateKeyChars(pair[0])) {\r\n                return null;\r\n            }\r\n            // Assert uniqueness of this key\r\n            if (keydeduper[pair[0]]) {\r\n                return null; // duplicate key: discard entire tracestate\r\n            }\r\n            else {\r\n                keydeduper[pair[0]] = true;\r\n            }\r\n            // All checks passed -- add this part\r\n            res.push(part);\r\n        }\r\n        return res;\r\n    };\r\n    Tracestate.strict = true;\r\n    return Tracestate;\r\n}());\r\nmodule.exports = Tracestate;\r\n//# sourceMappingURL=Tracestate.js.map","\"use strict\";\r\nvar __assign = (this && this.__assign) || Object.assign || function(t) {\r\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n        s = arguments[i];\r\n        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\r\n            t[p] = s[p];\r\n    }\r\n    return t;\r\n};\r\nvar http = require(\"http\");\r\nvar https = require(\"https\");\r\nvar url = require(\"url\");\r\nvar constants = require(\"constants\");\r\nvar Logging = require(\"./Logging\");\r\nvar RequestResponseHeaders = require(\"./RequestResponseHeaders\");\r\nvar Util = (function () {\r\n    function Util() {\r\n    }\r\n    /**\r\n     * helper method to access userId and sessionId cookie\r\n     */\r\n    Util.getCookie = function (name, cookie) {\r\n        var value = \"\";\r\n        if (name && name.length && typeof cookie === \"string\") {\r\n            var cookieName = name + \"=\";\r\n            var cookies = cookie.split(\";\");\r\n            for (var i = 0; i < cookies.length; i++) {\r\n                var cookie = cookies[i];\r\n                cookie = Util.trim(cookie);\r\n                if (cookie && cookie.indexOf(cookieName) === 0) {\r\n                    value = cookie.substring(cookieName.length, cookies[i].length);\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        return value;\r\n    };\r\n    /**\r\n     * helper method to trim strings (IE8 does not implement String.prototype.trim)\r\n     */\r\n    Util.trim = function (str) {\r\n        if (typeof str === \"string\") {\r\n            return str.replace(/^\\s+|\\s+$/g, \"\");\r\n        }\r\n        else {\r\n            return \"\";\r\n        }\r\n    };\r\n    /**\r\n     * Convert an array of int32 to Base64 (no '==' at the end).\r\n     * MSB first.\r\n     */\r\n    Util.int32ArrayToBase64 = function (array) {\r\n        var toChar = function (v, i) {\r\n            return String.fromCharCode((v >> i) & 0xFF);\r\n        };\r\n        var int32AsString = function (v) {\r\n            return toChar(v, 24) + toChar(v, 16) + toChar(v, 8) + toChar(v, 0);\r\n        };\r\n        var x = array.map(int32AsString).join(\"\");\r\n        var b = Buffer.from ? Buffer.from(x, \"binary\") : new Buffer(x, \"binary\");\r\n        var s = b.toString(\"base64\");\r\n        return s.substr(0, s.indexOf(\"=\"));\r\n    };\r\n    /**\r\n     * generate a random 32bit number (-0x80000000..0x7FFFFFFF).\r\n     */\r\n    Util.random32 = function () {\r\n        return (0x100000000 * Math.random()) | 0;\r\n    };\r\n    /**\r\n     * generate a random 32bit number (0x00000000..0xFFFFFFFF).\r\n     */\r\n    Util.randomu32 = function () {\r\n        return Util.random32() + 0x80000000;\r\n    };\r\n    /**\r\n     * generate W3C-compatible trace id\r\n     * https://github.com/w3c/distributed-tracing/blob/master/trace_context/HTTP_HEADER_FORMAT.md#trace-id\r\n     */\r\n    Util.w3cTraceId = function () {\r\n        var hexValues = [\"0\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\", \"a\", \"b\", \"c\", \"d\", \"e\", \"f\"];\r\n        // rfc4122 version 4 UUID without dashes and with lowercase letters\r\n        var oct = \"\", tmp;\r\n        for (var a = 0; a < 4; a++) {\r\n            tmp = Util.random32();\r\n            oct +=\r\n                hexValues[tmp & 0xF] +\r\n                    hexValues[tmp >> 4 & 0xF] +\r\n                    hexValues[tmp >> 8 & 0xF] +\r\n                    hexValues[tmp >> 12 & 0xF] +\r\n                    hexValues[tmp >> 16 & 0xF] +\r\n                    hexValues[tmp >> 20 & 0xF] +\r\n                    hexValues[tmp >> 24 & 0xF] +\r\n                    hexValues[tmp >> 28 & 0xF];\r\n        }\r\n        // \"Set the two most significant bits (bits 6 and 7) of the clock_seq_hi_and_reserved to zero and one, respectively\"\r\n        var clockSequenceHi = hexValues[8 + (Math.random() * 4) | 0];\r\n        return oct.substr(0, 8) + oct.substr(9, 4) + \"4\" + oct.substr(13, 3) + clockSequenceHi + oct.substr(16, 3) + oct.substr(19, 12);\r\n    };\r\n    Util.isValidW3CId = function (id) {\r\n        return id.length === 32 && id !== \"00000000000000000000000000000000\";\r\n    };\r\n    /**\r\n     * Check if an object is of type Array\r\n     */\r\n    Util.isArray = function (obj) {\r\n        return Object.prototype.toString.call(obj) === \"[object Array]\";\r\n    };\r\n    /**\r\n     * Check if an object is of type Error\r\n     */\r\n    Util.isError = function (obj) {\r\n        return obj instanceof Error;\r\n    };\r\n    Util.isPrimitive = function (input) {\r\n        var propType = typeof input;\r\n        return propType === \"string\" || propType === \"number\" || propType === \"boolean\";\r\n    };\r\n    /**\r\n     * Check if an object is of type Date\r\n     */\r\n    Util.isDate = function (obj) {\r\n        return Object.prototype.toString.call(obj) === \"[object Date]\";\r\n    };\r\n    /**\r\n     * Convert ms to c# time span format\r\n     */\r\n    Util.msToTimeSpan = function (totalms) {\r\n        if (isNaN(totalms) || totalms < 0) {\r\n            totalms = 0;\r\n        }\r\n        var sec = ((totalms / 1000) % 60).toFixed(7).replace(/0{0,4}$/, \"\");\r\n        var min = \"\" + Math.floor(totalms / (1000 * 60)) % 60;\r\n        var hour = \"\" + Math.floor(totalms / (1000 * 60 * 60)) % 24;\r\n        var days = Math.floor(totalms / (1000 * 60 * 60 * 24));\r\n        sec = sec.indexOf(\".\") < 2 ? \"0\" + sec : sec;\r\n        min = min.length < 2 ? \"0\" + min : min;\r\n        hour = hour.length < 2 ? \"0\" + hour : hour;\r\n        var daysText = days > 0 ? days + \".\" : \"\";\r\n        return daysText + hour + \":\" + min + \":\" + sec;\r\n    };\r\n    /**\r\n     * Using JSON.stringify, by default Errors do not serialize to something useful:\r\n     * Simplify a generic Node Error into a simpler map for customDimensions\r\n     * Custom errors can still implement toJSON to override this functionality\r\n     */\r\n    Util.extractError = function (err) {\r\n        // Error is often subclassed so may have code OR id properties:\r\n        // https://nodejs.org/api/errors.html#errors_error_code\r\n        var looseError = err;\r\n        return {\r\n            message: err.message,\r\n            code: looseError.code || looseError.id || \"\",\r\n        };\r\n    };\r\n    /**\r\n     * Manually call toJSON if available to pre-convert the value.\r\n     * If a primitive is returned, then the consumer of this function can skip JSON.stringify.\r\n     * This avoids double escaping of quotes for Date objects, for example.\r\n     */\r\n    Util.extractObject = function (origProperty) {\r\n        if (origProperty instanceof Error) {\r\n            return Util.extractError(origProperty);\r\n        }\r\n        if (typeof origProperty.toJSON === \"function\") {\r\n            return origProperty.toJSON();\r\n        }\r\n        return origProperty;\r\n    };\r\n    /**\r\n     * Validate that an object is of type { [key: string]: string }\r\n     */\r\n    Util.validateStringMap = function (obj) {\r\n        if (typeof obj !== \"object\") {\r\n            Logging.info(\"Invalid properties dropped from payload\");\r\n            return;\r\n        }\r\n        var map = {};\r\n        for (var field in obj) {\r\n            var property = '';\r\n            var origProperty = obj[field];\r\n            var propType = typeof origProperty;\r\n            if (Util.isPrimitive(origProperty)) {\r\n                property = origProperty.toString();\r\n            }\r\n            else if (origProperty === null || propType === \"undefined\") {\r\n                property = \"\";\r\n            }\r\n            else if (propType === \"function\") {\r\n                Logging.info(\"key: \" + field + \" was function; will not serialize\");\r\n                continue;\r\n            }\r\n            else {\r\n                var stringTarget = Util.isArray(origProperty) ? origProperty : Util.extractObject(origProperty);\r\n                try {\r\n                    if (Util.isPrimitive(stringTarget)) {\r\n                        property = stringTarget;\r\n                    }\r\n                    else {\r\n                        property = JSON.stringify(stringTarget);\r\n                    }\r\n                }\r\n                catch (e) {\r\n                    property = origProperty.constructor.name.toString() + \" (Error: \" + e.message + \")\";\r\n                    Logging.info(\"key: \" + field + \", could not be serialized\");\r\n                }\r\n            }\r\n            map[field] = property.substring(0, Util.MAX_PROPERTY_LENGTH);\r\n        }\r\n        return map;\r\n    };\r\n    /**\r\n     * Checks if a request url is not on a excluded domain list\r\n     * and if it is safe to add correlation headers\r\n     */\r\n    Util.canIncludeCorrelationHeader = function (client, requestUrl) {\r\n        var excludedDomains = client && client.config && client.config.correlationHeaderExcludedDomains;\r\n        if (!excludedDomains || excludedDomains.length == 0 || !requestUrl) {\r\n            return true;\r\n        }\r\n        for (var i = 0; i < excludedDomains.length; i++) {\r\n            var regex = new RegExp(excludedDomains[i].replace(/\\./g, \"\\.\").replace(/\\*/g, \".*\"));\r\n            if (regex.test(url.parse(requestUrl).hostname)) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    };\r\n    Util.getCorrelationContextTarget = function (response, key) {\r\n        var contextHeaders = response.headers && response.headers[RequestResponseHeaders.requestContextHeader];\r\n        if (contextHeaders) {\r\n            var keyValues = contextHeaders.split(\",\");\r\n            for (var i = 0; i < keyValues.length; ++i) {\r\n                var keyValue = keyValues[i].split(\"=\");\r\n                if (keyValue.length == 2 && keyValue[0] == key) {\r\n                    return keyValue[1];\r\n                }\r\n            }\r\n        }\r\n    };\r\n    /**\r\n     * Generate request\r\n     *\r\n     * Proxify the request creation to handle proxy http\r\n     *\r\n     * @param {string} requestUrl url endpoint\r\n     * @param {Object} requestOptions Request option\r\n     * @param {Function} requestCallback callback on request\r\n     * @returns {http.ClientRequest} request object\r\n     */\r\n    Util.makeRequest = function (config, requestUrl, requestOptions, requestCallback) {\r\n        if (requestUrl && requestUrl.indexOf('//') === 0) {\r\n            requestUrl = 'https:' + requestUrl;\r\n        }\r\n        var requestUrlParsed = url.parse(requestUrl);\r\n        var options = __assign({}, requestOptions, { host: requestUrlParsed.hostname, port: requestUrlParsed.port, path: requestUrlParsed.pathname });\r\n        var proxyUrl = undefined;\r\n        if (requestUrlParsed.protocol === 'https:') {\r\n            proxyUrl = config.proxyHttpsUrl || undefined;\r\n        }\r\n        if (requestUrlParsed.protocol === 'http:') {\r\n            proxyUrl = config.proxyHttpUrl || undefined;\r\n        }\r\n        if (proxyUrl) {\r\n            if (proxyUrl.indexOf('//') === 0) {\r\n                proxyUrl = 'http:' + proxyUrl;\r\n            }\r\n            var proxyUrlParsed = url.parse(proxyUrl);\r\n            // https is not supported at the moment\r\n            if (proxyUrlParsed.protocol === 'https:') {\r\n                Logging.info(\"Proxies that use HTTPS are not supported\");\r\n                proxyUrl = undefined;\r\n            }\r\n            else {\r\n                options = __assign({}, options, { host: proxyUrlParsed.hostname, port: proxyUrlParsed.port || \"80\", path: requestUrl, headers: __assign({}, options.headers, { Host: requestUrlParsed.hostname }) });\r\n            }\r\n        }\r\n        var isHttps = requestUrlParsed.protocol === 'https:' && !proxyUrl;\r\n        if (isHttps && config.httpsAgent !== undefined) {\r\n            options.agent = config.httpsAgent;\r\n        }\r\n        else if (!isHttps && config.httpAgent !== undefined) {\r\n            options.agent = config.httpAgent;\r\n        }\r\n        else if (isHttps) {\r\n            // HTTPS without a passed in agent. Use one that enforces our TLS rules\r\n            options.agent = Util.tlsRestrictedAgent;\r\n        }\r\n        if (isHttps) {\r\n            return https.request(options, requestCallback);\r\n        }\r\n        else {\r\n            return http.request(options, requestCallback);\r\n        }\r\n    };\r\n    ;\r\n    /**\r\n     * Parse standard <string | string[] | number> request-context header\r\n     */\r\n    Util.safeIncludeCorrelationHeader = function (client, request, correlationHeader) {\r\n        var header; // attempt to cast correlationHeader to string\r\n        if (typeof correlationHeader === \"string\") {\r\n            header = correlationHeader;\r\n        }\r\n        else if (correlationHeader instanceof Array) {\r\n            header = correlationHeader.join(\",\");\r\n        }\r\n        else if (correlationHeader && typeof correlationHeader.toString === \"function\") {\r\n            // best effort attempt: requires well-defined toString\r\n            try {\r\n                header = correlationHeader.toString();\r\n            }\r\n            catch (err) {\r\n                Logging.warn(\"Outgoing request-context header could not be read. Correlation of requests may be lost.\", err, correlationHeader);\r\n            }\r\n        }\r\n        if (header) {\r\n            Util.addCorrelationIdHeaderFromString(client, request, header);\r\n        }\r\n        else {\r\n            request.setHeader(RequestResponseHeaders.requestContextHeader, RequestResponseHeaders.requestContextSourceKey + \"=\" + client.config.correlationId);\r\n        }\r\n    };\r\n    Util.addCorrelationIdHeaderFromString = function (client, response, correlationHeader) {\r\n        var components = correlationHeader.split(\",\");\r\n        var key = RequestResponseHeaders.requestContextSourceKey + \"=\";\r\n        var found = components.some(function (value) { return value.substring(0, key.length) === key; });\r\n        if (!found) {\r\n            response.setHeader(RequestResponseHeaders.requestContextHeader, correlationHeader + \",\" + RequestResponseHeaders.requestContextSourceKey + \"=\" + client.config.correlationId);\r\n        }\r\n    };\r\n    Util.MAX_PROPERTY_LENGTH = 8192;\r\n    Util.tlsRestrictedAgent = new https.Agent({\r\n        secureOptions: constants.SSL_OP_NO_SSLv2 | constants.SSL_OP_NO_SSLv3 |\r\n            constants.SSL_OP_NO_TLSv1 | constants.SSL_OP_NO_TLSv1_1\r\n    });\r\n    return Util;\r\n}());\r\nmodule.exports = Util;\r\n//# sourceMappingURL=Util.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar AutoCollectPerformance = require(\"../AutoCollection/Performance\");\r\nvar TelemetryType = require(\"../Declarations/Contracts\");\r\nfunction performanceMetricsTelemetryProcessor(envelope, client) {\r\n    // If live metrics is enabled, forward all telemetry there\r\n    if (client) {\r\n        client.addDocument(envelope);\r\n    }\r\n    // Increment rate counters (for standard metrics and live metrics)\r\n    switch (envelope.data.baseType) {\r\n        case TelemetryType.TelemetryTypeString.Exception:\r\n            AutoCollectPerformance.countException();\r\n            break;\r\n        case TelemetryType.TelemetryTypeString.Request:\r\n            var requestData = envelope.data.baseData;\r\n            AutoCollectPerformance.countRequest(requestData.duration, requestData.success);\r\n            break;\r\n        case TelemetryType.TelemetryTypeString.Dependency:\r\n            var remoteDependencyData = envelope.data.baseData;\r\n            AutoCollectPerformance.countDependency(remoteDependencyData.duration, remoteDependencyData.success);\r\n            break;\r\n    }\r\n    return true;\r\n}\r\nexports.performanceMetricsTelemetryProcessor = performanceMetricsTelemetryProcessor;\r\n//# sourceMappingURL=PerformanceMetricsTelemetryProcessor.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar Contracts = require(\"../Declarations/Contracts\");\r\n/**\r\n *  A telemetry processor that handles sampling.\r\n */\r\nfunction samplingTelemetryProcessor(envelope, contextObjects) {\r\n    var samplingPercentage = envelope.sampleRate; // Set for us in Client.getEnvelope\r\n    var isSampledIn = false;\r\n    if (samplingPercentage === null || samplingPercentage === undefined || samplingPercentage >= 100) {\r\n        return true;\r\n    }\r\n    else if (envelope.data && Contracts.TelemetryType.Metric === Contracts.baseTypeToTelemetryType(envelope.data.baseType)) {\r\n        // Exclude MetricData telemetry from sampling\r\n        return true;\r\n    }\r\n    else if (contextObjects.correlationContext && contextObjects.correlationContext.operation) {\r\n        // If we're using dependency correlation, sampling should retain all telemetry from a given request\r\n        isSampledIn = getSamplingHashCode(contextObjects.correlationContext.operation.id) < samplingPercentage;\r\n    }\r\n    else {\r\n        // If we're not using dependency correlation, sampling should use a random distribution on each item\r\n        isSampledIn = (Math.random() * 100) < samplingPercentage;\r\n    }\r\n    return isSampledIn;\r\n}\r\nexports.samplingTelemetryProcessor = samplingTelemetryProcessor;\r\n/** Ported from AI .NET SDK */\r\nfunction getSamplingHashCode(input) {\r\n    var csharpMin = -2147483648;\r\n    var csharpMax = 2147483647;\r\n    var hash = 5381;\r\n    if (!input) {\r\n        return 0;\r\n    }\r\n    while (input.length < 8) {\r\n        input = input + input;\r\n    }\r\n    for (var i = 0; i < input.length; i++) {\r\n        // JS doesn't respond to integer overflow by wrapping around. Simulate it with bitwise operators ( | 0)\r\n        hash = ((((hash << 5) + hash) | 0) + input.charCodeAt(i) | 0);\r\n    }\r\n    hash = hash <= csharpMin ? csharpMax : Math.abs(hash);\r\n    return (hash / csharpMax) * 100;\r\n}\r\nexports.getSamplingHashCode = getSamplingHashCode;\r\n//# sourceMappingURL=SamplingTelemetryProcessor.js.map","\"use strict\";\r\nfunction __export(m) {\r\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n__export(require(\"./SamplingTelemetryProcessor\"));\r\n__export(require(\"./PerformanceMetricsTelemetryProcessor\"));\r\n//# sourceMappingURL=index.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar CorrelationContextManager = require(\"./AutoCollection/CorrelationContextManager\"); // Keep this first\r\nvar AutoCollectConsole = require(\"./AutoCollection/Console\");\r\nvar AutoCollectExceptions = require(\"./AutoCollection/Exceptions\");\r\nvar AutoCollectPerformance = require(\"./AutoCollection/Performance\");\r\nvar AutoCollectHttpDependencies = require(\"./AutoCollection/HttpDependencies\");\r\nvar AutoCollectHttpRequests = require(\"./AutoCollection/HttpRequests\");\r\nvar CorrelationIdManager = require(\"./Library/CorrelationIdManager\");\r\nvar Logging = require(\"./Library/Logging\");\r\nvar QuickPulseClient = require(\"./Library/QuickPulseStateManager\");\r\nvar NativePerformance_1 = require(\"./AutoCollection/NativePerformance\");\r\n// We export these imports so that SDK users may use these classes directly.\r\n// They're exposed using \"export import\" so that types are passed along as expected\r\nexports.TelemetryClient = require(\"./Library/NodeClient\");\r\nexports.Contracts = require(\"./Declarations/Contracts\");\r\nvar DistributedTracingModes;\r\n(function (DistributedTracingModes) {\r\n    /**\r\n     * (Default) Send Application Insights correlation headers\r\n     */\r\n    DistributedTracingModes[DistributedTracingModes[\"AI\"] = 0] = \"AI\";\r\n    /**\r\n     * Send both W3C Trace Context headers and back-compatibility Application Insights headers\r\n     */\r\n    DistributedTracingModes[DistributedTracingModes[\"AI_AND_W3C\"] = 1] = \"AI_AND_W3C\";\r\n})(DistributedTracingModes = exports.DistributedTracingModes || (exports.DistributedTracingModes = {}));\r\n// Default autocollection configuration\r\nvar _isConsole = true;\r\nvar _isConsoleLog = false;\r\nvar _isExceptions = true;\r\nvar _isPerformance = true;\r\nvar _isRequests = true;\r\nvar _isDependencies = true;\r\nvar _isDiskRetry = true;\r\nvar _isCorrelating = true;\r\nvar _forceClsHooked;\r\nvar _isSendingLiveMetrics = false; // Off by default\r\nvar _isNativePerformance = true;\r\nvar _disabledExtendedMetrics;\r\nvar _diskRetryInterval = undefined;\r\nvar _diskRetryMaxBytes = undefined;\r\nvar _console;\r\nvar _exceptions;\r\nvar _performance;\r\nvar _nativePerformance;\r\nvar _serverRequests;\r\nvar _clientRequests;\r\nvar _isStarted = false;\r\nvar _performanceLiveMetrics;\r\n/**\r\n * Initializes the default client. Should be called after setting\r\n * configuration options.\r\n *\r\n * @param setupString the Connection String or Instrumentation Key to use. Optional, if\r\n * this is not specified, the value will be read from the environment\r\n * variable APPLICATIONINSIGHTS_CONNECTION_STRING or APPINSIGHTS_INSTRUMENTATIONKEY.\r\n * @returns {Configuration} the configuration class to initialize\r\n * and start the SDK.\r\n */\r\nfunction setup(setupString) {\r\n    if (!exports.defaultClient) {\r\n        exports.defaultClient = new exports.TelemetryClient(setupString);\r\n        _console = new AutoCollectConsole(exports.defaultClient);\r\n        _exceptions = new AutoCollectExceptions(exports.defaultClient);\r\n        _performance = new AutoCollectPerformance(exports.defaultClient);\r\n        _serverRequests = new AutoCollectHttpRequests(exports.defaultClient);\r\n        _clientRequests = new AutoCollectHttpDependencies(exports.defaultClient);\r\n        if (!_nativePerformance) {\r\n            _nativePerformance = new NativePerformance_1.AutoCollectNativePerformance(exports.defaultClient);\r\n        }\r\n    }\r\n    else {\r\n        Logging.info(\"The default client is already setup\");\r\n    }\r\n    if (exports.defaultClient && exports.defaultClient.channel) {\r\n        exports.defaultClient.channel.setUseDiskRetryCaching(_isDiskRetry, _diskRetryInterval, _diskRetryMaxBytes);\r\n    }\r\n    return Configuration;\r\n}\r\nexports.setup = setup;\r\n/**\r\n * Starts automatic collection of telemetry. Prior to calling start no\r\n * telemetry will be *automatically* collected, though manual collection\r\n * is enabled.\r\n * @returns {ApplicationInsights} this class\r\n */\r\nfunction start() {\r\n    if (!!exports.defaultClient) {\r\n        _isStarted = true;\r\n        _console.enable(_isConsole, _isConsoleLog);\r\n        _exceptions.enable(_isExceptions);\r\n        _performance.enable(_isPerformance);\r\n        _nativePerformance.enable(_isNativePerformance, _disabledExtendedMetrics);\r\n        _serverRequests.useAutoCorrelation(_isCorrelating, _forceClsHooked);\r\n        _serverRequests.enable(_isRequests);\r\n        _clientRequests.enable(_isDependencies);\r\n        if (exports.liveMetricsClient && _isSendingLiveMetrics) {\r\n            exports.liveMetricsClient.enable(_isSendingLiveMetrics);\r\n        }\r\n    }\r\n    else {\r\n        Logging.warn(\"Start cannot be called before setup\");\r\n    }\r\n    return Configuration;\r\n}\r\nexports.start = start;\r\n/**\r\n * Returns an object that is shared across all code handling a given request.\r\n * This can be used similarly to thread-local storage in other languages.\r\n * Properties set on this object will be available to telemetry processors.\r\n *\r\n * Do not store sensitive information here.\r\n * Custom properties set on this object can be exposed in a future SDK\r\n * release via outgoing HTTP headers.\r\n * This is to allow for correlating data cross-component.\r\n *\r\n * This method will return null if automatic dependency correlation is disabled.\r\n * @returns A plain object for request storage or null if automatic dependency correlation is disabled.\r\n */\r\nfunction getCorrelationContext() {\r\n    if (_isCorrelating) {\r\n        return CorrelationContextManager.CorrelationContextManager.getCurrentContext();\r\n    }\r\n    return null;\r\n}\r\nexports.getCorrelationContext = getCorrelationContext;\r\n/**\r\n * Returns a function that will get the same correlation context within its\r\n * function body as the code executing this function.\r\n * Use this method if automatic dependency correlation is not propagating\r\n * correctly to an asynchronous callback.\r\n */\r\nfunction wrapWithCorrelationContext(fn) {\r\n    return CorrelationContextManager.CorrelationContextManager.wrapCallback(fn);\r\n}\r\nexports.wrapWithCorrelationContext = wrapWithCorrelationContext;\r\n/**\r\n * The active configuration for global SDK behaviors, such as autocollection.\r\n */\r\nvar Configuration = (function () {\r\n    function Configuration() {\r\n    }\r\n    /**\r\n     * Sets the distributed tracing modes. If W3C mode is enabled, W3C trace context\r\n     * headers (traceparent/tracestate) will be parsed in all incoming requests, and included in outgoing\r\n     * requests. In W3C mode, existing back-compatibility AI headers will also be parsed and included.\r\n     * Enabling W3C mode will not break existing correlation with other Application Insights instrumented\r\n     * services. Default=AI\r\n    */\r\n    Configuration.setDistributedTracingMode = function (value) {\r\n        CorrelationIdManager.w3cEnabled = value === DistributedTracingModes.AI_AND_W3C;\r\n        return Configuration;\r\n    };\r\n    /**\r\n     * Sets the state of console and logger tracking (enabled by default for third-party loggers only)\r\n     * @param value if true logger activity will be sent to Application Insights\r\n     * @param collectConsoleLog if true, logger autocollection will include console.log calls (default false)\r\n     * @returns {Configuration} this class\r\n     */\r\n    Configuration.setAutoCollectConsole = function (value, collectConsoleLog) {\r\n        if (collectConsoleLog === void 0) { collectConsoleLog = false; }\r\n        _isConsole = value;\r\n        _isConsoleLog = collectConsoleLog;\r\n        if (_isStarted) {\r\n            _console.enable(value, collectConsoleLog);\r\n        }\r\n        return Configuration;\r\n    };\r\n    /**\r\n     * Sets the state of exception tracking (enabled by default)\r\n     * @param value if true uncaught exceptions will be sent to Application Insights\r\n     * @returns {Configuration} this class\r\n     */\r\n    Configuration.setAutoCollectExceptions = function (value) {\r\n        _isExceptions = value;\r\n        if (_isStarted) {\r\n            _exceptions.enable(value);\r\n        }\r\n        return Configuration;\r\n    };\r\n    /**\r\n     * Sets the state of performance tracking (enabled by default)\r\n     * @param value if true performance counters will be collected every second and sent to Application Insights\r\n     * @param collectExtendedMetrics if true, extended metrics counters will be collected every minute and sent to Application Insights\r\n     * @returns {Configuration} this class\r\n     */\r\n    Configuration.setAutoCollectPerformance = function (value, collectExtendedMetrics) {\r\n        if (collectExtendedMetrics === void 0) { collectExtendedMetrics = true; }\r\n        _isPerformance = value;\r\n        var extendedMetricsConfig = NativePerformance_1.AutoCollectNativePerformance.parseEnabled(collectExtendedMetrics);\r\n        _isNativePerformance = extendedMetricsConfig.isEnabled;\r\n        _disabledExtendedMetrics = extendedMetricsConfig.disabledMetrics;\r\n        if (_isStarted) {\r\n            _performance.enable(value);\r\n            _nativePerformance.enable(extendedMetricsConfig.isEnabled, extendedMetricsConfig.disabledMetrics);\r\n        }\r\n        return Configuration;\r\n    };\r\n    /**\r\n     * Sets the state of request tracking (enabled by default)\r\n     * @param value if true requests will be sent to Application Insights\r\n     * @returns {Configuration} this class\r\n     */\r\n    Configuration.setAutoCollectRequests = function (value) {\r\n        _isRequests = value;\r\n        if (_isStarted) {\r\n            _serverRequests.enable(value);\r\n        }\r\n        return Configuration;\r\n    };\r\n    /**\r\n     * Sets the state of dependency tracking (enabled by default)\r\n     * @param value if true dependencies will be sent to Application Insights\r\n     * @returns {Configuration} this class\r\n     */\r\n    Configuration.setAutoCollectDependencies = function (value) {\r\n        _isDependencies = value;\r\n        if (_isStarted) {\r\n            _clientRequests.enable(value);\r\n        }\r\n        return Configuration;\r\n    };\r\n    /**\r\n     * Sets the state of automatic dependency correlation (enabled by default)\r\n     * @param value if true dependencies will be correlated with requests\r\n     * @param useAsyncHooks if true, forces use of experimental async_hooks module to provide correlation. If false, instead uses only patching-based techniques. If left blank, the best option is chosen for you based on your version of Node.js.\r\n     * @returns {Configuration} this class\r\n     */\r\n    Configuration.setAutoDependencyCorrelation = function (value, useAsyncHooks) {\r\n        _isCorrelating = value;\r\n        _forceClsHooked = useAsyncHooks;\r\n        if (_isStarted) {\r\n            _serverRequests.useAutoCorrelation(value, useAsyncHooks);\r\n        }\r\n        return Configuration;\r\n    };\r\n    /**\r\n     * Enable or disable disk-backed retry caching to cache events when client is offline (enabled by default)\r\n     * Note that this method only applies to the default client. Disk-backed retry caching is disabled by default for additional clients.\r\n     * For enable for additional clients, use client.channel.setUseDiskRetryCaching(true).\r\n     * These cached events are stored in your system or user's temporary directory and access restricted to your user when possible.\r\n     * @param value if true events that occured while client is offline will be cached on disk\r\n     * @param resendInterval The wait interval for resending cached events.\r\n     * @param maxBytesOnDisk The maximum size (in bytes) that the created temporary directory for cache events can grow to, before caching is disabled.\r\n     * @returns {Configuration} this class\r\n     */\r\n    Configuration.setUseDiskRetryCaching = function (value, resendInterval, maxBytesOnDisk) {\r\n        _isDiskRetry = value;\r\n        _diskRetryInterval = resendInterval;\r\n        _diskRetryMaxBytes = maxBytesOnDisk;\r\n        if (exports.defaultClient && exports.defaultClient.channel) {\r\n            exports.defaultClient.channel.setUseDiskRetryCaching(value, resendInterval, maxBytesOnDisk);\r\n        }\r\n        return Configuration;\r\n    };\r\n    /**\r\n     * Enables debug and warning logging for AppInsights itself.\r\n     * @param enableDebugLogging if true, enables debug logging\r\n     * @param enableWarningLogging if true, enables warning logging\r\n     * @returns {Configuration} this class\r\n     */\r\n    Configuration.setInternalLogging = function (enableDebugLogging, enableWarningLogging) {\r\n        if (enableDebugLogging === void 0) { enableDebugLogging = false; }\r\n        if (enableWarningLogging === void 0) { enableWarningLogging = true; }\r\n        Logging.enableDebug = enableDebugLogging;\r\n        Logging.disableWarnings = !enableWarningLogging;\r\n        return Configuration;\r\n    };\r\n    /**\r\n     * Enables communication with Application Insights Live Metrics.\r\n     * @param enable if true, enables communication with the live metrics service\r\n     */\r\n    Configuration.setSendLiveMetrics = function (enable) {\r\n        if (enable === void 0) { enable = false; }\r\n        if (!exports.defaultClient) {\r\n            // Need a defaultClient so that we can add the QPS telemetry processor to it\r\n            Logging.warn(\"Live metrics client cannot be setup without the default client\");\r\n            return Configuration;\r\n        }\r\n        if (!exports.liveMetricsClient) {\r\n            // No qps client exists. Create one and prepare it to be enabled at .start()\r\n            exports.liveMetricsClient = new QuickPulseClient(exports.defaultClient.config.instrumentationKey);\r\n            _performanceLiveMetrics = new AutoCollectPerformance(exports.liveMetricsClient, 1000, true);\r\n            exports.liveMetricsClient.addCollector(_performanceLiveMetrics);\r\n            exports.defaultClient.quickPulseClient = exports.liveMetricsClient; // Need this so we can forward all manual tracks to live metrics via PerformanceMetricsTelemetryProcessor\r\n            _isSendingLiveMetrics = enable;\r\n        }\r\n        else {\r\n            // qps client already exists; enable/disable it\r\n            exports.liveMetricsClient.enable(enable);\r\n        }\r\n        return Configuration;\r\n    };\r\n    // Convenience shortcut to ApplicationInsights.start\r\n    Configuration.start = start;\r\n    return Configuration;\r\n}());\r\nexports.Configuration = Configuration;\r\n/**\r\n * Disposes the default client and all the auto collectors so they can be reinitialized with different configuration\r\n*/\r\nfunction dispose() {\r\n    exports.defaultClient = null;\r\n    _isStarted = false;\r\n    if (_console) {\r\n        _console.dispose();\r\n    }\r\n    if (_exceptions) {\r\n        _exceptions.dispose();\r\n    }\r\n    if (_performance) {\r\n        _performance.dispose();\r\n    }\r\n    if (_nativePerformance) {\r\n        _nativePerformance.dispose();\r\n    }\r\n    if (_serverRequests) {\r\n        _serverRequests.dispose();\r\n    }\r\n    if (_clientRequests) {\r\n        _clientRequests.dispose();\r\n    }\r\n}\r\nexports.dispose = dispose;\r\n//# sourceMappingURL=applicationinsights.js.map","'use strict';\n\nconst asyncWrap = process.binding('async_wrap');\nconst TIMERWRAP = asyncWrap.Providers.TIMERWRAP;\n\nconst patchs = {\n  'nextTick': require('./patches/next-tick.js'),\n  'promise': require('./patches/promise.js'),\n  'timers': require('./patches/timers.js')\n};\n\nconst ignoreUIDs = new Set();\n\nfunction State() {\n  this.enabled = false;\n  this.counter = 0;\n}\n\nfunction Hooks() {\n  const initFns = this.initFns = [];\n  const preFns = this.preFns = [];\n  const postFns = this.postFns = [];\n  const destroyFns = this.destroyFns = [];\n\n  this.init = function (uid, provider, parentUid, parentHandle) {\n    // Ignore TIMERWRAP, since setTimeout etc. is monkey patched\n    if (provider === TIMERWRAP) {\n      ignoreUIDs.add(uid);\n      return;\n    }\n\n    // call hooks\n    for (const hook of initFns) {\n      hook(uid, this, provider, parentUid, parentHandle);\n    }\n  };\n\n  this.pre = function (uid) {\n    if (ignoreUIDs.has(uid)) return;\n\n    // call hooks\n    for (const hook of preFns) {\n      hook(uid, this);\n    }\n  };\n\n  this.post = function (uid, didThrow) {\n    if (ignoreUIDs.has(uid)) return;\n\n    // call hooks\n    for (const hook of postFns) {\n      hook(uid, this, didThrow);\n    }\n  };\n\n  this.destroy = function (uid) {\n    // Cleanup the ignore list if this uid should be ignored\n    if (ignoreUIDs.has(uid)) {\n      ignoreUIDs.delete(uid);\n      return;\n    }\n\n    // call hooks\n    for (const hook of destroyFns) {\n      hook(uid);\n    }\n  };\n}\n\nHooks.prototype.add = function (hooks) {\n  if (hooks.init) this.initFns.push(hooks.init);\n  if (hooks.pre) this.preFns.push(hooks.pre);\n  if (hooks.post) this.postFns.push(hooks.post);\n  if (hooks.destroy) this.destroyFns.push(hooks.destroy);\n};\n\nfunction removeElement(array, item) {\n  const index = array.indexOf(item);\n  if (index === -1) return;\n  array.splice(index, 1);\n}\n\nHooks.prototype.remove = function (hooks) {\n  if (hooks.init) removeElement(this.initFns, hooks.init);\n  if (hooks.pre) removeElement(this.preFns, hooks.pre);\n  if (hooks.post) removeElement(this.postFns, hooks.post);\n  if (hooks.destroy) removeElement(this.destroyFns, hooks.destroy);\n};\n\nfunction AsyncHook() {\n  this._state = new State();\n  this._hooks = new Hooks();\n\n  // expose version for conflict detection\n  this.version = require('./package.json').version;\n\n  // expose the Providers map\n  this.providers = asyncWrap.Providers;\n\n  // apply patches\n  for (const key of Object.keys(patchs)) {\n    patchs[key].call(this);\n  }\n\n  // setup async wrap\n  if (process.env.hasOwnProperty('NODE_ASYNC_HOOK_WARNING')) {\n    console.warn('warning: you are using async-hook-jl which is unstable.');\n  }\n  asyncWrap.setupHooks({\n    init: this._hooks.init,\n    pre: this._hooks.pre,\n    post: this._hooks.post,\n    destroy: this._hooks.destroy\n  });\n}\nmodule.exports = AsyncHook;\n\nAsyncHook.prototype.addHooks = function (hooks) {\n  this._hooks.add(hooks);\n};\n\nAsyncHook.prototype.removeHooks = function (hooks) {\n  this._hooks.remove(hooks);\n};\n\nAsyncHook.prototype.enable = function () {\n  this._state.enabled = true;\n  asyncWrap.enable();\n};\n\nAsyncHook.prototype.disable = function () {\n  this._state.enabled = false;\n  asyncWrap.disable();\n};","'use strict';\n\nconst AsyncHook = require('./async-hook.js');\n\n// If a another copy (same version or not) of stack-chain exists it will result\n// in wrong stack traces (most likely dublicate callSites).\nif (global._asyncHook) {\n  // In case the version match, we can simply return the first initialized copy\n  if (global._asyncHook.version === require('./package.json').version) {\n    module.exports = global._asyncHook;\n  }\n  // The version don't match, this is really bad. Lets just throw\n  else {\n    throw new Error('Conflicting version of async-hook-jl found');\n  }\n} else {\n  const stackChain = require('stack-chain');\n\n  // Remove callSites from this module. AsyncWrap doesn't have any callSites\n  // and the hooks are expected to be completely transparent.\n  stackChain.filter.attach(function (error, frames) {\n    return frames.filter(function (callSite) {\n      const filename = callSite.getFileName();\n      // filename is not always a string, for example in case of eval it is\n      // undefined. So check if the filename is defined.\n      return !(filename && filename.slice(0, __dirname.length) === __dirname);\n    });\n  });\n\n  module.exports = global._asyncHook = new AsyncHook();\n}","'use strict';\n\nfunction NextTickWrap() {}\n\nmodule.exports = function patch() {\n  const hooks = this._hooks;\n  const state = this._state;\n\n  const oldNextTick = process.nextTick;\n  process.nextTick = function () {\n    if (!state.enabled) return oldNextTick.apply(process, arguments);\n\n    const args = new Array(arguments.length);\n    for (let i = 0; i < arguments.length; i++) {\n      args[i] = arguments[i];\n    }\n    const callback = args[0];\n\n    if (typeof callback !== 'function') {\n      throw new TypeError('callback is not a function');\n    }\n\n    const handle = new NextTickWrap();\n    const uid = --state.counter;\n\n    // call the init hook\n    hooks.init.call(handle, uid, 0, null, null);\n\n    // overwrite callback\n    args[0] = function () {\n      // call the pre hook\n      hooks.pre.call(handle, uid);\n\n      let didThrow = true;\n      try {\n        callback.apply(this, arguments);\n        didThrow = false;\n      } finally {\n        // If `callback` threw and there is an uncaughtException handler\n        // then call the `post` and `destroy` hook after the uncaughtException\n        // user handlers have been invoked.\n        if(didThrow && process.listenerCount('uncaughtException') > 0) {\n          process.once('uncaughtException', function () {\n            hooks.post.call(handle, uid, true);\n            hooks.destroy.call(null, uid);\n          });\n        }\n      }\n\n      // callback done successfully\n      hooks.post.call(handle, uid, false);\n      hooks.destroy.call(null, uid);\n    };\n\n    return oldNextTick.apply(process, args);\n  };\n}\n","'use strict';\n\nfunction PromiseWrap() {}\n\nmodule.exports = function patchPromise() {\n  const hooks = this._hooks;\n  const state = this._state;\n\n  const Promise = global.Promise;\n\n  /* As per ECMAScript 2015, .catch must be implemented by calling .then, as\n   * such we need needn't patch .catch as well. see:\n   * http://www.ecma-international.org/ecma-262/6.0/#sec-promise.prototype.catch\n   */\n  const oldThen = Promise.prototype.then;\n  Promise.prototype.then = wrappedThen;\n\n  function makeWrappedHandler(fn, handle, uid, isOnFulfilled) {\n    if ('function' !== typeof fn) {\n      return isOnFulfilled\n        ? makeUnhandledResolutionHandler(uid)\n        : makeUnhandledRejectionHandler(uid);\n    }\n\n    return function wrappedHandler() {\n      hooks.pre.call(handle, uid);\n      try {\n        return fn.apply(this, arguments);\n      } finally {\n        hooks.post.call(handle, uid, false);\n        hooks.destroy.call(null, uid);\n      }\n    };\n  }\n\n  function makeUnhandledResolutionHandler(uid) {\n    return function unhandledResolutionHandler(val) {\n      hooks.destroy.call(null, uid);\n      return val;\n    };\n  }\n\n  function makeUnhandledRejectionHandler(uid) {\n    return function unhandledRejectedHandler(val) {\n      hooks.destroy.call(null, uid);\n      throw val;\n    };\n  }\n\n  function wrappedThen(onFulfilled, onRejected) {\n    if (!state.enabled) return oldThen.call(this, onFulfilled, onRejected);\n\n    const handle = new PromiseWrap();\n    const uid = --state.counter;\n\n    hooks.init.call(handle, uid, 0, null, null);\n\n    return oldThen.call(\n      this,\n      makeWrappedHandler(onFulfilled, handle, uid, true),\n      makeWrappedHandler(onRejected, handle, uid, false)\n    );\n  }\n};\n","'use strict';\n\nconst timers = require('timers');\n\nfunction TimeoutWrap() {}\nfunction IntervalWrap() {}\nfunction ImmediateWrap() {}\n\nconst timeoutMap = new Map();\nconst intervalMap = new Map();\nconst ImmediateMap = new Map();\n\nlet activeCallback = null;\nlet clearedInCallback = false;\n\nmodule.exports = function patch() {\n  patchTimer(this._hooks, this._state, 'setTimeout', 'clearTimeout', TimeoutWrap, timeoutMap, true);\n  patchTimer(this._hooks, this._state, 'setInterval', 'clearInterval', IntervalWrap, intervalMap, false);\n  patchTimer(this._hooks, this._state, 'setImmediate', 'clearImmediate', ImmediateWrap, ImmediateMap, true);\n\n  global.setTimeout = timers.setTimeout;\n  global.setInterval = timers.setInterval;\n  global.setImmediate = timers.setImmediate;\n\n  global.clearTimeout = timers.clearTimeout;\n  global.clearInterval = timers.clearInterval;\n  global.clearImmediate = timers.clearImmediate;\n};\n\nfunction patchTimer(hooks, state, setFn, clearFn, Handle, timerMap, singleCall) {\n  const oldSetFn = timers[setFn];\n  const oldClearFn = timers[clearFn];\n\n  // overwrite set[Timeout]\n  timers[setFn] = function () {\n    if (!state.enabled) return oldSetFn.apply(timers, arguments);\n\n    const args = new Array(arguments.length);\n    for (let i = 0; i < arguments.length; i++) {\n      args[i] = arguments[i];\n    }\n    const callback = args[0];\n\n    if (typeof callback !== 'function') {\n      throw new TypeError('\"callback\" argument must be a function');\n    }\n\n    const handle = new Handle();\n    const uid = --state.counter;\n    let timerId = undefined;\n\n    // call the init hook\n    hooks.init.call(handle, uid, 0, null, null);\n\n    // overwrite callback\n    args[0] = function () {\n      // call the pre hook\n      activeCallback = timerId;\n      hooks.pre.call(handle, uid);\n\n      let didThrow = true;\n      try {\n        callback.apply(this, arguments);\n        didThrow = false;\n      } finally {\n        // If `callback` threw and there is an uncaughtException handler\n        // then call the `post` and `destroy` hook after the uncaughtException\n        // user handlers have been invoked.\n        if (didThrow && process.listenerCount('uncaughtException') > 0) {\n          process.once('uncaughtException', function () {\n            // call the post hook\n            hooks.post.call(handle, uid, true);\n            // setInterval won't continue\n            timerMap.delete(timerId);\n            hooks.destroy.call(null, uid);\n          });\n        }\n      }\n\n      // callback done successfully\n      hooks.post.call(handle, uid, false);\n      activeCallback = null;\n\n      // call the destroy hook if the callback will only be called once\n      if (singleCall || clearedInCallback) {\n        clearedInCallback = false;\n        timerMap.delete(timerId);\n        hooks.destroy.call(null, uid);\n      }\n    };\n\n    timerId = oldSetFn.apply(timers, args);\n    // Bind the timerId and uid for later use, in case the clear* function is\n    // called.\n    timerMap.set(timerId, uid);\n\n    return timerId;\n  };\n\n  // overwrite clear[Timeout]\n  timers[clearFn] = function (timerId) {\n    // If clear* was called within the timer callback, then delay the destroy\n    // event to after the post event has been called.\n    if (activeCallback === timerId && timerId !== null) {\n      clearedInCallback = true;\n    }\n    // clear should call the destroy hook. Note if timerId doesn't exists\n    // it is because asyncWrap wasn't enabled at the time.\n    else if (timerMap.has(timerId)) {\n      const uid = timerMap.get(timerId);\n      timerMap.delete(timerId);\n      hooks.destroy.call(null, uid);\n    }\n\n    oldClearFn.apply(timers, arguments);\n  };\n}\n","'use strict';\n\nmodule.exports = (Promise, ensureAslWrapper) => {\n  // Updates to this class should also be applied to the the ES3 version\n  // in index.js.\n  return class WrappedPromise extends Promise {\n    constructor(executor) {\n      var context, args;\n      super(wrappedExecutor);\n      var promise = this;\n\n      try {\n        executor.apply(context, args);\n      } catch (err) {\n        args[1](err);\n      }\n\n      return promise;\n      function wrappedExecutor(resolve, reject) {\n        context = this;\n        args = [wrappedResolve, wrappedReject];\n\n        // These wrappers create a function that can be passed a function and an argument to\n        // call as a continuation from the resolve or reject.\n        function wrappedResolve(val) {\n          ensureAslWrapper(promise, false);\n          return resolve(val);\n        }\n\n        function wrappedReject(val) {\n          ensureAslWrapper(promise, false);\n          return reject(val);\n        }\n      }\n    }\n  }\n};\n","var wrap = require('shimmer').wrap;\n\n/*\n *\n * CONSTANTS\n *\n */\nvar HAS_CREATE_AL = 1 << 0;\nvar HAS_BEFORE_AL = 1 << 1;\nvar HAS_AFTER_AL = 1 << 2;\nvar HAS_ERROR_AL = 1 << 3;\n\n/**\n * There is one list of currently active listeners that is mutated in place by\n * addAsyncListener and removeAsyncListener. This complicates error-handling,\n * for reasons that are discussed below.\n */\nvar listeners = [];\n\n/**\n * There can be multiple listeners with the same properties, so disambiguate\n * them by assigning them an ID at creation time.\n */\nvar uid = 0;\n\n/**\n * Ensure that errors coming from within listeners are handed off to domains,\n * process._fatalException, or uncaughtException without being treated like\n * user errors.\n */\nvar inAsyncTick = false;\n\n/**\n * Because asynchronous contexts can be nested, and errors can come from anywhere\n * in the stack, a little extra work is required to keep track of where in the\n * nesting we are. Because JS arrays are frequently mutated in place\n */\nvar listenerStack = [];\n\n/**\n * The error handler on a listener can capture errors thrown during synchronous\n * execution immediately after the listener is added. To capture both\n * synchronous and asynchronous errors, the error handler just uses the\n * \"global\" list of active listeners, and the rest of the code ensures that the\n * listener list is correct by using a stack of listener lists during\n * asynchronous execution.\n */\nvar asyncCatcher;\n\n/**\n * The guts of the system -- called each time an asynchronous event happens\n * while one or more listeners are active.\n */\nvar asyncWrap;\n\n/**\n * Simple helper function that's probably faster than using Array\n * filter methods and can be inlined.\n */\nfunction union(dest, added) {\n  var destLength = dest.length;\n  var addedLength = added.length;\n  var returned = [];\n\n  if (destLength === 0 && addedLength === 0) return returned;\n\n  for (var j  = 0; j < destLength; j++) returned[j] = dest[j];\n\n  if (addedLength === 0) return returned;\n\n  for (var i = 0; i < addedLength; i++) {\n    var missing = true;\n    for (j = 0; j < destLength; j++) {\n      if (dest[j].uid === added[i].uid) {\n        missing = false;\n        break;\n      }\n    }\n    if (missing) returned.push(added[i]);\n  }\n\n  return returned;\n}\n\n/*\n * For performance, split error-handlers and asyncCatcher up into two separate\n * code paths.\n */\n\n// 0.9+\nif (process._fatalException) {\n  /**\n   * Error handlers on listeners can throw, the catcher needs to be able to\n   * discriminate between exceptions thrown by user code, and exceptions coming\n   * from within the catcher itself. Use a global to keep track of which state\n   * the catcher is currently in.\n   */\n  var inErrorTick = false;\n\n  /**\n   * Throwing always happens synchronously. If the current array of values for\n   * the current list of asyncListeners is put in a module-scoped variable right\n   * before a call that can throw, it will always be correct when the error\n   * handlers are run.\n   */\n  var errorValues;\n\n  asyncCatcher = function asyncCatcher(er) {\n    var length = listeners.length;\n    if (inErrorTick || length === 0) return false;\n\n    var handled = false;\n\n    /*\n     * error handlers\n     */\n    inErrorTick = true;\n    for (var i = 0; i < length; ++i) {\n      var listener = listeners[i];\n      if ((listener.flags & HAS_ERROR_AL) === 0) continue;\n\n      var value = errorValues && errorValues[listener.uid];\n      handled = listener.error(value, er) || handled;\n    }\n    inErrorTick = false;\n\n    /* Test whether there are any listener arrays on the stack. In the case of\n     * synchronous throws when the listener is active, there may have been\n     * none pushed yet.\n     */\n    if (listenerStack.length > 0) listeners = listenerStack.pop();\n    errorValues = undefined;\n\n    return handled && !inAsyncTick;\n  };\n\n  asyncWrap = function asyncWrap(original, list, length) {\n    var values = [];\n\n    /*\n     * listeners\n     */\n    inAsyncTick = true;\n    for (var i = 0; i < length; ++i) {\n      var listener = list[i];\n      values[listener.uid] = listener.data;\n\n      if ((listener.flags & HAS_CREATE_AL) === 0) continue;\n\n      var value = listener.create(listener.data);\n      if (value !== undefined) values[listener.uid] = value;\n    }\n    inAsyncTick = false;\n\n    /* One of the main differences between this polyfill and the core\n     * asyncListener support is that core avoids creating closures by putting a\n     * lot of the state managemnt on the C++ side of Node (and of course also it\n     * bakes support for async listeners into the Node C++ API through the\n     * AsyncWrap class, which means that it doesn't monkeypatch basically every\n     * async method like this does).\n     */\n    return function () {\n      // put the current values where the catcher can see them\n      errorValues = values;\n\n      /* More than one listener can end up inside these closures, so save the\n       * current listeners on a stack.\n       */\n      listenerStack.push(listeners);\n\n      /* Activate both the listeners that were active when the closure was\n       * created and the listeners that were previously active.\n       */\n      listeners = union(list, listeners);\n\n      /*\n       * before handlers\n       */\n      inAsyncTick = true;\n      for (var i = 0; i < length; ++i) {\n        if ((list[i].flags & HAS_BEFORE_AL) > 0) {\n          list[i].before(this, values[list[i].uid]);\n        }\n      }\n      inAsyncTick = false;\n\n      // save the return value to pass to the after callbacks\n      var returned = original.apply(this, arguments);\n\n      /*\n       * after handlers (not run if original throws)\n       */\n      inAsyncTick = true;\n      for (i = 0; i < length; ++i) {\n        if ((list[i].flags & HAS_AFTER_AL) > 0) {\n          list[i].after(this, values[list[i].uid]);\n        }\n      }\n      inAsyncTick = false;\n\n      // back to the previous listener list on the stack\n      listeners = listenerStack.pop();\n      errorValues = undefined;\n\n      return returned;\n    };\n  };\n\n  wrap(process, '_fatalException', function (_fatalException) {\n    return function _asyncFatalException(er) {\n      return asyncCatcher(er) || _fatalException(er);\n    };\n  });\n}\n// 0.8 and below\nelse {\n  /**\n   * If an error handler in asyncWrap throws, the process must die. Under 0.8\n   * and earlier the only way to put a bullet through the head of the process\n   * is to rethrow from inside the exception handler, so rethrow and set\n   * errorThrew to tell the uncaughtHandler what to do.\n   */\n  var errorThrew = false;\n\n  /**\n   * Under Node 0.8, this handler *only* handles synchronously thrown errors.\n   * This simplifies it, which almost but not quite makes up for the hit taken\n   * by putting everything in a try-catch.\n   */\n  asyncCatcher = function uncaughtCatcher(er) {\n    // going down hard\n    if (errorThrew) throw er;\n\n    var handled = false;\n\n    /*\n     * error handlers\n     */\n    var length = listeners.length;\n    for (var i = 0; i < length; ++i) {\n      var listener = listeners[i];\n      if ((listener.flags & HAS_ERROR_AL) === 0) continue;\n      handled = listener.error(null, er) || handled;\n    }\n\n    /* Rethrow if one of the before / after handlers fire, which will bring the\n     * process down immediately.\n     */\n    if (!handled && inAsyncTick) throw er;\n  };\n\n  asyncWrap = function asyncWrap(original, list, length) {\n    var values = [];\n\n    /*\n     * listeners\n     */\n    inAsyncTick = true;\n    for (var i = 0; i < length; ++i) {\n      var listener = list[i];\n      values[listener.uid] = listener.data;\n\n      if ((listener.flags & HAS_CREATE_AL) === 0) continue;\n\n      var value = listener.create(listener.data);\n      if (value !== undefined) values[listener.uid] = value;\n    }\n    inAsyncTick = false;\n\n    /* One of the main differences between this polyfill and the core\n     * asyncListener support is that core avoids creating closures by putting a\n     * lot of the state managemnt on the C++ side of Node (and of course also it\n     * bakes support for async listeners into the Node C++ API through the\n     * AsyncWrap class, which means that it doesn't monkeypatch basically every\n     * async method like this does).\n     */\n    return function () {\n      /*jshint maxdepth:4*/\n\n      // after() handlers don't run if threw\n      var threw = false;\n\n      // ...unless the error is handled\n      var handled = false;\n\n      /* More than one listener can end up inside these closures, so save the\n       * current listeners on a stack.\n       */\n      listenerStack.push(listeners);\n\n      /* Activate both the listeners that were active when the closure was\n       * created and the listeners that were previously active.\n       */\n      listeners = union(list, listeners);\n\n      /*\n       * before handlers\n       */\n      inAsyncTick = true;\n      for (var i = 0; i < length; ++i) {\n        if ((list[i].flags & HAS_BEFORE_AL) > 0) {\n          list[i].before(this, values[list[i].uid]);\n        }\n      }\n      inAsyncTick = false;\n\n      // save the return value to pass to the after callbacks\n      var returned;\n      try {\n        returned = original.apply(this, arguments);\n      }\n      catch (er) {\n        threw = true;\n        for (var i = 0; i < length; ++i) {\n          if ((listeners[i].flags & HAS_ERROR_AL) == 0) continue;\n          try {\n            handled = listeners[i].error(values[list[i].uid], er) || handled;\n          }\n          catch (x) {\n            errorThrew = true;\n            throw x;\n          }\n        }\n\n        if (!handled) {\n          // having an uncaughtException handler here alters crash semantics\n          process.removeListener('uncaughtException', asyncCatcher);\n          process._originalNextTick(function () {\n            process.addListener('uncaughtException', asyncCatcher);\n          });\n\n          throw er;\n        }\n      }\n      finally {\n        /*\n         * after handlers (not run if original throws)\n         */\n        if (!threw || handled) {\n          inAsyncTick = true;\n          for (i = 0; i < length; ++i) {\n            if ((list[i].flags & HAS_AFTER_AL) > 0) {\n              list[i].after(this, values[list[i].uid]);\n            }\n          }\n          inAsyncTick = false;\n        }\n\n        // back to the previous listener list on the stack\n        listeners = listenerStack.pop();\n      }\n\n\n      return returned;\n    };\n  };\n\n  // will be the first to fire if async-listener is the first module loaded\n  process.addListener('uncaughtException', asyncCatcher);\n}\n\n// for performance in the case where there are no handlers, just the listener\nfunction simpleWrap(original, list, length) {\n  inAsyncTick = true;\n  for (var i = 0; i < length; ++i) {\n    var listener = list[i];\n    if (listener.create) listener.create(listener.data);\n  }\n  inAsyncTick = false;\n\n  // still need to make sure nested async calls are made in the context\n  // of the listeners active at their creation\n  return function () {\n    listenerStack.push(listeners);\n    listeners = union(list, listeners);\n\n    var returned = original.apply(this, arguments);\n\n    listeners = listenerStack.pop();\n\n    return returned;\n  };\n}\n\n/**\n * Called each time an asynchronous function that's been monkeypatched in\n * index.js is called. If there are no listeners, return the function\n * unwrapped.  If there are any asyncListeners and any of them have callbacks,\n * pass them off to asyncWrap for later use, otherwise just call the listener.\n */\nfunction wrapCallback(original) {\n  var length = listeners.length;\n\n  // no context to capture, so avoid closure creation\n  if (length === 0) return original;\n\n  // capture the active listeners as of when the wrapped function was called\n  var list = listeners.slice();\n\n  for (var i = 0; i < length; ++i) {\n    if (list[i].flags > 0) return asyncWrap(original, list, length);\n  }\n\n  return simpleWrap(original, list, length);\n}\n\nfunction AsyncListener(callbacks, data) {\n  if (typeof callbacks.create === 'function') {\n    this.create = callbacks.create;\n    this.flags |= HAS_CREATE_AL;\n  }\n\n  if (typeof callbacks.before === 'function') {\n    this.before = callbacks.before;\n    this.flags |= HAS_BEFORE_AL;\n  }\n\n  if (typeof callbacks.after === 'function') {\n    this.after = callbacks.after;\n    this.flags |= HAS_AFTER_AL;\n  }\n\n  if (typeof callbacks.error === 'function') {\n    this.error = callbacks.error;\n    this.flags |= HAS_ERROR_AL;\n  }\n\n  this.uid = ++uid;\n  this.data = data === undefined ? null : data;\n}\nAsyncListener.prototype.create = undefined;\nAsyncListener.prototype.before = undefined;\nAsyncListener.prototype.after  = undefined;\nAsyncListener.prototype.error  = undefined;\nAsyncListener.prototype.data   = undefined;\nAsyncListener.prototype.uid    = 0;\nAsyncListener.prototype.flags  = 0;\n\nfunction createAsyncListener(callbacks, data) {\n  if (typeof callbacks !== 'object' || !callbacks) {\n    throw new TypeError('callbacks argument must be an object');\n  }\n\n  if (callbacks instanceof AsyncListener) {\n    return callbacks;\n  }\n  else {\n    return new AsyncListener(callbacks, data);\n  }\n}\n\nfunction addAsyncListener(callbacks, data) {\n  var listener;\n  if (!(callbacks instanceof AsyncListener)) {\n    listener = createAsyncListener(callbacks, data);\n  }\n  else {\n    listener = callbacks;\n  }\n\n  // Make sure the listener isn't already in the list.\n  var registered = false;\n  for (var i = 0; i < listeners.length; i++) {\n    if (listener === listeners[i]) {\n      registered = true;\n      break;\n    }\n  }\n\n  if (!registered) listeners.push(listener);\n\n  return listener;\n}\n\nfunction removeAsyncListener(listener) {\n  for (var i = 0; i < listeners.length; i++) {\n    if (listener === listeners[i]) {\n      listeners.splice(i, 1);\n      break;\n    }\n  }\n}\n\nprocess.createAsyncListener = createAsyncListener;\nprocess.addAsyncListener    = addAsyncListener;\nprocess.removeAsyncListener = removeAsyncListener;\n\nmodule.exports = wrapCallback;\n","'use strict';\n\nif (process.addAsyncListener) throw new Error(\"Don't require polyfill unless needed\");\n\nvar shimmer      = require('shimmer')\n  , semver       = require('semver')\n  , wrap         = shimmer.wrap\n  , massWrap     = shimmer.massWrap\n  , wrapCallback = require('./glue.js')\n  , util         = require('util')\n  ;\n\nvar v6plus = semver.gte(process.version, '6.0.0');\nvar v7plus = semver.gte(process.version, '7.0.0');\nvar v8plus = semver.gte(process.version, '8.0.0');\nvar v11plus = semver.gte(process.version, '11.0.0');\n\nvar net = require('net');\n\n// From Node.js v7.0.0, net._normalizeConnectArgs have been renamed net._normalizeArgs\nif (v7plus && !net._normalizeArgs) {\n  // a polyfill in our polyfill etc so forth -- taken from node master on 2017/03/09\n  net._normalizeArgs = function (args) {\n    if (args.length === 0) {\n      return [{}, null];\n    }\n\n    var arg0 = args[0];\n    var options = {};\n    if (typeof arg0 === 'object' && arg0 !== null) {\n      // (options[...][, cb])\n      options = arg0;\n    } else if (isPipeName(arg0)) {\n      // (path[...][, cb])\n      options.path = arg0;\n    } else {\n      // ([port][, host][...][, cb])\n      options.port = arg0;\n      if (args.length > 1 && typeof args[1] === 'string') {\n        options.host = args[1];\n      }\n    }\n\n    var cb = args[args.length - 1];\n    if (typeof cb !== 'function')\n      return [options, null];\n    else\n      return [options, cb];\n  }\n} else if (!v7plus && !net._normalizeConnectArgs) {\n  // a polyfill in our polyfill etc so forth -- taken from node master on 2013/10/30\n  net._normalizeConnectArgs = function (args) {\n    var options = {};\n\n    function toNumber(x) { return (x = Number(x)) >= 0 ? x : false; }\n\n    if (typeof args[0] === 'object' && args[0] !== null) {\n      // connect(options, [cb])\n      options = args[0];\n    }\n    else if (typeof args[0] === 'string' && toNumber(args[0]) === false) {\n      // connect(path, [cb]);\n      options.path = args[0];\n    }\n    else {\n      // connect(port, [host], [cb])\n      options.port = args[0];\n      if (typeof args[1] === 'string') {\n        options.host = args[1];\n      }\n    }\n\n    var cb = args[args.length - 1];\n    return typeof cb === 'function' ? [options, cb] : [options];\n  };\n}\n\n// In https://github.com/nodejs/node/pull/11796 `_listen2` was renamed\n// `_setUpListenHandle`. It's still aliased as `_listen2`, and currently the\n// Node internals still call the alias - but who knows for how long. So better\n// make sure we use the new name instead if available.\nif ('_setUpListenHandle' in net.Server.prototype) {\n  wrap(net.Server.prototype, '_setUpListenHandle', wrapSetUpListenHandle);\n} else {\n  wrap(net.Server.prototype, '_listen2', wrapSetUpListenHandle);\n}\n\nfunction wrapSetUpListenHandle(original) {\n  return function () {\n    this.on('connection', function (socket) {\n      if (socket._handle) {\n        socket._handle.onread = wrapCallback(socket._handle.onread);\n      }\n    });\n\n    try {\n      return original.apply(this, arguments);\n    }\n    finally {\n      // the handle will only not be set in cases where there has been an error\n      if (this._handle && this._handle.onconnection) {\n        this._handle.onconnection = wrapCallback(this._handle.onconnection);\n      }\n    }\n  };\n}\n\nfunction patchOnRead(ctx) {\n  if (ctx && ctx._handle) {\n    var handle = ctx._handle;\n    if (!handle._originalOnread) {\n      handle._originalOnread = handle.onread;\n    }\n    handle.onread = wrapCallback(handle._originalOnread);\n  }\n}\n\nwrap(net.Socket.prototype, 'connect', function (original) {\n  return function () {\n    var args;\n    // Node core uses an internal Symbol here to guard against the edge-case\n    // where the user accidentally passes in an array. As we don't have access\n    // to this Symbol we resort to this hack where we just detect if there is a\n    // symbol or not. Checking for the number of Symbols is by no means a fool\n    // proof solution, but it catches the most basic cases.\n    if (v8plus &&\n        Array.isArray(arguments[0]) &&\n        Object.getOwnPropertySymbols(arguments[0]).length > 0) {\n      // already normalized\n      args = arguments[0];\n    } else {\n      // From Node.js v7.0.0, net._normalizeConnectArgs have been renamed net._normalizeArgs\n      args = v7plus\n        ? net._normalizeArgs(arguments)\n        : net._normalizeConnectArgs(arguments);\n    }\n    if (args[1]) args[1] = wrapCallback(args[1]);\n    var result = original.apply(this, args);\n    patchOnRead(this);\n    return result;\n  };\n});\n\nvar http = require('http');\n\n// NOTE: A rewrite occurred in 0.11 that changed the addRequest signature\n// from (req, host, port, localAddress) to (req, options)\n// Here, I use the longer signature to maintain 0.10 support, even though\n// the rest of the arguments aren't actually used\nwrap(http.Agent.prototype, 'addRequest', function (original) {\n  return function (req) {\n    var onSocket = req.onSocket;\n    req.onSocket = wrapCallback(function (socket) {\n      patchOnRead(socket);\n      return onSocket.apply(this, arguments);\n    });\n    return original.apply(this, arguments);\n  };\n});\n\nvar childProcess = require('child_process');\n\nfunction wrapChildProcess(child) {\n  if (Array.isArray(child.stdio)) {\n    child.stdio.forEach(function (socket) {\n      if (socket && socket._handle) {\n        socket._handle.onread = wrapCallback(socket._handle.onread);\n        wrap(socket._handle, 'close', activatorFirst);\n      }\n    });\n  }\n\n  if (child._handle) {\n    child._handle.onexit = wrapCallback(child._handle.onexit);\n  }\n}\n\n// iojs v2.0.0+\nif (childProcess.ChildProcess) {\n  wrap(childProcess.ChildProcess.prototype, 'spawn', function (original) {\n    return function () {\n      var result = original.apply(this, arguments);\n      wrapChildProcess(this);\n      return result;\n    };\n  });\n} else {\n  massWrap(childProcess, [\n    'execFile', // exec is implemented in terms of execFile\n    'fork',\n    'spawn'\n  ], function (original) {\n    return function () {\n      var result = original.apply(this, arguments);\n      wrapChildProcess(result);\n      return result;\n    };\n  });\n}\n\n// need unwrapped nextTick for use within < 0.9 async error handling\nif (!process._fatalException) {\n  process._originalNextTick = process.nextTick;\n}\n\nvar processors = [];\nif (process._nextDomainTick) processors.push('_nextDomainTick');\nif (process._tickDomainCallback) processors.push('_tickDomainCallback');\n\nmassWrap(\n  process,\n  processors,\n  activator\n);\nwrap(process, 'nextTick', activatorFirst);\n\nvar asynchronizers = [\n  'setTimeout',\n  'setInterval'\n];\nif (global.setImmediate) asynchronizers.push('setImmediate');\n\nvar timers = require('timers');\nvar patchGlobalTimers = global.setTimeout === timers.setTimeout;\n\nmassWrap(\n  timers,\n  asynchronizers,\n  activatorFirst\n);\n\nif (patchGlobalTimers) {\n  massWrap(\n    global,\n    asynchronizers,\n    activatorFirst\n  );\n}\n\nvar dns = require('dns');\nmassWrap(\n  dns,\n  [\n    'lookup',\n    'resolve',\n    'resolve4',\n    'resolve6',\n    'resolveCname',\n    'resolveMx',\n    'resolveNs',\n    'resolveTxt',\n    'resolveSrv',\n    'reverse'\n  ],\n  activator\n);\n\nif (dns.resolveNaptr) wrap(dns, 'resolveNaptr', activator);\n\nvar fs = require('fs');\nmassWrap(\n  fs,\n  [\n    'watch',\n    'rename',\n    'truncate',\n    'chown',\n    'fchown',\n    'chmod',\n    'fchmod',\n    'stat',\n    'lstat',\n    'fstat',\n    'link',\n    'symlink',\n    'readlink',\n    'realpath',\n    'unlink',\n    'rmdir',\n    'mkdir',\n    'readdir',\n    'close',\n    'open',\n    'utimes',\n    'futimes',\n    'fsync',\n    'write',\n    'read',\n    'readFile',\n    'writeFile',\n    'appendFile',\n    'watchFile',\n    'unwatchFile',\n    \"exists\",\n  ],\n  activator\n);\n\n// only wrap lchown and lchmod on systems that have them.\nif (fs.lchown) wrap(fs, 'lchown', activator);\nif (fs.lchmod) wrap(fs, 'lchmod', activator);\n\n// only wrap ftruncate in versions of node that have it\nif (fs.ftruncate) wrap(fs, 'ftruncate', activator);\n\n// Wrap zlib streams\nvar zlib;\ntry { zlib = require('zlib'); } catch (err) { }\nif (zlib && zlib.Deflate && zlib.Deflate.prototype) {\n  var proto = Object.getPrototypeOf(zlib.Deflate.prototype);\n  if (proto._transform) {\n    // streams2\n    wrap(proto, \"_transform\", activator);\n  }\n  else if (proto.write && proto.flush && proto.end) {\n    // plain ol' streams\n    massWrap(\n      proto,\n      [\n        'write',\n        'flush',\n        'end'\n      ],\n      activator\n    );\n  }\n}\n\n// Wrap Crypto\nvar crypto;\ntry { crypto = require('crypto'); } catch (err) { }\nif (crypto) {\n\n  var toWrap = [\n      'pbkdf2',\n      'randomBytes',\n  ];\n  if (!v11plus) {\n    toWrap.push('pseudoRandomBytes');\n  }\n\n  massWrap(crypto, toWrap, activator);\n}\n\n// It is unlikely that any userspace promise implementations have a native\n// implementation of both Promise and Promise.toString.\nvar instrumentPromise = !!global.Promise &&\n    Promise.toString() === 'function Promise() { [native code] }' &&\n    Promise.toString.toString() === 'function toString() { [native code] }';\n\n// Check that global Promise is native\nif (instrumentPromise) {\n  // shoult not use any methods that have already been wrapped\n  var promiseListener = process.addAsyncListener({\n    create: function create() {\n      instrumentPromise = false;\n    }\n  });\n\n  // should not resolve synchronously\n  global.Promise.resolve(true).then(function notSync() {\n    instrumentPromise = false;\n  });\n\n  process.removeAsyncListener(promiseListener);\n}\n\n/*\n * Native promises use the microtask queue to make all callbacks run\n * asynchronously to avoid Zalgo issues. Since the microtask queue is not\n * exposed externally, promises need to be modified in a fairly invasive and\n * complex way.\n *\n * The async boundary in promises that must be patched is between the\n * fulfillment of the promise and the execution of any callback that is waiting\n * for that fulfillment to happen. This means that we need to trigger a create\n * when resolve or reject is called and trigger before, after and error handlers\n * around the callback execution. There may be multiple callbacks for each\n * fulfilled promise, so handlers will behave similar to setInterval where\n * there may be multiple before after and error calls for each create call.\n *\n * async-listener monkeypatching has one basic entry point: `wrapCallback`.\n * `wrapCallback` should be called when create should be triggered and be\n * passed a function to wrap, which will execute the body of the async work.\n * The resolve and reject calls can be modified fairly easily to call\n * `wrapCallback`, but at the time of resolve and reject all the work to be done\n * on fulfillment may not be defined, since a call to then, chain or fetch can\n * be made even after the promise has been fulfilled. To get around this, we\n * create a placeholder function which will call a function passed into it,\n * since the call to the main work is being made from within the wrapped\n * function, async-listener will work correctly.\n *\n * There is another complication with monkeypatching Promises. Calls to then,\n * chain and catch each create new Promises that are fulfilled internally in\n * different ways depending on the return value of the callback. When the\n * callback return a Promise, the new Promise is resolved asynchronously after\n * the returned Promise has been also been resolved. When something other than\n * a promise is resolved the resolve call for the new Promise is put in the\n * microtask queue and asynchronously resolved.\n *\n * Then must be wrapped so that its returned promise has a wrapper that can be\n * used to invoke further continuations. This wrapper cannot be created until\n * after the callback has run, since the callback may return either a promise\n * or another value. Fortunately we already have a wrapper function around the\n * callback we can use (the wrapper created by resolve or reject).\n *\n * By adding an additional argument to this wrapper, we can pass in the\n * returned promise so it can have its own wrapper appended. the wrapper\n * function can the call the callback, and take action based on the return\n * value. If a promise is returned, the new Promise can proxy the returned\n * Promise's wrapper (this wrapper may not exist yet, but will by the time the\n * wrapper needs to be invoked). Otherwise, a new wrapper can be create the\n * same way as in resolve and reject. Since this wrapper is created\n * synchronously within another wrapper, it will properly appear as a\n * continuation from within the callback.\n */\n\nif (instrumentPromise) {\n  wrapPromise();\n}\n\nfunction wrapPromise() {\n  var Promise = global.Promise;\n\n  // Updates to this class should also be applied to the the ES6 version\n  // in es6-wrapped-promise.js.\n  function wrappedPromise(executor) {\n    if (!(this instanceof wrappedPromise)) {\n      return Promise(executor);\n    }\n\n    if (typeof executor !== 'function') {\n      return new Promise(executor);\n    }\n\n    var context, args;\n    var promise = new Promise(wrappedExecutor);\n    promise.__proto__ = wrappedPromise.prototype;\n\n    try {\n      executor.apply(context, args);\n    } catch (err) {\n      args[1](err);\n    }\n\n    return promise;\n\n    function wrappedExecutor(resolve, reject) {\n      context = this;\n      args = [wrappedResolve, wrappedReject];\n\n      // These wrappers create a function that can be passed a function and an argument to\n      // call as a continuation from the resolve or reject.\n      function wrappedResolve(val) {\n        ensureAslWrapper(promise, false);\n        return resolve(val);\n      }\n\n      function wrappedReject(val) {\n        ensureAslWrapper(promise, false);\n        return reject(val);\n      }\n    }\n  }\n\n  util.inherits(wrappedPromise, Promise);\n\n  wrap(Promise.prototype, 'then', wrapThen);\n  // Node.js <v7 only, alias for .then\n  if (Promise.prototype.chain) {\n    wrap(Promise.prototype, 'chain', wrapThen);\n  }\n\n  if (v6plus) {\n    global.Promise = require('./es6-wrapped-promise.js')(Promise, ensureAslWrapper);\n  } else {\n    var PromiseFunctions = [\n      'all',\n      'race',\n      'reject',\n      'resolve',\n      'accept',  // Node.js <v7 only\n      'defer'    // Node.js <v7 only\n    ];\n\n    PromiseFunctions.forEach(function(key) {\n      // don't break `in` by creating a key for undefined entries\n      if (typeof Promise[key] === 'function') {\n        wrappedPromise[key] = Promise[key];\n      }\n    });\n    global.Promise = wrappedPromise\n  }\n\n  function ensureAslWrapper(promise, overwrite) {\n    if (!promise.__asl_wrapper || overwrite) {\n      promise.__asl_wrapper = wrapCallback(propagateAslWrapper);\n    }\n  }\n\n  function propagateAslWrapper(ctx, fn, result, next) {\n    var nextResult;\n    try {\n      nextResult = fn.call(ctx, result);\n      return {returnVal: nextResult, error: false}\n    } catch (err) {\n      return {errorVal: err, error: true}\n    } finally {\n      // Wrap any resulting futures as continuations.\n      if (nextResult instanceof Promise) {\n        next.__asl_wrapper = function proxyWrapper() {\n          var aslWrapper = nextResult.__asl_wrapper || propagateAslWrapper;\n          return aslWrapper.apply(this, arguments);\n        }\n      } else {\n        ensureAslWrapper(next, true);\n      }\n    }\n  }\n\n  function wrapThen(original) {\n    return function wrappedThen() {\n      var promise = this;\n      var next = original.apply(promise, Array.prototype.map.call(arguments, bind));\n\n      next.__asl_wrapper = function proxyWrapper(ctx, fn, val, last) {\n        if (promise.__asl_wrapper) {\n          promise.__asl_wrapper(ctx, function () {}, null, next);\n          return next.__asl_wrapper(ctx, fn, val, last);\n        }\n        return propagateAslWrapper(ctx, fn, val, last);\n      }\n\n      return next;\n\n      // wrap callbacks (success, error) so that the callbacks will be called as a\n      // continuations of the resolve or reject call using the __asl_wrapper created above.\n      function bind(fn) {\n        if (typeof fn !== 'function') return fn;\n        return wrapCallback(function (val) {\n          var result = (promise.__asl_wrapper || propagateAslWrapper)(this, fn, val, next);\n          if (result.error) {\n            throw result.errorVal\n          } else {\n            return result.returnVal\n          }\n        });\n      }\n    }\n  }\n}\n\n// Shim activator for functions that have callback last\nfunction activator(fn) {\n  var fallback = function () {\n    var args;\n    var cbIdx = arguments.length - 1;\n    if (typeof arguments[cbIdx] === \"function\") {\n      args = Array(arguments.length)\n      for (var i = 0; i < arguments.length - 1; i++) {\n        args[i] = arguments[i];\n      }\n      args[cbIdx] = wrapCallback(arguments[cbIdx]);\n    }\n    return fn.apply(this, args || arguments);\n  };\n  // Preserve function length for small arg count functions.\n  switch (fn.length) {\n    case 1:\n      return function (cb) {\n        if (arguments.length !== 1) return fallback.apply(this, arguments);\n        if (typeof cb === \"function\") cb = wrapCallback(cb);\n        return fn.call(this, cb);\n      };\n    case 2:\n      return function (a, cb) {\n        if (arguments.length !== 2) return fallback.apply(this, arguments);\n        if (typeof cb === \"function\") cb = wrapCallback(cb);\n        return fn.call(this, a, cb);\n      };\n    case 3:\n      return function (a, b, cb) {\n        if (arguments.length !== 3) return fallback.apply(this, arguments);\n        if (typeof cb === \"function\") cb = wrapCallback(cb);\n        return fn.call(this, a, b, cb);\n      };\n    case 4:\n      return function (a, b, c, cb) {\n        if (arguments.length !== 4) return fallback.apply(this, arguments);\n        if (typeof cb === \"function\") cb = wrapCallback(cb);\n        return fn.call(this, a, b, c, cb);\n      };\n    case 5:\n      return function (a, b, c, d, cb) {\n        if (arguments.length !== 5) return fallback.apply(this, arguments);\n        if (typeof cb === \"function\") cb = wrapCallback(cb);\n        return fn.call(this, a, b, c, d, cb);\n      };\n    case 6:\n      return function (a, b, c, d, e, cb) {\n        if (arguments.length !== 6) return fallback.apply(this, arguments);\n        if (typeof cb === \"function\") cb = wrapCallback(cb);\n        return fn.call(this, a, b, c, d, e, cb);\n      };\n    default:\n      return fallback;\n  }\n}\n\n// Shim activator for functions that have callback first\nfunction activatorFirst(fn) {\n  var fallback = function () {\n    var args;\n    if (typeof arguments[0] === \"function\") {\n      args = Array(arguments.length)\n      args[0] = wrapCallback(arguments[0]);\n      for (var i = 1; i < arguments.length; i++) {\n        args[i] = arguments[i];\n      }\n    }\n    return fn.apply(this, args || arguments);\n  };\n  // Preserve function length for small arg count functions.\n  switch (fn.length) {\n    case 1:\n      return function (cb) {\n        if (arguments.length !== 1) return fallback.apply(this, arguments);\n        if (typeof cb === \"function\") cb = wrapCallback(cb);\n        return fn.call(this, cb);\n      };\n    case 2:\n      return function (cb, a) {\n        if (arguments.length !== 2) return fallback.apply(this, arguments);\n        if (typeof cb === \"function\") cb = wrapCallback(cb);\n        return fn.call(this, cb, a);\n      };\n    case 3:\n      return function (cb, a, b) {\n        if (arguments.length !== 3) return fallback.apply(this, arguments);\n        if (typeof cb === \"function\") cb = wrapCallback(cb);\n        return fn.call(this, cb, a, b);\n      };\n    case 4:\n      return function (cb, a, b, c) {\n        if (arguments.length !== 4) return fallback.apply(this, arguments);\n        if (typeof cb === \"function\") cb = wrapCallback(cb);\n        return fn.call(this, cb, a, b, c);\n      };\n    case 5:\n      return function (cb, a, b, c, d) {\n        if (arguments.length !== 5) return fallback.apply(this, arguments);\n        if (typeof cb === \"function\") cb = wrapCallback(cb);\n        return fn.call(this, cb, a, b, c, d);\n      };\n    case 6:\n      return function (cb, a, b, c, d, e) {\n        if (arguments.length !== 6) return fallback.apply(this, arguments);\n        if (typeof cb === \"function\") cb = wrapCallback(cb);\n        return fn.call(this, cb, a, b, c, d, e);\n      };\n    default:\n      return fallback;\n  }\n}\n\n// taken from node master on 2017/03/09\nfunction toNumber(x) {\n  return (x = Number(x)) >= 0 ? x : false;\n}\n\n// taken from node master on 2017/03/09\nfunction isPipeName(s) {\n  return typeof s === 'string' && toNumber(s) === false;\n}\n","'use strict';\n\nconst util = require('util');\nconst assert = require('assert');\nconst wrapEmitter = require('emitter-listener');\nconst asyncHook = require('async-hook-jl');\n\nconst CONTEXTS_SYMBOL = 'cls@contexts';\nconst ERROR_SYMBOL = 'error@context';\n\n//const trace = [];\n\nconst invertedProviders = [];\nfor (let key in asyncHook.providers) {\n  invertedProviders[asyncHook.providers[key]] = key;\n}\n\nconst DEBUG_CLS_HOOKED = process.env.DEBUG_CLS_HOOKED;\n\nlet currentUid = -1;\n\nmodule.exports = {\n  getNamespace: getNamespace,\n  createNamespace: createNamespace,\n  destroyNamespace: destroyNamespace,\n  reset: reset,\n  //trace: trace,\n  ERROR_SYMBOL: ERROR_SYMBOL\n};\n\nfunction Namespace(name) {\n  this.name = name;\n  // changed in 2.7: no default context\n  this.active = null;\n  this._set = [];\n  this.id = null;\n  this._contexts = new Map();\n}\n\nNamespace.prototype.set = function set(key, value) {\n  if (!this.active) {\n    throw new Error('No context available. ns.run() or ns.bind() must be called first.');\n  }\n\n  if (DEBUG_CLS_HOOKED) {\n    debug2('    SETTING KEY:' + key + '=' + value + ' in ns:' + this.name + ' uid:' + currentUid + ' active:' +\n      util.inspect(this.active, true));\n  }\n  this.active[key] = value;\n  return value;\n};\n\nNamespace.prototype.get = function get(key) {\n  if (!this.active) {\n    if (DEBUG_CLS_HOOKED) {\n      debug2('    GETTING KEY:' + key + '=undefined' + ' ' + this.name + ' uid:' + currentUid + ' active:' +\n        util.inspect(this.active, true));\n    }\n    return undefined;\n  }\n  if (DEBUG_CLS_HOOKED) {\n    debug2('    GETTING KEY:' + key + '=' + this.active[key] + ' ' + this.name + ' uid:' + currentUid + ' active:' +\n      util.inspect(this.active, true));\n  }\n  return this.active[key];\n};\n\nNamespace.prototype.createContext = function createContext() {\n  if (DEBUG_CLS_HOOKED) {\n    debug2('   CREATING Context: ' + this.name + ' uid:' + currentUid + ' len:' + this._set.length + ' ' + ' active:' +\n      util.inspect(this.active, true, 2, true));\n  }\n\n  let context = Object.create(this.active ? this.active : Object.prototype);\n  context._ns_name = this.name;\n  context.id = currentUid;\n\n  if (DEBUG_CLS_HOOKED) {\n    debug2('   CREATED Context: ' + this.name + ' uid:' + currentUid + ' len:' + this._set.length + ' ' + ' context:' +\n      util.inspect(context, true, 2, true));\n  }\n\n  return context;\n};\n\nNamespace.prototype.run = function run(fn) {\n  let context = this.createContext();\n  this.enter(context);\n  try {\n    if (DEBUG_CLS_HOOKED) {\n      debug2(' BEFORE RUN: ' + this.name + ' uid:' + currentUid + ' len:' + this._set.length + ' ' +\n        util.inspect(context));\n    }\n    fn(context);\n    return context;\n  }\n  catch (exception) {\n    if (exception) {\n      exception[ERROR_SYMBOL] = context;\n    }\n    throw exception;\n  }\n  finally {\n    if (DEBUG_CLS_HOOKED) {\n      debug2(' AFTER RUN: ' + this.name + ' uid:' + currentUid + ' len:' + this._set.length + ' ' +\n        util.inspect(context));\n    }\n    this.exit(context);\n  }\n};\n\nNamespace.prototype.runAndReturn = function runAndReturn(fn) {\n  var value;\n  this.run(function (context) {\n    value = fn(context);\n  });\n  return value;\n};\n\n/**\n * Uses global Promise and assumes Promise is cls friendly or wrapped already.\n * @param {function} fn\n * @returns {*}\n */\nNamespace.prototype.runPromise = function runPromise(fn) {\n  let context = this.createContext();\n  this.enter(context);\n\n  let promise = fn(context);\n  if (!promise || !promise.then || !promise.catch) {\n    throw new Error('fn must return a promise.');\n  }\n\n  if (DEBUG_CLS_HOOKED) {\n    debug2(' BEFORE runPromise: ' + this.name + ' uid:' + currentUid + ' len:' + this._set.length + ' ' +\n      util.inspect(context));\n  }\n\n  return promise\n    .then(result => {\n      if (DEBUG_CLS_HOOKED) {\n        debug2(' AFTER runPromise: ' + this.name + ' uid:' + currentUid + ' len:' + this._set.length + ' ' +\n          util.inspect(context));\n      }\n      this.exit(context);\n      return result;\n    })\n    .catch(err => {\n      err[ERROR_SYMBOL] = context;\n      if (DEBUG_CLS_HOOKED) {\n        debug2(' AFTER runPromise: ' + this.name + ' uid:' + currentUid + ' len:' + this._set.length + ' ' +\n          util.inspect(context));\n      }\n      this.exit(context);\n      throw err;\n    });\n};\n\nNamespace.prototype.bind = function bindFactory(fn, context) {\n  if (!context) {\n    if (!this.active) {\n      context = this.createContext();\n    }\n    else {\n      context = this.active;\n    }\n  }\n\n  let self = this;\n  return function clsBind() {\n    self.enter(context);\n    try {\n      return fn.apply(this, arguments);\n    }\n    catch (exception) {\n      if (exception) {\n        exception[ERROR_SYMBOL] = context;\n      }\n      throw exception;\n    }\n    finally {\n      self.exit(context);\n    }\n  };\n};\n\nNamespace.prototype.enter = function enter(context) {\n  assert.ok(context, 'context must be provided for entering');\n  if (DEBUG_CLS_HOOKED) {\n    debug2('  ENTER ' + this.name + ' uid:' + currentUid + ' len:' + this._set.length + ' context: ' +\n      util.inspect(context));\n  }\n\n  this._set.push(this.active);\n  this.active = context;\n};\n\nNamespace.prototype.exit = function exit(context) {\n  assert.ok(context, 'context must be provided for exiting');\n  if (DEBUG_CLS_HOOKED) {\n    debug2('  EXIT ' + this.name + ' uid:' + currentUid + ' len:' + this._set.length + ' context: ' +\n      util.inspect(context));\n  }\n\n  // Fast path for most exits that are at the top of the stack\n  if (this.active === context) {\n    assert.ok(this._set.length, 'can\\'t remove top context');\n    this.active = this._set.pop();\n    return;\n  }\n\n  // Fast search in the stack using lastIndexOf\n  let index = this._set.lastIndexOf(context);\n\n  if (index < 0) {\n    if (DEBUG_CLS_HOOKED) {\n      debug2('??ERROR?? context exiting but not entered - ignoring: ' + util.inspect(context));\n    }\n    assert.ok(index >= 0, 'context not currently entered; can\\'t exit. \\n' + util.inspect(this) + '\\n' +\n      util.inspect(context));\n  } else {\n    assert.ok(index, 'can\\'t remove top context');\n    this._set.splice(index, 1);\n  }\n};\n\nNamespace.prototype.bindEmitter = function bindEmitter(emitter) {\n  assert.ok(emitter.on && emitter.addListener && emitter.emit, 'can only bind real EEs');\n\n  let namespace = this;\n  let thisSymbol = 'context@' + this.name;\n\n  // Capture the context active at the time the emitter is bound.\n  function attach(listener) {\n    if (!listener) {\n      return;\n    }\n    if (!listener[CONTEXTS_SYMBOL]) {\n      listener[CONTEXTS_SYMBOL] = Object.create(null);\n    }\n\n    listener[CONTEXTS_SYMBOL][thisSymbol] = {\n      namespace: namespace,\n      context: namespace.active\n    };\n  }\n\n  // At emit time, bind the listener within the correct context.\n  function bind(unwrapped) {\n    if (!(unwrapped && unwrapped[CONTEXTS_SYMBOL])) {\n      return unwrapped;\n    }\n\n    let wrapped = unwrapped;\n    let unwrappedContexts = unwrapped[CONTEXTS_SYMBOL];\n    Object.keys(unwrappedContexts).forEach(function (name) {\n      let thunk = unwrappedContexts[name];\n      wrapped = thunk.namespace.bind(wrapped, thunk.context);\n    });\n    return wrapped;\n  }\n\n  wrapEmitter(emitter, attach, bind);\n};\n\n/**\n * If an error comes out of a namespace, it will have a context attached to it.\n * This function knows how to find it.\n *\n * @param {Error} exception Possibly annotated error.\n */\nNamespace.prototype.fromException = function fromException(exception) {\n  return exception[ERROR_SYMBOL];\n};\n\nfunction getNamespace(name) {\n  return process.namespaces[name];\n}\n\nfunction createNamespace(name) {\n  assert.ok(name, 'namespace must be given a name.');\n\n  if (DEBUG_CLS_HOOKED) {\n    debug2('CREATING NAMESPACE ' + name);\n  }\n  let namespace = new Namespace(name);\n  namespace.id = currentUid;\n\n  asyncHook.addHooks({\n    init(uid, handle, provider, parentUid, parentHandle) {\n      //parentUid = parentUid || currentUid;  // Suggested usage but appears to work better for tracing modules.\n      currentUid = uid;\n\n      //CHAIN Parent's Context onto child if none exists. This is needed to pass net-events.spec\n      if (parentUid) {\n        namespace._contexts.set(uid, namespace._contexts.get(parentUid));\n        if (DEBUG_CLS_HOOKED) {\n          debug2('PARENTID: ' + name + ' uid:' + uid + ' parent:' + parentUid + ' provider:' + provider);\n        }\n      } else {\n        namespace._contexts.set(currentUid, namespace.active);\n      }\n\n      if (DEBUG_CLS_HOOKED) {\n        debug2('INIT ' + name + ' uid:' + uid + ' parent:' + parentUid + ' provider:' + invertedProviders[provider]\n          + ' active:' + util.inspect(namespace.active, true));\n      }\n\n    },\n    pre(uid, handle) {\n      currentUid = uid;\n      let context = namespace._contexts.get(uid);\n      if (context) {\n        if (DEBUG_CLS_HOOKED) {\n          debug2(' PRE ' + name + ' uid:' + uid + ' handle:' + getFunctionName(handle) + ' context:' +\n            util.inspect(context));\n        }\n\n        namespace.enter(context);\n      } else {\n        if (DEBUG_CLS_HOOKED) {\n          debug2(' PRE MISSING CONTEXT ' + name + ' uid:' + uid + ' handle:' + getFunctionName(handle));\n        }\n      }\n    },\n    post(uid, handle) {\n      currentUid = uid;\n      let context = namespace._contexts.get(uid);\n      if (context) {\n        if (DEBUG_CLS_HOOKED) {\n          debug2(' POST ' + name + ' uid:' + uid + ' handle:' + getFunctionName(handle) + ' context:' +\n            util.inspect(context));\n        }\n\n        namespace.exit(context);\n      } else {\n        if (DEBUG_CLS_HOOKED) {\n          debug2(' POST MISSING CONTEXT ' + name + ' uid:' + uid + ' handle:' + getFunctionName(handle));\n        }\n      }\n    },\n    destroy(uid) {\n      currentUid = uid;\n\n      if (DEBUG_CLS_HOOKED) {\n        debug2('DESTROY ' + name + ' uid:' + uid + ' context:' + util.inspect(namespace._contexts.get(currentUid))\n          + ' active:' + util.inspect(namespace.active, true));\n      }\n\n      namespace._contexts.delete(uid);\n    }\n  });\n\n  process.namespaces[name] = namespace;\n  return namespace;\n}\n\nfunction destroyNamespace(name) {\n  let namespace = getNamespace(name);\n\n  assert.ok(namespace, 'can\\'t delete nonexistent namespace! \"' + name + '\"');\n  assert.ok(namespace.id, 'don\\'t assign to process.namespaces directly! ' + util.inspect(namespace));\n\n  process.namespaces[name] = null;\n}\n\nfunction reset() {\n  // must unregister async listeners\n  if (process.namespaces) {\n    Object.keys(process.namespaces).forEach(function (name) {\n      destroyNamespace(name);\n    });\n  }\n  process.namespaces = Object.create(null);\n}\n\nprocess.namespaces = {};\n\nif (asyncHook._state && !asyncHook._state.enabled) {\n  asyncHook.enable();\n}\n\nfunction debug2(msg) {\n  if (process.env.DEBUG) {\n    process._rawDebug(msg);\n  }\n}\n\n\n/*function debug(from, ns) {\n process._rawDebug('DEBUG: ' + util.inspect({\n from: from,\n currentUid: currentUid,\n context: ns ? ns._contexts.get(currentUid) : 'no ns'\n }, true, 2, true));\n }*/\n\n\nfunction getFunctionName(fn) {\n  if (!fn) {\n    return fn;\n  }\n  if (typeof fn === 'function') {\n    if (fn.name) {\n      return fn.name;\n    }\n    return (fn.toString().trim().match(/^function\\s*([^\\s(]+)/) || [])[1];\n  } else if (fn.constructor && fn.constructor.name) {\n    return fn.constructor.name;\n  }\n}\n\n\n// Add back to callstack\nif (DEBUG_CLS_HOOKED) {\n  var stackChain = require('stack-chain');\n  for (var modifier in stackChain.filter._modifiers) {\n    stackChain.filter.deattach(modifier);\n  }\n}\n","/* eslint-disable max-len */\n'use strict';\n\nconst util = require('util');\nconst assert = require('assert');\nconst wrapEmitter = require('emitter-listener');\nconst async_hooks = require('async_hooks');\n\nconst CONTEXTS_SYMBOL = 'cls@contexts';\nconst ERROR_SYMBOL = 'error@context';\n\nconst DEBUG_CLS_HOOKED = process.env.DEBUG_CLS_HOOKED;\n\nlet currentUid = -1;\n\nmodule.exports = {\n  getNamespace: getNamespace,\n  createNamespace: createNamespace,\n  destroyNamespace: destroyNamespace,\n  reset: reset,\n  ERROR_SYMBOL: ERROR_SYMBOL\n};\n\nfunction Namespace(name) {\n  this.name = name;\n  // changed in 2.7: no default context\n  this.active = null;\n  this._set = [];\n  this.id = null;\n  this._contexts = new Map();\n  this._indent = 0;\n}\n\nNamespace.prototype.set = function set(key, value) {\n  if (!this.active) {\n    throw new Error('No context available. ns.run() or ns.bind() must be called first.');\n  }\n\n  this.active[key] = value;\n\n  if (DEBUG_CLS_HOOKED) {\n    const indentStr = ' '.repeat(this._indent < 0 ? 0 : this._indent);\n    debug2(indentStr + 'CONTEXT-SET KEY:' + key + '=' + value + ' in ns:' + this.name + ' currentUid:' + currentUid + ' active:' + util.inspect(this.active, {showHidden:true, depth:2, colors:true}));\n  }\n\n  return value;\n};\n\nNamespace.prototype.get = function get(key) {\n  if (!this.active) {\n    if (DEBUG_CLS_HOOKED) {\n      const asyncHooksCurrentId = async_hooks.currentId();\n      const triggerId = async_hooks.triggerAsyncId();\n      const indentStr = ' '.repeat(this._indent < 0 ? 0 : this._indent);\n      //debug2(indentStr + 'CONTEXT-GETTING KEY NO ACTIVE NS:' + key + '=undefined' + ' (' + this.name + ') currentUid:' + currentUid + ' active:' + util.inspect(this.active, {showHidden:true, depth:2, colors:true}));\n      debug2(`${indentStr}CONTEXT-GETTING KEY NO ACTIVE NS: (${this.name}) ${key}=undefined currentUid:${currentUid} asyncHooksCurrentId:${asyncHooksCurrentId} triggerId:${triggerId} len:${this._set.length}`);\n    }\n    return undefined;\n  }\n  if (DEBUG_CLS_HOOKED) {\n    const asyncHooksCurrentId = async_hooks.executionAsyncId();\n    const triggerId = async_hooks.triggerAsyncId();\n    const indentStr = ' '.repeat(this._indent < 0 ? 0 : this._indent);\n    debug2(indentStr + 'CONTEXT-GETTING KEY:' + key + '=' + this.active[key] + ' (' + this.name + ') currentUid:' + currentUid + ' active:' + util.inspect(this.active, {showHidden:true, depth:2, colors:true}));\n    debug2(`${indentStr}CONTEXT-GETTING KEY: (${this.name}) ${key}=${this.active[key]} currentUid:${currentUid} asyncHooksCurrentId:${asyncHooksCurrentId} triggerId:${triggerId} len:${this._set.length} active:${util.inspect(this.active)}`);\n  }\n  return this.active[key];\n};\n\nNamespace.prototype.createContext = function createContext() {\n  // Prototype inherit existing context if created a new child context within existing context.\n  let context = Object.create(this.active ? this.active : Object.prototype);\n  context._ns_name = this.name;\n  context.id = currentUid;\n\n  if (DEBUG_CLS_HOOKED) {\n    const asyncHooksCurrentId = async_hooks.executionAsyncId();\n    const triggerId = async_hooks.triggerAsyncId();\n    const indentStr = ' '.repeat(this._indent < 0 ? 0 : this._indent);\n    debug2(`${indentStr}CONTEXT-CREATED Context: (${this.name}) currentUid:${currentUid} asyncHooksCurrentId:${asyncHooksCurrentId} triggerId:${triggerId} len:${this._set.length} context:${util.inspect(context, {showHidden:true, depth:2, colors:true})}`);\n  }\n\n  return context;\n};\n\nNamespace.prototype.run = function run(fn) {\n  let context = this.createContext();\n  this.enter(context);\n\n  try {\n    if (DEBUG_CLS_HOOKED) {\n      const triggerId = async_hooks.triggerAsyncId();\n      const asyncHooksCurrentId = async_hooks.executionAsyncId();\n      const indentStr = ' '.repeat(this._indent < 0 ? 0 : this._indent);\n      debug2(`${indentStr}CONTEXT-RUN BEGIN: (${this.name}) currentUid:${currentUid} triggerId:${triggerId} asyncHooksCurrentId:${asyncHooksCurrentId} len:${this._set.length} context:${util.inspect(context)}`);\n    }\n    fn(context);\n    return context;\n  } catch (exception) {\n    if (exception) {\n      exception[ERROR_SYMBOL] = context;\n    }\n    throw exception;\n  } finally {\n    if (DEBUG_CLS_HOOKED) {\n      const triggerId = async_hooks.triggerAsyncId();\n      const asyncHooksCurrentId = async_hooks.executionAsyncId();\n      const indentStr = ' '.repeat(this._indent < 0 ? 0 : this._indent);\n      debug2(`${indentStr}CONTEXT-RUN END: (${this.name}) currentUid:${currentUid} triggerId:${triggerId} asyncHooksCurrentId:${asyncHooksCurrentId} len:${this._set.length} ${util.inspect(context)}`);\n    }\n    this.exit(context);\n  }\n};\n\nNamespace.prototype.runAndReturn = function runAndReturn(fn) {\n  let value;\n  this.run(function (context) {\n    value = fn(context);\n  });\n  return value;\n};\n\n/**\n * Uses global Promise and assumes Promise is cls friendly or wrapped already.\n * @param {function} fn\n * @returns {*}\n */\nNamespace.prototype.runPromise = function runPromise(fn) {\n  let context = this.createContext();\n  this.enter(context);\n\n  let promise = fn(context);\n  if (!promise || !promise.then || !promise.catch) {\n    throw new Error('fn must return a promise.');\n  }\n\n  if (DEBUG_CLS_HOOKED) {\n    debug2('CONTEXT-runPromise BEFORE: (' + this.name + ') currentUid:' + currentUid + ' len:' + this._set.length + ' ' + util.inspect(context));\n  }\n\n  return promise\n    .then(result => {\n      if (DEBUG_CLS_HOOKED) {\n        debug2('CONTEXT-runPromise AFTER then: (' + this.name + ') currentUid:' + currentUid + ' len:' + this._set.length + ' ' + util.inspect(context));\n      }\n      this.exit(context);\n      return result;\n    })\n    .catch(err => {\n      err[ERROR_SYMBOL] = context;\n      if (DEBUG_CLS_HOOKED) {\n        debug2('CONTEXT-runPromise AFTER catch: (' + this.name + ') currentUid:' + currentUid + ' len:' + this._set.length + ' ' + util.inspect(context));\n      }\n      this.exit(context);\n      throw err;\n    });\n};\n\nNamespace.prototype.bind = function bindFactory(fn, context) {\n  if (!context) {\n    if (!this.active) {\n      context = this.createContext();\n    } else {\n      context = this.active;\n    }\n  }\n\n  let self = this;\n  return function clsBind() {\n    self.enter(context);\n    try {\n      return fn.apply(this, arguments);\n    } catch (exception) {\n      if (exception) {\n        exception[ERROR_SYMBOL] = context;\n      }\n      throw exception;\n    } finally {\n      self.exit(context);\n    }\n  };\n};\n\nNamespace.prototype.enter = function enter(context) {\n  assert.ok(context, 'context must be provided for entering');\n  if (DEBUG_CLS_HOOKED) {\n    const asyncHooksCurrentId = async_hooks.executionAsyncId();\n    const triggerId = async_hooks.triggerAsyncId();\n    const indentStr = ' '.repeat(this._indent < 0 ? 0 : this._indent);\n    debug2(`${indentStr}CONTEXT-ENTER: (${this.name}) currentUid:${currentUid} triggerId:${triggerId} asyncHooksCurrentId:${asyncHooksCurrentId} len:${this._set.length} ${util.inspect(context)}`);\n  }\n\n  this._set.push(this.active);\n  this.active = context;\n};\n\nNamespace.prototype.exit = function exit(context) {\n  assert.ok(context, 'context must be provided for exiting');\n  if (DEBUG_CLS_HOOKED) {\n    const asyncHooksCurrentId = async_hooks.executionAsyncId();\n    const triggerId = async_hooks.triggerAsyncId();\n    const indentStr = ' '.repeat(this._indent < 0 ? 0 : this._indent);\n    debug2(`${indentStr}CONTEXT-EXIT: (${this.name}) currentUid:${currentUid} triggerId:${triggerId} asyncHooksCurrentId:${asyncHooksCurrentId} len:${this._set.length} ${util.inspect(context)}`);\n  }\n\n  // Fast path for most exits that are at the top of the stack\n  if (this.active === context) {\n    assert.ok(this._set.length, 'can\\'t remove top context');\n    this.active = this._set.pop();\n    return;\n  }\n\n  // Fast search in the stack using lastIndexOf\n  let index = this._set.lastIndexOf(context);\n\n  if (index < 0) {\n    if (DEBUG_CLS_HOOKED) {\n      debug2('??ERROR?? context exiting but not entered - ignoring: ' + util.inspect(context));\n    }\n    assert.ok(index >= 0, 'context not currently entered; can\\'t exit. \\n' + util.inspect(this) + '\\n' + util.inspect(context));\n  } else {\n    assert.ok(index, 'can\\'t remove top context');\n    this._set.splice(index, 1);\n  }\n};\n\nNamespace.prototype.bindEmitter = function bindEmitter(emitter) {\n  assert.ok(emitter.on && emitter.addListener && emitter.emit, 'can only bind real EEs');\n\n  let namespace = this;\n  let thisSymbol = 'context@' + this.name;\n\n  // Capture the context active at the time the emitter is bound.\n  function attach(listener) {\n    if (!listener) {\n      return;\n    }\n    if (!listener[CONTEXTS_SYMBOL]) {\n      listener[CONTEXTS_SYMBOL] = Object.create(null);\n    }\n\n    listener[CONTEXTS_SYMBOL][thisSymbol] = {\n      namespace: namespace,\n      context: namespace.active\n    };\n  }\n\n  // At emit time, bind the listener within the correct context.\n  function bind(unwrapped) {\n    if (!(unwrapped && unwrapped[CONTEXTS_SYMBOL])) {\n      return unwrapped;\n    }\n\n    let wrapped = unwrapped;\n    let unwrappedContexts = unwrapped[CONTEXTS_SYMBOL];\n    Object.keys(unwrappedContexts).forEach(function (name) {\n      let thunk = unwrappedContexts[name];\n      wrapped = thunk.namespace.bind(wrapped, thunk.context);\n    });\n    return wrapped;\n  }\n\n  wrapEmitter(emitter, attach, bind);\n};\n\n/**\n * If an error comes out of a namespace, it will have a context attached to it.\n * This function knows how to find it.\n *\n * @param {Error} exception Possibly annotated error.\n */\nNamespace.prototype.fromException = function fromException(exception) {\n  return exception[ERROR_SYMBOL];\n};\n\nfunction getNamespace(name) {\n  return process.namespaces[name];\n}\n\nfunction createNamespace(name) {\n  assert.ok(name, 'namespace must be given a name.');\n\n  if (DEBUG_CLS_HOOKED) {\n    debug2(`NS-CREATING NAMESPACE (${name})`);\n  }\n  let namespace = new Namespace(name);\n  namespace.id = currentUid;\n\n  const hook = async_hooks.createHook({\n    init(asyncId, type, triggerId, resource) {\n      currentUid = async_hooks.executionAsyncId();\n\n      //CHAIN Parent's Context onto child if none exists. This is needed to pass net-events.spec\n      // let initContext = namespace.active;\n      // if(!initContext && triggerId) {\n      //   let parentContext = namespace._contexts.get(triggerId);\n      //   if (parentContext) {\n      //     namespace.active = parentContext;\n      //     namespace._contexts.set(currentUid, parentContext);\n      //     if (DEBUG_CLS_HOOKED) {\n      //       const indentStr = ' '.repeat(namespace._indent < 0 ? 0 : namespace._indent);\n      //       debug2(`${indentStr}INIT [${type}] (${name}) WITH PARENT CONTEXT asyncId:${asyncId} currentUid:${currentUid} triggerId:${triggerId} active:${util.inspect(namespace.active, true)} resource:${resource}`);\n      //     }\n      //   } else if (DEBUG_CLS_HOOKED) {\n      //       const indentStr = ' '.repeat(namespace._indent < 0 ? 0 : namespace._indent);\n      //       debug2(`${indentStr}INIT [${type}] (${name}) MISSING CONTEXT asyncId:${asyncId} currentUid:${currentUid} triggerId:${triggerId} active:${util.inspect(namespace.active, true)} resource:${resource}`);\n      //     }\n      // }else {\n      //   namespace._contexts.set(currentUid, namespace.active);\n      //   if (DEBUG_CLS_HOOKED) {\n      //     const indentStr = ' '.repeat(namespace._indent < 0 ? 0 : namespace._indent);\n      //     debug2(`${indentStr}INIT [${type}] (${name}) asyncId:${asyncId} currentUid:${currentUid} triggerId:${triggerId} active:${util.inspect(namespace.active, true)} resource:${resource}`);\n      //   }\n      // }\n      if(namespace.active) {\n        namespace._contexts.set(asyncId, namespace.active);\n\n        if (DEBUG_CLS_HOOKED) {\n          const indentStr = ' '.repeat(namespace._indent < 0 ? 0 : namespace._indent);\n          debug2(`${indentStr}INIT [${type}] (${name}) asyncId:${asyncId} currentUid:${currentUid} triggerId:${triggerId} active:${util.inspect(namespace.active, {showHidden:true, depth:2, colors:true})} resource:${resource}`);\n        }\n      }else if(currentUid === 0){\n        // CurrentId will be 0 when triggered from C++. Promise events\n        // https://github.com/nodejs/node/blob/master/doc/api/async_hooks.md#triggerid\n        const triggerId = async_hooks.triggerAsyncId();\n        const triggerIdContext = namespace._contexts.get(triggerId);\n        if (triggerIdContext) {\n          namespace._contexts.set(asyncId, triggerIdContext);\n          if (DEBUG_CLS_HOOKED) {\n            const indentStr = ' '.repeat(namespace._indent < 0 ? 0 : namespace._indent);\n            debug2(`${indentStr}INIT USING CONTEXT FROM TRIGGERID [${type}] (${name}) asyncId:${asyncId} currentUid:${currentUid} triggerId:${triggerId} active:${util.inspect(namespace.active, { showHidden: true, depth: 2, colors: true })} resource:${resource}`);\n          }\n        } else if (DEBUG_CLS_HOOKED) {\n          const indentStr = ' '.repeat(namespace._indent < 0 ? 0 : namespace._indent);\n          debug2(`${indentStr}INIT MISSING CONTEXT [${type}] (${name}) asyncId:${asyncId} currentUid:${currentUid} triggerId:${triggerId} active:${util.inspect(namespace.active, { showHidden: true, depth: 2, colors: true })} resource:${resource}`);\n        }\n      }\n\n\n      if(DEBUG_CLS_HOOKED && type === 'PROMISE'){\n        debug2(util.inspect(resource, {showHidden: true}));\n        const parentId = resource.parentId;\n        const indentStr = ' '.repeat(namespace._indent < 0 ? 0 : namespace._indent);\n        debug2(`${indentStr}INIT RESOURCE-PROMISE [${type}] (${name}) parentId:${parentId} asyncId:${asyncId} currentUid:${currentUid} triggerId:${triggerId} active:${util.inspect(namespace.active, {showHidden:true, depth:2, colors:true})} resource:${resource}`);\n      }\n\n    },\n    before(asyncId) {\n      currentUid = async_hooks.executionAsyncId();\n      let context;\n\n      /*\n      if(currentUid === 0){\n        // CurrentId will be 0 when triggered from C++. Promise events\n        // https://github.com/nodejs/node/blob/master/doc/api/async_hooks.md#triggerid\n        //const triggerId = async_hooks.triggerAsyncId();\n        context = namespace._contexts.get(asyncId); // || namespace._contexts.get(triggerId);\n      }else{\n        context = namespace._contexts.get(currentUid);\n      }\n      */\n\n      //HACK to work with promises until they are fixed in node > 8.1.1\n      context = namespace._contexts.get(asyncId) || namespace._contexts.get(currentUid);\n\n      if (context) {\n        if (DEBUG_CLS_HOOKED) {\n          const triggerId = async_hooks.triggerAsyncId();\n          const indentStr = ' '.repeat(namespace._indent < 0 ? 0 : namespace._indent);\n          debug2(`${indentStr}BEFORE (${name}) asyncId:${asyncId} currentUid:${currentUid} triggerId:${triggerId} active:${util.inspect(namespace.active, {showHidden:true, depth:2, colors:true})} context:${util.inspect(context)}`);\n          namespace._indent += 2;\n        }\n\n        namespace.enter(context);\n\n      } else if (DEBUG_CLS_HOOKED) {\n        const triggerId = async_hooks.triggerAsyncId();\n        const indentStr = ' '.repeat(namespace._indent < 0 ? 0 : namespace._indent);\n        debug2(`${indentStr}BEFORE MISSING CONTEXT (${name}) asyncId:${asyncId} currentUid:${currentUid} triggerId:${triggerId} active:${util.inspect(namespace.active, {showHidden:true, depth:2, colors:true})} namespace._contexts:${util.inspect(namespace._contexts, {showHidden:true, depth:2, colors:true})}`);\n        namespace._indent += 2;\n      }\n    },\n    after(asyncId) {\n      currentUid = async_hooks.executionAsyncId();\n      let context; // = namespace._contexts.get(currentUid);\n      /*\n      if(currentUid === 0){\n        // CurrentId will be 0 when triggered from C++. Promise events\n        // https://github.com/nodejs/node/blob/master/doc/api/async_hooks.md#triggerid\n        //const triggerId = async_hooks.triggerAsyncId();\n        context = namespace._contexts.get(asyncId); // || namespace._contexts.get(triggerId);\n      }else{\n        context = namespace._contexts.get(currentUid);\n      }\n      */\n      //HACK to work with promises until they are fixed in node > 8.1.1\n      context = namespace._contexts.get(asyncId) || namespace._contexts.get(currentUid);\n\n      if (context) {\n        if (DEBUG_CLS_HOOKED) {\n          const triggerId = async_hooks.triggerAsyncId();\n          namespace._indent -= 2;\n          const indentStr = ' '.repeat(namespace._indent < 0 ? 0 : namespace._indent);\n          debug2(`${indentStr}AFTER (${name}) asyncId:${asyncId} currentUid:${currentUid} triggerId:${triggerId} active:${util.inspect(namespace.active, {showHidden:true, depth:2, colors:true})} context:${util.inspect(context)}`);\n        }\n\n        namespace.exit(context);\n\n      } else if (DEBUG_CLS_HOOKED) {\n        const triggerId = async_hooks.triggerAsyncId();\n        namespace._indent -= 2;\n        const indentStr = ' '.repeat(namespace._indent < 0 ? 0 : namespace._indent);\n        debug2(`${indentStr}AFTER MISSING CONTEXT (${name}) asyncId:${asyncId} currentUid:${currentUid} triggerId:${triggerId} active:${util.inspect(namespace.active, {showHidden:true, depth:2, colors:true})} context:${util.inspect(context)}`);\n      }\n    },\n    destroy(asyncId) {\n      currentUid = async_hooks.executionAsyncId();\n      if (DEBUG_CLS_HOOKED) {\n        const triggerId = async_hooks.triggerAsyncId();\n        const indentStr = ' '.repeat(namespace._indent < 0 ? 0 : namespace._indent);\n        debug2(`${indentStr}DESTROY (${name}) currentUid:${currentUid} asyncId:${asyncId} triggerId:${triggerId} active:${util.inspect(namespace.active, {showHidden:true, depth:2, colors:true})} context:${util.inspect(namespace._contexts.get(currentUid))}`);\n      }\n\n      namespace._contexts.delete(asyncId);\n    }\n  });\n\n  hook.enable();\n\n  process.namespaces[name] = namespace;\n  return namespace;\n}\n\nfunction destroyNamespace(name) {\n  let namespace = getNamespace(name);\n\n  assert.ok(namespace, 'can\\'t delete nonexistent namespace! \"' + name + '\"');\n  assert.ok(namespace.id, 'don\\'t assign to process.namespaces directly! ' + util.inspect(namespace));\n\n  process.namespaces[name] = null;\n}\n\nfunction reset() {\n  // must unregister async listeners\n  if (process.namespaces) {\n    Object.keys(process.namespaces).forEach(function (name) {\n      destroyNamespace(name);\n    });\n  }\n  process.namespaces = Object.create(null);\n}\n\nprocess.namespaces = {};\n\n//const fs = require('fs');\nfunction debug2(...args) {\n  if (DEBUG_CLS_HOOKED) {\n    //fs.writeSync(1, `${util.format(...args)}\\n`);\n    process._rawDebug(`${util.format(...args)}`);\n  }\n}\n\n/*function getFunctionName(fn) {\n  if (!fn) {\n    return fn;\n  }\n  if (typeof fn === 'function') {\n    if (fn.name) {\n      return fn.name;\n    }\n    return (fn.toString().trim().match(/^function\\s*([^\\s(]+)/) || [])[1];\n  } else if (fn.constructor && fn.constructor.name) {\n    return fn.constructor.name;\n  }\n}*/\n\n\n","'use strict';\n\nconst semver = require('semver');\n\n/**\n * In order to increase node version support, this loads the version of context\n * that is appropriate for the version of on nodejs that is running.\n * Node < v8 - uses AsyncWrap and async-hooks-jl\n * Node >= v8 - uses native async-hooks\n */\nif(process && semver.gte(process.versions.node, '8.0.0')){\n  module.exports = require('./context');\n}else{\n  module.exports = require('./context-legacy');\n}\n","'use strict';\n\nvar assert      = require('assert');\nvar wrapEmitter = require('emitter-listener');\n\n/*\n *\n * CONSTANTS\n *\n */\nvar CONTEXTS_SYMBOL = 'cls@contexts';\nvar ERROR_SYMBOL = 'error@context';\n\n// load polyfill if native support is unavailable\nif (!process.addAsyncListener) require('async-listener');\n\nfunction Namespace(name) {\n  this.name   = name;\n  // changed in 2.7: no default context\n  this.active = null;\n  this._set   = [];\n  this.id     = null;\n}\n\nNamespace.prototype.set = function (key, value) {\n  if (!this.active) {\n    throw new Error(\"No context available. ns.run() or ns.bind() must be called first.\");\n  }\n\n  this.active[key] = value;\n  return value;\n};\n\nNamespace.prototype.get = function (key) {\n  if (!this.active) return undefined;\n\n  return this.active[key];\n};\n\nNamespace.prototype.createContext = function () {\n  return Object.create(this.active);\n};\n\nNamespace.prototype.run = function (fn) {\n  var context = this.createContext();\n  this.enter(context);\n  try {\n    fn(context);\n    return context;\n  }\n  catch (exception) {\n    if (exception) {\n      exception[ERROR_SYMBOL] = context;\n    }\n    throw exception;\n  }\n  finally {\n    this.exit(context);\n  }\n};\n\nNamespace.prototype.runAndReturn = function (fn) {\n  var value;\n  this.run(function (context) {\n    value = fn(context);\n  });\n  return value;\n};\n\nNamespace.prototype.bind = function (fn, context) {\n  if (!context) {\n    if (!this.active) {\n      context = this.createContext();\n    }\n    else {\n      context = this.active;\n    }\n  }\n\n  var self = this;\n  return function () {\n    self.enter(context);\n    try {\n      return fn.apply(this, arguments);\n    }\n    catch (exception) {\n      if (exception) {\n        exception[ERROR_SYMBOL] = context;\n      }\n      throw exception;\n    }\n    finally {\n      self.exit(context);\n    }\n  };\n};\n\nNamespace.prototype.enter = function (context) {\n  assert.ok(context, \"context must be provided for entering\");\n\n  this._set.push(this.active);\n  this.active = context;\n};\n\nNamespace.prototype.exit = function (context) {\n  assert.ok(context, \"context must be provided for exiting\");\n\n  // Fast path for most exits that are at the top of the stack\n  if (this.active === context) {\n    assert.ok(this._set.length, \"can't remove top context\");\n    this.active = this._set.pop();\n    return;\n  }\n\n  // Fast search in the stack using lastIndexOf\n  var index = this._set.lastIndexOf(context);\n\n  assert.ok(index >= 0, \"context not currently entered; can't exit\");\n  assert.ok(index,      \"can't remove top context\");\n\n  this._set.splice(index, 1);\n};\n\nNamespace.prototype.bindEmitter = function (emitter) {\n  assert.ok(emitter.on && emitter.addListener && emitter.emit, \"can only bind real EEs\");\n\n  var namespace  = this;\n  var thisSymbol = 'context@' + this.name;\n\n  // Capture the context active at the time the emitter is bound.\n  function attach(listener) {\n    if (!listener) return;\n    if (!listener[CONTEXTS_SYMBOL]) listener[CONTEXTS_SYMBOL] = Object.create(null);\n\n    listener[CONTEXTS_SYMBOL][thisSymbol] = {\n      namespace : namespace,\n      context   : namespace.active\n    };\n  }\n\n  // At emit time, bind the listener within the correct context.\n  function bind(unwrapped) {\n    if (!(unwrapped && unwrapped[CONTEXTS_SYMBOL])) return unwrapped;\n\n    var wrapped  = unwrapped;\n    var contexts = unwrapped[CONTEXTS_SYMBOL];\n    Object.keys(contexts).forEach(function (name) {\n      var thunk = contexts[name];\n      wrapped = thunk.namespace.bind(wrapped, thunk.context);\n    });\n    return wrapped;\n  }\n\n  wrapEmitter(emitter, attach, bind);\n};\n\n/**\n * If an error comes out of a namespace, it will have a context attached to it.\n * This function knows how to find it.\n *\n * @param {Error} exception Possibly annotated error.\n */\nNamespace.prototype.fromException = function (exception) {\n  return exception[ERROR_SYMBOL];\n};\n\nfunction get(name) {\n  return process.namespaces[name];\n}\n\nfunction create(name) {\n  assert.ok(name, \"namespace must be given a name!\");\n\n  var namespace = new Namespace(name);\n  namespace.id = process.addAsyncListener({\n    create : function () { return namespace.active; },\n    before : function (context, storage) { if (storage) namespace.enter(storage); },\n    after  : function (context, storage) { if (storage) namespace.exit(storage); },\n    error  : function (storage) { if (storage) namespace.exit(storage); }\n  });\n\n  process.namespaces[name] = namespace;\n  return namespace;\n}\n\nfunction destroy(name) {\n  var namespace = get(name);\n\n  assert.ok(namespace,    \"can't delete nonexistent namespace!\");\n  assert.ok(namespace.id, \"don't assign to process.namespaces directly!\");\n\n  process.removeAsyncListener(namespace.id);\n  process.namespaces[name] = null;\n}\n\nfunction reset() {\n  // must unregister async listeners\n  if (process.namespaces) {\n    Object.keys(process.namespaces).forEach(function (name) {\n      destroy(name);\n    });\n  }\n  process.namespaces = Object.create(null);\n}\nif (!process.namespaces) reset(); // call immediately to set up\n\nmodule.exports = {\n  getNamespace     : get,\n  createNamespace  : create,\n  destroyNamespace : destroy,\n  reset            : reset\n};\n","function webpackEmptyContext(req) {\n\tvar e = new Error(\"Cannot find module '\" + req + \"'\");\n\te.code = 'MODULE_NOT_FOUND';\n\tthrow e;\n}\nwebpackEmptyContext.keys = function() { return []; };\nwebpackEmptyContext.resolve = webpackEmptyContext;\nmodule.exports = webpackEmptyContext;\nwebpackEmptyContext.id = \"./node_modules/diagnostic-channel-publishers/dist/src sync recursive ^.*\\\\/lib\\\\/Connection$\";","function webpackEmptyContext(req) {\n\tvar e = new Error(\"Cannot find module '\" + req + \"'\");\n\te.code = 'MODULE_NOT_FOUND';\n\tthrow e;\n}\nwebpackEmptyContext.keys = function() { return []; };\nwebpackEmptyContext.resolve = webpackEmptyContext;\nmodule.exports = webpackEmptyContext;\nwebpackEmptyContext.id = \"./node_modules/diagnostic-channel-publishers/dist/src sync recursive ^.*\\\\/lib\\\\/Pool$\";","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license. See LICENSE file in the project root for details.\nvar diagnostic_channel_1 = require(\"diagnostic-channel\");\nvar bunyanPatchFunction = function (originalBunyan) {\n    var originalEmit = originalBunyan.prototype._emit;\n    originalBunyan.prototype._emit = function (rec, noemit) {\n        var ret = originalEmit.apply(this, arguments);\n        if (!noemit) {\n            var str = ret;\n            if (!str) {\n                str = originalEmit.call(this, rec, true);\n            }\n            diagnostic_channel_1.channel.publish(\"bunyan\", { level: rec.level, result: str });\n        }\n        return ret;\n    };\n    return originalBunyan;\n};\nexports.bunyan = {\n    versionSpecifier: \">= 1.0.0 < 2.0.0\",\n    patch: bunyanPatchFunction,\n};\nfunction enable() {\n    diagnostic_channel_1.channel.registerMonkeyPatch(\"bunyan\", exports.bunyan);\n}\nexports.enable = enable;\n//# sourceMappingURL=bunyan.pub.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license. See LICENSE file in the project root for details.\nvar diagnostic_channel_1 = require(\"diagnostic-channel\");\nvar stream_1 = require(\"stream\");\nvar consolePatchFunction = function (originalConsole) {\n    var aiLoggingOutStream = new stream_1.Writable();\n    var aiLoggingErrStream = new stream_1.Writable();\n    // Default console is roughly equivalent to `new Console(process.stdout, process.stderr)`\n    // We create a version which publishes to the channel and also to stdout/stderr\n    aiLoggingOutStream.write = function (chunk) {\n        if (!chunk) {\n            return true;\n        }\n        var message = chunk.toString();\n        diagnostic_channel_1.channel.publish(\"console\", { message: message });\n        return true;\n    };\n    aiLoggingErrStream.write = function (chunk) {\n        if (!chunk) {\n            return true;\n        }\n        var message = chunk.toString();\n        diagnostic_channel_1.channel.publish(\"console\", { message: message, stderr: true });\n        return true;\n    };\n    var aiLoggingConsole = new originalConsole.Console(aiLoggingOutStream, aiLoggingErrStream);\n    var consoleMethods = [\"log\", \"info\", \"warn\", \"error\", \"dir\", \"time\", \"timeEnd\", \"trace\", \"assert\"];\n    var _loop_1 = function (method) {\n        var originalMethod = originalConsole[method];\n        if (originalMethod) {\n            originalConsole[method] = function () {\n                if (aiLoggingConsole[method]) {\n                    try {\n                        aiLoggingConsole[method].apply(aiLoggingConsole, arguments);\n                    }\n                    catch (e) {\n                        // Ignore errors; allow the original method to throw if necessary\n                    }\n                }\n                return originalMethod.apply(originalConsole, arguments);\n            };\n        }\n    };\n    for (var _i = 0, consoleMethods_1 = consoleMethods; _i < consoleMethods_1.length; _i++) {\n        var method = consoleMethods_1[_i];\n        _loop_1(method);\n    }\n    return originalConsole;\n};\nexports.console = {\n    versionSpecifier: \">= 4.0.0\",\n    patch: consolePatchFunction,\n};\nfunction enable() {\n    diagnostic_channel_1.channel.registerMonkeyPatch(\"console\", exports.console);\n    // Force patching of console\n    /* tslint:disable-next-line:no-var-requires */\n    require(\"console\");\n}\nexports.enable = enable;\n//# sourceMappingURL=console.pub.js.map","\"use strict\";\n// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license. See LICENSE file in the project root for details.\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar bunyan = require(\"./bunyan.pub\");\nexports.bunyan = bunyan;\nvar consolePub = require(\"./console.pub\");\nexports.console = consolePub;\nvar mongodbCore = require(\"./mongodb-core.pub\");\nexports.mongodbCore = mongodbCore;\nvar mongodb = require(\"./mongodb.pub\");\nexports.mongodb = mongodb;\nvar mysql = require(\"./mysql.pub\");\nexports.mysql = mysql;\nvar pgPool = require(\"./pg-pool.pub\");\nexports.pgPool = pgPool;\nvar pg = require(\"./pg.pub\");\nexports.pg = pg;\nvar redis = require(\"./redis.pub\");\nexports.redis = redis;\nvar winston = require(\"./winston.pub\");\nexports.winston = winston;\nfunction enable() {\n    bunyan.enable();\n    consolePub.enable();\n    mongodbCore.enable();\n    mongodb.enable();\n    mysql.enable();\n    pg.enable();\n    pgPool.enable();\n    redis.enable();\n    winston.enable();\n}\nexports.enable = enable;\n//# sourceMappingURL=index.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license. See LICENSE file in the project root for details.\nvar diagnostic_channel_1 = require(\"diagnostic-channel\");\nvar mongodbcorePatchFunction = function (originalMongoCore) {\n    var originalConnect = originalMongoCore.Server.prototype.connect;\n    originalMongoCore.Server.prototype.connect = function contextPreservingConnect() {\n        var ret = originalConnect.apply(this, arguments);\n        // Messages sent to mongo progress through a pool\n        // This can result in context getting mixed between different responses\n        // so we wrap the callbacks to restore appropriate state\n        var originalWrite = this.s.pool.write;\n        this.s.pool.write = function contextPreservingWrite() {\n            var cbidx = typeof arguments[1] === \"function\" ? 1 : 2;\n            if (typeof arguments[cbidx] === \"function\") {\n                arguments[cbidx] = diagnostic_channel_1.channel.bindToContext(arguments[cbidx]);\n            }\n            return originalWrite.apply(this, arguments);\n        };\n        // Logout is a special case, it doesn't call the write function but instead\n        // directly calls into connection.write\n        var originalLogout = this.s.pool.logout;\n        this.s.pool.logout = function contextPreservingLogout() {\n            if (typeof arguments[1] === \"function\") {\n                arguments[1] = diagnostic_channel_1.channel.bindToContext(arguments[1]);\n            }\n            return originalLogout.apply(this, arguments);\n        };\n        return ret;\n    };\n    return originalMongoCore;\n};\nexports.mongoCore = {\n    versionSpecifier: \">= 2.0.0 < 4.0.0\",\n    patch: mongodbcorePatchFunction,\n};\nfunction enable() {\n    diagnostic_channel_1.channel.registerMonkeyPatch(\"mongodb-core\", exports.mongoCore);\n}\nexports.enable = enable;\n//# sourceMappingURL=mongodb-core.pub.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license. See LICENSE file in the project root for details.\nvar diagnostic_channel_1 = require(\"diagnostic-channel\");\nvar mongodbPatchFunction = function (originalMongo) {\n    var listener = originalMongo.instrument({\n        operationIdGenerator: {\n            next: function () {\n                return diagnostic_channel_1.channel.bindToContext(function (cb) { return cb(); });\n            },\n        },\n    });\n    var eventMap = {};\n    listener.on(\"started\", function (event) {\n        if (eventMap[event.requestId]) {\n            // Note: Mongo can generate 2 completely separate requests\n            // which share the same requestId, if a certain race condition is triggered.\n            // For now, we accept that this can happen and potentially miss or mislabel some events.\n            return;\n        }\n        eventMap[event.requestId] = event;\n    });\n    listener.on(\"succeeded\", function (event) {\n        var startedData = eventMap[event.requestId];\n        if (startedData) {\n            delete eventMap[event.requestId];\n        }\n        event.operationId(function () { return diagnostic_channel_1.channel.publish(\"mongodb\", { startedData: startedData, event: event, succeeded: true }); });\n    });\n    listener.on(\"failed\", function (event) {\n        var startedData = eventMap[event.requestId];\n        if (startedData) {\n            delete eventMap[event.requestId];\n        }\n        event.operationId(function () { return diagnostic_channel_1.channel.publish(\"mongodb\", { startedData: startedData, event: event, succeeded: false }); });\n    });\n    return originalMongo;\n};\nvar mongodb3PatchFunction = function (originalMongo) {\n    var listener = originalMongo.instrument();\n    var eventMap = {};\n    var contextMap = {};\n    listener.on(\"started\", function (event) {\n        if (eventMap[event.requestId]) {\n            // Note: Mongo can generate 2 completely separate requests\n            // which share the same requestId, if a certain race condition is triggered.\n            // For now, we accept that this can happen and potentially miss or mislabel some events.\n            return;\n        }\n        contextMap[event.requestId] = diagnostic_channel_1.channel.bindToContext(function (cb) { return cb(); });\n        eventMap[event.requestId] = event;\n    });\n    listener.on(\"succeeded\", function (event) {\n        var startedData = eventMap[event.requestId];\n        if (startedData) {\n            delete eventMap[event.requestId];\n        }\n        if (typeof event === \"object\" && typeof contextMap[event.requestId] === \"function\") {\n            contextMap[event.requestId](function () { return diagnostic_channel_1.channel.publish(\"mongodb\", { startedData: startedData, event: event, succeeded: true }); });\n            delete contextMap[event.requestId];\n        }\n    });\n    listener.on(\"failed\", function (event) {\n        var startedData = eventMap[event.requestId];\n        if (startedData) {\n            delete eventMap[event.requestId];\n        }\n        if (typeof event === \"object\" && typeof contextMap[event.requestId] === \"function\") {\n            contextMap[event.requestId](function () { return diagnostic_channel_1.channel.publish(\"mongodb\", { startedData: startedData, event: event, succeeded: false }); });\n            delete contextMap[event.requestId];\n        }\n    });\n    return originalMongo;\n};\n// In mongodb 3.3.0, mongodb-core was merged into mongodb, so the same patching\n// can be used here. this.s.pool was changed to this.s.coreTopology.s.pool\nvar mongodbcorePatchFunction = function (originalMongo) {\n    var originalConnect = originalMongo.Server.prototype.connect;\n    originalMongo.Server.prototype.connect = function contextPreservingConnect() {\n        var ret = originalConnect.apply(this, arguments);\n        // Messages sent to mongo progress through a pool\n        // This can result in context getting mixed between different responses\n        // so we wrap the callbacks to restore appropriate state\n        var originalWrite = this.s.coreTopology.s.pool.write;\n        this.s.coreTopology.s.pool.write = function contextPreservingWrite() {\n            var cbidx = typeof arguments[1] === \"function\" ? 1 : 2;\n            if (typeof arguments[cbidx] === \"function\") {\n                arguments[cbidx] = diagnostic_channel_1.channel.bindToContext(arguments[cbidx]);\n            }\n            return originalWrite.apply(this, arguments);\n        };\n        // Logout is a special case, it doesn't call the write function but instead\n        // directly calls into connection.write\n        var originalLogout = this.s.coreTopology.s.pool.logout;\n        this.s.coreTopology.s.pool.logout = function contextPreservingLogout() {\n            if (typeof arguments[1] === \"function\") {\n                arguments[1] = diagnostic_channel_1.channel.bindToContext(arguments[1]);\n            }\n            return originalLogout.apply(this, arguments);\n        };\n        return ret;\n    };\n    return originalMongo;\n};\nvar mongodb330PatchFunction = function (originalMongo) {\n    mongodbcorePatchFunction(originalMongo); // apply mongodb-core patches\n    var listener = originalMongo.instrument();\n    var eventMap = {};\n    var contextMap = {};\n    listener.on(\"started\", function (event) {\n        if (eventMap[event.requestId]) {\n            // Note: Mongo can generate 2 completely separate requests\n            // which share the same requestId, if a certain race condition is triggered.\n            // For now, we accept that this can happen and potentially miss or mislabel some events.\n            return;\n        }\n        contextMap[event.requestId] = diagnostic_channel_1.channel.bindToContext(function (cb) { return cb(); });\n        eventMap[event.requestId] = event;\n    });\n    listener.on(\"succeeded\", function (event) {\n        var startedData = eventMap[event.requestId];\n        if (startedData) {\n            delete eventMap[event.requestId];\n        }\n        if (typeof event === \"object\" && typeof contextMap[event.requestId] === \"function\") {\n            contextMap[event.requestId](function () { return diagnostic_channel_1.channel.publish(\"mongodb\", { startedData: startedData, event: event, succeeded: true }); });\n            delete contextMap[event.requestId];\n        }\n    });\n    listener.on(\"failed\", function (event) {\n        var startedData = eventMap[event.requestId];\n        if (startedData) {\n            delete eventMap[event.requestId];\n        }\n        if (typeof event === \"object\" && typeof contextMap[event.requestId] === \"function\") {\n            contextMap[event.requestId](function () { return diagnostic_channel_1.channel.publish(\"mongodb\", { startedData: startedData, event: event, succeeded: false }); });\n            delete contextMap[event.requestId];\n        }\n    });\n    return originalMongo;\n};\nexports.mongo2 = {\n    versionSpecifier: \">= 2.0.0 <= 3.0.5\",\n    patch: mongodbPatchFunction,\n};\nexports.mongo3 = {\n    versionSpecifier: \"> 3.0.5 < 3.3.0\",\n    patch: mongodb3PatchFunction,\n};\nexports.mongo330 = {\n    versionSpecifier: \">= 3.3.0 < 4.0.0\",\n    patch: mongodb330PatchFunction,\n};\nfunction enable() {\n    diagnostic_channel_1.channel.registerMonkeyPatch(\"mongodb\", exports.mongo2);\n    diagnostic_channel_1.channel.registerMonkeyPatch(\"mongodb\", exports.mongo3);\n    diagnostic_channel_1.channel.registerMonkeyPatch(\"mongodb\", exports.mongo330);\n}\nexports.enable = enable;\n//# sourceMappingURL=mongodb.pub.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license. See LICENSE file in the project root for details.\nvar diagnostic_channel_1 = require(\"diagnostic-channel\");\nvar path = require(\"path\");\nvar mysqlPatchFunction = function (originalMysql, originalMysqlPath) {\n    // The `name` passed in here is for debugging purposes,\n    // to help distinguish which object is being patched.\n    var patchObjectFunction = function (obj, name) {\n        return function (func, cbWrapper) {\n            var originalFunc = obj[func];\n            if (originalFunc) {\n                obj[func] = function mysqlContextPreserver() {\n                    // Find the callback, if there is one\n                    var cbidx = arguments.length - 1;\n                    for (var i = arguments.length - 1; i >= 0; --i) {\n                        if (typeof arguments[i] === \"function\") {\n                            cbidx = i;\n                            break;\n                        }\n                        else if (typeof arguments[i] !== \"undefined\") {\n                            break;\n                        }\n                    }\n                    var cb = arguments[cbidx];\n                    var resultContainer = { result: null, startTime: null };\n                    if (typeof cb === \"function\") {\n                        // Preserve context on the callback.\n                        // If this is one of the functions that we want to track,\n                        // then wrap the callback with the tracking wrapper\n                        if (cbWrapper) {\n                            resultContainer.startTime = process.hrtime();\n                            arguments[cbidx] = diagnostic_channel_1.channel.bindToContext(cbWrapper(resultContainer, cb));\n                        }\n                        else {\n                            arguments[cbidx] = diagnostic_channel_1.channel.bindToContext(cb);\n                        }\n                    }\n                    var result = originalFunc.apply(this, arguments);\n                    resultContainer.result = result;\n                    return result;\n                };\n            }\n        };\n    };\n    var patchClassMemberFunction = function (classObject, name) {\n        return patchObjectFunction(classObject.prototype, name + \".prototype\");\n    };\n    var connectionCallbackFunctions = [\n        \"connect\", \"changeUser\",\n        \"ping\", \"statistics\", \"end\",\n    ];\n    var connectionClass = require(path.dirname(originalMysqlPath) + \"/lib/Connection\");\n    connectionCallbackFunctions.forEach(function (value) { return patchClassMemberFunction(connectionClass, \"Connection\")(value); });\n    // Connection.createQuery is a static method\n    patchObjectFunction(connectionClass, \"Connection\")(\"createQuery\", function (resultContainer, cb) {\n        return function (err) {\n            var hrDuration = process.hrtime(resultContainer.startTime);\n            /* tslint:disable-next-line:no-bitwise */\n            var duration = (hrDuration[0] * 1e3 + hrDuration[1] / 1e6) | 0;\n            diagnostic_channel_1.channel.publish(\"mysql\", { query: resultContainer.result, callbackArgs: arguments, err: err, duration: duration });\n            cb.apply(this, arguments);\n        };\n    });\n    var poolCallbackFunctions = [\n        \"_enqueueCallback\",\n    ];\n    var poolClass = require(path.dirname(originalMysqlPath) + \"/lib/Pool\");\n    poolCallbackFunctions.forEach(function (value) { return patchClassMemberFunction(poolClass, \"Pool\")(value); });\n    return originalMysql;\n};\nexports.mysql = {\n    versionSpecifier: \">= 2.0.0 < 3.0.0\",\n    patch: mysqlPatchFunction,\n};\nfunction enable() {\n    diagnostic_channel_1.channel.registerMonkeyPatch(\"mysql\", exports.mysql);\n}\nexports.enable = enable;\n//# sourceMappingURL=mysql.pub.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license. See LICENSE file in the project root for details.\nvar diagnostic_channel_1 = require(\"diagnostic-channel\");\nfunction postgresPool1PatchFunction(originalPgPool) {\n    var originalConnect = originalPgPool.prototype.connect;\n    originalPgPool.prototype.connect = function connect(callback) {\n        if (callback) {\n            arguments[0] = diagnostic_channel_1.channel.bindToContext(callback);\n        }\n        return originalConnect.apply(this, arguments);\n    };\n    return originalPgPool;\n}\nexports.postgresPool1 = {\n    versionSpecifier: \">= 1.0.0 < 3.0.0\",\n    patch: postgresPool1PatchFunction,\n};\nfunction enable() {\n    diagnostic_channel_1.channel.registerMonkeyPatch(\"pg-pool\", exports.postgresPool1);\n}\nexports.enable = enable;\n//# sourceMappingURL=pg-pool.pub.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license. See LICENSE file in the project root for details.\nvar diagnostic_channel_1 = require(\"diagnostic-channel\");\nvar events_1 = require(\"events\");\nfunction postgres6PatchFunction(originalPg, originalPgPath) {\n    var originalClientQuery = originalPg.Client.prototype.query;\n    var diagnosticOriginalFunc = \"__diagnosticOriginalFunc\";\n    // wherever the callback is passed, find it, save it, and remove it from the call\n    // to the the original .query() function\n    originalPg.Client.prototype.query = function query(config, values, callback) {\n        var data = {\n            query: {},\n            database: {\n                host: this.connectionParameters.host,\n                port: this.connectionParameters.port,\n            },\n            result: null,\n            error: null,\n            duration: 0,\n        };\n        var start = process.hrtime();\n        var queryResult;\n        function patchCallback(cb) {\n            if (cb && cb[diagnosticOriginalFunc]) {\n                cb = cb[diagnosticOriginalFunc];\n            }\n            var trackingCallback = diagnostic_channel_1.channel.bindToContext(function (err, res) {\n                var end = process.hrtime(start);\n                data.result = res && { rowCount: res.rowCount, command: res.command };\n                data.error = err;\n                data.duration = Math.ceil((end[0] * 1e3) + (end[1] / 1e6));\n                diagnostic_channel_1.channel.publish(\"postgres\", data);\n                // emulate weird internal behavior in pg@6\n                // on success, the callback is called *before* query events are emitted\n                // on failure, the callback is called *instead of* the query emitting events\n                // with no events, that means no promises (since the promise is resolved/rejected in an event handler)\n                // since we are always inserting ourselves as a callback, we have to restore the original\n                // behavior if the user didn't provide one themselves\n                if (err) {\n                    if (cb) {\n                        return cb.apply(this, arguments);\n                    }\n                    else if (queryResult && queryResult instanceof events_1.EventEmitter) {\n                        queryResult.emit(\"error\", err);\n                    }\n                }\n                else if (cb) {\n                    cb.apply(this, arguments);\n                }\n            });\n            try {\n                Object.defineProperty(trackingCallback, diagnosticOriginalFunc, { value: cb });\n                return trackingCallback;\n            }\n            catch (e) {\n                // this should never happen, but bailout in case it does\n                return cb;\n            }\n        }\n        // this function takes too many variations of arguments.\n        // this patches any provided callback or creates a new callback if one wasn't provided.\n        // since the callback is always called (if provided) in addition to always having a Promisified\n        // EventEmitter returned (well, sometimes -- see above), its safe to insert a callback if none was given\n        try {\n            if (typeof config === \"string\") {\n                if (values instanceof Array) {\n                    data.query.preparable = {\n                        text: config,\n                        args: values,\n                    };\n                    callback = patchCallback(callback);\n                }\n                else {\n                    data.query.text = config;\n                    // pg v6 will, for some reason, accept both\n                    // client.query(\"...\", undefined, () => {...})\n                    // **and**\n                    // client.query(\"...\", () => {...});\n                    // Internally, precedence is given to the callback argument\n                    if (callback) {\n                        callback = patchCallback(callback);\n                    }\n                    else {\n                        values = patchCallback(values);\n                    }\n                }\n            }\n            else {\n                if (typeof config.name === \"string\") {\n                    data.query.plan = config.name;\n                }\n                else if (config.values instanceof Array) {\n                    data.query.preparable = {\n                        text: config.text,\n                        args: config.values,\n                    };\n                }\n                else {\n                    data.query.text = config.text;\n                }\n                if (callback) {\n                    callback = patchCallback(callback);\n                }\n                else if (values) {\n                    values = patchCallback(values);\n                }\n                else {\n                    config.callback = patchCallback(config.callback);\n                }\n            }\n        }\n        catch (e) {\n            // if our logic here throws, bail out and just let pg do its thing\n            return originalClientQuery.apply(this, arguments);\n        }\n        arguments[0] = config;\n        arguments[1] = values;\n        arguments[2] = callback;\n        arguments.length = (arguments.length > 3) ? arguments.length : 3;\n        queryResult = originalClientQuery.apply(this, arguments);\n        return queryResult;\n    };\n    return originalPg;\n}\nfunction postgres7PatchFunction(originalPg, originalPgPath) {\n    var originalClientQuery = originalPg.Client.prototype.query;\n    var diagnosticOriginalFunc = \"__diagnosticOriginalFunc\";\n    // wherever the callback is passed, find it, save it, and remove it from the call\n    // to the the original .query() function\n    originalPg.Client.prototype.query = function query(config, values, callback) {\n        var _this = this;\n        var callbackProvided = !!callback; // Starting in pg@7.x+, Promise is returned only if !callbackProvided\n        var data = {\n            query: {},\n            database: {\n                host: this.connectionParameters.host,\n                port: this.connectionParameters.port,\n            },\n            result: null,\n            error: null,\n            duration: 0,\n        };\n        var start = process.hrtime();\n        var queryResult;\n        function patchCallback(cb) {\n            if (cb && cb[diagnosticOriginalFunc]) {\n                cb = cb[diagnosticOriginalFunc];\n            }\n            var trackingCallback = diagnostic_channel_1.channel.bindToContext(function (err, res) {\n                var end = process.hrtime(start);\n                data.result = res && { rowCount: res.rowCount, command: res.command };\n                data.error = err;\n                data.duration = Math.ceil((end[0] * 1e3) + (end[1] / 1e6));\n                diagnostic_channel_1.channel.publish(\"postgres\", data);\n                if (err) {\n                    if (cb) {\n                        return cb.apply(this, arguments);\n                    }\n                    else if (queryResult && queryResult instanceof events_1.EventEmitter) {\n                        queryResult.emit(\"error\", err);\n                    }\n                }\n                else if (cb) {\n                    cb.apply(this, arguments);\n                }\n            });\n            try {\n                Object.defineProperty(trackingCallback, diagnosticOriginalFunc, { value: cb });\n                return trackingCallback;\n            }\n            catch (e) {\n                // this should never happen, but bailout in case it does\n                return cb;\n            }\n        }\n        // Only try to wrap the callback if it is a function. We want to keep the same\n        // behavior of returning a promise only if no callback is provided. Wrapping\n        // a nonfunction makes it a function and pg will interpret it as a callback\n        try {\n            if (typeof config === \"string\") {\n                if (values instanceof Array) {\n                    data.query.preparable = {\n                        text: config,\n                        args: values,\n                    };\n                    callbackProvided = typeof callback === \"function\";\n                    callback = callback ? patchCallback(callback) : callback;\n                }\n                else {\n                    data.query.text = config;\n                    if (callback) {\n                        callbackProvided = typeof callback === \"function\";\n                        callback = callbackProvided ? patchCallback(callback) : callback;\n                    }\n                    else {\n                        callbackProvided = typeof values === \"function\";\n                        values = callbackProvided ? patchCallback(values) : values;\n                    }\n                }\n            }\n            else {\n                if (typeof config.name === \"string\") {\n                    data.query.plan = config.name;\n                }\n                else if (config.values instanceof Array) {\n                    data.query.preparable = {\n                        text: config.text,\n                        args: config.values,\n                    };\n                }\n                else {\n                    data.query.text = config.text;\n                }\n                if (callback) {\n                    callbackProvided = typeof callback === \"function\";\n                    callback = patchCallback(callback);\n                }\n                else if (values) {\n                    callbackProvided = typeof values === \"function\";\n                    values = callbackProvided ? patchCallback(values) : values;\n                }\n                else {\n                    callbackProvided = typeof config.callback === \"function\";\n                    config.callback = callbackProvided ? patchCallback(config.callback) : config.callback;\n                }\n            }\n        }\n        catch (e) {\n            // if our logic here throws, bail out and just let pg do its thing\n            return originalClientQuery.apply(this, arguments);\n        }\n        arguments[0] = config;\n        arguments[1] = values;\n        arguments[2] = callback;\n        arguments.length = (arguments.length > 3) ? arguments.length : 3;\n        queryResult = originalClientQuery.apply(this, arguments);\n        if (!callbackProvided) {\n            // no callback, so create a pass along promise\n            return queryResult\n                // pass resolved promise after publishing the event\n                .then(function (result) {\n                patchCallback()(undefined, result);\n                return new _this._Promise(function (resolve, reject) {\n                    resolve(result);\n                });\n            })\n                // pass along rejected promise after publishing the error\n                .catch(function (error) {\n                patchCallback()(error, undefined);\n                return new _this._Promise(function (resolve, reject) {\n                    reject(error);\n                });\n            });\n        }\n        return queryResult;\n    };\n    return originalPg;\n}\nexports.postgres6 = {\n    versionSpecifier: \"6.*\",\n    patch: postgres6PatchFunction,\n};\nexports.postgres7 = {\n    versionSpecifier: \"7.*\",\n    patch: postgres7PatchFunction,\n};\nfunction enable() {\n    diagnostic_channel_1.channel.registerMonkeyPatch(\"pg\", exports.postgres6);\n    diagnostic_channel_1.channel.registerMonkeyPatch(\"pg\", exports.postgres7);\n}\nexports.enable = enable;\n//# sourceMappingURL=pg.pub.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license. See LICENSE file in the project root for details.\nvar diagnostic_channel_1 = require(\"diagnostic-channel\");\nvar redisPatchFunction = function (originalRedis) {\n    var originalSend = originalRedis.RedisClient.prototype.internal_send_command;\n    // Note: This is mixing together both context tracking and dependency tracking\n    originalRedis.RedisClient.prototype.internal_send_command = function (commandObj) {\n        if (commandObj) {\n            var cb_1 = commandObj.callback;\n            if (!cb_1 || !cb_1.pubsubBound) {\n                var address_1 = this.address;\n                var startTime_1 = process.hrtime();\n                // Note: augmenting the callback on internal_send_command is correct for context\n                // tracking, but may be too low-level for dependency tracking. There are some 'errors'\n                // which higher levels expect in some cases\n                // However, the only other option is to intercept every individual command.\n                commandObj.callback = diagnostic_channel_1.channel.bindToContext(function (err, result) {\n                    var hrDuration = process.hrtime(startTime_1);\n                    /* tslint:disable-next-line:no-bitwise */\n                    var duration = (hrDuration[0] * 1e3 + hrDuration[1] / 1e6) | 0;\n                    diagnostic_channel_1.channel.publish(\"redis\", { duration: duration, address: address_1, commandObj: commandObj, err: err, result: result });\n                    if (typeof cb_1 === \"function\") {\n                        cb_1.apply(this, arguments);\n                    }\n                });\n                commandObj.callback.pubsubBound = true;\n            }\n        }\n        return originalSend.call(this, commandObj);\n    };\n    return originalRedis;\n};\nexports.redis = {\n    versionSpecifier: \">= 2.0.0 < 3.0.0\",\n    patch: redisPatchFunction,\n};\nfunction enable() {\n    diagnostic_channel_1.channel.registerMonkeyPatch(\"redis\", exports.redis);\n}\nexports.enable = enable;\n//# sourceMappingURL=redis.pub.js.map","\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __rest = (this && this.__rest) || function (s, e) {\n    var t = {};\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\n        t[p] = s[p];\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0)\n            t[p[i]] = s[p[i]];\n    return t;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license. See LICENSE file in the project root for details.\nvar diagnostic_channel_1 = require(\"diagnostic-channel\");\n// register a \"filter\" with each logger that publishes the data about to be logged\nvar winston2PatchFunction = function (originalWinston) {\n    var originalLog = originalWinston.Logger.prototype.log;\n    var curLevels;\n    var loggingFilter = function (level, message, meta) {\n        var levelKind;\n        if (curLevels === originalWinston.config.npm.levels) {\n            levelKind = \"npm\";\n        }\n        else if (curLevels === originalWinston.config.syslog.levels) {\n            levelKind = \"syslog\";\n        }\n        else {\n            levelKind = \"unknown\";\n        }\n        diagnostic_channel_1.channel.publish(\"winston\", { level: level, message: message, meta: meta, levelKind: levelKind });\n        return message;\n    };\n    // whenever someone logs, ensure our filter comes last\n    originalWinston.Logger.prototype.log = function log() {\n        curLevels = this.levels;\n        if (!this.filters || this.filters.length === 0) {\n            this.filters = [loggingFilter];\n        }\n        else if (this.filters[this.filters.length - 1] !== loggingFilter) {\n            this.filters = this.filters.filter(function (f) { return f !== loggingFilter; });\n            this.filters.push(loggingFilter);\n        }\n        return originalLog.apply(this, arguments);\n    };\n    return originalWinston;\n};\nvar winston3PatchFunction = function (originalWinston) {\n    var mapLevelToKind = function (winston, level) {\n        var levelKind;\n        if (winston.config.npm.levels[level] != null) {\n            levelKind = \"npm\";\n        }\n        else if (winston.config.syslog.levels[level] != null) {\n            levelKind = \"syslog\";\n        }\n        else {\n            levelKind = \"unknown\";\n        }\n        return levelKind;\n    };\n    var AppInsightsTransport = /** @class */ (function (_super) {\n        __extends(AppInsightsTransport, _super);\n        function AppInsightsTransport(winston, opts) {\n            var _this = _super.call(this, opts) || this;\n            _this.winston = winston;\n            return _this;\n        }\n        AppInsightsTransport.prototype.log = function (info, callback) {\n            // tslint:disable-next-line:prefer-const - try to obtain level from Symbol(level) afterwards\n            var message = info.message, level = info.level, meta = info.meta, splat = __rest(info, [\"message\", \"level\", \"meta\"]);\n            level = typeof Symbol[\"for\"] === \"function\" ? info[Symbol[\"for\"](\"level\")] : level; // Symbol(level) is uncolorized, so prefer getting it from here\n            var levelKind = mapLevelToKind(this.winston, level);\n            meta = meta || {}; // Winston _somtimes_ puts metadata inside meta, so start from here\n            for (var key in splat) {\n                if (splat.hasOwnProperty(key)) {\n                    meta[key] = splat[key];\n                }\n            }\n            diagnostic_channel_1.channel.publish(\"winston\", { message: message, level: level, levelKind: levelKind, meta: meta });\n            callback();\n        };\n        return AppInsightsTransport;\n    }(originalWinston.Transport));\n    // Patch this function\n    function patchedConfigure() {\n        // Grab highest sev logging level in case of custom logging levels\n        var levels = arguments[0].levels || originalWinston.config.npm.levels;\n        var lastLevel;\n        for (var level in levels) {\n            if (levels.hasOwnProperty(level)) {\n                lastLevel = lastLevel === undefined || levels[level] > levels[lastLevel] ? level : lastLevel;\n            }\n        }\n        this.add(new AppInsightsTransport(originalWinston, { level: lastLevel }));\n    }\n    var origCreate = originalWinston.createLogger;\n    originalWinston.createLogger = function patchedCreate() {\n        // Grab highest sev logging level in case of custom logging levels\n        var levels = arguments[0].levels || originalWinston.config.npm.levels;\n        var lastLevel;\n        for (var level in levels) {\n            if (levels.hasOwnProperty(level)) {\n                lastLevel = lastLevel === undefined || levels[level] > levels[lastLevel] ? level : lastLevel;\n            }\n        }\n        // Add custom app insights transport to the end\n        // Remark: Configure is not available until after createLogger()\n        // and the Logger prototype is not exported in winston 3.x, so\n        // patch both createLogger and configure. Could also call configure\n        // again after createLogger, but that would cause configure to be called\n        // twice per create.\n        var result = origCreate.apply(this, arguments);\n        result.add(new AppInsightsTransport(originalWinston, { level: lastLevel }));\n        var origConfigure = result.configure;\n        result.configure = function () {\n            origConfigure.apply(this, arguments);\n            patchedConfigure.apply(this, arguments);\n        };\n        return result;\n    };\n    var origRootConfigure = originalWinston.createLogger;\n    originalWinston.configure = function () {\n        origRootConfigure.apply(this, arguments);\n        patchedConfigure.apply(this, arguments);\n    };\n    originalWinston.add(new AppInsightsTransport(originalWinston));\n    return originalWinston;\n};\nexports.winston3 = {\n    versionSpecifier: \"3.x\",\n    patch: winston3PatchFunction,\n};\nexports.winston2 = {\n    versionSpecifier: \"2.x\",\n    patch: winston2PatchFunction,\n};\nfunction enable() {\n    diagnostic_channel_1.channel.registerMonkeyPatch(\"winston\", exports.winston2);\n    diagnostic_channel_1.channel.registerMonkeyPatch(\"winston\", exports.winston3);\n}\nexports.enable = enable;\n//# sourceMappingURL=winston.pub.js.map","\"use strict\";\r\n// Copyright (c) Microsoft Corporation. All rights reserved.\r\n// Licensed under the MIT license. See LICENSE file in the project root for details.\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar patchRequire_1 = require(\"./patchRequire\");\r\nvar patchRequire_2 = require(\"./patchRequire\");\r\nexports.makePatchingRequire = patchRequire_2.makePatchingRequire;\r\nvar trueFilter = function (publishing) { return true; };\r\nvar ContextPreservingEventEmitter = (function () {\r\n    function ContextPreservingEventEmitter() {\r\n        this.version = require(\"./../../package.json\").version; // Allow for future versions to replace things?\r\n        this.subscribers = {};\r\n        this.contextPreservationFunction = function (cb) { return cb; };\r\n        this.knownPatches = {};\r\n        this.currentlyPublishing = false;\r\n    }\r\n    ContextPreservingEventEmitter.prototype.shouldPublish = function (name) {\r\n        var listeners = this.subscribers[name];\r\n        if (listeners) {\r\n            return listeners.some(function (_a) {\r\n                var filter = _a.filter;\r\n                return !filter || filter(false);\r\n            });\r\n        }\r\n        return false;\r\n    };\r\n    ContextPreservingEventEmitter.prototype.publish = function (name, event) {\r\n        if (this.currentlyPublishing) {\r\n            return; // Avoid reentrancy\r\n        }\r\n        var listeners = this.subscribers[name];\r\n        // Note: Listeners called synchronously to preserve context\r\n        if (listeners) {\r\n            var standardEvent_1 = {\r\n                timestamp: Date.now(),\r\n                data: event,\r\n            };\r\n            this.currentlyPublishing = true;\r\n            listeners.forEach(function (_a) {\r\n                var listener = _a.listener, filter = _a.filter;\r\n                try {\r\n                    if (filter && filter(true)) {\r\n                        listener(standardEvent_1);\r\n                    }\r\n                }\r\n                catch (e) {\r\n                    // Subscriber threw an error\r\n                }\r\n            });\r\n            this.currentlyPublishing = false;\r\n        }\r\n    };\r\n    ContextPreservingEventEmitter.prototype.subscribe = function (name, listener, filter) {\r\n        if (filter === void 0) { filter = trueFilter; }\r\n        if (!this.subscribers[name]) {\r\n            this.subscribers[name] = [];\r\n        }\r\n        this.subscribers[name].push({ listener: listener, filter: filter });\r\n    };\r\n    ContextPreservingEventEmitter.prototype.unsubscribe = function (name, listener, filter) {\r\n        if (filter === void 0) { filter = trueFilter; }\r\n        var listeners = this.subscribers[name];\r\n        if (listeners) {\r\n            for (var index = 0; index < listeners.length; ++index) {\r\n                if (listeners[index].listener === listener && listeners[index].filter === filter) {\r\n                    listeners.splice(index, 1);\r\n                    return true;\r\n                }\r\n            }\r\n        }\r\n        return false;\r\n    };\r\n    // Used for tests\r\n    ContextPreservingEventEmitter.prototype.reset = function () {\r\n        var _this = this;\r\n        this.subscribers = {};\r\n        this.contextPreservationFunction = function (cb) { return cb; };\r\n        // Modify the knownPatches object rather than replace, since a reference will be used in the require patcher\r\n        Object.getOwnPropertyNames(this.knownPatches).forEach(function (prop) { return delete _this.knownPatches[prop]; });\r\n    };\r\n    ContextPreservingEventEmitter.prototype.bindToContext = function (cb) {\r\n        return this.contextPreservationFunction(cb);\r\n    };\r\n    ContextPreservingEventEmitter.prototype.addContextPreservation = function (preserver) {\r\n        var previousPreservationStack = this.contextPreservationFunction;\r\n        this.contextPreservationFunction = (function (cb) { return preserver(previousPreservationStack(cb)); });\r\n    };\r\n    ContextPreservingEventEmitter.prototype.registerMonkeyPatch = function (packageName, patcher) {\r\n        if (!this.knownPatches[packageName]) {\r\n            this.knownPatches[packageName] = [];\r\n        }\r\n        this.knownPatches[packageName].push(patcher);\r\n    };\r\n    ContextPreservingEventEmitter.prototype.getPatchesObject = function () {\r\n        return this.knownPatches;\r\n    };\r\n    return ContextPreservingEventEmitter;\r\n}());\r\nif (!global.diagnosticsSource) {\r\n    global.diagnosticsSource = new ContextPreservingEventEmitter();\r\n    // TODO: should this only patch require after at least one monkey patch is registered?\r\n    /* tslint:disable-next-line:no-var-requires */\r\n    var moduleModule = require(\"module\");\r\n    // Note: We pass in the object now before any patches are registered, but the object is passed by reference\r\n    // so any updates made to the object will be visible in the patcher.\r\n    moduleModule.prototype.require = patchRequire_1.makePatchingRequire(global.diagnosticsSource.getPatchesObject());\r\n}\r\nexports.channel = global.diagnosticsSource;\r\n//# sourceMappingURL=channel.js.map","\"use strict\";\r\n// Copyright (c) Microsoft Corporation. All rights reserved.\r\n// Licensed under the MIT license. See LICENSE file in the project root for details.\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar path = require(\"path\");\r\nvar semver = require(\"semver\");\r\n/* tslint:disable-next-line:no-var-requires */\r\nvar moduleModule = require(\"module\");\r\nvar nativeModules = Object.keys(process.binding(\"natives\"));\r\nvar originalRequire = moduleModule.prototype.require;\r\nfunction makePatchingRequire(knownPatches) {\r\n    var patchedModules = {};\r\n    return function patchedRequire(moduleId) {\r\n        var originalModule = originalRequire.apply(this, arguments);\r\n        if (knownPatches[moduleId]) {\r\n            // Fetch the specific path of the module\r\n            var modulePath = moduleModule._resolveFilename(moduleId, this);\r\n            if (patchedModules.hasOwnProperty(modulePath)) {\r\n                // This module has already been patched, no need to reapply\r\n                return patchedModules[modulePath];\r\n            }\r\n            var moduleVersion = void 0;\r\n            if (nativeModules.indexOf(moduleId) < 0) {\r\n                try {\r\n                    moduleVersion = originalRequire.call(this, path.join(moduleId, \"package.json\")).version;\r\n                }\r\n                catch (e) {\r\n                    // This should only happen if moduleId is actually a path rather than a module\r\n                    // This is not a supported scenario\r\n                    return originalModule;\r\n                }\r\n            }\r\n            else {\r\n                // This module is implemented natively so we cannot find a package.json\r\n                // Instead, take the version of node itself\r\n                moduleVersion = process.version.substring(1);\r\n            }\r\n            var prereleaseTagIndex = moduleVersion.indexOf(\"-\");\r\n            if (prereleaseTagIndex >= 0) {\r\n                // We ignore prerelease tags to avoid impossible to fix gaps in support\r\n                // e.g. supporting console in >= 4.0.0 would otherwise not include\r\n                // 8.0.0-pre\r\n                moduleVersion = moduleVersion.substring(0, prereleaseTagIndex);\r\n            }\r\n            var modifiedModule = originalModule;\r\n            for (var _i = 0, _a = knownPatches[moduleId]; _i < _a.length; _i++) {\r\n                var modulePatcher = _a[_i];\r\n                if (semver.satisfies(moduleVersion, modulePatcher.versionSpecifier)) {\r\n                    modifiedModule = modulePatcher.patch(modifiedModule, modulePath);\r\n                }\r\n            }\r\n            return patchedModules[modulePath] = modifiedModule;\r\n        }\r\n        return originalModule;\r\n    };\r\n}\r\nexports.makePatchingRequire = makePatchingRequire;\r\n//# sourceMappingURL=patchRequire.js.map","'use strict';\n\nvar shimmer = require('shimmer');\nvar wrap    = shimmer.wrap;\nvar unwrap  = shimmer.unwrap;\n\n// Default to complaining loudly when things don't go according to plan.\n// dunderscores are boring\nvar SYMBOL = 'wrap@before';\n\n// Sets a property on an object, preserving its enumerability.\n// This function assumes that the property is already writable.\nfunction defineProperty(obj, name, value) {\n  var enumerable = !!obj[name] && obj.propertyIsEnumerable(name);\n  Object.defineProperty(obj, name, {\n    configurable: true,\n    enumerable: enumerable,\n    writable: true,\n    value: value\n  });\n}\n\nfunction _process(self, listeners) {\n  var l = listeners.length;\n  for (var p = 0; p < l; p++) {\n    var listener = listeners[p];\n    // set up the listener so that onEmit can do whatever it needs\n    var before = self[SYMBOL];\n    if (typeof before === 'function') {\n      before(listener);\n    }\n    else if (Array.isArray(before)) {\n      var length = before.length;\n      for (var i = 0; i < length; i++) before[i](listener);\n    }\n  }\n}\n\nfunction _listeners(self, event) {\n  var listeners;\n  listeners = self._events && self._events[event];\n  if (!Array.isArray(listeners)) {\n    if (listeners) {\n      listeners = [listeners];\n    }\n    else {\n      listeners = [];\n    }\n  }\n\n  return listeners;\n}\n\nfunction _findAndProcess(self, event, before) {\n  var after = _listeners(self, event);\n  var unprocessed = after.filter(function(fn) { return before.indexOf(fn) === -1; });\n  if (unprocessed.length > 0) _process(self, unprocessed);\n}\n\nfunction _wrap(unwrapped, visit) {\n  if (!unwrapped) return;\n\n  var wrapped = unwrapped;\n  if (typeof unwrapped === 'function') {\n    wrapped = visit(unwrapped);\n  }\n  else if (Array.isArray(unwrapped)) {\n    wrapped = [];\n    for (var i = 0; i < unwrapped.length; i++) {\n      wrapped[i] = visit(unwrapped[i]);\n    }\n  }\n  return wrapped;\n}\n\nmodule.exports = function wrapEmitter(emitter, onAddListener, onEmit) {\n  if (!emitter || !emitter.on || !emitter.addListener ||\n      !emitter.removeListener || !emitter.emit) {\n    throw new Error(\"can only wrap real EEs\");\n  }\n\n  if (!onAddListener) throw new Error(\"must have function to run on listener addition\");\n  if (!onEmit) throw new Error(\"must have function to wrap listeners when emitting\");\n\n  /* Attach a context to a listener, and make sure that this hook stays\n   * attached to the emitter forevermore.\n   */\n  function adding(on) {\n    return function added(event, listener) {\n      var existing = _listeners(this, event).slice();\n\n      try {\n        var returned = on.call(this, event, listener);\n        _findAndProcess(this, event, existing);\n        return returned;\n      }\n      finally {\n        // old-style streaming overwrites .on and .addListener, so rewrap\n        if (!this.on.__wrapped) wrap(this, 'on', adding);\n        if (!this.addListener.__wrapped) wrap(this, 'addListener', adding);\n      }\n    };\n  }\n\n  function emitting(emit) {\n    return function emitted(event) {\n      if (!this._events || !this._events[event]) return emit.apply(this, arguments);\n\n      var unwrapped = this._events[event];\n\n      /* Ensure that if removeListener gets called, it's working with the\n       * unwrapped listeners.\n       */\n      function remover(removeListener) {\n        return function removed() {\n          this._events[event] = unwrapped;\n          try {\n            return removeListener.apply(this, arguments);\n          }\n          finally {\n            unwrapped = this._events[event];\n            this._events[event] = _wrap(unwrapped, onEmit);\n          }\n        };\n      }\n      wrap(this, 'removeListener', remover);\n\n      try {\n        /* At emit time, ensure that whatever else is going on, removeListener will\n         * still work while at the same time running whatever hooks are necessary to\n         * make sure the listener is run in the correct context.\n         */\n        this._events[event] = _wrap(unwrapped, onEmit);\n        return emit.apply(this, arguments);\n      }\n      finally {\n        /* Ensure that regardless of what happens when preparing and running the\n         * listeners, the status quo ante is restored before continuing.\n         */\n        unwrap(this, 'removeListener');\n        this._events[event] = unwrapped;\n      }\n    };\n  }\n\n  // support multiple onAddListeners\n  if (!emitter[SYMBOL]) {\n    defineProperty(emitter, SYMBOL, onAddListener);\n  }\n  else if (typeof emitter[SYMBOL] === 'function') {\n    defineProperty(emitter, SYMBOL, [emitter[SYMBOL], onAddListener]);\n  }\n  else if (Array.isArray(emitter[SYMBOL])) {\n    emitter[SYMBOL].push(onAddListener);\n  }\n\n  // only wrap the core functions once\n  if (!emitter.__wrapped) {\n    wrap(emitter, 'addListener', adding);\n    wrap(emitter, 'on',          adding);\n    wrap(emitter, 'emit',        emitting);\n\n    defineProperty(emitter, '__unwrap', function () {\n      unwrap(emitter, 'addListener');\n      unwrap(emitter, 'on');\n      unwrap(emitter, 'emit');\n      delete emitter[SYMBOL];\n      delete emitter.__wrapped;\n    });\n    defineProperty(emitter, '__wrapped', true);\n  }\n};\n","exports = module.exports = SemVer\n\nvar debug\n/* istanbul ignore next */\nif (typeof process === 'object' &&\n    process.env &&\n    process.env.NODE_DEBUG &&\n    /\\bsemver\\b/i.test(process.env.NODE_DEBUG)) {\n  debug = function () {\n    var args = Array.prototype.slice.call(arguments, 0)\n    args.unshift('SEMVER')\n    console.log.apply(console, args)\n  }\n} else {\n  debug = function () {}\n}\n\n// Note: this is the semver.org version of the spec that it implements\n// Not necessarily the package version of this code.\nexports.SEMVER_SPEC_VERSION = '2.0.0'\n\nvar MAX_LENGTH = 256\nvar MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER ||\n  /* istanbul ignore next */ 9007199254740991\n\n// Max safe segment length for coercion.\nvar MAX_SAFE_COMPONENT_LENGTH = 16\n\n// The actual regexps go on exports.re\nvar re = exports.re = []\nvar src = exports.src = []\nvar R = 0\n\n// The following Regular Expressions can be used for tokenizing,\n// validating, and parsing SemVer version strings.\n\n// ## Numeric Identifier\n// A single `0`, or a non-zero digit followed by zero or more digits.\n\nvar NUMERICIDENTIFIER = R++\nsrc[NUMERICIDENTIFIER] = '0|[1-9]\\\\d*'\nvar NUMERICIDENTIFIERLOOSE = R++\nsrc[NUMERICIDENTIFIERLOOSE] = '[0-9]+'\n\n// ## Non-numeric Identifier\n// Zero or more digits, followed by a letter or hyphen, and then zero or\n// more letters, digits, or hyphens.\n\nvar NONNUMERICIDENTIFIER = R++\nsrc[NONNUMERICIDENTIFIER] = '\\\\d*[a-zA-Z-][a-zA-Z0-9-]*'\n\n// ## Main Version\n// Three dot-separated numeric identifiers.\n\nvar MAINVERSION = R++\nsrc[MAINVERSION] = '(' + src[NUMERICIDENTIFIER] + ')\\\\.' +\n                   '(' + src[NUMERICIDENTIFIER] + ')\\\\.' +\n                   '(' + src[NUMERICIDENTIFIER] + ')'\n\nvar MAINVERSIONLOOSE = R++\nsrc[MAINVERSIONLOOSE] = '(' + src[NUMERICIDENTIFIERLOOSE] + ')\\\\.' +\n                        '(' + src[NUMERICIDENTIFIERLOOSE] + ')\\\\.' +\n                        '(' + src[NUMERICIDENTIFIERLOOSE] + ')'\n\n// ## Pre-release Version Identifier\n// A numeric identifier, or a non-numeric identifier.\n\nvar PRERELEASEIDENTIFIER = R++\nsrc[PRERELEASEIDENTIFIER] = '(?:' + src[NUMERICIDENTIFIER] +\n                            '|' + src[NONNUMERICIDENTIFIER] + ')'\n\nvar PRERELEASEIDENTIFIERLOOSE = R++\nsrc[PRERELEASEIDENTIFIERLOOSE] = '(?:' + src[NUMERICIDENTIFIERLOOSE] +\n                                 '|' + src[NONNUMERICIDENTIFIER] + ')'\n\n// ## Pre-release Version\n// Hyphen, followed by one or more dot-separated pre-release version\n// identifiers.\n\nvar PRERELEASE = R++\nsrc[PRERELEASE] = '(?:-(' + src[PRERELEASEIDENTIFIER] +\n                  '(?:\\\\.' + src[PRERELEASEIDENTIFIER] + ')*))'\n\nvar PRERELEASELOOSE = R++\nsrc[PRERELEASELOOSE] = '(?:-?(' + src[PRERELEASEIDENTIFIERLOOSE] +\n                       '(?:\\\\.' + src[PRERELEASEIDENTIFIERLOOSE] + ')*))'\n\n// ## Build Metadata Identifier\n// Any combination of digits, letters, or hyphens.\n\nvar BUILDIDENTIFIER = R++\nsrc[BUILDIDENTIFIER] = '[0-9A-Za-z-]+'\n\n// ## Build Metadata\n// Plus sign, followed by one or more period-separated build metadata\n// identifiers.\n\nvar BUILD = R++\nsrc[BUILD] = '(?:\\\\+(' + src[BUILDIDENTIFIER] +\n             '(?:\\\\.' + src[BUILDIDENTIFIER] + ')*))'\n\n// ## Full Version String\n// A main version, followed optionally by a pre-release version and\n// build metadata.\n\n// Note that the only major, minor, patch, and pre-release sections of\n// the version string are capturing groups.  The build metadata is not a\n// capturing group, because it should not ever be used in version\n// comparison.\n\nvar FULL = R++\nvar FULLPLAIN = 'v?' + src[MAINVERSION] +\n                src[PRERELEASE] + '?' +\n                src[BUILD] + '?'\n\nsrc[FULL] = '^' + FULLPLAIN + '$'\n\n// like full, but allows v1.2.3 and =1.2.3, which people do sometimes.\n// also, 1.0.0alpha1 (prerelease without the hyphen) which is pretty\n// common in the npm registry.\nvar LOOSEPLAIN = '[v=\\\\s]*' + src[MAINVERSIONLOOSE] +\n                 src[PRERELEASELOOSE] + '?' +\n                 src[BUILD] + '?'\n\nvar LOOSE = R++\nsrc[LOOSE] = '^' + LOOSEPLAIN + '$'\n\nvar GTLT = R++\nsrc[GTLT] = '((?:<|>)?=?)'\n\n// Something like \"2.*\" or \"1.2.x\".\n// Note that \"x.x\" is a valid xRange identifer, meaning \"any version\"\n// Only the first item is strictly required.\nvar XRANGEIDENTIFIERLOOSE = R++\nsrc[XRANGEIDENTIFIERLOOSE] = src[NUMERICIDENTIFIERLOOSE] + '|x|X|\\\\*'\nvar XRANGEIDENTIFIER = R++\nsrc[XRANGEIDENTIFIER] = src[NUMERICIDENTIFIER] + '|x|X|\\\\*'\n\nvar XRANGEPLAIN = R++\nsrc[XRANGEPLAIN] = '[v=\\\\s]*(' + src[XRANGEIDENTIFIER] + ')' +\n                   '(?:\\\\.(' + src[XRANGEIDENTIFIER] + ')' +\n                   '(?:\\\\.(' + src[XRANGEIDENTIFIER] + ')' +\n                   '(?:' + src[PRERELEASE] + ')?' +\n                   src[BUILD] + '?' +\n                   ')?)?'\n\nvar XRANGEPLAINLOOSE = R++\nsrc[XRANGEPLAINLOOSE] = '[v=\\\\s]*(' + src[XRANGEIDENTIFIERLOOSE] + ')' +\n                        '(?:\\\\.(' + src[XRANGEIDENTIFIERLOOSE] + ')' +\n                        '(?:\\\\.(' + src[XRANGEIDENTIFIERLOOSE] + ')' +\n                        '(?:' + src[PRERELEASELOOSE] + ')?' +\n                        src[BUILD] + '?' +\n                        ')?)?'\n\nvar XRANGE = R++\nsrc[XRANGE] = '^' + src[GTLT] + '\\\\s*' + src[XRANGEPLAIN] + '$'\nvar XRANGELOOSE = R++\nsrc[XRANGELOOSE] = '^' + src[GTLT] + '\\\\s*' + src[XRANGEPLAINLOOSE] + '$'\n\n// Coercion.\n// Extract anything that could conceivably be a part of a valid semver\nvar COERCE = R++\nsrc[COERCE] = '(?:^|[^\\\\d])' +\n              '(\\\\d{1,' + MAX_SAFE_COMPONENT_LENGTH + '})' +\n              '(?:\\\\.(\\\\d{1,' + MAX_SAFE_COMPONENT_LENGTH + '}))?' +\n              '(?:\\\\.(\\\\d{1,' + MAX_SAFE_COMPONENT_LENGTH + '}))?' +\n              '(?:$|[^\\\\d])'\n\n// Tilde ranges.\n// Meaning is \"reasonably at or greater than\"\nvar LONETILDE = R++\nsrc[LONETILDE] = '(?:~>?)'\n\nvar TILDETRIM = R++\nsrc[TILDETRIM] = '(\\\\s*)' + src[LONETILDE] + '\\\\s+'\nre[TILDETRIM] = new RegExp(src[TILDETRIM], 'g')\nvar tildeTrimReplace = '$1~'\n\nvar TILDE = R++\nsrc[TILDE] = '^' + src[LONETILDE] + src[XRANGEPLAIN] + '$'\nvar TILDELOOSE = R++\nsrc[TILDELOOSE] = '^' + src[LONETILDE] + src[XRANGEPLAINLOOSE] + '$'\n\n// Caret ranges.\n// Meaning is \"at least and backwards compatible with\"\nvar LONECARET = R++\nsrc[LONECARET] = '(?:\\\\^)'\n\nvar CARETTRIM = R++\nsrc[CARETTRIM] = '(\\\\s*)' + src[LONECARET] + '\\\\s+'\nre[CARETTRIM] = new RegExp(src[CARETTRIM], 'g')\nvar caretTrimReplace = '$1^'\n\nvar CARET = R++\nsrc[CARET] = '^' + src[LONECARET] + src[XRANGEPLAIN] + '$'\nvar CARETLOOSE = R++\nsrc[CARETLOOSE] = '^' + src[LONECARET] + src[XRANGEPLAINLOOSE] + '$'\n\n// A simple gt/lt/eq thing, or just \"\" to indicate \"any version\"\nvar COMPARATORLOOSE = R++\nsrc[COMPARATORLOOSE] = '^' + src[GTLT] + '\\\\s*(' + LOOSEPLAIN + ')$|^$'\nvar COMPARATOR = R++\nsrc[COMPARATOR] = '^' + src[GTLT] + '\\\\s*(' + FULLPLAIN + ')$|^$'\n\n// An expression to strip any whitespace between the gtlt and the thing\n// it modifies, so that `> 1.2.3` ==> `>1.2.3`\nvar COMPARATORTRIM = R++\nsrc[COMPARATORTRIM] = '(\\\\s*)' + src[GTLT] +\n                      '\\\\s*(' + LOOSEPLAIN + '|' + src[XRANGEPLAIN] + ')'\n\n// this one has to use the /g flag\nre[COMPARATORTRIM] = new RegExp(src[COMPARATORTRIM], 'g')\nvar comparatorTrimReplace = '$1$2$3'\n\n// Something like `1.2.3 - 1.2.4`\n// Note that these all use the loose form, because they'll be\n// checked against either the strict or loose comparator form\n// later.\nvar HYPHENRANGE = R++\nsrc[HYPHENRANGE] = '^\\\\s*(' + src[XRANGEPLAIN] + ')' +\n                   '\\\\s+-\\\\s+' +\n                   '(' + src[XRANGEPLAIN] + ')' +\n                   '\\\\s*$'\n\nvar HYPHENRANGELOOSE = R++\nsrc[HYPHENRANGELOOSE] = '^\\\\s*(' + src[XRANGEPLAINLOOSE] + ')' +\n                        '\\\\s+-\\\\s+' +\n                        '(' + src[XRANGEPLAINLOOSE] + ')' +\n                        '\\\\s*$'\n\n// Star ranges basically just allow anything at all.\nvar STAR = R++\nsrc[STAR] = '(<|>)?=?\\\\s*\\\\*'\n\n// Compile to actual regexp objects.\n// All are flag-free, unless they were created above with a flag.\nfor (var i = 0; i < R; i++) {\n  debug(i, src[i])\n  if (!re[i]) {\n    re[i] = new RegExp(src[i])\n  }\n}\n\nexports.parse = parse\nfunction parse (version, options) {\n  if (!options || typeof options !== 'object') {\n    options = {\n      loose: !!options,\n      includePrerelease: false\n    }\n  }\n\n  if (version instanceof SemVer) {\n    return version\n  }\n\n  if (typeof version !== 'string') {\n    return null\n  }\n\n  if (version.length > MAX_LENGTH) {\n    return null\n  }\n\n  var r = options.loose ? re[LOOSE] : re[FULL]\n  if (!r.test(version)) {\n    return null\n  }\n\n  try {\n    return new SemVer(version, options)\n  } catch (er) {\n    return null\n  }\n}\n\nexports.valid = valid\nfunction valid (version, options) {\n  var v = parse(version, options)\n  return v ? v.version : null\n}\n\nexports.clean = clean\nfunction clean (version, options) {\n  var s = parse(version.trim().replace(/^[=v]+/, ''), options)\n  return s ? s.version : null\n}\n\nexports.SemVer = SemVer\n\nfunction SemVer (version, options) {\n  if (!options || typeof options !== 'object') {\n    options = {\n      loose: !!options,\n      includePrerelease: false\n    }\n  }\n  if (version instanceof SemVer) {\n    if (version.loose === options.loose) {\n      return version\n    } else {\n      version = version.version\n    }\n  } else if (typeof version !== 'string') {\n    throw new TypeError('Invalid Version: ' + version)\n  }\n\n  if (version.length > MAX_LENGTH) {\n    throw new TypeError('version is longer than ' + MAX_LENGTH + ' characters')\n  }\n\n  if (!(this instanceof SemVer)) {\n    return new SemVer(version, options)\n  }\n\n  debug('SemVer', version, options)\n  this.options = options\n  this.loose = !!options.loose\n\n  var m = version.trim().match(options.loose ? re[LOOSE] : re[FULL])\n\n  if (!m) {\n    throw new TypeError('Invalid Version: ' + version)\n  }\n\n  this.raw = version\n\n  // these are actually numbers\n  this.major = +m[1]\n  this.minor = +m[2]\n  this.patch = +m[3]\n\n  if (this.major > MAX_SAFE_INTEGER || this.major < 0) {\n    throw new TypeError('Invalid major version')\n  }\n\n  if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) {\n    throw new TypeError('Invalid minor version')\n  }\n\n  if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) {\n    throw new TypeError('Invalid patch version')\n  }\n\n  // numberify any prerelease numeric ids\n  if (!m[4]) {\n    this.prerelease = []\n  } else {\n    this.prerelease = m[4].split('.').map(function (id) {\n      if (/^[0-9]+$/.test(id)) {\n        var num = +id\n        if (num >= 0 && num < MAX_SAFE_INTEGER) {\n          return num\n        }\n      }\n      return id\n    })\n  }\n\n  this.build = m[5] ? m[5].split('.') : []\n  this.format()\n}\n\nSemVer.prototype.format = function () {\n  this.version = this.major + '.' + this.minor + '.' + this.patch\n  if (this.prerelease.length) {\n    this.version += '-' + this.prerelease.join('.')\n  }\n  return this.version\n}\n\nSemVer.prototype.toString = function () {\n  return this.version\n}\n\nSemVer.prototype.compare = function (other) {\n  debug('SemVer.compare', this.version, this.options, other)\n  if (!(other instanceof SemVer)) {\n    other = new SemVer(other, this.options)\n  }\n\n  return this.compareMain(other) || this.comparePre(other)\n}\n\nSemVer.prototype.compareMain = function (other) {\n  if (!(other instanceof SemVer)) {\n    other = new SemVer(other, this.options)\n  }\n\n  return compareIdentifiers(this.major, other.major) ||\n         compareIdentifiers(this.minor, other.minor) ||\n         compareIdentifiers(this.patch, other.patch)\n}\n\nSemVer.prototype.comparePre = function (other) {\n  if (!(other instanceof SemVer)) {\n    other = new SemVer(other, this.options)\n  }\n\n  // NOT having a prerelease is > having one\n  if (this.prerelease.length && !other.prerelease.length) {\n    return -1\n  } else if (!this.prerelease.length && other.prerelease.length) {\n    return 1\n  } else if (!this.prerelease.length && !other.prerelease.length) {\n    return 0\n  }\n\n  var i = 0\n  do {\n    var a = this.prerelease[i]\n    var b = other.prerelease[i]\n    debug('prerelease compare', i, a, b)\n    if (a === undefined && b === undefined) {\n      return 0\n    } else if (b === undefined) {\n      return 1\n    } else if (a === undefined) {\n      return -1\n    } else if (a === b) {\n      continue\n    } else {\n      return compareIdentifiers(a, b)\n    }\n  } while (++i)\n}\n\n// preminor will bump the version up to the next minor release, and immediately\n// down to pre-release. premajor and prepatch work the same way.\nSemVer.prototype.inc = function (release, identifier) {\n  switch (release) {\n    case 'premajor':\n      this.prerelease.length = 0\n      this.patch = 0\n      this.minor = 0\n      this.major++\n      this.inc('pre', identifier)\n      break\n    case 'preminor':\n      this.prerelease.length = 0\n      this.patch = 0\n      this.minor++\n      this.inc('pre', identifier)\n      break\n    case 'prepatch':\n      // If this is already a prerelease, it will bump to the next version\n      // drop any prereleases that might already exist, since they are not\n      // relevant at this point.\n      this.prerelease.length = 0\n      this.inc('patch', identifier)\n      this.inc('pre', identifier)\n      break\n    // If the input is a non-prerelease version, this acts the same as\n    // prepatch.\n    case 'prerelease':\n      if (this.prerelease.length === 0) {\n        this.inc('patch', identifier)\n      }\n      this.inc('pre', identifier)\n      break\n\n    case 'major':\n      // If this is a pre-major version, bump up to the same major version.\n      // Otherwise increment major.\n      // 1.0.0-5 bumps to 1.0.0\n      // 1.1.0 bumps to 2.0.0\n      if (this.minor !== 0 ||\n          this.patch !== 0 ||\n          this.prerelease.length === 0) {\n        this.major++\n      }\n      this.minor = 0\n      this.patch = 0\n      this.prerelease = []\n      break\n    case 'minor':\n      // If this is a pre-minor version, bump up to the same minor version.\n      // Otherwise increment minor.\n      // 1.2.0-5 bumps to 1.2.0\n      // 1.2.1 bumps to 1.3.0\n      if (this.patch !== 0 || this.prerelease.length === 0) {\n        this.minor++\n      }\n      this.patch = 0\n      this.prerelease = []\n      break\n    case 'patch':\n      // If this is not a pre-release version, it will increment the patch.\n      // If it is a pre-release it will bump up to the same patch version.\n      // 1.2.0-5 patches to 1.2.0\n      // 1.2.0 patches to 1.2.1\n      if (this.prerelease.length === 0) {\n        this.patch++\n      }\n      this.prerelease = []\n      break\n    // This probably shouldn't be used publicly.\n    // 1.0.0 \"pre\" would become 1.0.0-0 which is the wrong direction.\n    case 'pre':\n      if (this.prerelease.length === 0) {\n        this.prerelease = [0]\n      } else {\n        var i = this.prerelease.length\n        while (--i >= 0) {\n          if (typeof this.prerelease[i] === 'number') {\n            this.prerelease[i]++\n            i = -2\n          }\n        }\n        if (i === -1) {\n          // didn't increment anything\n          this.prerelease.push(0)\n        }\n      }\n      if (identifier) {\n        // 1.2.0-beta.1 bumps to 1.2.0-beta.2,\n        // 1.2.0-beta.fooblz or 1.2.0-beta bumps to 1.2.0-beta.0\n        if (this.prerelease[0] === identifier) {\n          if (isNaN(this.prerelease[1])) {\n            this.prerelease = [identifier, 0]\n          }\n        } else {\n          this.prerelease = [identifier, 0]\n        }\n      }\n      break\n\n    default:\n      throw new Error('invalid increment argument: ' + release)\n  }\n  this.format()\n  this.raw = this.version\n  return this\n}\n\nexports.inc = inc\nfunction inc (version, release, loose, identifier) {\n  if (typeof (loose) === 'string') {\n    identifier = loose\n    loose = undefined\n  }\n\n  try {\n    return new SemVer(version, loose).inc(release, identifier).version\n  } catch (er) {\n    return null\n  }\n}\n\nexports.diff = diff\nfunction diff (version1, version2) {\n  if (eq(version1, version2)) {\n    return null\n  } else {\n    var v1 = parse(version1)\n    var v2 = parse(version2)\n    var prefix = ''\n    if (v1.prerelease.length || v2.prerelease.length) {\n      prefix = 'pre'\n      var defaultResult = 'prerelease'\n    }\n    for (var key in v1) {\n      if (key === 'major' || key === 'minor' || key === 'patch') {\n        if (v1[key] !== v2[key]) {\n          return prefix + key\n        }\n      }\n    }\n    return defaultResult // may be undefined\n  }\n}\n\nexports.compareIdentifiers = compareIdentifiers\n\nvar numeric = /^[0-9]+$/\nfunction compareIdentifiers (a, b) {\n  var anum = numeric.test(a)\n  var bnum = numeric.test(b)\n\n  if (anum && bnum) {\n    a = +a\n    b = +b\n  }\n\n  return a === b ? 0\n    : (anum && !bnum) ? -1\n    : (bnum && !anum) ? 1\n    : a < b ? -1\n    : 1\n}\n\nexports.rcompareIdentifiers = rcompareIdentifiers\nfunction rcompareIdentifiers (a, b) {\n  return compareIdentifiers(b, a)\n}\n\nexports.major = major\nfunction major (a, loose) {\n  return new SemVer(a, loose).major\n}\n\nexports.minor = minor\nfunction minor (a, loose) {\n  return new SemVer(a, loose).minor\n}\n\nexports.patch = patch\nfunction patch (a, loose) {\n  return new SemVer(a, loose).patch\n}\n\nexports.compare = compare\nfunction compare (a, b, loose) {\n  return new SemVer(a, loose).compare(new SemVer(b, loose))\n}\n\nexports.compareLoose = compareLoose\nfunction compareLoose (a, b) {\n  return compare(a, b, true)\n}\n\nexports.rcompare = rcompare\nfunction rcompare (a, b, loose) {\n  return compare(b, a, loose)\n}\n\nexports.sort = sort\nfunction sort (list, loose) {\n  return list.sort(function (a, b) {\n    return exports.compare(a, b, loose)\n  })\n}\n\nexports.rsort = rsort\nfunction rsort (list, loose) {\n  return list.sort(function (a, b) {\n    return exports.rcompare(a, b, loose)\n  })\n}\n\nexports.gt = gt\nfunction gt (a, b, loose) {\n  return compare(a, b, loose) > 0\n}\n\nexports.lt = lt\nfunction lt (a, b, loose) {\n  return compare(a, b, loose) < 0\n}\n\nexports.eq = eq\nfunction eq (a, b, loose) {\n  return compare(a, b, loose) === 0\n}\n\nexports.neq = neq\nfunction neq (a, b, loose) {\n  return compare(a, b, loose) !== 0\n}\n\nexports.gte = gte\nfunction gte (a, b, loose) {\n  return compare(a, b, loose) >= 0\n}\n\nexports.lte = lte\nfunction lte (a, b, loose) {\n  return compare(a, b, loose) <= 0\n}\n\nexports.cmp = cmp\nfunction cmp (a, op, b, loose) {\n  switch (op) {\n    case '===':\n      if (typeof a === 'object')\n        a = a.version\n      if (typeof b === 'object')\n        b = b.version\n      return a === b\n\n    case '!==':\n      if (typeof a === 'object')\n        a = a.version\n      if (typeof b === 'object')\n        b = b.version\n      return a !== b\n\n    case '':\n    case '=':\n    case '==':\n      return eq(a, b, loose)\n\n    case '!=':\n      return neq(a, b, loose)\n\n    case '>':\n      return gt(a, b, loose)\n\n    case '>=':\n      return gte(a, b, loose)\n\n    case '<':\n      return lt(a, b, loose)\n\n    case '<=':\n      return lte(a, b, loose)\n\n    default:\n      throw new TypeError('Invalid operator: ' + op)\n  }\n}\n\nexports.Comparator = Comparator\nfunction Comparator (comp, options) {\n  if (!options || typeof options !== 'object') {\n    options = {\n      loose: !!options,\n      includePrerelease: false\n    }\n  }\n\n  if (comp instanceof Comparator) {\n    if (comp.loose === !!options.loose) {\n      return comp\n    } else {\n      comp = comp.value\n    }\n  }\n\n  if (!(this instanceof Comparator)) {\n    return new Comparator(comp, options)\n  }\n\n  debug('comparator', comp, options)\n  this.options = options\n  this.loose = !!options.loose\n  this.parse(comp)\n\n  if (this.semver === ANY) {\n    this.value = ''\n  } else {\n    this.value = this.operator + this.semver.version\n  }\n\n  debug('comp', this)\n}\n\nvar ANY = {}\nComparator.prototype.parse = function (comp) {\n  var r = this.options.loose ? re[COMPARATORLOOSE] : re[COMPARATOR]\n  var m = comp.match(r)\n\n  if (!m) {\n    throw new TypeError('Invalid comparator: ' + comp)\n  }\n\n  this.operator = m[1]\n  if (this.operator === '=') {\n    this.operator = ''\n  }\n\n  // if it literally is just '>' or '' then allow anything.\n  if (!m[2]) {\n    this.semver = ANY\n  } else {\n    this.semver = new SemVer(m[2], this.options.loose)\n  }\n}\n\nComparator.prototype.toString = function () {\n  return this.value\n}\n\nComparator.prototype.test = function (version) {\n  debug('Comparator.test', version, this.options.loose)\n\n  if (this.semver === ANY) {\n    return true\n  }\n\n  if (typeof version === 'string') {\n    version = new SemVer(version, this.options)\n  }\n\n  return cmp(version, this.operator, this.semver, this.options)\n}\n\nComparator.prototype.intersects = function (comp, options) {\n  if (!(comp instanceof Comparator)) {\n    throw new TypeError('a Comparator is required')\n  }\n\n  if (!options || typeof options !== 'object') {\n    options = {\n      loose: !!options,\n      includePrerelease: false\n    }\n  }\n\n  var rangeTmp\n\n  if (this.operator === '') {\n    rangeTmp = new Range(comp.value, options)\n    return satisfies(this.value, rangeTmp, options)\n  } else if (comp.operator === '') {\n    rangeTmp = new Range(this.value, options)\n    return satisfies(comp.semver, rangeTmp, options)\n  }\n\n  var sameDirectionIncreasing =\n    (this.operator === '>=' || this.operator === '>') &&\n    (comp.operator === '>=' || comp.operator === '>')\n  var sameDirectionDecreasing =\n    (this.operator === '<=' || this.operator === '<') &&\n    (comp.operator === '<=' || comp.operator === '<')\n  var sameSemVer = this.semver.version === comp.semver.version\n  var differentDirectionsInclusive =\n    (this.operator === '>=' || this.operator === '<=') &&\n    (comp.operator === '>=' || comp.operator === '<=')\n  var oppositeDirectionsLessThan =\n    cmp(this.semver, '<', comp.semver, options) &&\n    ((this.operator === '>=' || this.operator === '>') &&\n    (comp.operator === '<=' || comp.operator === '<'))\n  var oppositeDirectionsGreaterThan =\n    cmp(this.semver, '>', comp.semver, options) &&\n    ((this.operator === '<=' || this.operator === '<') &&\n    (comp.operator === '>=' || comp.operator === '>'))\n\n  return sameDirectionIncreasing || sameDirectionDecreasing ||\n    (sameSemVer && differentDirectionsInclusive) ||\n    oppositeDirectionsLessThan || oppositeDirectionsGreaterThan\n}\n\nexports.Range = Range\nfunction Range (range, options) {\n  if (!options || typeof options !== 'object') {\n    options = {\n      loose: !!options,\n      includePrerelease: false\n    }\n  }\n\n  if (range instanceof Range) {\n    if (range.loose === !!options.loose &&\n        range.includePrerelease === !!options.includePrerelease) {\n      return range\n    } else {\n      return new Range(range.raw, options)\n    }\n  }\n\n  if (range instanceof Comparator) {\n    return new Range(range.value, options)\n  }\n\n  if (!(this instanceof Range)) {\n    return new Range(range, options)\n  }\n\n  this.options = options\n  this.loose = !!options.loose\n  this.includePrerelease = !!options.includePrerelease\n\n  // First, split based on boolean or ||\n  this.raw = range\n  this.set = range.split(/\\s*\\|\\|\\s*/).map(function (range) {\n    return this.parseRange(range.trim())\n  }, this).filter(function (c) {\n    // throw out any that are not relevant for whatever reason\n    return c.length\n  })\n\n  if (!this.set.length) {\n    throw new TypeError('Invalid SemVer Range: ' + range)\n  }\n\n  this.format()\n}\n\nRange.prototype.format = function () {\n  this.range = this.set.map(function (comps) {\n    return comps.join(' ').trim()\n  }).join('||').trim()\n  return this.range\n}\n\nRange.prototype.toString = function () {\n  return this.range\n}\n\nRange.prototype.parseRange = function (range) {\n  var loose = this.options.loose\n  range = range.trim()\n  // `1.2.3 - 1.2.4` => `>=1.2.3 <=1.2.4`\n  var hr = loose ? re[HYPHENRANGELOOSE] : re[HYPHENRANGE]\n  range = range.replace(hr, hyphenReplace)\n  debug('hyphen replace', range)\n  // `> 1.2.3 < 1.2.5` => `>1.2.3 <1.2.5`\n  range = range.replace(re[COMPARATORTRIM], comparatorTrimReplace)\n  debug('comparator trim', range, re[COMPARATORTRIM])\n\n  // `~ 1.2.3` => `~1.2.3`\n  range = range.replace(re[TILDETRIM], tildeTrimReplace)\n\n  // `^ 1.2.3` => `^1.2.3`\n  range = range.replace(re[CARETTRIM], caretTrimReplace)\n\n  // normalize spaces\n  range = range.split(/\\s+/).join(' ')\n\n  // At this point, the range is completely trimmed and\n  // ready to be split into comparators.\n\n  var compRe = loose ? re[COMPARATORLOOSE] : re[COMPARATOR]\n  var set = range.split(' ').map(function (comp) {\n    return parseComparator(comp, this.options)\n  }, this).join(' ').split(/\\s+/)\n  if (this.options.loose) {\n    // in loose mode, throw out any that are not valid comparators\n    set = set.filter(function (comp) {\n      return !!comp.match(compRe)\n    })\n  }\n  set = set.map(function (comp) {\n    return new Comparator(comp, this.options)\n  }, this)\n\n  return set\n}\n\nRange.prototype.intersects = function (range, options) {\n  if (!(range instanceof Range)) {\n    throw new TypeError('a Range is required')\n  }\n\n  return this.set.some(function (thisComparators) {\n    return thisComparators.every(function (thisComparator) {\n      return range.set.some(function (rangeComparators) {\n        return rangeComparators.every(function (rangeComparator) {\n          return thisComparator.intersects(rangeComparator, options)\n        })\n      })\n    })\n  })\n}\n\n// Mostly just for testing and legacy API reasons\nexports.toComparators = toComparators\nfunction toComparators (range, options) {\n  return new Range(range, options).set.map(function (comp) {\n    return comp.map(function (c) {\n      return c.value\n    }).join(' ').trim().split(' ')\n  })\n}\n\n// comprised of xranges, tildes, stars, and gtlt's at this point.\n// already replaced the hyphen ranges\n// turn into a set of JUST comparators.\nfunction parseComparator (comp, options) {\n  debug('comp', comp, options)\n  comp = replaceCarets(comp, options)\n  debug('caret', comp)\n  comp = replaceTildes(comp, options)\n  debug('tildes', comp)\n  comp = replaceXRanges(comp, options)\n  debug('xrange', comp)\n  comp = replaceStars(comp, options)\n  debug('stars', comp)\n  return comp\n}\n\nfunction isX (id) {\n  return !id || id.toLowerCase() === 'x' || id === '*'\n}\n\n// ~, ~> --> * (any, kinda silly)\n// ~2, ~2.x, ~2.x.x, ~>2, ~>2.x ~>2.x.x --> >=2.0.0 <3.0.0\n// ~2.0, ~2.0.x, ~>2.0, ~>2.0.x --> >=2.0.0 <2.1.0\n// ~1.2, ~1.2.x, ~>1.2, ~>1.2.x --> >=1.2.0 <1.3.0\n// ~1.2.3, ~>1.2.3 --> >=1.2.3 <1.3.0\n// ~1.2.0, ~>1.2.0 --> >=1.2.0 <1.3.0\nfunction replaceTildes (comp, options) {\n  return comp.trim().split(/\\s+/).map(function (comp) {\n    return replaceTilde(comp, options)\n  }).join(' ')\n}\n\nfunction replaceTilde (comp, options) {\n  var r = options.loose ? re[TILDELOOSE] : re[TILDE]\n  return comp.replace(r, function (_, M, m, p, pr) {\n    debug('tilde', comp, _, M, m, p, pr)\n    var ret\n\n    if (isX(M)) {\n      ret = ''\n    } else if (isX(m)) {\n      ret = '>=' + M + '.0.0 <' + (+M + 1) + '.0.0'\n    } else if (isX(p)) {\n      // ~1.2 == >=1.2.0 <1.3.0\n      ret = '>=' + M + '.' + m + '.0 <' + M + '.' + (+m + 1) + '.0'\n    } else if (pr) {\n      debug('replaceTilde pr', pr)\n      ret = '>=' + M + '.' + m + '.' + p + '-' + pr +\n            ' <' + M + '.' + (+m + 1) + '.0'\n    } else {\n      // ~1.2.3 == >=1.2.3 <1.3.0\n      ret = '>=' + M + '.' + m + '.' + p +\n            ' <' + M + '.' + (+m + 1) + '.0'\n    }\n\n    debug('tilde return', ret)\n    return ret\n  })\n}\n\n// ^ --> * (any, kinda silly)\n// ^2, ^2.x, ^2.x.x --> >=2.0.0 <3.0.0\n// ^2.0, ^2.0.x --> >=2.0.0 <3.0.0\n// ^1.2, ^1.2.x --> >=1.2.0 <2.0.0\n// ^1.2.3 --> >=1.2.3 <2.0.0\n// ^1.2.0 --> >=1.2.0 <2.0.0\nfunction replaceCarets (comp, options) {\n  return comp.trim().split(/\\s+/).map(function (comp) {\n    return replaceCaret(comp, options)\n  }).join(' ')\n}\n\nfunction replaceCaret (comp, options) {\n  debug('caret', comp, options)\n  var r = options.loose ? re[CARETLOOSE] : re[CARET]\n  return comp.replace(r, function (_, M, m, p, pr) {\n    debug('caret', comp, _, M, m, p, pr)\n    var ret\n\n    if (isX(M)) {\n      ret = ''\n    } else if (isX(m)) {\n      ret = '>=' + M + '.0.0 <' + (+M + 1) + '.0.0'\n    } else if (isX(p)) {\n      if (M === '0') {\n        ret = '>=' + M + '.' + m + '.0 <' + M + '.' + (+m + 1) + '.0'\n      } else {\n        ret = '>=' + M + '.' + m + '.0 <' + (+M + 1) + '.0.0'\n      }\n    } else if (pr) {\n      debug('replaceCaret pr', pr)\n      if (M === '0') {\n        if (m === '0') {\n          ret = '>=' + M + '.' + m + '.' + p + '-' + pr +\n                ' <' + M + '.' + m + '.' + (+p + 1)\n        } else {\n          ret = '>=' + M + '.' + m + '.' + p + '-' + pr +\n                ' <' + M + '.' + (+m + 1) + '.0'\n        }\n      } else {\n        ret = '>=' + M + '.' + m + '.' + p + '-' + pr +\n              ' <' + (+M + 1) + '.0.0'\n      }\n    } else {\n      debug('no pr')\n      if (M === '0') {\n        if (m === '0') {\n          ret = '>=' + M + '.' + m + '.' + p +\n                ' <' + M + '.' + m + '.' + (+p + 1)\n        } else {\n          ret = '>=' + M + '.' + m + '.' + p +\n                ' <' + M + '.' + (+m + 1) + '.0'\n        }\n      } else {\n        ret = '>=' + M + '.' + m + '.' + p +\n              ' <' + (+M + 1) + '.0.0'\n      }\n    }\n\n    debug('caret return', ret)\n    return ret\n  })\n}\n\nfunction replaceXRanges (comp, options) {\n  debug('replaceXRanges', comp, options)\n  return comp.split(/\\s+/).map(function (comp) {\n    return replaceXRange(comp, options)\n  }).join(' ')\n}\n\nfunction replaceXRange (comp, options) {\n  comp = comp.trim()\n  var r = options.loose ? re[XRANGELOOSE] : re[XRANGE]\n  return comp.replace(r, function (ret, gtlt, M, m, p, pr) {\n    debug('xRange', comp, ret, gtlt, M, m, p, pr)\n    var xM = isX(M)\n    var xm = xM || isX(m)\n    var xp = xm || isX(p)\n    var anyX = xp\n\n    if (gtlt === '=' && anyX) {\n      gtlt = ''\n    }\n\n    if (xM) {\n      if (gtlt === '>' || gtlt === '<') {\n        // nothing is allowed\n        ret = '<0.0.0'\n      } else {\n        // nothing is forbidden\n        ret = '*'\n      }\n    } else if (gtlt && anyX) {\n      // we know patch is an x, because we have any x at all.\n      // replace X with 0\n      if (xm) {\n        m = 0\n      }\n      p = 0\n\n      if (gtlt === '>') {\n        // >1 => >=2.0.0\n        // >1.2 => >=1.3.0\n        // >1.2.3 => >= 1.2.4\n        gtlt = '>='\n        if (xm) {\n          M = +M + 1\n          m = 0\n          p = 0\n        } else {\n          m = +m + 1\n          p = 0\n        }\n      } else if (gtlt === '<=') {\n        // <=0.7.x is actually <0.8.0, since any 0.7.x should\n        // pass.  Similarly, <=7.x is actually <8.0.0, etc.\n        gtlt = '<'\n        if (xm) {\n          M = +M + 1\n        } else {\n          m = +m + 1\n        }\n      }\n\n      ret = gtlt + M + '.' + m + '.' + p\n    } else if (xm) {\n      ret = '>=' + M + '.0.0 <' + (+M + 1) + '.0.0'\n    } else if (xp) {\n      ret = '>=' + M + '.' + m + '.0 <' + M + '.' + (+m + 1) + '.0'\n    }\n\n    debug('xRange return', ret)\n\n    return ret\n  })\n}\n\n// Because * is AND-ed with everything else in the comparator,\n// and '' means \"any version\", just remove the *s entirely.\nfunction replaceStars (comp, options) {\n  debug('replaceStars', comp, options)\n  // Looseness is ignored here.  star is always as loose as it gets!\n  return comp.trim().replace(re[STAR], '')\n}\n\n// This function is passed to string.replace(re[HYPHENRANGE])\n// M, m, patch, prerelease, build\n// 1.2 - 3.4.5 => >=1.2.0 <=3.4.5\n// 1.2.3 - 3.4 => >=1.2.0 <3.5.0 Any 3.4.x will do\n// 1.2 - 3.4 => >=1.2.0 <3.5.0\nfunction hyphenReplace ($0,\n  from, fM, fm, fp, fpr, fb,\n  to, tM, tm, tp, tpr, tb) {\n  if (isX(fM)) {\n    from = ''\n  } else if (isX(fm)) {\n    from = '>=' + fM + '.0.0'\n  } else if (isX(fp)) {\n    from = '>=' + fM + '.' + fm + '.0'\n  } else {\n    from = '>=' + from\n  }\n\n  if (isX(tM)) {\n    to = ''\n  } else if (isX(tm)) {\n    to = '<' + (+tM + 1) + '.0.0'\n  } else if (isX(tp)) {\n    to = '<' + tM + '.' + (+tm + 1) + '.0'\n  } else if (tpr) {\n    to = '<=' + tM + '.' + tm + '.' + tp + '-' + tpr\n  } else {\n    to = '<=' + to\n  }\n\n  return (from + ' ' + to).trim()\n}\n\n// if ANY of the sets match ALL of its comparators, then pass\nRange.prototype.test = function (version) {\n  if (!version) {\n    return false\n  }\n\n  if (typeof version === 'string') {\n    version = new SemVer(version, this.options)\n  }\n\n  for (var i = 0; i < this.set.length; i++) {\n    if (testSet(this.set[i], version, this.options)) {\n      return true\n    }\n  }\n  return false\n}\n\nfunction testSet (set, version, options) {\n  for (var i = 0; i < set.length; i++) {\n    if (!set[i].test(version)) {\n      return false\n    }\n  }\n\n  if (version.prerelease.length && !options.includePrerelease) {\n    // Find the set of versions that are allowed to have prereleases\n    // For example, ^1.2.3-pr.1 desugars to >=1.2.3-pr.1 <2.0.0\n    // That should allow `1.2.3-pr.2` to pass.\n    // However, `1.2.4-alpha.notready` should NOT be allowed,\n    // even though it's within the range set by the comparators.\n    for (i = 0; i < set.length; i++) {\n      debug(set[i].semver)\n      if (set[i].semver === ANY) {\n        continue\n      }\n\n      if (set[i].semver.prerelease.length > 0) {\n        var allowed = set[i].semver\n        if (allowed.major === version.major &&\n            allowed.minor === version.minor &&\n            allowed.patch === version.patch) {\n          return true\n        }\n      }\n    }\n\n    // Version has a -pre, but it's not one of the ones we like.\n    return false\n  }\n\n  return true\n}\n\nexports.satisfies = satisfies\nfunction satisfies (version, range, options) {\n  try {\n    range = new Range(range, options)\n  } catch (er) {\n    return false\n  }\n  return range.test(version)\n}\n\nexports.maxSatisfying = maxSatisfying\nfunction maxSatisfying (versions, range, options) {\n  var max = null\n  var maxSV = null\n  try {\n    var rangeObj = new Range(range, options)\n  } catch (er) {\n    return null\n  }\n  versions.forEach(function (v) {\n    if (rangeObj.test(v)) {\n      // satisfies(v, range, options)\n      if (!max || maxSV.compare(v) === -1) {\n        // compare(max, v, true)\n        max = v\n        maxSV = new SemVer(max, options)\n      }\n    }\n  })\n  return max\n}\n\nexports.minSatisfying = minSatisfying\nfunction minSatisfying (versions, range, options) {\n  var min = null\n  var minSV = null\n  try {\n    var rangeObj = new Range(range, options)\n  } catch (er) {\n    return null\n  }\n  versions.forEach(function (v) {\n    if (rangeObj.test(v)) {\n      // satisfies(v, range, options)\n      if (!min || minSV.compare(v) === 1) {\n        // compare(min, v, true)\n        min = v\n        minSV = new SemVer(min, options)\n      }\n    }\n  })\n  return min\n}\n\nexports.minVersion = minVersion\nfunction minVersion (range, loose) {\n  range = new Range(range, loose)\n\n  var minver = new SemVer('0.0.0')\n  if (range.test(minver)) {\n    return minver\n  }\n\n  minver = new SemVer('0.0.0-0')\n  if (range.test(minver)) {\n    return minver\n  }\n\n  minver = null\n  for (var i = 0; i < range.set.length; ++i) {\n    var comparators = range.set[i]\n\n    comparators.forEach(function (comparator) {\n      // Clone to avoid manipulating the comparator's semver object.\n      var compver = new SemVer(comparator.semver.version)\n      switch (comparator.operator) {\n        case '>':\n          if (compver.prerelease.length === 0) {\n            compver.patch++\n          } else {\n            compver.prerelease.push(0)\n          }\n          compver.raw = compver.format()\n          /* fallthrough */\n        case '':\n        case '>=':\n          if (!minver || gt(minver, compver)) {\n            minver = compver\n          }\n          break\n        case '<':\n        case '<=':\n          /* Ignore maximum versions */\n          break\n        /* istanbul ignore next */\n        default:\n          throw new Error('Unexpected operation: ' + comparator.operator)\n      }\n    })\n  }\n\n  if (minver && range.test(minver)) {\n    return minver\n  }\n\n  return null\n}\n\nexports.validRange = validRange\nfunction validRange (range, options) {\n  try {\n    // Return '*' instead of '' so that truthiness works.\n    // This will throw if it's invalid anyway\n    return new Range(range, options).range || '*'\n  } catch (er) {\n    return null\n  }\n}\n\n// Determine if version is less than all the versions possible in the range\nexports.ltr = ltr\nfunction ltr (version, range, options) {\n  return outside(version, range, '<', options)\n}\n\n// Determine if version is greater than all the versions possible in the range.\nexports.gtr = gtr\nfunction gtr (version, range, options) {\n  return outside(version, range, '>', options)\n}\n\nexports.outside = outside\nfunction outside (version, range, hilo, options) {\n  version = new SemVer(version, options)\n  range = new Range(range, options)\n\n  var gtfn, ltefn, ltfn, comp, ecomp\n  switch (hilo) {\n    case '>':\n      gtfn = gt\n      ltefn = lte\n      ltfn = lt\n      comp = '>'\n      ecomp = '>='\n      break\n    case '<':\n      gtfn = lt\n      ltefn = gte\n      ltfn = gt\n      comp = '<'\n      ecomp = '<='\n      break\n    default:\n      throw new TypeError('Must provide a hilo val of \"<\" or \">\"')\n  }\n\n  // If it satisifes the range it is not outside\n  if (satisfies(version, range, options)) {\n    return false\n  }\n\n  // From now on, variable terms are as if we're in \"gtr\" mode.\n  // but note that everything is flipped for the \"ltr\" function.\n\n  for (var i = 0; i < range.set.length; ++i) {\n    var comparators = range.set[i]\n\n    var high = null\n    var low = null\n\n    comparators.forEach(function (comparator) {\n      if (comparator.semver === ANY) {\n        comparator = new Comparator('>=0.0.0')\n      }\n      high = high || comparator\n      low = low || comparator\n      if (gtfn(comparator.semver, high.semver, options)) {\n        high = comparator\n      } else if (ltfn(comparator.semver, low.semver, options)) {\n        low = comparator\n      }\n    })\n\n    // If the edge version comparator has a operator then our version\n    // isn't outside it\n    if (high.operator === comp || high.operator === ecomp) {\n      return false\n    }\n\n    // If the lowest version comparator has an operator and our version\n    // is less than it then it isn't higher than the range\n    if ((!low.operator || low.operator === comp) &&\n        ltefn(version, low.semver)) {\n      return false\n    } else if (low.operator === ecomp && ltfn(version, low.semver)) {\n      return false\n    }\n  }\n  return true\n}\n\nexports.prerelease = prerelease\nfunction prerelease (version, options) {\n  var parsed = parse(version, options)\n  return (parsed && parsed.prerelease.length) ? parsed.prerelease : null\n}\n\nexports.intersects = intersects\nfunction intersects (r1, r2, options) {\n  r1 = new Range(r1, options)\n  r2 = new Range(r2, options)\n  return r1.intersects(r2)\n}\n\nexports.coerce = coerce\nfunction coerce (version) {\n  if (version instanceof SemVer) {\n    return version\n  }\n\n  if (typeof version !== 'string') {\n    return null\n  }\n\n  var match = version.match(re[COERCE])\n\n  if (match == null) {\n    return null\n  }\n\n  return parse(match[1] +\n    '.' + (match[2] || '0') +\n    '.' + (match[3] || '0'))\n}\n","'use strict'\n\nfunction isFunction (funktion) {\n  return typeof funktion === 'function'\n}\n\n// Default to complaining loudly when things don't go according to plan.\nvar logger = console.error.bind(console)\n\n// Sets a property on an object, preserving its enumerability.\n// This function assumes that the property is already writable.\nfunction defineProperty (obj, name, value) {\n  var enumerable = !!obj[name] && obj.propertyIsEnumerable(name)\n  Object.defineProperty(obj, name, {\n    configurable: true,\n    enumerable: enumerable,\n    writable: true,\n    value: value\n  })\n}\n\n// Keep initialization idempotent.\nfunction shimmer (options) {\n  if (options && options.logger) {\n    if (!isFunction(options.logger)) logger(\"new logger isn't a function, not replacing\")\n    else logger = options.logger\n  }\n}\n\nfunction wrap (nodule, name, wrapper) {\n  if (!nodule || !nodule[name]) {\n    logger('no original function ' + name + ' to wrap')\n    return\n  }\n\n  if (!wrapper) {\n    logger('no wrapper function')\n    logger((new Error()).stack)\n    return\n  }\n\n  if (!isFunction(nodule[name]) || !isFunction(wrapper)) {\n    logger('original object and wrapper must be functions')\n    return\n  }\n\n  var original = nodule[name]\n  var wrapped = wrapper(original, name)\n\n  defineProperty(wrapped, '__original', original)\n  defineProperty(wrapped, '__unwrap', function () {\n    if (nodule[name] === wrapped) defineProperty(nodule, name, original)\n  })\n  defineProperty(wrapped, '__wrapped', true)\n\n  defineProperty(nodule, name, wrapped)\n  return wrapped\n}\n\nfunction massWrap (nodules, names, wrapper) {\n  if (!nodules) {\n    logger('must provide one or more modules to patch')\n    logger((new Error()).stack)\n    return\n  } else if (!Array.isArray(nodules)) {\n    nodules = [nodules]\n  }\n\n  if (!(names && Array.isArray(names))) {\n    logger('must provide one or more functions to wrap on modules')\n    return\n  }\n\n  nodules.forEach(function (nodule) {\n    names.forEach(function (name) {\n      wrap(nodule, name, wrapper)\n    })\n  })\n}\n\nfunction unwrap (nodule, name) {\n  if (!nodule || !nodule[name]) {\n    logger('no function to unwrap.')\n    logger((new Error()).stack)\n    return\n  }\n\n  if (!nodule[name].__unwrap) {\n    logger('no original to unwrap to -- has ' + name + ' already been unwrapped?')\n  } else {\n    return nodule[name].__unwrap()\n  }\n}\n\nfunction massUnwrap (nodules, names) {\n  if (!nodules) {\n    logger('must provide one or more modules to patch')\n    logger((new Error()).stack)\n    return\n  } else if (!Array.isArray(nodules)) {\n    nodules = [nodules]\n  }\n\n  if (!(names && Array.isArray(names))) {\n    logger('must provide one or more functions to unwrap on modules')\n    return\n  }\n\n  nodules.forEach(function (nodule) {\n    names.forEach(function (name) {\n      unwrap(nodule, name)\n    })\n  })\n}\n\nshimmer.wrap = wrap\nshimmer.massWrap = massWrap\nshimmer.unwrap = unwrap\nshimmer.massUnwrap = massUnwrap\n\nmodule.exports = shimmer\n","// Copyright 2012 the V8 project authors. All rights reserved.\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are\n// met:\n//\n//     * Redistributions of source code must retain the above copyright\n//       notice, this list of conditions and the following disclaimer.\n//     * Redistributions in binary form must reproduce the above\n//       copyright notice, this list of conditions and the following\n//       disclaimer in the documentation and/or other materials provided\n//       with the distribution.\n//     * Neither the name of Google Inc. nor the names of its\n//       contributors may be used to endorse or promote products derived\n//       from this software without specific prior written permission.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n// \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\nfunction FormatErrorString(error) {\n  try {\n    return Error.prototype.toString.call(error);\n  } catch (e) {\n    try {\n      return \"<error: \" + e + \">\";\n    } catch (ee) {\n      return \"<error>\";\n    }\n  }\n}\n\nmodule.exports = function FormatStackTrace(error, frames) {\n  var lines = [];\n  lines.push(FormatErrorString(error));\n  for (var i = 0; i < frames.length; i++) {\n    var frame = frames[i];\n    var line;\n    try {\n      line = frame.toString();\n    } catch (e) {\n      try {\n        line = \"<error: \" + e + \">\";\n      } catch (ee) {\n        // Any code that reaches this point is seriously nasty!\n        line = \"<error>\";\n      }\n    }\n    lines.push(\"    at \" + line);\n  }\n  return lines.join(\"\\n\");\n};\n","// If a another copy (same version or not) of stack-chain exists it will result\n// in wrong stack traces (most likely dublicate callSites).\nif (global._stackChain) {\n  // In case the version match, we can simply return the first initialized copy\n  if (global._stackChain.version === require('./package.json').version) {\n    module.exports = global._stackChain;\n  }\n  // The version don't match, this is really bad. Lets just throw\n  else {\n    throw new Error('Conflicting version of stack-chain found');\n  }\n}\n// Yay, no other stack-chain copy exists, yet :/\nelse {\n  module.exports = global._stackChain = require('./stack-chain');\n}\n","\n// use a already existing formater or fallback to the default v8 formater\nvar defaultFormater = require('./format.js');\n\n// public define API\nfunction stackChain() {\n  this.extend = new TraceModifier();\n  this.filter = new TraceModifier();\n  this.format = new StackFormater();\n  this.version = require('./package.json').version;\n}\n\n\nvar SHORTCIRCUIT_CALLSITE = false;\nstackChain.prototype.callSite = function collectCallSites(options) {\n  if (!options) options = {};\n\n  // Get CallSites\n  SHORTCIRCUIT_CALLSITE = true;\n  var obj = {};\n  Error.captureStackTrace(obj, collectCallSites);\n  var callSites = obj.stack;\n  SHORTCIRCUIT_CALLSITE = false;\n\n  // Slice\n  callSites = callSites.slice(options.slice || 0);\n\n  // Modify CallSites\n  if (options.extend) callSites = this.extend._modify(obj, callSites);\n  if (options.filter) callSites = this.filter._modify(obj, callSites);\n\n  // Done\n  return callSites;\n};\n\nvar chain = new stackChain();\n\nfunction TraceModifier() {\n  this._modifiers = [];\n}\n\nTraceModifier.prototype._modify = function (error, frames) {\n  for (var i = 0, l = this._modifiers.length; i < l; i++) {\n    frames = this._modifiers[i](error, frames);\n  }\n\n  return frames;\n};\n\nTraceModifier.prototype.attach = function (modifier) {\n  this._modifiers.push(modifier);\n};\n\nTraceModifier.prototype.deattach = function (modifier) {\n  var index = this._modifiers.indexOf(modifier);\n\n  if (index === -1) return false;\n\n  this._modifiers.splice(index, 1);\n  return true;\n};\n\nfunction StackFormater() {\n  this._formater = defaultFormater;\n  this._previous = undefined;\n}\n\nStackFormater.prototype.replace = function (formater) {\n  if (formater) {\n    this._formater = formater;\n  } else {\n    this.restore();\n  }\n};\n\nStackFormater.prototype.restore  = function () {\n  this._formater = defaultFormater;\n  this._previous = undefined;\n};\n\nStackFormater.prototype._backup = function () {\n  this._previous = this._formater;\n};\n\nStackFormater.prototype._roolback = function () {\n  if (this._previous === defaultFormater) {\n    this.replace(undefined);\n  } else {\n    this.replace(this._previous);\n  }\n\n  this._previous = undefined;\n};\n\n\n//\n// Set Error.prepareStackTrace thus allowing stack-chain\n// to take control of the Error().stack formating.\n//\n\n// If there already is a custom stack formater, then set\n// that as the stack-chain formater.\nif (Error.prepareStackTrace) {\n    chain.format.replace(Error.prepareStackTrace);\n}\n\nvar SHORTCIRCUIT_FORMATER = false;\nfunction prepareStackTrace(error, originalFrames) {\n  if (SHORTCIRCUIT_CALLSITE) return originalFrames;\n  if (SHORTCIRCUIT_FORMATER) return defaultFormater(error, originalFrames);\n\n  // Make a loss copy of originalFrames\n  var frames = originalFrames.concat();\n\n  // extend frames\n  frames = chain.extend._modify(error, frames);\n\n  // filter frames\n  frames = chain.filter._modify(error, frames);\n\n  // reduce frames to match Error.stackTraceLimit\n  frames = frames.slice(0, Error.stackTraceLimit);\n\n  // Set the callSite property\n  // But only if it hasn't been explicitly set, otherwise\n  // error.stack would have unintended side effects. Check also for\n  // non-extensible/sealed objects, such as those from Google's Closure Library\n  if (Object.isExtensible(error) &&\n      (Object.getOwnPropertyDescriptor(error, \"callSite\") === undefined)) {\n    error.callSite = {\n      original: originalFrames,\n      mutated: frames\n    };\n  }\n\n  // format frames\n  SHORTCIRCUIT_FORMATER = true;\n  var format = chain.format._formater(error, frames);\n  SHORTCIRCUIT_FORMATER = false;\n\n  return format;\n}\n\n// Replace the v8 stack trace creator\nObject.defineProperty(Error, 'prepareStackTrace', {\n  'get': function () {\n    return prepareStackTrace;\n  },\n\n  'set': function (formater) {\n    // If formater is prepareStackTrace it means that someone ran\n    // var old = Error.prepareStackTrace;\n    // Error.prepareStackTrace = custom\n    // new Error().stack\n    // Error.prepareStackTrace = old;\n    // The effect of this, should be that the old behaviour is restored.\n    if (formater === prepareStackTrace) {\n      chain.format._roolback();\n    }\n    // Error.prepareStackTrace was set, this means that someone is\n    // trying to take control of the Error().stack format. Make\n    // them belive they succeeded by setting them up as the stack-chain\n    // formater.\n    else {\n      chain.format._backup();\n      chain.format.replace(formater);\n    }\n  }\n});\n\n//\n// Manage call site storeage\n//\nfunction callSiteGetter() {\n  // calculate call site object\n  this.stack;\n\n  // return call site object\n  return this.callSite;\n}\n\nObject.defineProperty(Error.prototype, 'callSite', {\n  'get': callSiteGetter,\n\n  'set': function (frames) {\n    // In case callSite was set before [[getter]], just set\n    // the value\n    Object.defineProperty(this, 'callSite', {\n        value: frames,\n        writable: true,\n        configurable: true\n    });\n  },\n\n  configurable: true\n});\n\nmodule.exports = chain;\n","'use strict';\n\nconst WebSocket = require('./lib/websocket');\n\nWebSocket.createWebSocketStream = require('./lib/stream');\nWebSocket.Server = require('./lib/websocket-server');\nWebSocket.Receiver = require('./lib/receiver');\nWebSocket.Sender = require('./lib/sender');\n\nmodule.exports = WebSocket;\n","'use strict';\n\nconst { EMPTY_BUFFER } = require('./constants');\n\n/**\n * Merges an array of buffers into a new buffer.\n *\n * @param {Buffer[]} list The array of buffers to concat\n * @param {Number} totalLength The total length of buffers in the list\n * @return {Buffer} The resulting buffer\n * @public\n */\nfunction concat(list, totalLength) {\n  if (list.length === 0) return EMPTY_BUFFER;\n  if (list.length === 1) return list[0];\n\n  const target = Buffer.allocUnsafe(totalLength);\n  let offset = 0;\n\n  for (let i = 0; i < list.length; i++) {\n    const buf = list[i];\n    target.set(buf, offset);\n    offset += buf.length;\n  }\n\n  if (offset < totalLength) return target.slice(0, offset);\n\n  return target;\n}\n\n/**\n * Masks a buffer using the given mask.\n *\n * @param {Buffer} source The buffer to mask\n * @param {Buffer} mask The mask to use\n * @param {Buffer} output The buffer where to store the result\n * @param {Number} offset The offset at which to start writing\n * @param {Number} length The number of bytes to mask.\n * @public\n */\nfunction _mask(source, mask, output, offset, length) {\n  for (let i = 0; i < length; i++) {\n    output[offset + i] = source[i] ^ mask[i & 3];\n  }\n}\n\n/**\n * Unmasks a buffer using the given mask.\n *\n * @param {Buffer} buffer The buffer to unmask\n * @param {Buffer} mask The mask to use\n * @public\n */\nfunction _unmask(buffer, mask) {\n  // Required until https://github.com/nodejs/node/issues/9006 is resolved.\n  const length = buffer.length;\n  for (let i = 0; i < length; i++) {\n    buffer[i] ^= mask[i & 3];\n  }\n}\n\n/**\n * Converts a buffer to an `ArrayBuffer`.\n *\n * @param {Buffer} buf The buffer to convert\n * @return {ArrayBuffer} Converted buffer\n * @public\n */\nfunction toArrayBuffer(buf) {\n  if (buf.byteLength === buf.buffer.byteLength) {\n    return buf.buffer;\n  }\n\n  return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength);\n}\n\n/**\n * Converts `data` to a `Buffer`.\n *\n * @param {*} data The data to convert\n * @return {Buffer} The buffer\n * @throws {TypeError}\n * @public\n */\nfunction toBuffer(data) {\n  toBuffer.readOnly = true;\n\n  if (Buffer.isBuffer(data)) return data;\n\n  let buf;\n\n  if (data instanceof ArrayBuffer) {\n    buf = Buffer.from(data);\n  } else if (ArrayBuffer.isView(data)) {\n    buf = viewToBuffer(data);\n  } else {\n    buf = Buffer.from(data);\n    toBuffer.readOnly = false;\n  }\n\n  return buf;\n}\n\n/**\n * Converts an `ArrayBuffer` view into a buffer.\n *\n * @param {(DataView|TypedArray)} view The view to convert\n * @return {Buffer} Converted view\n * @private\n */\nfunction viewToBuffer(view) {\n  const buf = Buffer.from(view.buffer);\n\n  if (view.byteLength !== view.buffer.byteLength) {\n    return buf.slice(view.byteOffset, view.byteOffset + view.byteLength);\n  }\n\n  return buf;\n}\n\ntry {\n  const bufferUtil = require('bufferutil');\n  const bu = bufferUtil.BufferUtil || bufferUtil;\n\n  module.exports = {\n    concat,\n    mask(source, mask, output, offset, length) {\n      if (length < 48) _mask(source, mask, output, offset, length);\n      else bu.mask(source, mask, output, offset, length);\n    },\n    toArrayBuffer,\n    toBuffer,\n    unmask(buffer, mask) {\n      if (buffer.length < 32) _unmask(buffer, mask);\n      else bu.unmask(buffer, mask);\n    }\n  };\n} catch (e) /* istanbul ignore next */ {\n  module.exports = {\n    concat,\n    mask: _mask,\n    toArrayBuffer,\n    toBuffer,\n    unmask: _unmask\n  };\n}\n","'use strict';\n\nmodule.exports = {\n  BINARY_TYPES: ['nodebuffer', 'arraybuffer', 'fragments'],\n  GUID: '258EAFA5-E914-47DA-95CA-C5AB0DC85B11',\n  kStatusCode: Symbol('status-code'),\n  kWebSocket: Symbol('websocket'),\n  EMPTY_BUFFER: Buffer.alloc(0),\n  NOOP: () => {}\n};\n","'use strict';\n\n/**\n * Class representing an event.\n *\n * @private\n */\nclass Event {\n  /**\n   * Create a new `Event`.\n   *\n   * @param {String} type The name of the event\n   * @param {Object} target A reference to the target to which the event was dispatched\n   */\n  constructor(type, target) {\n    this.target = target;\n    this.type = type;\n  }\n}\n\n/**\n * Class representing a message event.\n *\n * @extends Event\n * @private\n */\nclass MessageEvent extends Event {\n  /**\n   * Create a new `MessageEvent`.\n   *\n   * @param {(String|Buffer|ArrayBuffer|Buffer[])} data The received data\n   * @param {WebSocket} target A reference to the target to which the event was dispatched\n   */\n  constructor(data, target) {\n    super('message', target);\n\n    this.data = data;\n  }\n}\n\n/**\n * Class representing a close event.\n *\n * @extends Event\n * @private\n */\nclass CloseEvent extends Event {\n  /**\n   * Create a new `CloseEvent`.\n   *\n   * @param {Number} code The status code explaining why the connection is being closed\n   * @param {String} reason A human-readable string explaining why the connection is closing\n   * @param {WebSocket} target A reference to the target to which the event was dispatched\n   */\n  constructor(code, reason, target) {\n    super('close', target);\n\n    this.wasClean = target._closeFrameReceived && target._closeFrameSent;\n    this.reason = reason;\n    this.code = code;\n  }\n}\n\n/**\n * Class representing an open event.\n *\n * @extends Event\n * @private\n */\nclass OpenEvent extends Event {\n  /**\n   * Create a new `OpenEvent`.\n   *\n   * @param {WebSocket} target A reference to the target to which the event was dispatched\n   */\n  constructor(target) {\n    super('open', target);\n  }\n}\n\n/**\n * Class representing an error event.\n *\n * @extends Event\n * @private\n */\nclass ErrorEvent extends Event {\n  /**\n   * Create a new `ErrorEvent`.\n   *\n   * @param {Object} error The error that generated this event\n   * @param {WebSocket} target A reference to the target to which the event was dispatched\n   */\n  constructor(error, target) {\n    super('error', target);\n\n    this.message = error.message;\n    this.error = error;\n  }\n}\n\n/**\n * This provides methods for emulating the `EventTarget` interface. It's not\n * meant to be used directly.\n *\n * @mixin\n */\nconst EventTarget = {\n  /**\n   * Register an event listener.\n   *\n   * @param {String} method A string representing the event type to listen for\n   * @param {Function} listener The listener to add\n   * @public\n   */\n  addEventListener(method, listener) {\n    if (typeof listener !== 'function') return;\n\n    function onMessage(data) {\n      listener.call(this, new MessageEvent(data, this));\n    }\n\n    function onClose(code, message) {\n      listener.call(this, new CloseEvent(code, message, this));\n    }\n\n    function onError(error) {\n      listener.call(this, new ErrorEvent(error, this));\n    }\n\n    function onOpen() {\n      listener.call(this, new OpenEvent(this));\n    }\n\n    if (method === 'message') {\n      onMessage._listener = listener;\n      this.on(method, onMessage);\n    } else if (method === 'close') {\n      onClose._listener = listener;\n      this.on(method, onClose);\n    } else if (method === 'error') {\n      onError._listener = listener;\n      this.on(method, onError);\n    } else if (method === 'open') {\n      onOpen._listener = listener;\n      this.on(method, onOpen);\n    } else {\n      this.on(method, listener);\n    }\n  },\n\n  /**\n   * Remove an event listener.\n   *\n   * @param {String} method A string representing the event type to remove\n   * @param {Function} listener The listener to remove\n   * @public\n   */\n  removeEventListener(method, listener) {\n    const listeners = this.listeners(method);\n\n    for (let i = 0; i < listeners.length; i++) {\n      if (listeners[i] === listener || listeners[i]._listener === listener) {\n        this.removeListener(method, listeners[i]);\n      }\n    }\n  }\n};\n\nmodule.exports = EventTarget;\n","'use strict';\n\n//\n// Allowed token characters:\n//\n// '!', '#', '$', '%', '&', ''', '*', '+', '-',\n// '.', 0-9, A-Z, '^', '_', '`', a-z, '|', '~'\n//\n// tokenChars[32] === 0 // ' '\n// tokenChars[33] === 1 // '!'\n// tokenChars[34] === 0 // '\"'\n// ...\n//\n// prettier-ignore\nconst tokenChars = [\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, // 0 - 15\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, // 16 - 31\n  0, 1, 0, 1, 1, 1, 1, 1, 0, 0, 1, 1, 0, 1, 1, 0, // 32 - 47\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, // 48 - 63\n  0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, // 64 - 79\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, // 80 - 95\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, // 96 - 111\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0 // 112 - 127\n];\n\n/**\n * Adds an offer to the map of extension offers or a parameter to the map of\n * parameters.\n *\n * @param {Object} dest The map of extension offers or parameters\n * @param {String} name The extension or parameter name\n * @param {(Object|Boolean|String)} elem The extension parameters or the\n *     parameter value\n * @private\n */\nfunction push(dest, name, elem) {\n  if (dest[name] === undefined) dest[name] = [elem];\n  else dest[name].push(elem);\n}\n\n/**\n * Parses the `Sec-WebSocket-Extensions` header into an object.\n *\n * @param {String} header The field value of the header\n * @return {Object} The parsed object\n * @public\n */\nfunction parse(header) {\n  const offers = Object.create(null);\n\n  if (header === undefined || header === '') return offers;\n\n  let params = Object.create(null);\n  let mustUnescape = false;\n  let isEscaping = false;\n  let inQuotes = false;\n  let extensionName;\n  let paramName;\n  let start = -1;\n  let end = -1;\n  let i = 0;\n\n  for (; i < header.length; i++) {\n    const code = header.charCodeAt(i);\n\n    if (extensionName === undefined) {\n      if (end === -1 && tokenChars[code] === 1) {\n        if (start === -1) start = i;\n      } else if (code === 0x20 /* ' ' */ || code === 0x09 /* '\\t' */) {\n        if (end === -1 && start !== -1) end = i;\n      } else if (code === 0x3b /* ';' */ || code === 0x2c /* ',' */) {\n        if (start === -1) {\n          throw new SyntaxError(`Unexpected character at index ${i}`);\n        }\n\n        if (end === -1) end = i;\n        const name = header.slice(start, end);\n        if (code === 0x2c) {\n          push(offers, name, params);\n          params = Object.create(null);\n        } else {\n          extensionName = name;\n        }\n\n        start = end = -1;\n      } else {\n        throw new SyntaxError(`Unexpected character at index ${i}`);\n      }\n    } else if (paramName === undefined) {\n      if (end === -1 && tokenChars[code] === 1) {\n        if (start === -1) start = i;\n      } else if (code === 0x20 || code === 0x09) {\n        if (end === -1 && start !== -1) end = i;\n      } else if (code === 0x3b || code === 0x2c) {\n        if (start === -1) {\n          throw new SyntaxError(`Unexpected character at index ${i}`);\n        }\n\n        if (end === -1) end = i;\n        push(params, header.slice(start, end), true);\n        if (code === 0x2c) {\n          push(offers, extensionName, params);\n          params = Object.create(null);\n          extensionName = undefined;\n        }\n\n        start = end = -1;\n      } else if (code === 0x3d /* '=' */ && start !== -1 && end === -1) {\n        paramName = header.slice(start, i);\n        start = end = -1;\n      } else {\n        throw new SyntaxError(`Unexpected character at index ${i}`);\n      }\n    } else {\n      //\n      // The value of a quoted-string after unescaping must conform to the\n      // token ABNF, so only token characters are valid.\n      // Ref: https://tools.ietf.org/html/rfc6455#section-9.1\n      //\n      if (isEscaping) {\n        if (tokenChars[code] !== 1) {\n          throw new SyntaxError(`Unexpected character at index ${i}`);\n        }\n        if (start === -1) start = i;\n        else if (!mustUnescape) mustUnescape = true;\n        isEscaping = false;\n      } else if (inQuotes) {\n        if (tokenChars[code] === 1) {\n          if (start === -1) start = i;\n        } else if (code === 0x22 /* '\"' */ && start !== -1) {\n          inQuotes = false;\n          end = i;\n        } else if (code === 0x5c /* '\\' */) {\n          isEscaping = true;\n        } else {\n          throw new SyntaxError(`Unexpected character at index ${i}`);\n        }\n      } else if (code === 0x22 && header.charCodeAt(i - 1) === 0x3d) {\n        inQuotes = true;\n      } else if (end === -1 && tokenChars[code] === 1) {\n        if (start === -1) start = i;\n      } else if (start !== -1 && (code === 0x20 || code === 0x09)) {\n        if (end === -1) end = i;\n      } else if (code === 0x3b || code === 0x2c) {\n        if (start === -1) {\n          throw new SyntaxError(`Unexpected character at index ${i}`);\n        }\n\n        if (end === -1) end = i;\n        let value = header.slice(start, end);\n        if (mustUnescape) {\n          value = value.replace(/\\\\/g, '');\n          mustUnescape = false;\n        }\n        push(params, paramName, value);\n        if (code === 0x2c) {\n          push(offers, extensionName, params);\n          params = Object.create(null);\n          extensionName = undefined;\n        }\n\n        paramName = undefined;\n        start = end = -1;\n      } else {\n        throw new SyntaxError(`Unexpected character at index ${i}`);\n      }\n    }\n  }\n\n  if (start === -1 || inQuotes) {\n    throw new SyntaxError('Unexpected end of input');\n  }\n\n  if (end === -1) end = i;\n  const token = header.slice(start, end);\n  if (extensionName === undefined) {\n    push(offers, token, params);\n  } else {\n    if (paramName === undefined) {\n      push(params, token, true);\n    } else if (mustUnescape) {\n      push(params, paramName, token.replace(/\\\\/g, ''));\n    } else {\n      push(params, paramName, token);\n    }\n    push(offers, extensionName, params);\n  }\n\n  return offers;\n}\n\n/**\n * Builds the `Sec-WebSocket-Extensions` header field value.\n *\n * @param {Object} extensions The map of extensions and parameters to format\n * @return {String} A string representing the given object\n * @public\n */\nfunction format(extensions) {\n  return Object.keys(extensions)\n    .map((extension) => {\n      let configurations = extensions[extension];\n      if (!Array.isArray(configurations)) configurations = [configurations];\n      return configurations\n        .map((params) => {\n          return [extension]\n            .concat(\n              Object.keys(params).map((k) => {\n                let values = params[k];\n                if (!Array.isArray(values)) values = [values];\n                return values\n                  .map((v) => (v === true ? k : `${k}=${v}`))\n                  .join('; ');\n              })\n            )\n            .join('; ');\n        })\n        .join(', ');\n    })\n    .join(', ');\n}\n\nmodule.exports = { format, parse };\n","'use strict';\n\nconst kDone = Symbol('kDone');\nconst kRun = Symbol('kRun');\n\n/**\n * A very simple job queue with adjustable concurrency. Adapted from\n * https://github.com/STRML/async-limiter\n */\nclass Limiter {\n  /**\n   * Creates a new `Limiter`.\n   *\n   * @param {Number} concurrency The maximum number of jobs allowed to run\n   *     concurrently\n   */\n  constructor(concurrency) {\n    this[kDone] = () => {\n      this.pending--;\n      this[kRun]();\n    };\n    this.concurrency = concurrency || Infinity;\n    this.jobs = [];\n    this.pending = 0;\n  }\n\n  /**\n   * Adds a job to the queue.\n   *\n   * @public\n   */\n  add(job) {\n    this.jobs.push(job);\n    this[kRun]();\n  }\n\n  /**\n   * Removes a job from the queue and runs it if possible.\n   *\n   * @private\n   */\n  [kRun]() {\n    if (this.pending === this.concurrency) return;\n\n    if (this.jobs.length) {\n      const job = this.jobs.shift();\n\n      this.pending++;\n      job(this[kDone]);\n    }\n  }\n}\n\nmodule.exports = Limiter;\n","'use strict';\n\nconst zlib = require('zlib');\n\nconst bufferUtil = require('./buffer-util');\nconst Limiter = require('./limiter');\nconst { kStatusCode, NOOP } = require('./constants');\n\nconst TRAILER = Buffer.from([0x00, 0x00, 0xff, 0xff]);\nconst kPerMessageDeflate = Symbol('permessage-deflate');\nconst kTotalLength = Symbol('total-length');\nconst kCallback = Symbol('callback');\nconst kBuffers = Symbol('buffers');\nconst kError = Symbol('error');\n\n//\n// We limit zlib concurrency, which prevents severe memory fragmentation\n// as documented in https://github.com/nodejs/node/issues/8871#issuecomment-250915913\n// and https://github.com/websockets/ws/issues/1202\n//\n// Intentionally global; it's the global thread pool that's an issue.\n//\nlet zlibLimiter;\n\n/**\n * permessage-deflate implementation.\n */\nclass PerMessageDeflate {\n  /**\n   * Creates a PerMessageDeflate instance.\n   *\n   * @param {Object} options Configuration options\n   * @param {Boolean} options.serverNoContextTakeover Request/accept disabling\n   *     of server context takeover\n   * @param {Boolean} options.clientNoContextTakeover Advertise/acknowledge\n   *     disabling of client context takeover\n   * @param {(Boolean|Number)} options.serverMaxWindowBits Request/confirm the\n   *     use of a custom server window size\n   * @param {(Boolean|Number)} options.clientMaxWindowBits Advertise support\n   *     for, or request, a custom client window size\n   * @param {Object} options.zlibDeflateOptions Options to pass to zlib on deflate\n   * @param {Object} options.zlibInflateOptions Options to pass to zlib on inflate\n   * @param {Number} options.threshold Size (in bytes) below which messages\n   *     should not be compressed\n   * @param {Number} options.concurrencyLimit The number of concurrent calls to\n   *     zlib\n   * @param {Boolean} isServer Create the instance in either server or client\n   *     mode\n   * @param {Number} maxPayload The maximum allowed message length\n   */\n  constructor(options, isServer, maxPayload) {\n    this._maxPayload = maxPayload | 0;\n    this._options = options || {};\n    this._threshold =\n      this._options.threshold !== undefined ? this._options.threshold : 1024;\n    this._isServer = !!isServer;\n    this._deflate = null;\n    this._inflate = null;\n\n    this.params = null;\n\n    if (!zlibLimiter) {\n      const concurrency =\n        this._options.concurrencyLimit !== undefined\n          ? this._options.concurrencyLimit\n          : 10;\n      zlibLimiter = new Limiter(concurrency);\n    }\n  }\n\n  /**\n   * @type {String}\n   */\n  static get extensionName() {\n    return 'permessage-deflate';\n  }\n\n  /**\n   * Create an extension negotiation offer.\n   *\n   * @return {Object} Extension parameters\n   * @public\n   */\n  offer() {\n    const params = {};\n\n    if (this._options.serverNoContextTakeover) {\n      params.server_no_context_takeover = true;\n    }\n    if (this._options.clientNoContextTakeover) {\n      params.client_no_context_takeover = true;\n    }\n    if (this._options.serverMaxWindowBits) {\n      params.server_max_window_bits = this._options.serverMaxWindowBits;\n    }\n    if (this._options.clientMaxWindowBits) {\n      params.client_max_window_bits = this._options.clientMaxWindowBits;\n    } else if (this._options.clientMaxWindowBits == null) {\n      params.client_max_window_bits = true;\n    }\n\n    return params;\n  }\n\n  /**\n   * Accept an extension negotiation offer/response.\n   *\n   * @param {Array} configurations The extension negotiation offers/reponse\n   * @return {Object} Accepted configuration\n   * @public\n   */\n  accept(configurations) {\n    configurations = this.normalizeParams(configurations);\n\n    this.params = this._isServer\n      ? this.acceptAsServer(configurations)\n      : this.acceptAsClient(configurations);\n\n    return this.params;\n  }\n\n  /**\n   * Releases all resources used by the extension.\n   *\n   * @public\n   */\n  cleanup() {\n    if (this._inflate) {\n      this._inflate.close();\n      this._inflate = null;\n    }\n\n    if (this._deflate) {\n      if (this._deflate[kCallback]) {\n        this._deflate[kCallback]();\n      }\n\n      this._deflate.close();\n      this._deflate = null;\n    }\n  }\n\n  /**\n   *  Accept an extension negotiation offer.\n   *\n   * @param {Array} offers The extension negotiation offers\n   * @return {Object} Accepted configuration\n   * @private\n   */\n  acceptAsServer(offers) {\n    const opts = this._options;\n    const accepted = offers.find((params) => {\n      if (\n        (opts.serverNoContextTakeover === false &&\n          params.server_no_context_takeover) ||\n        (params.server_max_window_bits &&\n          (opts.serverMaxWindowBits === false ||\n            (typeof opts.serverMaxWindowBits === 'number' &&\n              opts.serverMaxWindowBits > params.server_max_window_bits))) ||\n        (typeof opts.clientMaxWindowBits === 'number' &&\n          !params.client_max_window_bits)\n      ) {\n        return false;\n      }\n\n      return true;\n    });\n\n    if (!accepted) {\n      throw new Error('None of the extension offers can be accepted');\n    }\n\n    if (opts.serverNoContextTakeover) {\n      accepted.server_no_context_takeover = true;\n    }\n    if (opts.clientNoContextTakeover) {\n      accepted.client_no_context_takeover = true;\n    }\n    if (typeof opts.serverMaxWindowBits === 'number') {\n      accepted.server_max_window_bits = opts.serverMaxWindowBits;\n    }\n    if (typeof opts.clientMaxWindowBits === 'number') {\n      accepted.client_max_window_bits = opts.clientMaxWindowBits;\n    } else if (\n      accepted.client_max_window_bits === true ||\n      opts.clientMaxWindowBits === false\n    ) {\n      delete accepted.client_max_window_bits;\n    }\n\n    return accepted;\n  }\n\n  /**\n   * Accept the extension negotiation response.\n   *\n   * @param {Array} response The extension negotiation response\n   * @return {Object} Accepted configuration\n   * @private\n   */\n  acceptAsClient(response) {\n    const params = response[0];\n\n    if (\n      this._options.clientNoContextTakeover === false &&\n      params.client_no_context_takeover\n    ) {\n      throw new Error('Unexpected parameter \"client_no_context_takeover\"');\n    }\n\n    if (!params.client_max_window_bits) {\n      if (typeof this._options.clientMaxWindowBits === 'number') {\n        params.client_max_window_bits = this._options.clientMaxWindowBits;\n      }\n    } else if (\n      this._options.clientMaxWindowBits === false ||\n      (typeof this._options.clientMaxWindowBits === 'number' &&\n        params.client_max_window_bits > this._options.clientMaxWindowBits)\n    ) {\n      throw new Error(\n        'Unexpected or invalid parameter \"client_max_window_bits\"'\n      );\n    }\n\n    return params;\n  }\n\n  /**\n   * Normalize parameters.\n   *\n   * @param {Array} configurations The extension negotiation offers/reponse\n   * @return {Array} The offers/response with normalized parameters\n   * @private\n   */\n  normalizeParams(configurations) {\n    configurations.forEach((params) => {\n      Object.keys(params).forEach((key) => {\n        let value = params[key];\n\n        if (value.length > 1) {\n          throw new Error(`Parameter \"${key}\" must have only a single value`);\n        }\n\n        value = value[0];\n\n        if (key === 'client_max_window_bits') {\n          if (value !== true) {\n            const num = +value;\n            if (!Number.isInteger(num) || num < 8 || num > 15) {\n              throw new TypeError(\n                `Invalid value for parameter \"${key}\": ${value}`\n              );\n            }\n            value = num;\n          } else if (!this._isServer) {\n            throw new TypeError(\n              `Invalid value for parameter \"${key}\": ${value}`\n            );\n          }\n        } else if (key === 'server_max_window_bits') {\n          const num = +value;\n          if (!Number.isInteger(num) || num < 8 || num > 15) {\n            throw new TypeError(\n              `Invalid value for parameter \"${key}\": ${value}`\n            );\n          }\n          value = num;\n        } else if (\n          key === 'client_no_context_takeover' ||\n          key === 'server_no_context_takeover'\n        ) {\n          if (value !== true) {\n            throw new TypeError(\n              `Invalid value for parameter \"${key}\": ${value}`\n            );\n          }\n        } else {\n          throw new Error(`Unknown parameter \"${key}\"`);\n        }\n\n        params[key] = value;\n      });\n    });\n\n    return configurations;\n  }\n\n  /**\n   * Decompress data. Concurrency limited.\n   *\n   * @param {Buffer} data Compressed data\n   * @param {Boolean} fin Specifies whether or not this is the last fragment\n   * @param {Function} callback Callback\n   * @public\n   */\n  decompress(data, fin, callback) {\n    zlibLimiter.add((done) => {\n      this._decompress(data, fin, (err, result) => {\n        done();\n        callback(err, result);\n      });\n    });\n  }\n\n  /**\n   * Compress data. Concurrency limited.\n   *\n   * @param {Buffer} data Data to compress\n   * @param {Boolean} fin Specifies whether or not this is the last fragment\n   * @param {Function} callback Callback\n   * @public\n   */\n  compress(data, fin, callback) {\n    zlibLimiter.add((done) => {\n      this._compress(data, fin, (err, result) => {\n        done();\n        if (err || result) {\n          callback(err, result);\n        }\n      });\n    });\n  }\n\n  /**\n   * Decompress data.\n   *\n   * @param {Buffer} data Compressed data\n   * @param {Boolean} fin Specifies whether or not this is the last fragment\n   * @param {Function} callback Callback\n   * @private\n   */\n  _decompress(data, fin, callback) {\n    const endpoint = this._isServer ? 'client' : 'server';\n\n    if (!this._inflate) {\n      const key = `${endpoint}_max_window_bits`;\n      const windowBits =\n        typeof this.params[key] !== 'number'\n          ? zlib.Z_DEFAULT_WINDOWBITS\n          : this.params[key];\n\n      this._inflate = zlib.createInflateRaw({\n        ...this._options.zlibInflateOptions,\n        windowBits\n      });\n      this._inflate[kPerMessageDeflate] = this;\n      this._inflate[kTotalLength] = 0;\n      this._inflate[kBuffers] = [];\n      this._inflate.on('error', inflateOnError);\n      this._inflate.on('data', inflateOnData);\n    }\n\n    this._inflate[kCallback] = callback;\n\n    this._inflate.write(data);\n    if (fin) this._inflate.write(TRAILER);\n\n    this._inflate.flush(() => {\n      const err = this._inflate[kError];\n\n      if (err) {\n        this._inflate.close();\n        this._inflate = null;\n        callback(err);\n        return;\n      }\n\n      const data = bufferUtil.concat(\n        this._inflate[kBuffers],\n        this._inflate[kTotalLength]\n      );\n\n      if (fin && this.params[`${endpoint}_no_context_takeover`]) {\n        this._inflate.close();\n        this._inflate = null;\n      } else {\n        this._inflate[kTotalLength] = 0;\n        this._inflate[kBuffers] = [];\n      }\n\n      callback(null, data);\n    });\n  }\n\n  /**\n   * Compress data.\n   *\n   * @param {Buffer} data Data to compress\n   * @param {Boolean} fin Specifies whether or not this is the last fragment\n   * @param {Function} callback Callback\n   * @private\n   */\n  _compress(data, fin, callback) {\n    const endpoint = this._isServer ? 'server' : 'client';\n\n    if (!this._deflate) {\n      const key = `${endpoint}_max_window_bits`;\n      const windowBits =\n        typeof this.params[key] !== 'number'\n          ? zlib.Z_DEFAULT_WINDOWBITS\n          : this.params[key];\n\n      this._deflate = zlib.createDeflateRaw({\n        ...this._options.zlibDeflateOptions,\n        windowBits\n      });\n\n      this._deflate[kTotalLength] = 0;\n      this._deflate[kBuffers] = [];\n\n      //\n      // An `'error'` event is emitted, only on Node.js < 10.0.0, if the\n      // `zlib.DeflateRaw` instance is closed while data is being processed.\n      // This can happen if `PerMessageDeflate#cleanup()` is called at the wrong\n      // time due to an abnormal WebSocket closure.\n      //\n      this._deflate.on('error', NOOP);\n      this._deflate.on('data', deflateOnData);\n    }\n\n    this._deflate[kCallback] = callback;\n\n    this._deflate.write(data);\n    this._deflate.flush(zlib.Z_SYNC_FLUSH, () => {\n      if (!this._deflate) {\n        //\n        // This `if` statement is only needed for Node.js < 10.0.0 because as of\n        // commit https://github.com/nodejs/node/commit/5e3f5164, the flush\n        // callback is no longer called if the deflate stream is closed while\n        // data is being processed.\n        //\n        return;\n      }\n\n      let data = bufferUtil.concat(\n        this._deflate[kBuffers],\n        this._deflate[kTotalLength]\n      );\n\n      if (fin) data = data.slice(0, data.length - 4);\n\n      //\n      // Ensure that the callback will not be called again in\n      // `PerMessageDeflate#cleanup()`.\n      //\n      this._deflate[kCallback] = null;\n\n      if (fin && this.params[`${endpoint}_no_context_takeover`]) {\n        this._deflate.close();\n        this._deflate = null;\n      } else {\n        this._deflate[kTotalLength] = 0;\n        this._deflate[kBuffers] = [];\n      }\n\n      callback(null, data);\n    });\n  }\n}\n\nmodule.exports = PerMessageDeflate;\n\n/**\n * The listener of the `zlib.DeflateRaw` stream `'data'` event.\n *\n * @param {Buffer} chunk A chunk of data\n * @private\n */\nfunction deflateOnData(chunk) {\n  this[kBuffers].push(chunk);\n  this[kTotalLength] += chunk.length;\n}\n\n/**\n * The listener of the `zlib.InflateRaw` stream `'data'` event.\n *\n * @param {Buffer} chunk A chunk of data\n * @private\n */\nfunction inflateOnData(chunk) {\n  this[kTotalLength] += chunk.length;\n\n  if (\n    this[kPerMessageDeflate]._maxPayload < 1 ||\n    this[kTotalLength] <= this[kPerMessageDeflate]._maxPayload\n  ) {\n    this[kBuffers].push(chunk);\n    return;\n  }\n\n  this[kError] = new RangeError('Max payload size exceeded');\n  this[kError][kStatusCode] = 1009;\n  this.removeListener('data', inflateOnData);\n  this.reset();\n}\n\n/**\n * The listener of the `zlib.InflateRaw` stream `'error'` event.\n *\n * @param {Error} err The emitted error\n * @private\n */\nfunction inflateOnError(err) {\n  //\n  // There is no need to call `Zlib#close()` as the handle is automatically\n  // closed when an error is emitted.\n  //\n  this[kPerMessageDeflate]._inflate = null;\n  err[kStatusCode] = 1007;\n  this[kCallback](err);\n}\n","'use strict';\n\nconst { Writable } = require('stream');\n\nconst PerMessageDeflate = require('./permessage-deflate');\nconst {\n  BINARY_TYPES,\n  EMPTY_BUFFER,\n  kStatusCode,\n  kWebSocket\n} = require('./constants');\nconst { concat, toArrayBuffer, unmask } = require('./buffer-util');\nconst { isValidStatusCode, isValidUTF8 } = require('./validation');\n\nconst GET_INFO = 0;\nconst GET_PAYLOAD_LENGTH_16 = 1;\nconst GET_PAYLOAD_LENGTH_64 = 2;\nconst GET_MASK = 3;\nconst GET_DATA = 4;\nconst INFLATING = 5;\n\n/**\n * HyBi Receiver implementation.\n *\n * @extends stream.Writable\n */\nclass Receiver extends Writable {\n  /**\n   * Creates a Receiver instance.\n   *\n   * @param {String} binaryType The type for binary data\n   * @param {Object} extensions An object containing the negotiated extensions\n   * @param {Number} maxPayload The maximum allowed message length\n   */\n  constructor(binaryType, extensions, maxPayload) {\n    super();\n\n    this._binaryType = binaryType || BINARY_TYPES[0];\n    this[kWebSocket] = undefined;\n    this._extensions = extensions || {};\n    this._maxPayload = maxPayload | 0;\n\n    this._bufferedBytes = 0;\n    this._buffers = [];\n\n    this._compressed = false;\n    this._payloadLength = 0;\n    this._mask = undefined;\n    this._fragmented = 0;\n    this._masked = false;\n    this._fin = false;\n    this._opcode = 0;\n\n    this._totalPayloadLength = 0;\n    this._messageLength = 0;\n    this._fragments = [];\n\n    this._state = GET_INFO;\n    this._loop = false;\n  }\n\n  /**\n   * Implements `Writable.prototype._write()`.\n   *\n   * @param {Buffer} chunk The chunk of data to write\n   * @param {String} encoding The character encoding of `chunk`\n   * @param {Function} cb Callback\n   */\n  _write(chunk, encoding, cb) {\n    if (this._opcode === 0x08 && this._state == GET_INFO) return cb();\n\n    this._bufferedBytes += chunk.length;\n    this._buffers.push(chunk);\n    this.startLoop(cb);\n  }\n\n  /**\n   * Consumes `n` bytes from the buffered data.\n   *\n   * @param {Number} n The number of bytes to consume\n   * @return {Buffer} The consumed bytes\n   * @private\n   */\n  consume(n) {\n    this._bufferedBytes -= n;\n\n    if (n === this._buffers[0].length) return this._buffers.shift();\n\n    if (n < this._buffers[0].length) {\n      const buf = this._buffers[0];\n      this._buffers[0] = buf.slice(n);\n      return buf.slice(0, n);\n    }\n\n    const dst = Buffer.allocUnsafe(n);\n\n    do {\n      const buf = this._buffers[0];\n      const offset = dst.length - n;\n\n      if (n >= buf.length) {\n        dst.set(this._buffers.shift(), offset);\n      } else {\n        dst.set(new Uint8Array(buf.buffer, buf.byteOffset, n), offset);\n        this._buffers[0] = buf.slice(n);\n      }\n\n      n -= buf.length;\n    } while (n > 0);\n\n    return dst;\n  }\n\n  /**\n   * Starts the parsing loop.\n   *\n   * @param {Function} cb Callback\n   * @private\n   */\n  startLoop(cb) {\n    let err;\n    this._loop = true;\n\n    do {\n      switch (this._state) {\n        case GET_INFO:\n          err = this.getInfo();\n          break;\n        case GET_PAYLOAD_LENGTH_16:\n          err = this.getPayloadLength16();\n          break;\n        case GET_PAYLOAD_LENGTH_64:\n          err = this.getPayloadLength64();\n          break;\n        case GET_MASK:\n          this.getMask();\n          break;\n        case GET_DATA:\n          err = this.getData(cb);\n          break;\n        default:\n          // `INFLATING`\n          this._loop = false;\n          return;\n      }\n    } while (this._loop);\n\n    cb(err);\n  }\n\n  /**\n   * Reads the first two bytes of a frame.\n   *\n   * @return {(RangeError|undefined)} A possible error\n   * @private\n   */\n  getInfo() {\n    if (this._bufferedBytes < 2) {\n      this._loop = false;\n      return;\n    }\n\n    const buf = this.consume(2);\n\n    if ((buf[0] & 0x30) !== 0x00) {\n      this._loop = false;\n      return error(RangeError, 'RSV2 and RSV3 must be clear', true, 1002);\n    }\n\n    const compressed = (buf[0] & 0x40) === 0x40;\n\n    if (compressed && !this._extensions[PerMessageDeflate.extensionName]) {\n      this._loop = false;\n      return error(RangeError, 'RSV1 must be clear', true, 1002);\n    }\n\n    this._fin = (buf[0] & 0x80) === 0x80;\n    this._opcode = buf[0] & 0x0f;\n    this._payloadLength = buf[1] & 0x7f;\n\n    if (this._opcode === 0x00) {\n      if (compressed) {\n        this._loop = false;\n        return error(RangeError, 'RSV1 must be clear', true, 1002);\n      }\n\n      if (!this._fragmented) {\n        this._loop = false;\n        return error(RangeError, 'invalid opcode 0', true, 1002);\n      }\n\n      this._opcode = this._fragmented;\n    } else if (this._opcode === 0x01 || this._opcode === 0x02) {\n      if (this._fragmented) {\n        this._loop = false;\n        return error(RangeError, `invalid opcode ${this._opcode}`, true, 1002);\n      }\n\n      this._compressed = compressed;\n    } else if (this._opcode > 0x07 && this._opcode < 0x0b) {\n      if (!this._fin) {\n        this._loop = false;\n        return error(RangeError, 'FIN must be set', true, 1002);\n      }\n\n      if (compressed) {\n        this._loop = false;\n        return error(RangeError, 'RSV1 must be clear', true, 1002);\n      }\n\n      if (this._payloadLength > 0x7d) {\n        this._loop = false;\n        return error(\n          RangeError,\n          `invalid payload length ${this._payloadLength}`,\n          true,\n          1002\n        );\n      }\n    } else {\n      this._loop = false;\n      return error(RangeError, `invalid opcode ${this._opcode}`, true, 1002);\n    }\n\n    if (!this._fin && !this._fragmented) this._fragmented = this._opcode;\n    this._masked = (buf[1] & 0x80) === 0x80;\n\n    if (this._payloadLength === 126) this._state = GET_PAYLOAD_LENGTH_16;\n    else if (this._payloadLength === 127) this._state = GET_PAYLOAD_LENGTH_64;\n    else return this.haveLength();\n  }\n\n  /**\n   * Gets extended payload length (7+16).\n   *\n   * @return {(RangeError|undefined)} A possible error\n   * @private\n   */\n  getPayloadLength16() {\n    if (this._bufferedBytes < 2) {\n      this._loop = false;\n      return;\n    }\n\n    this._payloadLength = this.consume(2).readUInt16BE(0);\n    return this.haveLength();\n  }\n\n  /**\n   * Gets extended payload length (7+64).\n   *\n   * @return {(RangeError|undefined)} A possible error\n   * @private\n   */\n  getPayloadLength64() {\n    if (this._bufferedBytes < 8) {\n      this._loop = false;\n      return;\n    }\n\n    const buf = this.consume(8);\n    const num = buf.readUInt32BE(0);\n\n    //\n    // The maximum safe integer in JavaScript is 2^53 - 1. An error is returned\n    // if payload length is greater than this number.\n    //\n    if (num > Math.pow(2, 53 - 32) - 1) {\n      this._loop = false;\n      return error(\n        RangeError,\n        'Unsupported WebSocket frame: payload length > 2^53 - 1',\n        false,\n        1009\n      );\n    }\n\n    this._payloadLength = num * Math.pow(2, 32) + buf.readUInt32BE(4);\n    return this.haveLength();\n  }\n\n  /**\n   * Payload length has been read.\n   *\n   * @return {(RangeError|undefined)} A possible error\n   * @private\n   */\n  haveLength() {\n    if (this._payloadLength && this._opcode < 0x08) {\n      this._totalPayloadLength += this._payloadLength;\n      if (this._totalPayloadLength > this._maxPayload && this._maxPayload > 0) {\n        this._loop = false;\n        return error(RangeError, 'Max payload size exceeded', false, 1009);\n      }\n    }\n\n    if (this._masked) this._state = GET_MASK;\n    else this._state = GET_DATA;\n  }\n\n  /**\n   * Reads mask bytes.\n   *\n   * @private\n   */\n  getMask() {\n    if (this._bufferedBytes < 4) {\n      this._loop = false;\n      return;\n    }\n\n    this._mask = this.consume(4);\n    this._state = GET_DATA;\n  }\n\n  /**\n   * Reads data bytes.\n   *\n   * @param {Function} cb Callback\n   * @return {(Error|RangeError|undefined)} A possible error\n   * @private\n   */\n  getData(cb) {\n    let data = EMPTY_BUFFER;\n\n    if (this._payloadLength) {\n      if (this._bufferedBytes < this._payloadLength) {\n        this._loop = false;\n        return;\n      }\n\n      data = this.consume(this._payloadLength);\n      if (this._masked) unmask(data, this._mask);\n    }\n\n    if (this._opcode > 0x07) return this.controlMessage(data);\n\n    if (this._compressed) {\n      this._state = INFLATING;\n      this.decompress(data, cb);\n      return;\n    }\n\n    if (data.length) {\n      //\n      // This message is not compressed so its lenght is the sum of the payload\n      // length of all fragments.\n      //\n      this._messageLength = this._totalPayloadLength;\n      this._fragments.push(data);\n    }\n\n    return this.dataMessage();\n  }\n\n  /**\n   * Decompresses data.\n   *\n   * @param {Buffer} data Compressed data\n   * @param {Function} cb Callback\n   * @private\n   */\n  decompress(data, cb) {\n    const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];\n\n    perMessageDeflate.decompress(data, this._fin, (err, buf) => {\n      if (err) return cb(err);\n\n      if (buf.length) {\n        this._messageLength += buf.length;\n        if (this._messageLength > this._maxPayload && this._maxPayload > 0) {\n          return cb(\n            error(RangeError, 'Max payload size exceeded', false, 1009)\n          );\n        }\n\n        this._fragments.push(buf);\n      }\n\n      const er = this.dataMessage();\n      if (er) return cb(er);\n\n      this.startLoop(cb);\n    });\n  }\n\n  /**\n   * Handles a data message.\n   *\n   * @return {(Error|undefined)} A possible error\n   * @private\n   */\n  dataMessage() {\n    if (this._fin) {\n      const messageLength = this._messageLength;\n      const fragments = this._fragments;\n\n      this._totalPayloadLength = 0;\n      this._messageLength = 0;\n      this._fragmented = 0;\n      this._fragments = [];\n\n      if (this._opcode === 2) {\n        let data;\n\n        if (this._binaryType === 'nodebuffer') {\n          data = concat(fragments, messageLength);\n        } else if (this._binaryType === 'arraybuffer') {\n          data = toArrayBuffer(concat(fragments, messageLength));\n        } else {\n          data = fragments;\n        }\n\n        this.emit('message', data);\n      } else {\n        const buf = concat(fragments, messageLength);\n\n        if (!isValidUTF8(buf)) {\n          this._loop = false;\n          return error(Error, 'invalid UTF-8 sequence', true, 1007);\n        }\n\n        this.emit('message', buf.toString());\n      }\n    }\n\n    this._state = GET_INFO;\n  }\n\n  /**\n   * Handles a control message.\n   *\n   * @param {Buffer} data Data to handle\n   * @return {(Error|RangeError|undefined)} A possible error\n   * @private\n   */\n  controlMessage(data) {\n    if (this._opcode === 0x08) {\n      this._loop = false;\n\n      if (data.length === 0) {\n        this.emit('conclude', 1005, '');\n        this.end();\n      } else if (data.length === 1) {\n        return error(RangeError, 'invalid payload length 1', true, 1002);\n      } else {\n        const code = data.readUInt16BE(0);\n\n        if (!isValidStatusCode(code)) {\n          return error(RangeError, `invalid status code ${code}`, true, 1002);\n        }\n\n        const buf = data.slice(2);\n\n        if (!isValidUTF8(buf)) {\n          return error(Error, 'invalid UTF-8 sequence', true, 1007);\n        }\n\n        this.emit('conclude', code, buf.toString());\n        this.end();\n      }\n    } else if (this._opcode === 0x09) {\n      this.emit('ping', data);\n    } else {\n      this.emit('pong', data);\n    }\n\n    this._state = GET_INFO;\n  }\n}\n\nmodule.exports = Receiver;\n\n/**\n * Builds an error object.\n *\n * @param {(Error|RangeError)} ErrorCtor The error constructor\n * @param {String} message The error message\n * @param {Boolean} prefix Specifies whether or not to add a default prefix to\n *     `message`\n * @param {Number} statusCode The status code\n * @return {(Error|RangeError)} The error\n * @private\n */\nfunction error(ErrorCtor, message, prefix, statusCode) {\n  const err = new ErrorCtor(\n    prefix ? `Invalid WebSocket frame: ${message}` : message\n  );\n\n  Error.captureStackTrace(err, error);\n  err[kStatusCode] = statusCode;\n  return err;\n}\n","'use strict';\n\nconst { randomFillSync } = require('crypto');\n\nconst PerMessageDeflate = require('./permessage-deflate');\nconst { EMPTY_BUFFER } = require('./constants');\nconst { isValidStatusCode } = require('./validation');\nconst { mask: applyMask, toBuffer } = require('./buffer-util');\n\nconst mask = Buffer.alloc(4);\n\n/**\n * HyBi Sender implementation.\n */\nclass Sender {\n  /**\n   * Creates a Sender instance.\n   *\n   * @param {net.Socket} socket The connection socket\n   * @param {Object} extensions An object containing the negotiated extensions\n   */\n  constructor(socket, extensions) {\n    this._extensions = extensions || {};\n    this._socket = socket;\n\n    this._firstFragment = true;\n    this._compress = false;\n\n    this._bufferedBytes = 0;\n    this._deflating = false;\n    this._queue = [];\n  }\n\n  /**\n   * Frames a piece of data according to the HyBi WebSocket protocol.\n   *\n   * @param {Buffer} data The data to frame\n   * @param {Object} options Options object\n   * @param {Number} options.opcode The opcode\n   * @param {Boolean} options.readOnly Specifies whether `data` can be modified\n   * @param {Boolean} options.fin Specifies whether or not to set the FIN bit\n   * @param {Boolean} options.mask Specifies whether or not to mask `data`\n   * @param {Boolean} options.rsv1 Specifies whether or not to set the RSV1 bit\n   * @return {Buffer[]} The framed data as a list of `Buffer` instances\n   * @public\n   */\n  static frame(data, options) {\n    const merge = options.mask && options.readOnly;\n    let offset = options.mask ? 6 : 2;\n    let payloadLength = data.length;\n\n    if (data.length >= 65536) {\n      offset += 8;\n      payloadLength = 127;\n    } else if (data.length > 125) {\n      offset += 2;\n      payloadLength = 126;\n    }\n\n    const target = Buffer.allocUnsafe(merge ? data.length + offset : offset);\n\n    target[0] = options.fin ? options.opcode | 0x80 : options.opcode;\n    if (options.rsv1) target[0] |= 0x40;\n\n    target[1] = payloadLength;\n\n    if (payloadLength === 126) {\n      target.writeUInt16BE(data.length, 2);\n    } else if (payloadLength === 127) {\n      target.writeUInt32BE(0, 2);\n      target.writeUInt32BE(data.length, 6);\n    }\n\n    if (!options.mask) return [target, data];\n\n    randomFillSync(mask, 0, 4);\n\n    target[1] |= 0x80;\n    target[offset - 4] = mask[0];\n    target[offset - 3] = mask[1];\n    target[offset - 2] = mask[2];\n    target[offset - 1] = mask[3];\n\n    if (merge) {\n      applyMask(data, mask, target, offset, data.length);\n      return [target];\n    }\n\n    applyMask(data, mask, data, 0, data.length);\n    return [target, data];\n  }\n\n  /**\n   * Sends a close message to the other peer.\n   *\n   * @param {(Number|undefined)} code The status code component of the body\n   * @param {String} data The message component of the body\n   * @param {Boolean} mask Specifies whether or not to mask the message\n   * @param {Function} cb Callback\n   * @public\n   */\n  close(code, data, mask, cb) {\n    let buf;\n\n    if (code === undefined) {\n      buf = EMPTY_BUFFER;\n    } else if (typeof code !== 'number' || !isValidStatusCode(code)) {\n      throw new TypeError('First argument must be a valid error code number');\n    } else if (data === undefined || data === '') {\n      buf = Buffer.allocUnsafe(2);\n      buf.writeUInt16BE(code, 0);\n    } else {\n      buf = Buffer.allocUnsafe(2 + Buffer.byteLength(data));\n      buf.writeUInt16BE(code, 0);\n      buf.write(data, 2);\n    }\n\n    if (this._deflating) {\n      this.enqueue([this.doClose, buf, mask, cb]);\n    } else {\n      this.doClose(buf, mask, cb);\n    }\n  }\n\n  /**\n   * Frames and sends a close message.\n   *\n   * @param {Buffer} data The message to send\n   * @param {Boolean} mask Specifies whether or not to mask `data`\n   * @param {Function} cb Callback\n   * @private\n   */\n  doClose(data, mask, cb) {\n    this.sendFrame(\n      Sender.frame(data, {\n        fin: true,\n        rsv1: false,\n        opcode: 0x08,\n        mask,\n        readOnly: false\n      }),\n      cb\n    );\n  }\n\n  /**\n   * Sends a ping message to the other peer.\n   *\n   * @param {*} data The message to send\n   * @param {Boolean} mask Specifies whether or not to mask `data`\n   * @param {Function} cb Callback\n   * @public\n   */\n  ping(data, mask, cb) {\n    const buf = toBuffer(data);\n\n    if (this._deflating) {\n      this.enqueue([this.doPing, buf, mask, toBuffer.readOnly, cb]);\n    } else {\n      this.doPing(buf, mask, toBuffer.readOnly, cb);\n    }\n  }\n\n  /**\n   * Frames and sends a ping message.\n   *\n   * @param {*} data The message to send\n   * @param {Boolean} mask Specifies whether or not to mask `data`\n   * @param {Boolean} readOnly Specifies whether `data` can be modified\n   * @param {Function} cb Callback\n   * @private\n   */\n  doPing(data, mask, readOnly, cb) {\n    this.sendFrame(\n      Sender.frame(data, {\n        fin: true,\n        rsv1: false,\n        opcode: 0x09,\n        mask,\n        readOnly\n      }),\n      cb\n    );\n  }\n\n  /**\n   * Sends a pong message to the other peer.\n   *\n   * @param {*} data The message to send\n   * @param {Boolean} mask Specifies whether or not to mask `data`\n   * @param {Function} cb Callback\n   * @public\n   */\n  pong(data, mask, cb) {\n    const buf = toBuffer(data);\n\n    if (this._deflating) {\n      this.enqueue([this.doPong, buf, mask, toBuffer.readOnly, cb]);\n    } else {\n      this.doPong(buf, mask, toBuffer.readOnly, cb);\n    }\n  }\n\n  /**\n   * Frames and sends a pong message.\n   *\n   * @param {*} data The message to send\n   * @param {Boolean} mask Specifies whether or not to mask `data`\n   * @param {Boolean} readOnly Specifies whether `data` can be modified\n   * @param {Function} cb Callback\n   * @private\n   */\n  doPong(data, mask, readOnly, cb) {\n    this.sendFrame(\n      Sender.frame(data, {\n        fin: true,\n        rsv1: false,\n        opcode: 0x0a,\n        mask,\n        readOnly\n      }),\n      cb\n    );\n  }\n\n  /**\n   * Sends a data message to the other peer.\n   *\n   * @param {*} data The message to send\n   * @param {Object} options Options object\n   * @param {Boolean} options.compress Specifies whether or not to compress `data`\n   * @param {Boolean} options.binary Specifies whether `data` is binary or text\n   * @param {Boolean} options.fin Specifies whether the fragment is the last one\n   * @param {Boolean} options.mask Specifies whether or not to mask `data`\n   * @param {Function} cb Callback\n   * @public\n   */\n  send(data, options, cb) {\n    const buf = toBuffer(data);\n    const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];\n    let opcode = options.binary ? 2 : 1;\n    let rsv1 = options.compress;\n\n    if (this._firstFragment) {\n      this._firstFragment = false;\n      if (rsv1 && perMessageDeflate) {\n        rsv1 = buf.length >= perMessageDeflate._threshold;\n      }\n      this._compress = rsv1;\n    } else {\n      rsv1 = false;\n      opcode = 0;\n    }\n\n    if (options.fin) this._firstFragment = true;\n\n    if (perMessageDeflate) {\n      const opts = {\n        fin: options.fin,\n        rsv1,\n        opcode,\n        mask: options.mask,\n        readOnly: toBuffer.readOnly\n      };\n\n      if (this._deflating) {\n        this.enqueue([this.dispatch, buf, this._compress, opts, cb]);\n      } else {\n        this.dispatch(buf, this._compress, opts, cb);\n      }\n    } else {\n      this.sendFrame(\n        Sender.frame(buf, {\n          fin: options.fin,\n          rsv1: false,\n          opcode,\n          mask: options.mask,\n          readOnly: toBuffer.readOnly\n        }),\n        cb\n      );\n    }\n  }\n\n  /**\n   * Dispatches a data message.\n   *\n   * @param {Buffer} data The message to send\n   * @param {Boolean} compress Specifies whether or not to compress `data`\n   * @param {Object} options Options object\n   * @param {Number} options.opcode The opcode\n   * @param {Boolean} options.readOnly Specifies whether `data` can be modified\n   * @param {Boolean} options.fin Specifies whether or not to set the FIN bit\n   * @param {Boolean} options.mask Specifies whether or not to mask `data`\n   * @param {Boolean} options.rsv1 Specifies whether or not to set the RSV1 bit\n   * @param {Function} cb Callback\n   * @private\n   */\n  dispatch(data, compress, options, cb) {\n    if (!compress) {\n      this.sendFrame(Sender.frame(data, options), cb);\n      return;\n    }\n\n    const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];\n\n    this._deflating = true;\n    perMessageDeflate.compress(data, options.fin, (_, buf) => {\n      this._deflating = false;\n      options.readOnly = false;\n      this.sendFrame(Sender.frame(buf, options), cb);\n      this.dequeue();\n    });\n  }\n\n  /**\n   * Executes queued send operations.\n   *\n   * @private\n   */\n  dequeue() {\n    while (!this._deflating && this._queue.length) {\n      const params = this._queue.shift();\n\n      this._bufferedBytes -= params[1].length;\n      Reflect.apply(params[0], this, params.slice(1));\n    }\n  }\n\n  /**\n   * Enqueues a send operation.\n   *\n   * @param {Array} params Send operation parameters.\n   * @private\n   */\n  enqueue(params) {\n    this._bufferedBytes += params[1].length;\n    this._queue.push(params);\n  }\n\n  /**\n   * Sends a frame.\n   *\n   * @param {Buffer[]} list The frame to send\n   * @param {Function} cb Callback\n   * @private\n   */\n  sendFrame(list, cb) {\n    if (list.length === 2) {\n      this._socket.cork();\n      this._socket.write(list[0]);\n      this._socket.write(list[1], cb);\n      this._socket.uncork();\n    } else {\n      this._socket.write(list[0], cb);\n    }\n  }\n}\n\nmodule.exports = Sender;\n","'use strict';\n\nconst { Duplex } = require('stream');\n\n/**\n * Emits the `'close'` event on a stream.\n *\n * @param {stream.Duplex} The stream.\n * @private\n */\nfunction emitClose(stream) {\n  stream.emit('close');\n}\n\n/**\n * The listener of the `'end'` event.\n *\n * @private\n */\nfunction duplexOnEnd() {\n  if (!this.destroyed && this._writableState.finished) {\n    this.destroy();\n  }\n}\n\n/**\n * The listener of the `'error'` event.\n *\n * @private\n */\nfunction duplexOnError(err) {\n  this.removeListener('error', duplexOnError);\n  this.destroy();\n  if (this.listenerCount('error') === 0) {\n    // Do not suppress the throwing behavior.\n    this.emit('error', err);\n  }\n}\n\n/**\n * Wraps a `WebSocket` in a duplex stream.\n *\n * @param {WebSocket} ws The `WebSocket` to wrap\n * @param {Object} options The options for the `Duplex` constructor\n * @return {stream.Duplex} The duplex stream\n * @public\n */\nfunction createWebSocketStream(ws, options) {\n  let resumeOnReceiverDrain = true;\n\n  function receiverOnDrain() {\n    if (resumeOnReceiverDrain) ws._socket.resume();\n  }\n\n  if (ws.readyState === ws.CONNECTING) {\n    ws.once('open', function open() {\n      ws._receiver.removeAllListeners('drain');\n      ws._receiver.on('drain', receiverOnDrain);\n    });\n  } else {\n    ws._receiver.removeAllListeners('drain');\n    ws._receiver.on('drain', receiverOnDrain);\n  }\n\n  const duplex = new Duplex({\n    ...options,\n    autoDestroy: false,\n    emitClose: false,\n    objectMode: false,\n    writableObjectMode: false\n  });\n\n  ws.on('message', function message(msg) {\n    if (!duplex.push(msg)) {\n      resumeOnReceiverDrain = false;\n      ws._socket.pause();\n    }\n  });\n\n  ws.once('error', function error(err) {\n    duplex.destroy(err);\n  });\n\n  ws.once('close', function close() {\n    if (duplex.destroyed) return;\n\n    duplex.push(null);\n  });\n\n  duplex._destroy = function(err, callback) {\n    if (ws.readyState === ws.CLOSED) {\n      callback(err);\n      process.nextTick(emitClose, duplex);\n      return;\n    }\n\n    ws.once('close', function close() {\n      callback(err);\n      process.nextTick(emitClose, duplex);\n    });\n    ws.terminate();\n  };\n\n  duplex._final = function(callback) {\n    if (ws.readyState === ws.CONNECTING) {\n      ws.once('open', function open() {\n        duplex._final(callback);\n      });\n      return;\n    }\n\n    if (ws._socket._writableState.finished) {\n      if (duplex._readableState.endEmitted) duplex.destroy();\n      callback();\n    } else {\n      ws._socket.once('finish', function finish() {\n        // `duplex` is not destroyed here because the `'end'` event will be\n        // emitted on `duplex` after this `'finish'` event. The EOF signaling\n        // `null` chunk is, in fact, pushed when the WebSocket emits `'close'`.\n        callback();\n      });\n      ws.close();\n    }\n  };\n\n  duplex._read = function() {\n    if (ws.readyState === ws.OPEN && !resumeOnReceiverDrain) {\n      resumeOnReceiverDrain = true;\n      if (!ws._receiver._writableState.needDrain) ws._socket.resume();\n    }\n  };\n\n  duplex._write = function(chunk, encoding, callback) {\n    if (ws.readyState === ws.CONNECTING) {\n      ws.once('open', function open() {\n        duplex._write(chunk, encoding, callback);\n      });\n      return;\n    }\n\n    ws.send(chunk, callback);\n  };\n\n  duplex.on('end', duplexOnEnd);\n  duplex.on('error', duplexOnError);\n  return duplex;\n}\n\nmodule.exports = createWebSocketStream;\n","'use strict';\n\ntry {\n  const isValidUTF8 = require('utf-8-validate');\n\n  exports.isValidUTF8 =\n    typeof isValidUTF8 === 'object'\n      ? isValidUTF8.Validation.isValidUTF8 // utf-8-validate@<3.0.0\n      : isValidUTF8;\n} catch (e) /* istanbul ignore next */ {\n  exports.isValidUTF8 = () => true;\n}\n\n/**\n * Checks if a status code is allowed in a close frame.\n *\n * @param {Number} code The status code\n * @return {Boolean} `true` if the status code is valid, else `false`\n * @public\n */\nexports.isValidStatusCode = (code) => {\n  return (\n    (code >= 1000 &&\n      code <= 1013 &&\n      code !== 1004 &&\n      code !== 1005 &&\n      code !== 1006) ||\n    (code >= 3000 && code <= 4999)\n  );\n};\n","'use strict';\n\nconst EventEmitter = require('events');\nconst { createHash } = require('crypto');\nconst { createServer, STATUS_CODES } = require('http');\n\nconst PerMessageDeflate = require('./permessage-deflate');\nconst WebSocket = require('./websocket');\nconst { format, parse } = require('./extension');\nconst { GUID } = require('./constants');\n\nconst keyRegex = /^[+/0-9A-Za-z]{22}==$/;\nconst kUsedByWebSocketServer = Symbol('kUsedByWebSocketServer');\n\n/**\n * Class representing a WebSocket server.\n *\n * @extends EventEmitter\n */\nclass WebSocketServer extends EventEmitter {\n  /**\n   * Create a `WebSocketServer` instance.\n   *\n   * @param {Object} options Configuration options\n   * @param {Number} options.backlog The maximum length of the queue of pending\n   *     connections\n   * @param {Boolean} options.clientTracking Specifies whether or not to track\n   *     clients\n   * @param {Function} options.handleProtocols A hook to handle protocols\n   * @param {String} options.host The hostname where to bind the server\n   * @param {Number} options.maxPayload The maximum allowed message size\n   * @param {Boolean} options.noServer Enable no server mode\n   * @param {String} options.path Accept only connections matching this path\n   * @param {(Boolean|Object)} options.perMessageDeflate Enable/disable\n   *     permessage-deflate\n   * @param {Number} options.port The port where to bind the server\n   * @param {http.Server} options.server A pre-created HTTP/S server to use\n   * @param {Function} options.verifyClient A hook to reject connections\n   * @param {Function} callback A listener for the `listening` event\n   */\n  constructor(options, callback) {\n    super();\n\n    options = {\n      maxPayload: 100 * 1024 * 1024,\n      perMessageDeflate: false,\n      handleProtocols: null,\n      clientTracking: true,\n      verifyClient: null,\n      noServer: false,\n      backlog: null, // use default (511 as implemented in net.js)\n      server: null,\n      host: null,\n      path: null,\n      port: null,\n      ...options\n    };\n\n    if (options.port == null && !options.server && !options.noServer) {\n      throw new TypeError(\n        'One of the \"port\", \"server\", or \"noServer\" options must be specified'\n      );\n    }\n\n    if (options.port != null) {\n      this._server = createServer((req, res) => {\n        const body = STATUS_CODES[426];\n\n        res.writeHead(426, {\n          'Content-Length': body.length,\n          'Content-Type': 'text/plain'\n        });\n        res.end(body);\n      });\n      this._server.listen(\n        options.port,\n        options.host,\n        options.backlog,\n        callback\n      );\n    } else if (options.server) {\n      if (options.server[kUsedByWebSocketServer]) {\n        throw new Error(\n          'The HTTP/S server is already being used by another WebSocket server'\n        );\n      }\n\n      options.server[kUsedByWebSocketServer] = true;\n      this._server = options.server;\n    }\n\n    if (this._server) {\n      this._removeListeners = addListeners(this._server, {\n        listening: this.emit.bind(this, 'listening'),\n        error: this.emit.bind(this, 'error'),\n        upgrade: (req, socket, head) => {\n          this.handleUpgrade(req, socket, head, (ws) => {\n            this.emit('connection', ws, req);\n          });\n        }\n      });\n    }\n\n    if (options.perMessageDeflate === true) options.perMessageDeflate = {};\n    if (options.clientTracking) this.clients = new Set();\n    this.options = options;\n  }\n\n  /**\n   * Returns the bound address, the address family name, and port of the server\n   * as reported by the operating system if listening on an IP socket.\n   * If the server is listening on a pipe or UNIX domain socket, the name is\n   * returned as a string.\n   *\n   * @return {(Object|String|null)} The address of the server\n   * @public\n   */\n  address() {\n    if (this.options.noServer) {\n      throw new Error('The server is operating in \"noServer\" mode');\n    }\n\n    if (!this._server) return null;\n    return this._server.address();\n  }\n\n  /**\n   * Close the server.\n   *\n   * @param {Function} cb Callback\n   * @public\n   */\n  close(cb) {\n    if (cb) this.once('close', cb);\n\n    //\n    // Terminate all associated clients.\n    //\n    if (this.clients) {\n      for (const client of this.clients) client.terminate();\n    }\n\n    const server = this._server;\n\n    if (server) {\n      this._removeListeners();\n      this._removeListeners = this._server = null;\n\n      //\n      // Close the http server if it was internally created.\n      //\n      if (this.options.port != null) {\n        server.close(() => this.emit('close'));\n        return;\n      }\n\n      delete server[kUsedByWebSocketServer];\n    }\n\n    process.nextTick(emitClose, this);\n  }\n\n  /**\n   * See if a given request should be handled by this server instance.\n   *\n   * @param {http.IncomingMessage} req Request object to inspect\n   * @return {Boolean} `true` if the request is valid, else `false`\n   * @public\n   */\n  shouldHandle(req) {\n    if (this.options.path) {\n      const index = req.url.indexOf('?');\n      const pathname = index !== -1 ? req.url.slice(0, index) : req.url;\n\n      if (pathname !== this.options.path) return false;\n    }\n\n    return true;\n  }\n\n  /**\n   * Handle a HTTP Upgrade request.\n   *\n   * @param {http.IncomingMessage} req The request object\n   * @param {net.Socket} socket The network socket between the server and client\n   * @param {Buffer} head The first packet of the upgraded stream\n   * @param {Function} cb Callback\n   * @public\n   */\n  handleUpgrade(req, socket, head, cb) {\n    socket.on('error', socketOnError);\n\n    const key =\n      req.headers['sec-websocket-key'] !== undefined\n        ? req.headers['sec-websocket-key'].trim()\n        : false;\n    const version = +req.headers['sec-websocket-version'];\n    const extensions = {};\n\n    if (\n      req.method !== 'GET' ||\n      req.headers.upgrade.toLowerCase() !== 'websocket' ||\n      !key ||\n      !keyRegex.test(key) ||\n      (version !== 8 && version !== 13) ||\n      !this.shouldHandle(req)\n    ) {\n      return abortHandshake(socket, 400);\n    }\n\n    if (this.options.perMessageDeflate) {\n      const perMessageDeflate = new PerMessageDeflate(\n        this.options.perMessageDeflate,\n        true,\n        this.options.maxPayload\n      );\n\n      try {\n        const offers = parse(req.headers['sec-websocket-extensions']);\n\n        if (offers[PerMessageDeflate.extensionName]) {\n          perMessageDeflate.accept(offers[PerMessageDeflate.extensionName]);\n          extensions[PerMessageDeflate.extensionName] = perMessageDeflate;\n        }\n      } catch (err) {\n        return abortHandshake(socket, 400);\n      }\n    }\n\n    //\n    // Optionally call external client verification handler.\n    //\n    if (this.options.verifyClient) {\n      const info = {\n        origin:\n          req.headers[`${version === 8 ? 'sec-websocket-origin' : 'origin'}`],\n        secure: !!(req.connection.authorized || req.connection.encrypted),\n        req\n      };\n\n      if (this.options.verifyClient.length === 2) {\n        this.options.verifyClient(info, (verified, code, message, headers) => {\n          if (!verified) {\n            return abortHandshake(socket, code || 401, message, headers);\n          }\n\n          this.completeUpgrade(key, extensions, req, socket, head, cb);\n        });\n        return;\n      }\n\n      if (!this.options.verifyClient(info)) return abortHandshake(socket, 401);\n    }\n\n    this.completeUpgrade(key, extensions, req, socket, head, cb);\n  }\n\n  /**\n   * Upgrade the connection to WebSocket.\n   *\n   * @param {String} key The value of the `Sec-WebSocket-Key` header\n   * @param {Object} extensions The accepted extensions\n   * @param {http.IncomingMessage} req The request object\n   * @param {net.Socket} socket The network socket between the server and client\n   * @param {Buffer} head The first packet of the upgraded stream\n   * @param {Function} cb Callback\n   * @private\n   */\n  completeUpgrade(key, extensions, req, socket, head, cb) {\n    //\n    // Destroy the socket if the client has already sent a FIN packet.\n    //\n    if (!socket.readable || !socket.writable) return socket.destroy();\n\n    const digest = createHash('sha1')\n      .update(key + GUID)\n      .digest('base64');\n\n    const headers = [\n      'HTTP/1.1 101 Switching Protocols',\n      'Upgrade: websocket',\n      'Connection: Upgrade',\n      `Sec-WebSocket-Accept: ${digest}`\n    ];\n\n    const ws = new WebSocket(null);\n    let protocol = req.headers['sec-websocket-protocol'];\n\n    if (protocol) {\n      protocol = protocol.trim().split(/ *, */);\n\n      //\n      // Optionally call external protocol selection handler.\n      //\n      if (this.options.handleProtocols) {\n        protocol = this.options.handleProtocols(protocol, req);\n      } else {\n        protocol = protocol[0];\n      }\n\n      if (protocol) {\n        headers.push(`Sec-WebSocket-Protocol: ${protocol}`);\n        ws.protocol = protocol;\n      }\n    }\n\n    if (extensions[PerMessageDeflate.extensionName]) {\n      const params = extensions[PerMessageDeflate.extensionName].params;\n      const value = format({\n        [PerMessageDeflate.extensionName]: [params]\n      });\n      headers.push(`Sec-WebSocket-Extensions: ${value}`);\n      ws._extensions = extensions;\n    }\n\n    //\n    // Allow external modification/inspection of handshake headers.\n    //\n    this.emit('headers', headers, req);\n\n    socket.write(headers.concat('\\r\\n').join('\\r\\n'));\n    socket.removeListener('error', socketOnError);\n\n    ws.setSocket(socket, head, this.options.maxPayload);\n\n    if (this.clients) {\n      this.clients.add(ws);\n      ws.on('close', () => this.clients.delete(ws));\n    }\n\n    cb(ws);\n  }\n}\n\nmodule.exports = WebSocketServer;\n\n/**\n * Add event listeners on an `EventEmitter` using a map of <event, listener>\n * pairs.\n *\n * @param {EventEmitter} server The event emitter\n * @param {Object.<String, Function>} map The listeners to add\n * @return {Function} A function that will remove the added listeners when called\n * @private\n */\nfunction addListeners(server, map) {\n  for (const event of Object.keys(map)) server.on(event, map[event]);\n\n  return function removeListeners() {\n    for (const event of Object.keys(map)) {\n      server.removeListener(event, map[event]);\n    }\n  };\n}\n\n/**\n * Emit a `'close'` event on an `EventEmitter`.\n *\n * @param {EventEmitter} server The event emitter\n * @private\n */\nfunction emitClose(server) {\n  server.emit('close');\n}\n\n/**\n * Handle premature socket errors.\n *\n * @private\n */\nfunction socketOnError() {\n  this.destroy();\n}\n\n/**\n * Close the connection when preconditions are not fulfilled.\n *\n * @param {net.Socket} socket The socket of the upgrade request\n * @param {Number} code The HTTP response status code\n * @param {String} [message] The HTTP response body\n * @param {Object} [headers] Additional HTTP response headers\n * @private\n */\nfunction abortHandshake(socket, code, message, headers) {\n  if (socket.writable) {\n    message = message || STATUS_CODES[code];\n    headers = {\n      Connection: 'close',\n      'Content-type': 'text/html',\n      'Content-Length': Buffer.byteLength(message),\n      ...headers\n    };\n\n    socket.write(\n      `HTTP/1.1 ${code} ${STATUS_CODES[code]}\\r\\n` +\n        Object.keys(headers)\n          .map((h) => `${h}: ${headers[h]}`)\n          .join('\\r\\n') +\n        '\\r\\n\\r\\n' +\n        message\n    );\n  }\n\n  socket.removeListener('error', socketOnError);\n  socket.destroy();\n}\n","'use strict';\n\nconst EventEmitter = require('events');\nconst https = require('https');\nconst http = require('http');\nconst net = require('net');\nconst tls = require('tls');\nconst { randomBytes, createHash } = require('crypto');\nconst { URL } = require('url');\n\nconst PerMessageDeflate = require('./permessage-deflate');\nconst Receiver = require('./receiver');\nconst Sender = require('./sender');\nconst {\n  BINARY_TYPES,\n  EMPTY_BUFFER,\n  GUID,\n  kStatusCode,\n  kWebSocket,\n  NOOP\n} = require('./constants');\nconst { addEventListener, removeEventListener } = require('./event-target');\nconst { format, parse } = require('./extension');\nconst { toBuffer } = require('./buffer-util');\n\nconst readyStates = ['CONNECTING', 'OPEN', 'CLOSING', 'CLOSED'];\nconst protocolVersions = [8, 13];\nconst closeTimeout = 30 * 1000;\n\n/**\n * Class representing a WebSocket.\n *\n * @extends EventEmitter\n */\nclass WebSocket extends EventEmitter {\n  /**\n   * Create a new `WebSocket`.\n   *\n   * @param {(String|url.URL)} address The URL to which to connect\n   * @param {(String|String[])} protocols The subprotocols\n   * @param {Object} options Connection options\n   */\n  constructor(address, protocols, options) {\n    super();\n\n    this.readyState = WebSocket.CONNECTING;\n    this.protocol = '';\n\n    this._binaryType = BINARY_TYPES[0];\n    this._closeFrameReceived = false;\n    this._closeFrameSent = false;\n    this._closeMessage = '';\n    this._closeTimer = null;\n    this._closeCode = 1006;\n    this._extensions = {};\n    this._receiver = null;\n    this._sender = null;\n    this._socket = null;\n\n    if (address !== null) {\n      this._bufferedAmount = 0;\n      this._isServer = false;\n      this._redirects = 0;\n\n      if (Array.isArray(protocols)) {\n        protocols = protocols.join(', ');\n      } else if (typeof protocols === 'object' && protocols !== null) {\n        options = protocols;\n        protocols = undefined;\n      }\n\n      initAsClient(this, address, protocols, options);\n    } else {\n      this._isServer = true;\n    }\n  }\n\n  get CONNECTING() {\n    return WebSocket.CONNECTING;\n  }\n  get CLOSING() {\n    return WebSocket.CLOSING;\n  }\n  get CLOSED() {\n    return WebSocket.CLOSED;\n  }\n  get OPEN() {\n    return WebSocket.OPEN;\n  }\n\n  /**\n   * This deviates from the WHATWG interface since ws doesn't support the\n   * required default \"blob\" type (instead we define a custom \"nodebuffer\"\n   * type).\n   *\n   * @type {String}\n   */\n  get binaryType() {\n    return this._binaryType;\n  }\n\n  set binaryType(type) {\n    if (!BINARY_TYPES.includes(type)) return;\n\n    this._binaryType = type;\n\n    //\n    // Allow to change `binaryType` on the fly.\n    //\n    if (this._receiver) this._receiver._binaryType = type;\n  }\n\n  /**\n   * @type {Number}\n   */\n  get bufferedAmount() {\n    if (!this._socket) return this._bufferedAmount;\n\n    //\n    // `socket.bufferSize` is `undefined` if the socket is closed.\n    //\n    return (this._socket.bufferSize || 0) + this._sender._bufferedBytes;\n  }\n\n  /**\n   * @type {String}\n   */\n  get extensions() {\n    return Object.keys(this._extensions).join();\n  }\n\n  /**\n   * Set up the socket and the internal resources.\n   *\n   * @param {net.Socket} socket The network socket between the server and client\n   * @param {Buffer} head The first packet of the upgraded stream\n   * @param {Number} maxPayload The maximum allowed message size\n   * @private\n   */\n  setSocket(socket, head, maxPayload) {\n    const receiver = new Receiver(\n      this._binaryType,\n      this._extensions,\n      maxPayload\n    );\n\n    this._sender = new Sender(socket, this._extensions);\n    this._receiver = receiver;\n    this._socket = socket;\n\n    receiver[kWebSocket] = this;\n    socket[kWebSocket] = this;\n\n    receiver.on('conclude', receiverOnConclude);\n    receiver.on('drain', receiverOnDrain);\n    receiver.on('error', receiverOnError);\n    receiver.on('message', receiverOnMessage);\n    receiver.on('ping', receiverOnPing);\n    receiver.on('pong', receiverOnPong);\n\n    socket.setTimeout(0);\n    socket.setNoDelay();\n\n    if (head.length > 0) socket.unshift(head);\n\n    socket.on('close', socketOnClose);\n    socket.on('data', socketOnData);\n    socket.on('end', socketOnEnd);\n    socket.on('error', socketOnError);\n\n    this.readyState = WebSocket.OPEN;\n    this.emit('open');\n  }\n\n  /**\n   * Emit the `'close'` event.\n   *\n   * @private\n   */\n  emitClose() {\n    this.readyState = WebSocket.CLOSED;\n\n    if (!this._socket) {\n      this.emit('close', this._closeCode, this._closeMessage);\n      return;\n    }\n\n    if (this._extensions[PerMessageDeflate.extensionName]) {\n      this._extensions[PerMessageDeflate.extensionName].cleanup();\n    }\n\n    this._receiver.removeAllListeners();\n    this.emit('close', this._closeCode, this._closeMessage);\n  }\n\n  /**\n   * Start a closing handshake.\n   *\n   *          +----------+   +-----------+   +----------+\n   *     - - -|ws.close()|-->|close frame|-->|ws.close()|- - -\n   *    |     +----------+   +-----------+   +----------+     |\n   *          +----------+   +-----------+         |\n   * CLOSING  |ws.close()|<--|close frame|<--+-----+       CLOSING\n   *          +----------+   +-----------+   |\n   *    |           |                        |   +---+        |\n   *                +------------------------+-->|fin| - - - -\n   *    |         +---+                      |   +---+\n   *     - - - - -|fin|<---------------------+\n   *              +---+\n   *\n   * @param {Number} code Status code explaining why the connection is closing\n   * @param {String} data A string explaining why the connection is closing\n   * @public\n   */\n  close(code, data) {\n    if (this.readyState === WebSocket.CLOSED) return;\n    if (this.readyState === WebSocket.CONNECTING) {\n      const msg = 'WebSocket was closed before the connection was established';\n      return abortHandshake(this, this._req, msg);\n    }\n\n    if (this.readyState === WebSocket.CLOSING) {\n      if (this._closeFrameSent && this._closeFrameReceived) this._socket.end();\n      return;\n    }\n\n    this.readyState = WebSocket.CLOSING;\n    this._sender.close(code, data, !this._isServer, (err) => {\n      //\n      // This error is handled by the `'error'` listener on the socket. We only\n      // want to know if the close frame has been sent here.\n      //\n      if (err) return;\n\n      this._closeFrameSent = true;\n      if (this._closeFrameReceived) this._socket.end();\n    });\n\n    //\n    // Specify a timeout for the closing handshake to complete.\n    //\n    this._closeTimer = setTimeout(\n      this._socket.destroy.bind(this._socket),\n      closeTimeout\n    );\n  }\n\n  /**\n   * Send a ping.\n   *\n   * @param {*} data The data to send\n   * @param {Boolean} mask Indicates whether or not to mask `data`\n   * @param {Function} cb Callback which is executed when the ping is sent\n   * @public\n   */\n  ping(data, mask, cb) {\n    if (this.readyState === WebSocket.CONNECTING) {\n      throw new Error('WebSocket is not open: readyState 0 (CONNECTING)');\n    }\n\n    if (typeof data === 'function') {\n      cb = data;\n      data = mask = undefined;\n    } else if (typeof mask === 'function') {\n      cb = mask;\n      mask = undefined;\n    }\n\n    if (typeof data === 'number') data = data.toString();\n\n    if (this.readyState !== WebSocket.OPEN) {\n      sendAfterClose(this, data, cb);\n      return;\n    }\n\n    if (mask === undefined) mask = !this._isServer;\n    this._sender.ping(data || EMPTY_BUFFER, mask, cb);\n  }\n\n  /**\n   * Send a pong.\n   *\n   * @param {*} data The data to send\n   * @param {Boolean} mask Indicates whether or not to mask `data`\n   * @param {Function} cb Callback which is executed when the pong is sent\n   * @public\n   */\n  pong(data, mask, cb) {\n    if (this.readyState === WebSocket.CONNECTING) {\n      throw new Error('WebSocket is not open: readyState 0 (CONNECTING)');\n    }\n\n    if (typeof data === 'function') {\n      cb = data;\n      data = mask = undefined;\n    } else if (typeof mask === 'function') {\n      cb = mask;\n      mask = undefined;\n    }\n\n    if (typeof data === 'number') data = data.toString();\n\n    if (this.readyState !== WebSocket.OPEN) {\n      sendAfterClose(this, data, cb);\n      return;\n    }\n\n    if (mask === undefined) mask = !this._isServer;\n    this._sender.pong(data || EMPTY_BUFFER, mask, cb);\n  }\n\n  /**\n   * Send a data message.\n   *\n   * @param {*} data The message to send\n   * @param {Object} options Options object\n   * @param {Boolean} options.compress Specifies whether or not to compress\n   *     `data`\n   * @param {Boolean} options.binary Specifies whether `data` is binary or text\n   * @param {Boolean} options.fin Specifies whether the fragment is the last one\n   * @param {Boolean} options.mask Specifies whether or not to mask `data`\n   * @param {Function} cb Callback which is executed when data is written out\n   * @public\n   */\n  send(data, options, cb) {\n    if (this.readyState === WebSocket.CONNECTING) {\n      throw new Error('WebSocket is not open: readyState 0 (CONNECTING)');\n    }\n\n    if (typeof options === 'function') {\n      cb = options;\n      options = {};\n    }\n\n    if (typeof data === 'number') data = data.toString();\n\n    if (this.readyState !== WebSocket.OPEN) {\n      sendAfterClose(this, data, cb);\n      return;\n    }\n\n    const opts = {\n      binary: typeof data !== 'string',\n      mask: !this._isServer,\n      compress: true,\n      fin: true,\n      ...options\n    };\n\n    if (!this._extensions[PerMessageDeflate.extensionName]) {\n      opts.compress = false;\n    }\n\n    this._sender.send(data || EMPTY_BUFFER, opts, cb);\n  }\n\n  /**\n   * Forcibly close the connection.\n   *\n   * @public\n   */\n  terminate() {\n    if (this.readyState === WebSocket.CLOSED) return;\n    if (this.readyState === WebSocket.CONNECTING) {\n      const msg = 'WebSocket was closed before the connection was established';\n      return abortHandshake(this, this._req, msg);\n    }\n\n    if (this._socket) {\n      this.readyState = WebSocket.CLOSING;\n      this._socket.destroy();\n    }\n  }\n}\n\nreadyStates.forEach((readyState, i) => {\n  WebSocket[readyState] = i;\n});\n\n//\n// Add the `onopen`, `onerror`, `onclose`, and `onmessage` attributes.\n// See https://html.spec.whatwg.org/multipage/comms.html#the-websocket-interface\n//\n['open', 'error', 'close', 'message'].forEach((method) => {\n  Object.defineProperty(WebSocket.prototype, `on${method}`, {\n    /**\n     * Return the listener of the event.\n     *\n     * @return {(Function|undefined)} The event listener or `undefined`\n     * @public\n     */\n    get() {\n      const listeners = this.listeners(method);\n      for (let i = 0; i < listeners.length; i++) {\n        if (listeners[i]._listener) return listeners[i]._listener;\n      }\n\n      return undefined;\n    },\n    /**\n     * Add a listener for the event.\n     *\n     * @param {Function} listener The listener to add\n     * @public\n     */\n    set(listener) {\n      const listeners = this.listeners(method);\n      for (let i = 0; i < listeners.length; i++) {\n        //\n        // Remove only the listeners added via `addEventListener`.\n        //\n        if (listeners[i]._listener) this.removeListener(method, listeners[i]);\n      }\n      this.addEventListener(method, listener);\n    }\n  });\n});\n\nWebSocket.prototype.addEventListener = addEventListener;\nWebSocket.prototype.removeEventListener = removeEventListener;\n\nmodule.exports = WebSocket;\n\n/**\n * Initialize a WebSocket client.\n *\n * @param {WebSocket} websocket The client to initialize\n * @param {(String|url.URL)} address The URL to which to connect\n * @param {String} protocols The subprotocols\n * @param {Object} options Connection options\n * @param {(Boolean|Object)} options.perMessageDeflate Enable/disable\n *     permessage-deflate\n * @param {Number} options.handshakeTimeout Timeout in milliseconds for the\n *     handshake request\n * @param {Number} options.protocolVersion Value of the `Sec-WebSocket-Version`\n *     header\n * @param {String} options.origin Value of the `Origin` or\n *     `Sec-WebSocket-Origin` header\n * @param {Number} options.maxPayload The maximum allowed message size\n * @param {Boolean} options.followRedirects Whether or not to follow redirects\n * @param {Number} options.maxRedirects The maximum number of redirects allowed\n * @private\n */\nfunction initAsClient(websocket, address, protocols, options) {\n  const opts = {\n    protocolVersion: protocolVersions[1],\n    maxPayload: 100 * 1024 * 1024,\n    perMessageDeflate: true,\n    followRedirects: false,\n    maxRedirects: 10,\n    ...options,\n    createConnection: undefined,\n    socketPath: undefined,\n    hostname: undefined,\n    protocol: undefined,\n    timeout: undefined,\n    method: undefined,\n    auth: undefined,\n    host: undefined,\n    path: undefined,\n    port: undefined\n  };\n\n  if (!protocolVersions.includes(opts.protocolVersion)) {\n    throw new RangeError(\n      `Unsupported protocol version: ${opts.protocolVersion} ` +\n        `(supported versions: ${protocolVersions.join(', ')})`\n    );\n  }\n\n  let parsedUrl;\n\n  if (address instanceof URL) {\n    parsedUrl = address;\n    websocket.url = address.href;\n  } else {\n    parsedUrl = new URL(address);\n    websocket.url = address;\n  }\n\n  const isUnixSocket = parsedUrl.protocol === 'ws+unix:';\n\n  if (!parsedUrl.host && (!isUnixSocket || !parsedUrl.pathname)) {\n    throw new Error(`Invalid URL: ${websocket.url}`);\n  }\n\n  const isSecure =\n    parsedUrl.protocol === 'wss:' || parsedUrl.protocol === 'https:';\n  const defaultPort = isSecure ? 443 : 80;\n  const key = randomBytes(16).toString('base64');\n  const get = isSecure ? https.get : http.get;\n  let perMessageDeflate;\n\n  opts.createConnection = isSecure ? tlsConnect : netConnect;\n  opts.defaultPort = opts.defaultPort || defaultPort;\n  opts.port = parsedUrl.port || defaultPort;\n  opts.host = parsedUrl.hostname.startsWith('[')\n    ? parsedUrl.hostname.slice(1, -1)\n    : parsedUrl.hostname;\n  opts.headers = {\n    'Sec-WebSocket-Version': opts.protocolVersion,\n    'Sec-WebSocket-Key': key,\n    Connection: 'Upgrade',\n    Upgrade: 'websocket',\n    ...opts.headers\n  };\n  opts.path = parsedUrl.pathname + parsedUrl.search;\n  opts.timeout = opts.handshakeTimeout;\n\n  if (opts.perMessageDeflate) {\n    perMessageDeflate = new PerMessageDeflate(\n      opts.perMessageDeflate !== true ? opts.perMessageDeflate : {},\n      false,\n      opts.maxPayload\n    );\n    opts.headers['Sec-WebSocket-Extensions'] = format({\n      [PerMessageDeflate.extensionName]: perMessageDeflate.offer()\n    });\n  }\n  if (protocols) {\n    opts.headers['Sec-WebSocket-Protocol'] = protocols;\n  }\n  if (opts.origin) {\n    if (opts.protocolVersion < 13) {\n      opts.headers['Sec-WebSocket-Origin'] = opts.origin;\n    } else {\n      opts.headers.Origin = opts.origin;\n    }\n  }\n  if (parsedUrl.username || parsedUrl.password) {\n    opts.auth = `${parsedUrl.username}:${parsedUrl.password}`;\n  }\n\n  if (isUnixSocket) {\n    const parts = opts.path.split(':');\n\n    opts.socketPath = parts[0];\n    opts.path = parts[1];\n  }\n\n  let req = (websocket._req = get(opts));\n\n  if (opts.timeout) {\n    req.on('timeout', () => {\n      abortHandshake(websocket, req, 'Opening handshake has timed out');\n    });\n  }\n\n  req.on('error', (err) => {\n    if (websocket._req.aborted) return;\n\n    req = websocket._req = null;\n    websocket.readyState = WebSocket.CLOSING;\n    websocket.emit('error', err);\n    websocket.emitClose();\n  });\n\n  req.on('response', (res) => {\n    const location = res.headers.location;\n    const statusCode = res.statusCode;\n\n    if (\n      location &&\n      opts.followRedirects &&\n      statusCode >= 300 &&\n      statusCode < 400\n    ) {\n      if (++websocket._redirects > opts.maxRedirects) {\n        abortHandshake(websocket, req, 'Maximum redirects exceeded');\n        return;\n      }\n\n      req.abort();\n\n      const addr = new URL(location, address);\n\n      initAsClient(websocket, addr, protocols, options);\n    } else if (!websocket.emit('unexpected-response', req, res)) {\n      abortHandshake(\n        websocket,\n        req,\n        `Unexpected server response: ${res.statusCode}`\n      );\n    }\n  });\n\n  req.on('upgrade', (res, socket, head) => {\n    websocket.emit('upgrade', res);\n\n    //\n    // The user may have closed the connection from a listener of the `upgrade`\n    // event.\n    //\n    if (websocket.readyState !== WebSocket.CONNECTING) return;\n\n    req = websocket._req = null;\n\n    const digest = createHash('sha1')\n      .update(key + GUID)\n      .digest('base64');\n\n    if (res.headers['sec-websocket-accept'] !== digest) {\n      abortHandshake(websocket, socket, 'Invalid Sec-WebSocket-Accept header');\n      return;\n    }\n\n    const serverProt = res.headers['sec-websocket-protocol'];\n    const protList = (protocols || '').split(/, */);\n    let protError;\n\n    if (!protocols && serverProt) {\n      protError = 'Server sent a subprotocol but none was requested';\n    } else if (protocols && !serverProt) {\n      protError = 'Server sent no subprotocol';\n    } else if (serverProt && !protList.includes(serverProt)) {\n      protError = 'Server sent an invalid subprotocol';\n    }\n\n    if (protError) {\n      abortHandshake(websocket, socket, protError);\n      return;\n    }\n\n    if (serverProt) websocket.protocol = serverProt;\n\n    if (perMessageDeflate) {\n      try {\n        const extensions = parse(res.headers['sec-websocket-extensions']);\n\n        if (extensions[PerMessageDeflate.extensionName]) {\n          perMessageDeflate.accept(extensions[PerMessageDeflate.extensionName]);\n          websocket._extensions[\n            PerMessageDeflate.extensionName\n          ] = perMessageDeflate;\n        }\n      } catch (err) {\n        abortHandshake(\n          websocket,\n          socket,\n          'Invalid Sec-WebSocket-Extensions header'\n        );\n        return;\n      }\n    }\n\n    websocket.setSocket(socket, head, opts.maxPayload);\n  });\n}\n\n/**\n * Create a `net.Socket` and initiate a connection.\n *\n * @param {Object} options Connection options\n * @return {net.Socket} The newly created socket used to start the connection\n * @private\n */\nfunction netConnect(options) {\n  options.path = options.socketPath;\n  return net.connect(options);\n}\n\n/**\n * Create a `tls.TLSSocket` and initiate a connection.\n *\n * @param {Object} options Connection options\n * @return {tls.TLSSocket} The newly created socket used to start the connection\n * @private\n */\nfunction tlsConnect(options) {\n  options.path = undefined;\n\n  if (!options.servername && options.servername !== '') {\n    options.servername = options.host;\n  }\n\n  return tls.connect(options);\n}\n\n/**\n * Abort the handshake and emit an error.\n *\n * @param {WebSocket} websocket The WebSocket instance\n * @param {(http.ClientRequest|net.Socket)} stream The request to abort or the\n *     socket to destroy\n * @param {String} message The error message\n * @private\n */\nfunction abortHandshake(websocket, stream, message) {\n  websocket.readyState = WebSocket.CLOSING;\n\n  const err = new Error(message);\n  Error.captureStackTrace(err, abortHandshake);\n\n  if (stream.setHeader) {\n    stream.abort();\n    stream.once('abort', websocket.emitClose.bind(websocket));\n    websocket.emit('error', err);\n  } else {\n    stream.destroy(err);\n    stream.once('error', websocket.emit.bind(websocket, 'error'));\n    stream.once('close', websocket.emitClose.bind(websocket));\n  }\n}\n\n/**\n * Handle cases where the `ping()`, `pong()`, or `send()` methods are called\n * when the `readyState` attribute is `CLOSING` or `CLOSED`.\n *\n * @param {WebSocket} websocket The WebSocket instance\n * @param {*} data The data to send\n * @param {Function} cb Callback\n * @private\n */\nfunction sendAfterClose(websocket, data, cb) {\n  if (data) {\n    const length = toBuffer(data).length;\n\n    //\n    // The `_bufferedAmount` property is used only when the peer is a client and\n    // the opening handshake fails. Under these circumstances, in fact, the\n    // `setSocket()` method is not called, so the `_socket` and `_sender`\n    // properties are set to `null`.\n    //\n    if (websocket._socket) websocket._sender._bufferedBytes += length;\n    else websocket._bufferedAmount += length;\n  }\n\n  if (cb) {\n    const err = new Error(\n      `WebSocket is not open: readyState ${websocket.readyState} ` +\n        `(${readyStates[websocket.readyState]})`\n    );\n    cb(err);\n  }\n}\n\n/**\n * The listener of the `Receiver` `'conclude'` event.\n *\n * @param {Number} code The status code\n * @param {String} reason The reason for closing\n * @private\n */\nfunction receiverOnConclude(code, reason) {\n  const websocket = this[kWebSocket];\n\n  websocket._socket.removeListener('data', socketOnData);\n  websocket._socket.resume();\n\n  websocket._closeFrameReceived = true;\n  websocket._closeMessage = reason;\n  websocket._closeCode = code;\n\n  if (code === 1005) websocket.close();\n  else websocket.close(code, reason);\n}\n\n/**\n * The listener of the `Receiver` `'drain'` event.\n *\n * @private\n */\nfunction receiverOnDrain() {\n  this[kWebSocket]._socket.resume();\n}\n\n/**\n * The listener of the `Receiver` `'error'` event.\n *\n * @param {(RangeError|Error)} err The emitted error\n * @private\n */\nfunction receiverOnError(err) {\n  const websocket = this[kWebSocket];\n\n  websocket._socket.removeListener('data', socketOnData);\n\n  websocket.readyState = WebSocket.CLOSING;\n  websocket._closeCode = err[kStatusCode];\n  websocket.emit('error', err);\n  websocket._socket.destroy();\n}\n\n/**\n * The listener of the `Receiver` `'finish'` event.\n *\n * @private\n */\nfunction receiverOnFinish() {\n  this[kWebSocket].emitClose();\n}\n\n/**\n * The listener of the `Receiver` `'message'` event.\n *\n * @param {(String|Buffer|ArrayBuffer|Buffer[])} data The message\n * @private\n */\nfunction receiverOnMessage(data) {\n  this[kWebSocket].emit('message', data);\n}\n\n/**\n * The listener of the `Receiver` `'ping'` event.\n *\n * @param {Buffer} data The data included in the ping frame\n * @private\n */\nfunction receiverOnPing(data) {\n  const websocket = this[kWebSocket];\n\n  websocket.pong(data, !websocket._isServer, NOOP);\n  websocket.emit('ping', data);\n}\n\n/**\n * The listener of the `Receiver` `'pong'` event.\n *\n * @param {Buffer} data The data included in the pong frame\n * @private\n */\nfunction receiverOnPong(data) {\n  this[kWebSocket].emit('pong', data);\n}\n\n/**\n * The listener of the `net.Socket` `'close'` event.\n *\n * @private\n */\nfunction socketOnClose() {\n  const websocket = this[kWebSocket];\n\n  this.removeListener('close', socketOnClose);\n  this.removeListener('end', socketOnEnd);\n\n  websocket.readyState = WebSocket.CLOSING;\n\n  //\n  // The close frame might not have been received or the `'end'` event emitted,\n  // for example, if the socket was destroyed due to an error. Ensure that the\n  // `receiver` stream is closed after writing any remaining buffered data to\n  // it. If the readable side of the socket is in flowing mode then there is no\n  // buffered data as everything has been already written and `readable.read()`\n  // will return `null`. If instead, the socket is paused, any possible buffered\n  // data will be read as a single chunk and emitted synchronously in a single\n  // `'data'` event.\n  //\n  websocket._socket.read();\n  websocket._receiver.end();\n\n  this.removeListener('data', socketOnData);\n  this[kWebSocket] = undefined;\n\n  clearTimeout(websocket._closeTimer);\n\n  if (\n    websocket._receiver._writableState.finished ||\n    websocket._receiver._writableState.errorEmitted\n  ) {\n    websocket.emitClose();\n  } else {\n    websocket._receiver.on('error', receiverOnFinish);\n    websocket._receiver.on('finish', receiverOnFinish);\n  }\n}\n\n/**\n * The listener of the `net.Socket` `'data'` event.\n *\n * @param {Buffer} chunk A chunk of data\n * @private\n */\nfunction socketOnData(chunk) {\n  if (!this[kWebSocket]._receiver.write(chunk)) {\n    this.pause();\n  }\n}\n\n/**\n * The listener of the `net.Socket` `'end'` event.\n *\n * @private\n */\nfunction socketOnEnd() {\n  const websocket = this[kWebSocket];\n\n  websocket.readyState = WebSocket.CLOSING;\n  websocket._receiver.end();\n  this.end();\n}\n\n/**\n * The listener of the `net.Socket` `'error'` event.\n *\n * @private\n */\nfunction socketOnError() {\n  const websocket = this[kWebSocket];\n\n  this.removeListener('error', socketOnError);\n  this.on('error', NOOP);\n\n  if (websocket) {\n    websocket.readyState = WebSocket.CLOSING;\n    this.destroy();\n  }\n}\n","import * as path from 'path';\r\nimport * as vscode from 'vscode';\r\nimport WebSocket from 'ws';\r\nimport TelemetryReporter from './telemetry';\r\nimport QuickPickItem = vscode.QuickPickItem;\r\nimport * as utils from './utils';\r\nimport packageJson from \"../package.json\";\r\n\r\ninterface IPackageInfo {\r\n    name: string;\r\n    version: string;\r\n    aiKey: string;\r\n}\r\n\r\nconst debuggerType: string = 'devtools-for-chrome';\r\nconst defaultUrl: string = 'about:blank';\r\nlet telemetryReporter: TelemetryReporter;\r\n\r\nexport function activate(context: vscode.ExtensionContext) {\r\n\r\n    const packageInfo = getPackageInfo(context);\r\n    if (packageInfo && vscode.env.machineId !== 'someValue.machineId') {\r\n        // Use the real telemetry reporter\r\n        telemetryReporter = new TelemetryReporter(packageInfo.name, packageInfo.version, packageInfo.aiKey);\r\n    } else {\r\n        // Fallback to a fake telemetry reporter\r\n        telemetryReporter = new DebugTelemetryReporter();\r\n    }\r\n    context.subscriptions.push(telemetryReporter);\r\n\r\n    context.subscriptions.push(vscode.commands.registerCommand('devtools-for-chrome.launch', async () => {\r\n        launch(context);\r\n    }));\r\n\r\n    context.subscriptions.push(vscode.commands.registerCommand('devtools-for-chrome.attach', async () => {\r\n        attach(context, /* viaConfig= */ false, defaultUrl);\r\n    }));\r\n\r\n    vscode.debug.registerDebugConfigurationProvider(debuggerType, {\r\n        provideDebugConfigurations(folder: vscode.WorkspaceFolder | undefined, token?: vscode.CancellationToken): vscode.ProviderResult<vscode.DebugConfiguration[]> {\r\n            return Promise.resolve([{\r\n                type: debuggerType,\r\n                name: 'Launch Chrome against localhost',\r\n                request: 'launch',\r\n                url: 'http://localhost:8080'\r\n            }]);\r\n        },\r\n\r\n        resolveDebugConfiguration(folder: vscode.WorkspaceFolder | undefined, config: vscode.DebugConfiguration, token?: vscode.CancellationToken): vscode.ProviderResult<vscode.DebugConfiguration> {\r\n            if (config && config.type === debuggerType) {\r\n                const targetUri: string = utils.getUrlFromConfig(folder, config);\r\n                if (config.request && config.request.localeCompare('attach', 'en', { sensitivity: 'base' }) === 0) {\r\n                    attach(context, /* viaConfig= */ true, targetUri);\r\n                    telemetryReporter.sendTelemetryEvent('launch/command/attach');\r\n                } else if (config.request && config.request.localeCompare('launch', 'en', { sensitivity: 'base' }) === 0) {\r\n                    launch(context, targetUri, config.chromePath);\r\n                    telemetryReporter.sendTelemetryEvent('launch/command/launch');\r\n                }\r\n            } else {\r\n                vscode.window.showErrorMessage('No supported launch config was found.');\r\n                telemetryReporter.sendTelemetryEvent('launch/error/config_not_found');\r\n            }\r\n            return;\r\n        }\r\n    });\r\n}\r\n\r\nasync function launch(context: vscode.ExtensionContext, launchUrl?: string, chromePathFromLaunchConfig?: string) {\r\n    const viaConfig = !!(launchUrl || chromePathFromLaunchConfig);\r\n    const telemetryProps = { viaConfig: `${viaConfig}` };\r\n    telemetryReporter.sendTelemetryEvent('launch', telemetryProps);\r\n\r\n    const { hostname, port } = getSettings();\r\n    const portFree = await utils.isPortFree(hostname, port);\r\n    if (portFree) {\r\n        const settings = vscode.workspace.getConfiguration('vscode-devtools-for-chrome');\r\n        const pathToChrome = settings.get('chromePath') as string || chromePathFromLaunchConfig || utils.getPathToChrome();\r\n\r\n        if (!pathToChrome || !utils.existsSync(pathToChrome)) {\r\n            vscode.window.showErrorMessage('Chrome was not found. Chrome must be installed for this extension to function. If you have Chrome installed at a custom location you can specify it in the \\'chromePath\\' setting.');\r\n            telemetryReporter.sendTelemetryEvent('launch/error/chrome_not_found', telemetryProps);\r\n            return;\r\n        }\r\n\r\n        utils.launchLocalChrome(pathToChrome, port, defaultUrl);\r\n    }\r\n\r\n    const target = JSON.parse(await utils.getURL(`http://${hostname}:${port}/json/new?${launchUrl}`));\r\n\r\n    if (!target || !target.webSocketDebuggerUrl || target.webSocketDebuggerUrl === '') {\r\n        vscode.window.showErrorMessage(`Could not find the launched Chrome tab: (${launchUrl}).`);\r\n        telemetryReporter.sendTelemetryEvent('launch/error/tab_not_found', telemetryProps);\r\n        attach(context, viaConfig, defaultUrl);\r\n    } else {\r\n        DevToolsPanel.createOrShow(context, target.webSocketDebuggerUrl);\r\n    }\r\n}\r\n\r\nasync function attach(context: vscode.ExtensionContext, viaConfig: boolean, targetUrl: string) {\r\n    const telemetryProps = { viaConfig: `${viaConfig}` };\r\n    telemetryReporter.sendTelemetryEvent('attach', telemetryProps);\r\n\r\n    const { hostname, port } = getSettings();\r\n    const responseArray = await getListOfTargets(hostname, port);\r\n    if (Array.isArray(responseArray)) {\r\n        telemetryReporter.sendTelemetryEvent('attach/list', telemetryProps, { targetCount: responseArray.length });\r\n\r\n        if (responseArray.length === 0) {\r\n            vscode.window.showErrorMessage(`Could not find any targets for attaching.\\nDid you remember to run Chrome with '--remote-debugging-port=9222'?`);\r\n            return;\r\n        }\r\n\r\n        const items: QuickPickItem[] = [];\r\n\r\n        responseArray.forEach(i => {\r\n            i = utils.fixRemoteUrl(hostname, port, i);\r\n            items.push({\r\n                label: i.title,\r\n                description: i.url,\r\n                detail: i.webSocketDebuggerUrl\r\n            });\r\n        });\r\n\r\n        let targetWebsocketUrl = '';\r\n        if (typeof targetUrl === 'string' && targetUrl.length > 0 && targetUrl !== defaultUrl) {\r\n            const matches = items.filter(i => i.description && targetUrl.localeCompare(i.description, 'en', { sensitivity: 'base' }) === 0);\r\n            if (matches && matches.length > 0 ) {\r\n                targetWebsocketUrl = matches[0].detail || '';\r\n            } else {\r\n                vscode.window.showErrorMessage(`Couldn't attach to ${targetUrl}.`);\r\n            }\r\n        }\r\n\r\n        if (targetWebsocketUrl && targetWebsocketUrl.length > 0) {\r\n            DevToolsPanel.createOrShow(context, targetWebsocketUrl as string);\r\n        } else {\r\n            vscode.window.showQuickPick(items).then((selection) => {\r\n                if (selection) {\r\n                    DevToolsPanel.createOrShow(context, selection.detail as string);\r\n                }\r\n            });\r\n        }\r\n    } else {\r\n        telemetryReporter.sendTelemetryEvent('attach/error/no_json_array', telemetryProps);\r\n    }\r\n}\r\n\r\nfunction getSettings(): { hostname: string, port: number } {\r\n    const settings = vscode.workspace.getConfiguration('vscode-devtools-for-chrome');\r\n    const hostname = settings.get('hostname') as string || 'localhost';\r\n    const port = settings.get('port') as number || 9222;\r\n\r\n    return { hostname, port };\r\n}\r\n\r\nfunction getPackageInfo(context: vscode.ExtensionContext): IPackageInfo {\r\n    if (packageJson) {\r\n        return {\r\n            name: packageJson.name,\r\n            version: packageJson.version,\r\n            aiKey: packageJson.aiKey\r\n        };\r\n    }\r\n    return undefined as any as IPackageInfo;\r\n}\r\n\r\nasync function getListOfTargets(hostname: string, port: number, useHttps: boolean = false): Promise<Array<any>> {\r\n    const checkDiscoveryEndpoint = (uri: string) => {\r\n        return utils.getURL(uri, { headers: { Host: \"localhost\" } });\r\n    };\r\n\r\n    const protocol = (useHttps ? \"https\" : \"http\");\r\n\r\n    let jsonResponse = \"\";\r\n    for (const endpoint of [\"/json/list\", \"/json\"]) {\r\n        try {\r\n            jsonResponse = await checkDiscoveryEndpoint(`${protocol}://${hostname}:${port}${endpoint}`);\r\n            if (jsonResponse) {\r\n                break;\r\n            }\r\n        } catch {\r\n            // Do nothing\r\n        }\r\n    }\r\n\r\n    let result: any[];\r\n    try {\r\n        result = JSON.parse(jsonResponse);\r\n    } catch {\r\n        result = [];\r\n    }\r\n    return result;\r\n}\r\n\r\nclass DevToolsPanel {\r\n    private static currentPanel: DevToolsPanel | undefined;\r\n    private readonly _panel: vscode.WebviewPanel;\r\n    private readonly _context: vscode.ExtensionContext;\r\n    private readonly _extensionPath: string;\r\n    private readonly _targetUrl: string;\r\n    private _socket: WebSocket | undefined = undefined;\r\n    private _isConnected: boolean = false;\r\n    private _messages: any[] = [];\r\n    private _disposables: vscode.Disposable[] = [];\r\n\r\n    public static createOrShow(context: vscode.ExtensionContext, targetUrl: string) {\r\n        const column = vscode.ViewColumn.Beside;\r\n\r\n        if (DevToolsPanel.currentPanel) {\r\n            DevToolsPanel.currentPanel._panel.reveal(column);\r\n        } else {\r\n            const panel = vscode.window.createWebviewPanel('devtools-for-chrome', 'DevTools', column, {\r\n                enableScripts: true,\r\n                enableCommandUris: true,\r\n                retainContextWhenHidden: true\r\n            });\r\n\r\n            DevToolsPanel.currentPanel = new DevToolsPanel(panel, context, targetUrl);\r\n        }\r\n    }\r\n\r\n    public static revive(panel: vscode.WebviewPanel, context: vscode.ExtensionContext, targetUrl: string) {\r\n        DevToolsPanel.currentPanel = new DevToolsPanel(panel, context, targetUrl);\r\n    }\r\n\r\n    private constructor(panel: vscode.WebviewPanel, context: vscode.ExtensionContext, targetUrl: string) {\r\n        this._panel = panel;\r\n        this._context = context;\r\n        this._extensionPath = context.extensionPath;\r\n        this._targetUrl = targetUrl;\r\n\r\n        this._update();\r\n\r\n        // Handle closing\r\n        this._panel.onDidDispose(() => {\r\n            this.dispose();\r\n        }, undefined, this._disposables);\r\n\r\n        // Handle view change\r\n        this._panel.onDidChangeViewState(e => {\r\n            if (this._panel.visible) {\r\n                this._update();\r\n            }\r\n        }, undefined, this._disposables);\r\n\r\n        // Handle messages from the webview\r\n        this._panel.webview.onDidReceiveMessage(message => {\r\n            this._onMessageFromWebview(message);\r\n        }, undefined, this._disposables);\r\n    }\r\n\r\n    public dispose() {\r\n        DevToolsPanel.currentPanel = undefined;\r\n\r\n        this._panel.dispose();\r\n        this._disposeSocket();\r\n\r\n        while (this._disposables.length) {\r\n            const x = this._disposables.pop();\r\n            if (x) {\r\n                x.dispose();\r\n            }\r\n        }\r\n    }\r\n\r\n    private _disposeSocket() {\r\n        if (this._socket) {\r\n            // Reset the socket since the devtools have been reloaded\r\n            telemetryReporter.sendTelemetryEvent('websocket/dispose');\r\n            const s = this._socket as any;\r\n            s.onopen = undefined;\r\n            s.onmessage = undefined;\r\n            s.onerror = undefined;\r\n            s.onclose = undefined;\r\n            this._socket.close();\r\n            this._socket = undefined;\r\n        }\r\n    }\r\n\r\n    private _onMessageFromWebview(message: string) {\r\n        if (message === 'ready') {\r\n            if (this._socket) {\r\n                telemetryReporter.sendTelemetryEvent('websocket/reconnect');\r\n            }\r\n            this._disposeSocket();\r\n        } else if (message.substr(0, 10) === 'telemetry:') {\r\n            return this._sendTelemetryMessage(message.substr(10));\r\n        } else if (message.substr(0, 9) === 'getState:') {\r\n            return this._getDevtoolsState();\r\n        } else if (message.substr(0, 9) === 'setState:') {\r\n            return this._setDevtoolsState(message.substr(9));\r\n        } else if (message.substr(0, 7) === 'getUrl:') {\r\n            return this._getDevtoolsUrl(message.substr(7));\r\n        } else if (message.substr(0, 7) === 'copyText:') {\r\n            return this._copyText(message.substr(9));\r\n        }\r\n\r\n        if (!this._socket) {\r\n            // First message, so connect a real websocket to the target\r\n            this._connectToTarget();\r\n        } else if (!this._isConnected) {\r\n            // DevTools are sending a message before the real websocket has finished opening so cache it\r\n            this._messages.push(message);\r\n        } else {\r\n            // Websocket ready so send the message directly\r\n            this._socket.send(message);\r\n        }\r\n    }\r\n\r\n    private _connectToTarget() {\r\n        const url = this._targetUrl;\r\n\r\n        // Create the websocket\r\n        this._socket = new WebSocket(url);\r\n        this._socket.onopen = this._onOpen.bind(this);\r\n        this._socket.onmessage = this._onMessage.bind(this);\r\n        this._socket.onerror = this._onError.bind(this);\r\n        this._socket.onclose = this._onClose.bind(this);\r\n    }\r\n\r\n    private _onOpen() {\r\n        this._isConnected = true;\r\n        // Tell the devtools that the real websocket was opened\r\n        telemetryReporter.sendTelemetryEvent('websocket/open');\r\n        this._panel.webview.postMessage('open');\r\n\r\n        if (this._socket) {\r\n            // Forward any cached messages onto the real websocket\r\n            for (const message of this._messages) {\r\n                this._socket.send(message);\r\n            }\r\n            this._messages = [];\r\n        }\r\n    }\r\n\r\n    private _onMessage(message: any) {\r\n        if (this._isConnected) {\r\n            // Forward the message onto the devtools\r\n            this._panel.webview.postMessage(message.data);\r\n        }\r\n    }\r\n\r\n    private _onError() {\r\n        if (this._isConnected) {\r\n            // Tell the devtools that there was a connection error\r\n            telemetryReporter.sendTelemetryEvent('websocket/error');\r\n            this._panel.webview.postMessage('error');\r\n        }\r\n    }\r\n\r\n    private _onClose() {\r\n        if (this._isConnected) {\r\n            // Tell the devtools that the real websocket was closed\r\n            telemetryReporter.sendTelemetryEvent('websocket/close');\r\n            this._panel.webview.postMessage('close');\r\n        }\r\n        this._isConnected = false;\r\n    }\r\n\r\n    private _sendTelemetryMessage(message: string) {\r\n        const telemetry = JSON.parse(message);\r\n        telemetryReporter.sendTelemetryEvent(telemetry.name, telemetry.properties, telemetry.metrics);\r\n    }\r\n\r\n    private _getDevtoolsState() {\r\n        const allPrefsKey = 'devtools-preferences';\r\n        const allPrefs: any = this._context.workspaceState.get(allPrefsKey) ||\r\n            {\r\n                uiTheme: '\"dark\"',\r\n                screencastEnabled: false\r\n            };\r\n        this._panel.webview.postMessage(`preferences:${JSON.stringify(allPrefs)}`);\r\n    }\r\n\r\n    private _setDevtoolsState(message: string) {\r\n        // Parse the preference from the message and store it\r\n        const pref = JSON.parse(message) as { name: string, value: string };\r\n\r\n        const allPrefsKey = 'devtools-preferences';\r\n        const allPrefs: any = this._context.workspaceState.get(allPrefsKey) || {};\r\n        allPrefs[pref.name] = pref.value;\r\n        this._context.workspaceState.update(allPrefsKey, allPrefs);\r\n    }\r\n\r\n    private async _getDevtoolsUrl(message: string) {\r\n        // Parse the request from the message and store it\r\n        const request = JSON.parse(message) as { id: number, url: string };\r\n\r\n        let content = '';\r\n        try {\r\n            content = await utils.getURL(request.url);\r\n        } catch (ex) {\r\n            content = '';\r\n        }\r\n\r\n        this._panel.webview.postMessage(`setUrl:${JSON.stringify({ id: request.id, content })}`);\r\n    }\r\n\r\n    private async _copyText(message: string) {\r\n        // Parse the request from the message and store it\r\n        const request = JSON.parse(message) as { text: string };\r\n        vscode.env.clipboard.writeText(request.text);\r\n    }\r\n\r\n    private _update() {\r\n        this._panel.webview.html = this._getHtmlForWebview();\r\n    }\r\n\r\n    private _getHtmlForWebview() {\r\n        const htmlPath = vscode.Uri.file(path.join(this._extensionPath, 'out/tools/front_end', 'inspector.html'));\r\n        const htmlUri = htmlPath.with({ scheme: 'vscode-resource' });\r\n\r\n        const scriptPath = vscode.Uri.file(path.join(this._extensionPath, 'out', 'host', 'messaging.bundle.js'));\r\n        const scriptUri = scriptPath.with({ scheme: 'vscode-resource' });\r\n\r\n        const stylesPath = vscode.Uri.file(path.join(this._extensionPath, 'out', 'common', 'styles.css'));\r\n        const stylesUri = stylesPath.with({ scheme: 'vscode-resource' });\r\n\r\n        return `\r\n            <!doctype html>\r\n            <html>\r\n            <head>\r\n                <meta http-equiv=\"content-type\" content=\"text/html; charset=utf-8\">\r\n                <meta http-equiv=\"Content-Security-Policy\"\r\n                    content=\"default-src 'none';\r\n                    frame-src vscode-resource:;\r\n                    script-src vscode-resource:;\r\n                    style-src vscode-resource:;\">\r\n                <link href=\"${stylesUri}\" rel=\"stylesheet\"/>\r\n                <script src=\"${scriptUri}\"></script>\r\n            </head>\r\n            <body>\r\n                <iframe id=\"host\" frameBorder=\"0\" src=\"${htmlUri}?ws=trueD&experiments=true&edgeThemes=true\"></iframe>\r\n            </body>\r\n            </html>\r\n            `;\r\n    }\r\n}\r\n\r\nclass DebugTelemetryReporter extends TelemetryReporter {\r\n    constructor() {\r\n        super('extensionId', 'extensionVersion', 'key');\r\n    }\r\n\r\n    public sendTelemetryEvent(name: string, properties?: any, measurements?: any) {\r\n        console.log(`${name}: ${JSON.stringify(properties)}, ${JSON.stringify(properties)}`);\r\n    }\r\n\r\n    public dispose(): Promise<any> {\r\n        return Promise.resolve();\r\n    }\r\n}\r\n","/*---------------------------------------------------------\r\n * Copyright (C) Microsoft Corporation. All rights reserved.\r\n *--------------------------------------------------------*/\r\n// Edited to fix the user id reporting\r\n\r\n'use strict';\r\n\r\nprocess.env['APPLICATION_INSIGHTS_NO_DIAGNOSTIC_CHANNEL'] = 'true';\r\n\r\nimport * as appInsights from 'applicationinsights';\r\nimport * as fs from 'fs';\r\nimport * as os from 'os';\r\nimport * as path from 'path';\r\nimport * as vscode from 'vscode';\r\n\r\nexport default class TelemetryReporter extends vscode.Disposable {\r\n    private appInsightsClient: appInsights.TelemetryClient | undefined;\r\n    private userOptIn: boolean = false;\r\n    private toDispose: vscode.Disposable[] = [];\r\n\r\n    private static TELEMETRY_CONFIG_ID = 'telemetry';\r\n    private static TELEMETRY_CONFIG_ENABLED_ID = 'enableTelemetry';\r\n\r\n    private logStream: fs.WriteStream | undefined;\r\n\r\n    constructor(private extensionId: string, private extensionVersion: string, key: string) {\r\n        super(() => this.toDispose.forEach((d) => d && d.dispose()));\r\n        let logFilePath = process.env['VSCODE_LOGS'] || '';\r\n        if (logFilePath && extensionId && process.env['VSCODE_LOG_LEVEL'] === 'trace') {\r\n            logFilePath = path.join(logFilePath, `${extensionId}.txt`);\r\n            this.logStream = fs.createWriteStream(logFilePath, { flags: 'a', encoding: 'utf8', autoClose: true });\r\n        }\r\n        this.updateUserOptIn(key);\r\n        this.toDispose.push(vscode.workspace.onDidChangeConfiguration(() => this.updateUserOptIn(key)));\r\n    }\r\n\r\n    private updateUserOptIn(key: string): void {\r\n        const config = vscode.workspace.getConfiguration(TelemetryReporter.TELEMETRY_CONFIG_ID);\r\n        if (this.userOptIn !== config.get<boolean>(TelemetryReporter.TELEMETRY_CONFIG_ENABLED_ID, true)) {\r\n            this.userOptIn = config.get<boolean>(TelemetryReporter.TELEMETRY_CONFIG_ENABLED_ID, true);\r\n            if (this.userOptIn) {\r\n                this.createAppInsightsClient(key);\r\n            } else {\r\n                this.dispose();\r\n            }\r\n        }\r\n    }\r\n\r\n    private createAppInsightsClient(key: string) {\r\n        // Check if another instance is already initialized\r\n        if (appInsights.defaultClient) {\r\n            this.appInsightsClient = new appInsights.TelemetryClient(key);\r\n            // No other way to enable offline mode\r\n            this.appInsightsClient.channel.setUseDiskRetryCaching(true);\r\n        } else {\r\n            appInsights.setup(key)\r\n                .setAutoCollectRequests(false)\r\n                .setAutoCollectPerformance(false)\r\n                .setAutoCollectExceptions(false)\r\n                .setAutoCollectDependencies(false)\r\n                .setAutoDependencyCorrelation(false)\r\n                .setAutoCollectConsole(false)\r\n                .setUseDiskRetryCaching(true)\r\n                .start();\r\n            this.appInsightsClient = appInsights.defaultClient;\r\n        }\r\n\r\n        this.appInsightsClient.commonProperties = this.getCommonProperties();\r\n\r\n        // Add the user and session id's to the context so that the analytics will correctly assign users\r\n        if (vscode && vscode.env) {\r\n            this.appInsightsClient.context.tags[this.appInsightsClient.context.keys.userId] = vscode.env.machineId;\r\n            this.appInsightsClient.context.tags[this.appInsightsClient.context.keys.sessionId] = vscode.env.sessionId;\r\n        }\r\n\r\n        // Check if it's an Asimov key to change the endpoint\r\n        if (key && key.indexOf('AIF-') === 0) {\r\n            this.appInsightsClient.config.endpointUrl = 'https://vortex.data.microsoft.com/collect/v1';\r\n        }\r\n    }\r\n\r\n    // __GDPR__COMMON__ \"common.os\" : { \"classification\": \"SystemMetaData\", \"purpose\": \"FeatureInsight\" }\r\n    // __GDPR__COMMON__ \"common.platformversion\" : { \"classification\": \"SystemMetaData\", \"purpose\": \"FeatureInsight\" }\r\n    // __GDPR__COMMON__ \"common.extname\" : { \"classification\": \"PublicNonPersonalData\", \"purpose\": \"FeatureInsight\" }\r\n    // __GDPR__COMMON__ \"common.extversion\" : { \"classification\": \"PublicNonPersonalData\", \"purpose\": \"FeatureInsight\" }\r\n    // __GDPR__COMMON__ \"common.vscodemachineid\" : { \"endPoint\": \"MacAddressHash\", \"classification\": \"EndUserPseudonymizedInformation\", \"purpose\": \"FeatureInsight\" }\r\n    // __GDPR__COMMON__ \"common.vscodesessionid\" : { \"classification\": \"SystemMetaData\", \"purpose\": \"FeatureInsight\" }\r\n    // __GDPR__COMMON__ \"common.vscodeversion\" : { \"classification\": \"SystemMetaData\", \"purpose\": \"FeatureInsight\" }\r\n    private getCommonProperties(): { [key: string]: string } {\r\n        // tslint:disable-next-line:no-null-keyword\r\n        const commonProperties = Object.create(null);\r\n        commonProperties['common.os'] = os.platform();\r\n        commonProperties['common.platformversion'] = (os.release() || '').replace(/^(\\d+)(\\.\\d+)?(\\.\\d+)?(.*)/, '$1$2$3');\r\n        commonProperties['common.extname'] = this.extensionId;\r\n        commonProperties['common.extversion'] = this.extensionVersion;\r\n        if (vscode && vscode.env) {\r\n            commonProperties['common.vscodemachineid'] = vscode.env.machineId;\r\n            commonProperties['common.vscodesessionid'] = vscode.env.sessionId;\r\n            commonProperties['common.vscodeversion'] = vscode.version;\r\n        }\r\n        return commonProperties;\r\n    }\r\n\r\n    public sendTelemetryEvent(eventName: string, properties?: { [key: string]: string }, measurements?: { [key: string]: number }): void {\r\n        if (this.userOptIn && eventName && this.appInsightsClient) {\r\n            this.appInsightsClient.trackEvent({\r\n                name: `${this.extensionId}/${eventName}`,\r\n                properties: properties,\r\n                measurements: measurements\r\n            });\r\n\r\n            if (this.logStream) {\r\n                this.logStream.write(`telemetry/${eventName} ${JSON.stringify({ properties, measurements })}\\n`);\r\n            }\r\n        }\r\n    }\r\n\r\n    public dispose(): Promise<any> {\r\n        const flushEventsToLogger = new Promise<any>(resolve => {\r\n            if (!this.logStream) {\r\n                return resolve(void 0);\r\n            }\r\n            this.logStream.on('finish', resolve);\r\n            this.logStream.end();\r\n        });\r\n\r\n        const flushEventsToAI = new Promise<any>(resolve => {\r\n            if (this.appInsightsClient) {\r\n                this.appInsightsClient.flush({\r\n                    callback: () => {\r\n                        // All data flushed\r\n                        this.appInsightsClient = undefined;\r\n                        resolve(void 0);\r\n                    }\r\n                });\r\n            } else {\r\n                resolve(void 0);\r\n            }\r\n        });\r\n        return Promise.all([flushEventsToAI, flushEventsToLogger]);\r\n    }\r\n}","import * as cp from 'child_process';\r\nimport * as fs from 'fs';\r\nimport * as http from 'http';\r\nimport * as https from 'https';\r\nimport * as net from 'net';\r\nimport * as os from 'os';\r\nimport * as path from 'path';\r\nimport * as url from 'url';\r\nimport * as vscode from 'vscode';\r\n\r\nexport function getURL(aUrl: string, options: https.RequestOptions = {}): Promise<string> {\r\n    return new Promise((resolve, reject) => {\r\n        const parsedUrl = url.parse(aUrl);\r\n        const get = parsedUrl.protocol === 'https:' ? https.get : http.get;\r\n        options = <http.RequestOptions>{\r\n            rejectUnauthorized: false,\r\n            ...parsedUrl,\r\n            ...options\r\n        };\r\n\r\n        get(options, (response) => {\r\n            let responseData = '';\r\n            response.on('data', chunk => {\r\n                responseData += chunk.toString();\r\n            });\r\n            response.on('end', () => {\r\n                // Sometimes the 'error' event is not fired. Double check here.\r\n                if (response.statusCode === 200) {\r\n                    resolve(responseData);\r\n                } else {\r\n                    reject(new Error(responseData.trim()));\r\n                }\r\n            });\r\n        }).on('error', e => {\r\n            reject(e);\r\n        });\r\n    });\r\n}\r\n\r\nexport function fixRemoteUrl(remoteAddress: string, remotePort: number, target: any): any {\r\n    if (target.webSocketDebuggerUrl) {\r\n        const addressMatch = target.webSocketDebuggerUrl.match(/ws:\\/\\/([^/]+)\\/?/);\r\n        if (addressMatch) {\r\n            const replaceAddress = `${remoteAddress}:${remotePort}`;\r\n            target.webSocketDebuggerUrl = target.webSocketDebuggerUrl.replace(addressMatch[1], replaceAddress);\r\n        }\r\n    }\r\n    return target;\r\n}\r\n\r\n\r\nexport const enum Platform {\r\n    Windows, OSX, Linux\r\n}\r\n\r\nexport function getPlatform(): Platform {\r\n    const platform = os.platform();\r\n    return platform === 'darwin' ? Platform.OSX :\r\n        platform === 'win32' ? Platform.Windows :\r\n            Platform.Linux;\r\n}\r\n\r\nexport function existsSync(path: string): boolean {\r\n    try {\r\n        fs.statSync(path);\r\n        return true;\r\n    } catch (e) {\r\n        return false;\r\n    }\r\n}\r\n\r\nexport function launchLocalChrome(chromePath: string, chromePort: number, targetUrl: string) {\r\n    const chromeArgs = [\r\n        '--disable-extensions',\r\n        `--remote-debugging-port=${chromePort}`\r\n    ];\r\n\r\n    const chromeProc = cp.spawn(chromePath, chromeArgs, {\r\n        stdio: 'ignore',\r\n        detached: true\r\n    });\r\n\r\n    chromeProc.unref();\r\n}\r\n\r\nexport async function isPortFree(host: string, port: number): Promise<boolean> {\r\n    return new Promise<boolean>((resolve) => {\r\n        const server = net.createServer();\r\n\r\n        server.on('error', () => resolve(false));\r\n        server.listen(port, host);\r\n\r\n        server.on('listening', () => {\r\n            server.close();\r\n            server.unref();\r\n        });\r\n\r\n        server.on('close', () => resolve(true));\r\n    });\r\n}\r\n\r\nconst WIN_APPDATA = process.env.LOCALAPPDATA || '/';\r\nconst DEFAULT_CHROME_PATH = {\r\n    LINUX: '/usr/bin/google-chrome',\r\n    OSX: '/Applications/Google Chrome.app/Contents/MacOS/Google Chrome',\r\n    WIN: 'C:\\\\Program Files\\\\Google\\\\Chrome\\\\Application\\\\chrome.exe',\r\n    WIN_LOCALAPPDATA: path.join(WIN_APPDATA, 'Google\\\\Chrome\\\\Application\\\\chrome.exe'),\r\n    WINx86: 'C:\\\\Program Files (x86)\\\\Google\\\\Chrome\\\\Application\\\\chrome.exe',\r\n};\r\n\r\nexport function getPathToChrome(): string {\r\n    const platform = getPlatform();\r\n    if (platform === Platform.OSX) {\r\n        return existsSync(DEFAULT_CHROME_PATH.OSX) ? DEFAULT_CHROME_PATH.OSX : '';\r\n    } else if (platform === Platform.Windows) {\r\n        if (existsSync(DEFAULT_CHROME_PATH.WINx86)) {\r\n            return DEFAULT_CHROME_PATH.WINx86;\r\n        } else if (existsSync(DEFAULT_CHROME_PATH.WIN)) {\r\n            return DEFAULT_CHROME_PATH.WIN;\r\n        } else if (existsSync(DEFAULT_CHROME_PATH.WIN_LOCALAPPDATA)) {\r\n            return DEFAULT_CHROME_PATH.WIN_LOCALAPPDATA;\r\n        } else {\r\n            return '';\r\n        }\r\n    } else {\r\n        return existsSync(DEFAULT_CHROME_PATH.LINUX) ? DEFAULT_CHROME_PATH.LINUX : '';\r\n    }\r\n}\r\n\r\nexport function pathToFileURL(absPath: string, normalize?: boolean): string {\r\n    if (normalize) {\r\n        absPath = path.normalize(absPath);\r\n        absPath = forceForwardSlashes(absPath);\r\n    }\r\n\r\n    absPath = (absPath.startsWith('/') ? 'file://' : 'file:///') +  absPath;\r\n    return encodeURI(absPath);\r\n}\r\n\r\nexport function forceForwardSlashes(aUrl: string): string {\r\n    return aUrl\r\n        .replace(/\\\\\\//g, '/') // Replace \\/ (unnecessarily escaped forward slash)\r\n        .replace(/\\\\/g, '/');\r\n}\r\n\r\nexport function getUrlFromConfig(folder: vscode.WorkspaceFolder | undefined, config: vscode.DebugConfiguration): string {\r\n    let outUrlString = '';\r\n\r\n    if (config.file && folder) {\r\n        outUrlString = config.file;\r\n        outUrlString = outUrlString.replace('${workspaceFolder}', folder.uri.path);\r\n        outUrlString = pathToFileURL(outUrlString);\r\n    } else if (config.url) {\r\n        outUrlString = config.url;\r\n    }\r\n\r\n    return outUrlString;\r\n}\r\n","module.exports = require(\"assert\");","module.exports = require(\"async_hooks\");","module.exports = require(\"child_process\");","module.exports = require(\"console\");","module.exports = require(\"constants\");","module.exports = require(\"crypto\");","module.exports = require(\"dns\");","module.exports = require(\"events\");","module.exports = require(\"fs\");","module.exports = require(\"http\");","module.exports = require(\"https\");","module.exports = require(\"module\");","module.exports = require(\"net\");","module.exports = require(\"os\");","module.exports = require(\"path\");","module.exports = require(\"stream\");","module.exports = require(\"timers\");","module.exports = require(\"tls\");","module.exports = require(\"url\");","module.exports = require(\"util\");","module.exports = require(\"vscode\");","module.exports = require(\"zlib\");"],"sourceRoot":""}