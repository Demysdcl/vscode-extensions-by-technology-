"use strict";

var RE2;

try {
	RE2 = require("re2");
}catch(e){ /* squelch */ }

if(RE2){
	var ScannerRE2 =function ScannerRE2(){
				this.reset();
			};

	ScannerRE2.prototype = {

		// public interface

		reset: function(){
			this.buffer = new Buffer(0);
			this.line   = this.pos = 1;
			this.noMore = false;
		},

		addBuffer: function(buffer, noMore){
			if (buffer.length) {
				this.buffer = Buffer.concat([this.buffer,
					Buffer.isBuffer(buffer) ? buffer : new Buffer(buffer)]);
			}
			this.noMore = noMore;
		},

		isFinished: function(){
			return this.noMore && !this.buffer.length;
		},

		padding: 16,

		// private workings

		newLinePattern: /[\u000A\u2028\u2029]|\u000D\u000A|\u000D/g,

		getToken: function(state, peek){
			var buffer = this.buffer;
			if(!buffer.length){
				// no input data: true/false for more data
				return !this.noMore;
			}
			if(state.pattern instanceof RegExp){
				state.pattern = new RE2(state.pattern);
			}
			var m = state.pattern.exec(buffer);
			if(!m){
				return null;
			}
			if(!this.noMore && m[0].length >= buffer.length - this.padding){
				// need more information
				return true;
			}
			var matched = m[0], index = 0;
			if(state.tokens.length > 1){
				for(index = 1; !m[index].length; ++index);
				--index;
			}
			// prepare the found token
			var token   = Object.create(state.tokens[index]);
			token.value = matched.toString();
			token.line  = this.line;
			token.pos   = this.pos;
			// update line and position, if it was not a peek
			if(!peek){
				var rest = 0;
//				if(this.newLinePattern){
					if(this.newLinePattern instanceof RegExp){
						this.newLinePattern = new RE2(this.newLinePattern);
					}
					var self = this;
					this.newLinePattern.replace(matched, function(match, offset){
						rest = match.length + offset;
						++self.line;
						self.pos = 1;
						return "";
					});
//				}else{
					// for(var i = 0, n = rest; i < n; ++i){
					// 	switch(matched.charCodeAt(i)){
					// 		case 0x0A:
					// 		case 0x2028:
					// 		case 0x2029:
					// 			rest = 0;
					// 			break;
					// 		case 0x0D:
					// 			rest = i + 1 < n && matched.charCodeAt(i + 1) === 0x0A ? -1 : 0;
					// 			break;
					// 		default:
					// 			continue;
					// 	}
					// 	rest += n - i - 1;
					// 	++this.line;
					// 	this.pos = 1;
					// }
//				}
				this.pos += token.value.length - rest;
				this.buffer = buffer.slice(matched.length);
			}
			// done
			return token;
		}
	};

	module.exports = ScannerRE2;
}else{
	console.log("Can't find RE2 (use: npm install re2) -- reverting to RegExp.");
	module.exports = require("./Scanner");
}
